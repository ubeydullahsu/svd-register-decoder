{
    "1073816576": {
        "name": "ADC_ISR",
        "address": 1073816576,
        "size": 32,
        "access": "",
        "desc": "ADC interrupt and status register",
        "fields": [
            {
                "name": "ADRDY",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC ready\nThis bit is set by hardware after the ADC has been enabled (ADEN+1) and when the ADC reaches a state where it is ready to accept conversion requests.\nIt is cleared by software writing 1 to it."
            },
            {
                "name": "EOSMP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "End of sampling flag\nThis bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to 1."
            },
            {
                "name": "EOC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "End of conversion flag\nThis bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register."
            },
            {
                "name": "EOS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "End of sequence flag\nThis bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it."
            },
            {
                "name": "OVR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "ADC overrun\nThis bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it."
            },
            {
                "name": "AWD1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog 1 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1."
            },
            {
                "name": "AWD2",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog 2 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it."
            },
            {
                "name": "AWD3",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog 3 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1."
            },
            {
                "name": "EOCAL",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "End Of Calibration flag\nThis bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it."
            },
            {
                "name": "CCRDY",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Channel Configuration Ready flag\nThis flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it.\nNote: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration."
            }
        ]
    },
    "1073816580": {
        "name": "ADC_IER",
        "address": 1073816580,
        "size": 32,
        "access": "",
        "desc": "ADC interrupt enable register",
        "fields": [
            {
                "name": "ADRDYIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC ready interrupt enable\nThis bit is set and cleared by software to enable/disable the ADC Ready interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOSMPIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "End of sampling flag interrupt enable\nThis bit is set and cleared by software to enable/disable the end of the sampling phase interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOCIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "End of conversion interrupt enable\nThis bit is set and cleared by software to enable/disable the end of conversion interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOSIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "End of conversion sequence interrupt enable\nThis bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing)."
            },
            {
                "name": "OVRIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Overrun interrupt enable\nThis bit is set and cleared by software to enable/disable the overrun interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD1IE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog 1 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2IE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog 2 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3IE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog 3 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOCALIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "End of calibration interrupt enable\nThis bit is set and cleared by software to enable/disable the end of calibration interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing)."
            },
            {
                "name": "CCRDYIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Channel Configuration Ready Interrupt enable\nThis bit is set and cleared by software to enable/disable the channel configuration ready interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared (this ensures that no conversion is ongoing)."
            }
        ]
    },
    "1073816584": {
        "name": "ADC_CR",
        "address": 1073816584,
        "size": 32,
        "access": "read-write",
        "desc": "ADC control register",
        "fields": [
            {
                "name": "ADEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC enable command\nThis bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set.\nIt is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command."
            },
            {
                "name": "ADDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ADC disable command"
            },
            {
                "name": "ADSTART",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "ADC start conversion command"
            },
            {
                "name": "ADSTP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "ADC stop conversion command"
            },
            {
                "name": "ADVREGEN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "ADC Voltage Regulator Enable"
            },
            {
                "name": "ADCAL",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "ADC calibration\nThis bit is set by software to start the calibration of the ADC."
            }
        ]
    },
    "1073816588": {
        "name": "ADC_CFGR1",
        "address": 1073816588,
        "size": 32,
        "access": "",
        "desc": "ADC configuration register 1",
        "fields": [
            {
                "name": "DMAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Direct memory access enable\nThis bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to Section113.6.5: Managing converted data using the DMA on page1333."
            },
            {
                "name": "DMACFG",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Direct memory access configuration\nThis bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN1=11.\nFor more details, refer to Section113.6.5: Managing converted data using the DMA on page1333."
            },
            {
                "name": "SCANDIR",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Scan sequence direction\nThis bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared.\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "RES",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Data resolution\nThese bits are written by software to select the resolution of the conversion."
            },
            {
                "name": "ALIGN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Data alignment\nThis bit is set and cleared by software to select right or left alignment. Refer to Figure141: Data alignment and resolution (oversampling disabled: OVSE = 0) on page1332"
            },
            {
                "name": "EXTSEL",
                "bitOffset": 6,
                "bitWidth": 3,
                "desc": "External trigger selection\nThese bits select the external event used to trigger the start of conversion (refer to Table160: External triggers for details):"
            },
            {
                "name": "EXTEN",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "External trigger enable and polarity selection\nThese bits are set and cleared by software to select the external trigger polarity and enable the trigger."
            },
            {
                "name": "OVRMOD",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun management mode\nThis bit is set and cleared by software and configure the way data overruns are managed."
            },
            {
                "name": "CONT",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Single / continuous conversion mode\nThis bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared.\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN1=11 and CONT1=11."
            },
            {
                "name": "WAIT",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Wait conversion mode\nThis bit is set and cleared by software to enable/disable wait conversion mode.<sup>.</sup>"
            },
            {
                "name": "AUTOFF",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Auto-off mode\nThis bit is set and cleared by software to enable/disable auto-off mode.<sup>.</sup>"
            },
            {
                "name": "DISCEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Discontinuous mode\nThis bit is set and cleared by software to enable/disable discontinuous mode.\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN1=11 and CONT1=11."
            },
            {
                "name": "CHSELRMOD",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Mode selection of the ADC_CHSELR register\nThis bit is set and cleared by software to control the ADC_CHSELR feature:\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "AWD1SGL",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Enable the watchdog on a single channel or on all channels\nThis bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels"
            },
            {
                "name": "AWD1EN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Analog watchdog enable\nThis bit is set and cleared by software."
            },
            {
                "name": "AWD1CH",
                "bitOffset": 26,
                "bitWidth": 5,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.\n.....\nOthers: Reserved\nNote: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register."
            }
        ]
    },
    "1073816592": {
        "name": "ADC_CFGR2",
        "address": 1073816592,
        "size": 32,
        "access": "",
        "desc": "ADC configuration register 2",
        "fields": [
            {
                "name": "OVSE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Oversampler Enable\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADEN bit is cleared."
            },
            {
                "name": "OVSR",
                "bitOffset": 2,
                "bitWidth": 3,
                "desc": "Oversampling ratio\nThis bit filed defines the number of oversampling ratio.\nNote: The software is allowed to write this bit only when ADEN bit is cleared."
            },
            {
                "name": "OVSS",
                "bitOffset": 5,
                "bitWidth": 4,
                "desc": "Oversampling shift\nThis bit is set and cleared by software.\nOthers: Reserved\nNote: The software is allowed to write this bit only when ADEN bit is cleared."
            },
            {
                "name": "TOVS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Triggered Oversampling\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADEN bit is cleared."
            },
            {
                "name": "LFTRIG",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Low frequency trigger mode enable\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADEN bit is cleared."
            },
            {
                "name": "CKMODE",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "ADC clock mode\nThese bits are set and cleared by software to define how the analog ADC is clocked:\nIn all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion.\nNote: The software is allowed to write these bits only when the ADC is disabled (ADCAL1=10, ADSTART1=10, ADSTP1=10, ADDIS1=10 and ADEN1=10)."
            }
        ]
    },
    "1073816596": {
        "name": "ADC_SMPR",
        "address": 1073816596,
        "size": 32,
        "access": "",
        "desc": "ADC sampling time register",
        "fields": [
            {
                "name": "SMP1",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Sampling time selection 1\nThese bits are written by software to select the sampling time that applies to all channels.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMP2",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Sampling time selection 2\nThese bits are written by software to select the sampling time that applies to all channels.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL0",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL1",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL2",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL3",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL4",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL5",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL6",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL7",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL8",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL9",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL10",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL11",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL12",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL13",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL14",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL15",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL16",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL17",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL18",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL19",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection (x1=119 to 0)\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1073816608": {
        "name": "ADC_AWD1TR",
        "address": 1073816608,
        "size": 32,
        "access": "",
        "desc": "ADC watchdog threshold register",
        "fields": [
            {
                "name": "LT1",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Analog watchdog 1 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to Section113.8: Analog window watchdogs on page1337."
            },
            {
                "name": "HT1",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Analog watchdog 1 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to Section113.8: Analog window watchdogs on page1337."
            }
        ]
    },
    "1073816612": {
        "name": "ADC_AWD2TR",
        "address": 1073816612,
        "size": 32,
        "access": "",
        "desc": "ADC watchdog threshold register",
        "fields": [
            {
                "name": "LT2",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Analog watchdog 2 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to Section113.8: Analog window watchdogs on page1337."
            },
            {
                "name": "HT2",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Analog watchdog 2 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to Section113.8: Analog window watchdogs on page1337."
            }
        ]
    },
    "1073816616": {
        "name": "ADC_CHSELR",
        "address": 1073816616,
        "size": 32,
        "access": "",
        "desc": "ADC channel selection register",
        "fields": [
            {
                "name": "CHSEL0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing).\nNote: If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            }
        ]
    },
    "1073816620": {
        "name": "ADC_AWD3TR",
        "address": 1073816620,
        "size": 32,
        "access": "",
        "desc": "ADC watchdog threshold register",
        "fields": [
            {
                "name": "LT3",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Analog watchdog 3lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to Section113.8: Analog window watchdogs on page1337."
            },
            {
                "name": "HT3",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Analog watchdog 3 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to Section113.8: Analog window watchdogs on page1337."
            }
        ]
    },
    "1073816640": {
        "name": "ADC_DR",
        "address": 1073816640,
        "size": 32,
        "access": "",
        "desc": "ADC data register",
        "fields": [
            {
                "name": "DATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Converted data\nThese bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in Figure141: Data alignment and resolution (oversampling disabled: OVSE = 0) on page1332.\nJust after a calibration is complete, DATA[6:0] contains the calibration factor."
            }
        ]
    },
    "1073816736": {
        "name": "ADC_AWD2CR",
        "address": 1073816736,
        "size": 32,
        "access": "",
        "desc": "ADC analog watchdog 2 configuration register",
        "fields": [
            {
                "name": "AWD2CH0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1073816740": {
        "name": "ADC_AWD3CR",
        "address": 1073816740,
        "size": 32,
        "access": "",
        "desc": "ADC Analog Watchdog 3 Configuration register",
        "fields": [
            {
                "name": "AWD3CH0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1073816756": {
        "name": "ADC_CALFACT",
        "address": 1073816756,
        "size": 32,
        "access": "",
        "desc": "ADC calibration factor",
        "fields": [
            {
                "name": "CALFACT",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Calibration factor\nThese bits are written by hardware or by software.\nOnce a calibration is complete,1they are updated by hardware with the calibration factors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new conversion is launched.\nJust after a calibration is complete, DATA[6:0] contains the calibration factor.\nNote: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing)."
            }
        ]
    },
    "1073817352": {
        "name": "ADC_CCR",
        "address": 1073817352,
        "size": 32,
        "access": "",
        "desc": "ADC common configuration register",
        "fields": [
            {
                "name": "PRESC",
                "bitOffset": 18,
                "bitWidth": 4,
                "desc": "ADC prescaler\nSet and cleared by software to select the frequency of the clock to the ADC.\nOther: Reserved\nNote: Software is allowed to write these bits only when the ADC is disabled (ADCAL1=10, ADSTART1=10, ADSTP1=10, ADDIS1=10 and ADEN1=10)."
            },
            {
                "name": "VREFEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "V<sub>REFINT</sub> enable\nThis bit is set and cleared by software to enable/disable the V<sub>REFINT</sub>.\nNote: Software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "TSEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Temperature sensor enable\nThis bit is set and cleared by software to enable/disable the temperature sensor.\nNote: Software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "VBATEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "V<sub>BAT</sub> enable\nThis bit is set and cleared by software to enable/disable the V<sub>BAT</sub> channel.\nNote: The software is allowed to write this bit only when ADSTART1=10 (which ensures that no conversion is ongoing)"
            }
        ]
    },
    "1073897472": {
        "name": "AES_CR",
        "address": 1073897472,
        "size": 32,
        "access": "",
        "desc": "AES control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Enable\nThis bit enables/disables the AES peripheral.\nAt any moment, clearing then setting the bit re-initializes the AES peripheral.\nThis bit is automatically cleared by hardware upon the completion of the key preparation (MODE[1:0] at 0x1) and upon the completion of GCM/GMAC/CCM initialization phase.\nThe bit cannot be set as long as KEYVALID1is cleared"
            },
            {
                "name": "DATATYPE",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Data type\nThis bitfield defines the format of data written in the AES_DINR register or read from the AES_DOUTR register, through selecting the mode of data swapping. This swapping is defined in Section121.4.14: AES data registers and data swapping.\nAttempts to write the bitfield are ignored when EN is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "MODE",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Operating mode\nThis bitfield selects the AES operating mode:\nAttempts to write the bitfield are ignored when EN is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "CHMOD",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "CHMOD[1:0]: Chaining mode\nThis bitfield selects the AES chaining mode:\nothers: Reserved\nAttempts to write the bitfield are ignored when EN is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "DMAINEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "DMA input enable\nThis bit enables automatic generation of DMA requests during the data phase, for incoming data transfers to AES via DMA.\nSetting this bit is ignored when MODE[1:0] is at 0x1 (key derivation)."
            },
            {
                "name": "DMAOUTEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "DMA output enable\nThis bit enables automatic generation of DMA requests during the data phase, for outgoing data transfers from AES via DMA.\nSetting this bit is ignored when MODE[1:0] is at 0x1 (key derivation)."
            },
            {
                "name": "GCMPH",
                "bitOffset": 13,
                "bitWidth": 2,
                "desc": "GCM or CCM phase selection\nThis bitfield selects the phase, applicable only with GCM, GMAC or CCM chaining modes."
            },
            {
                "name": "CHMOD_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CHMOD[2]"
            },
            {
                "name": "KEYSIZE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Key size selection\nThis bitfield defines the key length in bits of the key used by AES.\nAttempts to write the bit are ignored when the EN is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "NPBLB",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Number of padding bytes in last block\nThis padding information must be filled by software before processing the last block of GCM payload encryption or CCM payload decryption, otherwise authentication tag computation is incorrect.\n..."
            },
            {
                "name": "IPRST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "AES peripheral software reset\nSetting the bit resets the AES peripheral, putting all registers to their default values, except the IPRST bit itself. Hence, any key-relative data are lost. For this reason, it is recommended to set the bit before handing over the AES to a less secure application.\nThe bit must be kept low while writing any configuration registers."
            }
        ]
    },
    "1073897476": {
        "name": "AES_SR",
        "address": 1073897476,
        "size": 32,
        "access": "",
        "desc": "AES status register",
        "fields": [
            {
                "name": "RDERRF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Read error flag\nThis bit is set when an unexpected read to the AES_DOUTR register occurred. When set RDERRF bit has no impact on the AES operations.\nThe flag setting generates an interrupt if the RWEIE bit of the AES_IER register is set.\nThe flag is cleared by setting the RWEIF bit of the AES_ICR register."
            },
            {
                "name": "WRERRF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Write error flag\nThis bit is set when an unexpected write to the AES_DINR register occurred. When set WRERRF bit has no impact on the AES operations.\nThe flag setting generates an interrupt if the RWEIE bit of the AES_IER register is set.\nThe flag is cleared by setting the RWEIF bit of the AES_ICR register."
            },
            {
                "name": "BUSY",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Busy\nThis flag indicates whether AES is idle or busy.\nAES is flagged as idle when disabled (when EN is low) or when the last processing is completed.\nAES is flagged as busy when processing a block data, preparing a key (ECB or CBC decryption only).\nWhen GCM encryption is selected, this flag must be at zero before suspending current process to manage a higher-priority message."
            },
            {
                "name": "KEYVALID",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Key valid flag\nThis bit is set by hardware when the key of size defined by KEYSIZE is loaded in AES_KEYRx key registers.\nThe EN bit can only be set when KEYVALID is set.\nThe key must be written in the key registers in the correct sequence, otherwise the KEIF flag is set and KEYVALID remains cleared.\nIf set, KEIF must be cleared through the AES_ICR register, otherwise KEYVALID cannot be set. See the KEIF flag description for more details.\nFor further information on key loading, refer to Section121.4.15: AES key registers."
            }
        ]
    },
    "1073897480": {
        "name": "AES_DINR",
        "address": 1073897480,
        "size": 32,
        "access": "",
        "desc": "AES data input register",
        "fields": [
            {
                "name": "DIN",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Data input\nA four-fold sequential write to this bitfield during the Input phase results in writing a complete 16-bytes block of input data to the AES peripheral. From the first to the fourth write, the corresponding data weights are [127:96], [95:64], [63:32], and [31:0]. Upon each write, the data from the 32-bit input buffer are handled by the data swap block according to the DATATYPE[1:0] bitfield, then written into the AES core 16-bytes input buffer.\nReads return zero."
            }
        ]
    },
    "1073897484": {
        "name": "AES_DOUTR",
        "address": 1073897484,
        "size": 32,
        "access": "",
        "desc": "AES data output register",
        "fields": [
            {
                "name": "DOUT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Data output\nThis read-only bitfield fetches a 32-bit output buffer. A four-fold sequential read of this bitfield, upon\nthe computation completion (CCF flag set), virtually reads a complete 16-byte block of output data from the AES peripheral. Before reaching the output buffer, the data produced by the AES core are\nhandled by the data swap block according to the DATATYPE[1:0] bitfield.\nData weights from the first to the fourth read operation are: [127:96], [95:64], [63:32], and [31:0]."
            }
        ]
    },
    "1073897488": {
        "name": "AES_KEYR0",
        "address": 1073897488,
        "size": 32,
        "access": "",
        "desc": "AES key register 0",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [31:0]\nThese are bits [31:0] of the write-only bitfield KEY[255:0] AES encryption or decryption key, depending on the MODE[1:0] bitfield of the AES_CR register.\nWrites to AES_KEYRx registers are ignored when AES is enabled (EN bit set).\n A special writing sequence is required. In this sequence, any valid write to AES_KEYRx register clears the KEYVALID flag except for the sequence-completing write that sets it. Also refer to the description of the KEYVALID flag in the AES_SR register."
            }
        ]
    },
    "1073897492": {
        "name": "AES_KEYR1",
        "address": 1073897492,
        "size": 32,
        "access": "",
        "desc": "AES key register 1",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [63:32]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers."
            }
        ]
    },
    "1073897496": {
        "name": "AES_KEYR2",
        "address": 1073897496,
        "size": 32,
        "access": "",
        "desc": "AES key register 2",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [95:64]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers."
            }
        ]
    },
    "1073897500": {
        "name": "AES_KEYR3",
        "address": 1073897500,
        "size": 32,
        "access": "",
        "desc": "AES key register 3",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [127:96]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers."
            }
        ]
    },
    "1073897504": {
        "name": "AES_IVR0",
        "address": 1073897504,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 0",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [31:0]\nAES_IVRx registers store the 128-bit initialization vector or the nonce, depending on the chaining mode selected. This value is updated by hardware after each computation round (when applicable).\nWrite to this register is ignored when EN bit is set in AES_SR register"
            }
        ]
    },
    "1073897508": {
        "name": "AES_IVR1",
        "address": 1073897508,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 1",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [63:32]\nRefer to the AES_IVR0 register for description of the IVI[128:0] bitfield."
            }
        ]
    },
    "1073897512": {
        "name": "AES_IVR2",
        "address": 1073897512,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 2",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [95:64]\nRefer to the AES_IVR0 register for description of the IVI[128:0] bitfield."
            }
        ]
    },
    "1073897516": {
        "name": "AES_IVR3",
        "address": 1073897516,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 3",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [127:96]\nRefer to the AES_IVR0 register for description of the IVI[128:0] bitfield."
            }
        ]
    },
    "1073897520": {
        "name": "AES_KEYR4",
        "address": 1073897520,
        "size": 32,
        "access": "",
        "desc": "AES key register 4",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [159:128]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers."
            }
        ]
    },
    "1073897524": {
        "name": "AES_KEYR5",
        "address": 1073897524,
        "size": 32,
        "access": "",
        "desc": "AES key register 5",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [191:160]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers."
            }
        ]
    },
    "1073897528": {
        "name": "AES_KEYR6",
        "address": 1073897528,
        "size": 32,
        "access": "",
        "desc": "AES key register 6",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [223:192]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers."
            }
        ]
    },
    "1073897532": {
        "name": "AES_KEYR7",
        "address": 1073897532,
        "size": 32,
        "access": "",
        "desc": "AES key register 7",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [255:224]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield and for information relative to writing AES_KEYRx registers."
            }
        ]
    },
    "1073897536": {
        "name": "AES_SUSPR0",
        "address": 1073897536,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1073897540": {
        "name": "AES_SUSPR1",
        "address": 1073897540,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1073897544": {
        "name": "AES_SUSPR2",
        "address": 1073897544,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1073897548": {
        "name": "AES_SUSPR3",
        "address": 1073897548,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1073897552": {
        "name": "AES_SUSPR4",
        "address": 1073897552,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1073897556": {
        "name": "AES_SUSPR5",
        "address": 1073897556,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1073897560": {
        "name": "AES_SUSPR6",
        "address": 1073897560,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1073897564": {
        "name": "AES_SUSPR7",
        "address": 1073897564,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section121.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1073898240": {
        "name": "AES_IER",
        "address": 1073898240,
        "size": 32,
        "access": "",
        "desc": "AES interrupt enable register",
        "fields": [
            {
                "name": "CCFIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Computation complete flag interrupt enable\nThis bit enables or disables (masks) the AES interrupt generation when CCF (computation complete flag) is set."
            },
            {
                "name": "RWEIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Read or write error interrupt enable\nThis bit enables or disables (masks) the AES interrupt generation when RWEIF (read and/or write error flag) is set."
            },
            {
                "name": "KEIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Key error interrupt enable\nThis bit enables or disables (masks) the AES interrupt generation when KEIF (key error flag) is set."
            }
        ]
    },
    "1073898244": {
        "name": "AES_ISR",
        "address": 1073898244,
        "size": 32,
        "access": "",
        "desc": "AES interrupt status register",
        "fields": [
            {
                "name": "CCF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Computation complete flag\nThis flag indicates whether the computation is completed. It is significant only when the DMAOUTEN bit is cleared, and it may stay high when DMAOUTEN is set.\nThe flag setting generates an interrupt if the CCFIE bit of the AES_IER register is set.\nThe flag is cleared by setting the corresponding bit of the AES_ICR register."
            },
            {
                "name": "RWEIF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Read or write error interrupt flag\nThis read-only bit is set by hardware when a RDERRF or a WRERRF error flag is set in the AES_SR register.\nThe flag setting generates an interrupt if the RWEIE bit of the AES_IER register is set.\nThe flag is cleared by setting the corresponding bit of the AES_ICR register.\nThe flags has no meaning when key derivation mode is selected.\nSee the AES_SR register for details."
            },
            {
                "name": "KEIF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Key error interrupt flag\nThis read-only bit is set by hardware when the key information fails to load into key registers.\nThe flag setting generates an interrupt if the KEIE bit of the AES_IER register is set.\nThe flag is cleared by setting the corresponding bit of the AES_ICR register.\nKEIF is raised upon any of the following events:\nAES_KEYRx register write does not respect the correct order. (For KEYSIZE1cleared, AES_KEYR0 then AES_KEYR1 then AES_KEYR2 then AES_KEYR3 register, or reverse. For KEYSIZE set, AES_KEYR0 then AES_KEYR1 then AES_KEYR2 then AES_KEYR3 then AES_KEYR4 then AES_KEYR5 then AES_KEYR6 then AES_KEYR7, or reverse).\nKEIF must be cleared by the application software, otherwise KEYVALID cannot be set."
            }
        ]
    },
    "1073898248": {
        "name": "AES_ICR",
        "address": 1073898248,
        "size": 32,
        "access": "",
        "desc": "AES interrupt clear register",
        "fields": [
            {
                "name": "CCF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Computation complete flag clear\nSetting this bit clears the CCF status bit of the AES_ISR register."
            },
            {
                "name": "RWEIF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Read or write error interrupt flag clear\nSetting this bit clears the RWEIF status bit of the AES_ISR register, and clears both RDERRF and WRERRF flags in the AES_SR register."
            },
            {
                "name": "KEIF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Key error interrupt flag clear\nSetting this bit clears the KEIF status bit of the AES_ISR register."
            }
        ]
    },
    "1073807872": {
        "name": "COMP1_CSR",
        "address": 1073807872,
        "size": 32,
        "access": "",
        "desc": "Comparator 1 control and status register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Comparator 1 enable bit\nThis bit is controlled by software (if not locked). It enables the comparator 1:"
            },
            {
                "name": "INMSEL",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Comparator 1 signal selector for inverting input INM\nThis bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP_INM of the comparator 1:\nRefer to Table176: COMP1 inverting input assignment."
            },
            {
                "name": "INPSEL",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "Comparator 1 signal selector for noninverting input\nThis bitfield is controlled by software (if not locked). It selects the signal for the noninverting input COMP_INP of the comparator 1 (also see the WINMODE bit):\nRefer to Table175: COMP1 noninverting input assignment."
            },
            {
                "name": "WINMODE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Comparator 1 noninverting input selector for window mode\nThis bit is controlled by software (if not locked). It selects the signal for COMP_INP input of the comparator 1:"
            },
            {
                "name": "WINOUT",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Comparator 1 output selector\nThis bit is controlled by software (if not locked). It selects the comparator 1 output:"
            },
            {
                "name": "POLARITY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Comparator 1 polarity selector\nThis bit is controlled by software (if not locked). It selects the comparator 1 output polarity:"
            },
            {
                "name": "HYST",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Comparator 1 hysteresis selector\nThis bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 1:"
            },
            {
                "name": "PWRMODE",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Comparator 1 power mode selector\nThis bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 1:"
            },
            {
                "name": "BLANKSEL",
                "bitOffset": 20,
                "bitWidth": 5,
                "desc": "Comparator 1 blanking source selector\nThis bitfield is controlled by software (if not locked). It selects the blanking source:\nOthers: Reserved, must not be used"
            },
            {
                "name": "VALUE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Comparator 1 output status\nThis bit is read-only. It reflects the level of the comparator 1 output after the polarity selector and blanking, as indicated in Figure163."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "COMP_CSR register lock\nThis bit is set by software and cleared by a system reset. It locks the comparator 3 control bits. When locked, all register bits are read-only."
            }
        ]
    },
    "1073807876": {
        "name": "COMP2_CSR",
        "address": 1073807876,
        "size": 32,
        "access": "",
        "desc": "Comparator 2 control and status register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Comparator 2 enable bit\nThis bit is controlled by software (if not locked). It enables the comparator 2:"
            },
            {
                "name": "INMSEL",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Comparator 2 signal selector for inverting input INM\nThis bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP_INM of the comparator 2:\nRefer to Table178: COMP2 inverting input assignment."
            },
            {
                "name": "INPSEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Comparator 2 signal selector for noninverting input\nThis bitfield is controlled by software (if not locked). It selects the signal for the noninverting input COMP_INP of the comparator 2 (also see the WINMODE bit):\nRefer to Table177: COMP2 noninverting input assignment."
            },
            {
                "name": "WINMODE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Comparator 2 noninverting input selector for window mode\nThis bit is controlled by software (if not locked). It selects the signal for COMP_INP input of the comparator 2:"
            },
            {
                "name": "WINOUT",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Comparator 2 output selector\nThis bit is controlled by software (if not locked). It selects the comparator 2 output:"
            },
            {
                "name": "POLARITY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Comparator 2 polarity selector\nThis bit is controlled by software (if not locked). It selects the comparator 2 output polarity:"
            },
            {
                "name": "HYST",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Comparator 2 hysteresis selector\nThis bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 2:"
            },
            {
                "name": "PWRMODE",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Comparator 2 power mode selector\nThis bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 2:"
            },
            {
                "name": "BLANKSEL",
                "bitOffset": 20,
                "bitWidth": 5,
                "desc": "Comparator 2 blanking source selector\nThis bitfield is controlled by software (if not locked). It selects the blanking source:\nOthers: Reserved, must not be used"
            },
            {
                "name": "VALUE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Comparator 2 output status\nThis bit is read-only. It reflects the level of the comparator 2 output after the polarity selector and blanking, as indicated in Figure163."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "COMP_CSR register lock\nThis bit is set by software and cleared by a system reset. It locks the comparator 3 control bits. When locked, all register bits are read-only."
            }
        ]
    },
    "1073885184": {
        "name": "CRC_DR",
        "address": 1073885184,
        "size": 32,
        "access": "",
        "desc": "CRC data register",
        "fields": [
            {
                "name": "DR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Data register bits\nThis register is used to write new data to the CRC calculator.\nIt holds the previous CRC calculation result when it is read.\nIf the data size is less than 32 bits, the least significant bits are used to write/read the correct value."
            }
        ]
    },
    "1073885188": {
        "name": "CRC_IDR",
        "address": 1073885188,
        "size": 32,
        "access": "",
        "desc": "CRC independent data register",
        "fields": [
            {
                "name": "IDR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "General-purpose 32-bit data register bits\nThese bits can be used as a temporary storage location for four bytes.\nThis register is not affected by CRC resets generated by the RESET bit in the CRC_CR register"
            }
        ]
    },
    "1073885192": {
        "name": "CRC_CR",
        "address": 1073885192,
        "size": 32,
        "access": "",
        "desc": "CRC control register",
        "fields": [
            {
                "name": "RESET",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RESET bit\nThis bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware"
            },
            {
                "name": "POLYSIZE",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Polynomial size\nThese bits control the size of the polynomial."
            },
            {
                "name": "REV_IN",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Reverse input data\nThis bitfield controls the reversal of the bit order of the input data"
            },
            {
                "name": "REV_OUT",
                "bitOffset": 7,
                "bitWidth": 2,
                "desc": "Reverse output data\nThis bitfield controls the reversal of the bit order of the output data."
            },
            {
                "name": "RTYPE_IN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Reverse type input\nThis bit controls the reversal granularity of the input data."
            },
            {
                "name": "RTYPE_OUT",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Reverse type output\nThis bit controls the reversal granularity of the output data."
            }
        ]
    },
    "1073885200": {
        "name": "CRC_INIT",
        "address": 1073885200,
        "size": 32,
        "access": "",
        "desc": "CRC initial value",
        "fields": [
            {
                "name": "CRC_INIT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Programmable initial CRC value\nThis register is used to write the CRC initial value."
            }
        ]
    },
    "1073885204": {
        "name": "CRC_POL",
        "address": 1073885204,
        "size": 32,
        "access": "",
        "desc": "CRC polynomial",
        "fields": [
            {
                "name": "POL",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Programmable polynomial\nThis register is used to write the coefficients of the polynomial to be used for CRC calculation.\nIf the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value."
            }
        ]
    },
    "1073769472": {
        "name": "CRS_CR",
        "address": 1073769472,
        "size": 32,
        "access": "",
        "desc": "CRS control register",
        "fields": [
            {
                "name": "SYNCOKIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYNC event OK interrupt enable"
            },
            {
                "name": "SYNCWARNIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SYNC warning interrupt enable"
            },
            {
                "name": "ERRIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Synchronization or trimming error interrupt enable"
            },
            {
                "name": "ESYNCIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Expected SYNC interrupt enable"
            },
            {
                "name": "CEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Frequency error counter enable\nThis bit enables the oscillator clock for the frequency error counter.\nWhen this bit is set, the CRS_CFGR register is write-protected and cannot be modified."
            },
            {
                "name": "AUTOTRIMEN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Automatic trimming enable\nThis bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section15.4.4 for more details."
            },
            {
                "name": "SWSYNC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Generate software SYNC event\nThis bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware."
            },
            {
                "name": "TRIM",
                "bitOffset": 8,
                "bitWidth": 7,
                "desc": "HSI48 oscillator smooth trimming\nThe default value of the HSI48 oscillator smooth trimming is 64, which corresponds to the middle of the trimming interval."
            }
        ]
    },
    "1073769476": {
        "name": "CRS_CFGR",
        "address": 1073769476,
        "size": 32,
        "access": "",
        "desc": "CRS configuration register",
        "fields": [
            {
                "name": "RELOAD",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter reload value\nRELOAD is the value to be loaded in the frequency error counter with each SYNC event.\nRefer to Section15.4.3 for more details about counter behavior."
            },
            {
                "name": "FELIM",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Frequency error limit\nFELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section15.4.4 for more details about FECAP evaluation."
            },
            {
                "name": "SYNCDIV",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "SYNC divider\nThese bits are set and cleared by software to control the division factor of the SYNC signal."
            },
            {
                "name": "SYNCSRC",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "SYNC signal source selection\nThese bits are set and cleared by software to select the SYNC signal source (see Table122):\nNote: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF is not generated by the host. No SYNC signal is therefore provided to the CRS to calibrate the HSI48 oscillator on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs must be used as SYNC signal."
            },
            {
                "name": "SYNCPOL",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "SYNC polarity selection\nThis bit is set and cleared by software to select the input polarity for the SYNC signal source."
            }
        ]
    },
    "1073769480": {
        "name": "CRS_ISR",
        "address": 1073769480,
        "size": 32,
        "access": "",
        "desc": "CRS interrupt and status register",
        "fields": [
            {
                "name": "SYNCOKF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYNC event OK flag\nThis flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register."
            },
            {
                "name": "SYNCWARNF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SYNC warning flag\nThis flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register."
            },
            {
                "name": "ERRF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Error flag\nThis flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits."
            },
            {
                "name": "ESYNCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Expected SYNC flag\nThis flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register."
            },
            {
                "name": "SYNCERR",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SYNC error\nThis flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action has to be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register."
            },
            {
                "name": "SYNCMISS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "SYNC missed\nThis flag is set by hardware when the frequency error counter reaches value FELIM * 128 and no SYNC is detected, meaning either that a SYNC pulse was missed, or the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, hence some other action must be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC), and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register."
            },
            {
                "name": "TRIMOVF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Trimming overflow or underflow\nThis flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register."
            },
            {
                "name": "FEDIR",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Frequency error direction\nFEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target."
            },
            {
                "name": "FECAP",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Frequency error capture\nFECAP is the frequency error counter value latched in the time of the last SYNC event.\nRefer to Section15.4.4 for more details about FECAP usage."
            }
        ]
    },
    "1073769484": {
        "name": "CRS_ICR",
        "address": 1073769484,
        "size": 32,
        "access": "",
        "desc": "CRS interrupt flag clear register",
        "fields": [
            {
                "name": "SYNCOKC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYNC event OK clear flag\nWriting 1 to this bit clears the SYNCOKF flag in the CRS_ISR register."
            },
            {
                "name": "SYNCWARNC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SYNC warning clear flag\nWriting 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register."
            },
            {
                "name": "ERRC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Error clear flag\nWriting 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register."
            },
            {
                "name": "ESYNCC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Expected SYNC clear flag\nWriting 1 to this bit clears the ESYNCF flag in the CRS_ISR register."
            }
        ]
    },
    "1073771520": {
        "name": "DAC_CR",
        "address": 1073771520,
        "size": 32,
        "access": "",
        "desc": "DAC control register",
        "fields": [
            {
                "name": "EN1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DAC channel1 enable\nThis bit is set and cleared by software to enable/disable DAC channel1."
            },
            {
                "name": "TEN1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DAC channel1 trigger enable\nThis bit is set and cleared by software to enable/disable DAC channel1 trigger.\nNote: When software trigger is selected, the transfer from the DAC_DHR1 register to the DAC_DOR1 register takes only one dac_pclk clock cycle."
            },
            {
                "name": "TSEL1",
                "bitOffset": 2,
                "bitWidth": 4,
                "desc": "DAC channel1 trigger selection\nThese bits select the external event used to trigger DAC channel1\n...\nRefer to the trigger selection tables in Section114.4.2: DAC pins and internal signals for details on trigger configuration and mapping.\nNote: Only used if bit TEN11=11 (DAC channel1 trigger enabled)."
            },
            {
                "name": "WAVE1",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "DAC channel1 noise/triangle wave generation enable\nThese bits are set and cleared by software.\n1x: Triangle wave generation enabled\nOnly used if bit TEN11=11 (DAC channel1 trigger enabled)."
            },
            {
                "name": "MAMP1",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "DAC channel1 mask/amplitude selector"
            },
            {
                "name": "DMAEN1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "DAC channel1 DMA enable\nThis bit is set and cleared by software."
            },
            {
                "name": "DMAUDRIE1",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DAC channel1 DMA Underrun Interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "CEN1",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "DAC channel1 calibration enable\nThis bit is set and cleared by software to enable/disable DAC channel1 calibration, it can be written only if bit EN11=10 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored."
            }
        ]
    },
    "1073771524": {
        "name": "DAC_SWTRGR",
        "address": 1073771524,
        "size": 32,
        "access": "",
        "desc": "DAC software trigger register",
        "fields": [
            {
                "name": "SWTRIG1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DAC channel1 software trigger\nThis bit is set by software to trigger the DAC in software trigger mode.\nNote: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register."
            }
        ]
    },
    "1073771528": {
        "name": "DAC_DHR12R1",
        "address": 1073771528,
        "size": 32,
        "access": "",
        "desc": "DAC channel1 12-bit right-aligned data holding register",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit right-aligned data\nThese bits are written by software. They specify 12-bit data for DAC channel1."
            }
        ]
    },
    "1073771532": {
        "name": "DAC_DHR12L1",
        "address": 1073771532,
        "size": 32,
        "access": "",
        "desc": "DAC channel1 12-bit left aligned data holding register",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 4,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit left-aligned data\nThese bits are written by software.\nThey specify 12-bit data for DAC channel1."
            }
        ]
    },
    "1073771536": {
        "name": "DAC_DHR8R1",
        "address": 1073771536,
        "size": 32,
        "access": "",
        "desc": "DAC channel1 8-bit right aligned data holding register",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "DAC channel1 8-bit right-aligned data\nThese bits are written by software. They specify 8-bit data for DAC channel1."
            }
        ]
    },
    "1073771564": {
        "name": "DAC_DOR1",
        "address": 1073771564,
        "size": 32,
        "access": "",
        "desc": "DAC channel1 data output register",
        "fields": [
            {
                "name": "DACC1DOR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel1 data output\nThese bits are read-only, they contain data output for DAC channel1."
            }
        ]
    },
    "1073771572": {
        "name": "DAC_SR",
        "address": 1073771572,
        "size": 32,
        "access": "",
        "desc": "DAC status register",
        "fields": [
            {
                "name": "DMAUDR1",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DAC channel1 DMA underrun flag\nThis bit is set by hardware and cleared by software (by writing it to 1)."
            },
            {
                "name": "CAL_FLAG1",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "DAC channel1 calibration offset status\nThis bit is set and cleared by hardware"
            },
            {
                "name": "BWST1",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DAC channel1 busy writing sample time flag\nThis bit is systematically set just after Sample and hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3 LSI periods of synchronization)."
            }
        ]
    },
    "1073771576": {
        "name": "DAC_CCR",
        "address": 1073771576,
        "size": 32,
        "access": "",
        "desc": "DAC calibration control register",
        "fields": [
            {
                "name": "OTRIM1",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DAC channel1 offset trimming value"
            }
        ]
    },
    "1073771580": {
        "name": "DAC_MCR",
        "address": 1073771580,
        "size": 32,
        "access": "",
        "desc": "DAC mode control register",
        "fields": [
            {
                "name": "MODE1",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "DAC channel1 mode\nThese bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN11=10 and bit CEN11=10 in the DAC_CR register). If EN11=11 or CEN11=11 the write operation is ignored.\nThey can be set and cleared by software to select the DAC channel1 mode:\nDAC channel1 in Normal mode\nDAC channel1 in sample & hold mode\nNote: This register can be modified only when EN11=10."
            }
        ]
    },
    "1073771584": {
        "name": "DAC_SHSR1",
        "address": 1073771584,
        "size": 32,
        "access": "",
        "desc": "DAC channel1 sample and hold sample time register",
        "fields": [
            {
                "name": "TSAMPLE1",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "DAC channel1 sample time (only valid in Sample and hold mode)\nThese bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWST1 of DAC_SR register is low, If BWST11=11, the write operation is ignored."
            }
        ]
    },
    "1073771592": {
        "name": "DAC_SHHR",
        "address": 1073771592,
        "size": 32,
        "access": "",
        "desc": "DAC sample and hold time register",
        "fields": [
            {
                "name": "THOLD1",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "DAC channel1 hold time (only valid in Sample and hold mode)\nHold time1=1(THOLD[9:0]) x LSI clock period\nNote: This register can be modified only when EN11=10."
            }
        ]
    },
    "1073771596": {
        "name": "DAC_SHRR",
        "address": 1073771596,
        "size": 32,
        "access": "",
        "desc": "DAC sample and hold refresh time register",
        "fields": [
            {
                "name": "TREFRESH1",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "DAC channel1 refresh time (only valid in Sample and hold mode)\nRefresh time1=1(TREFRESH[7:0]) x LSI clock period\nNote: This register can be modified only when EN11=10."
            }
        ]
    },
    "1073829888": {
        "name": "DBGMCU_IDCODE",
        "address": 1073829888,
        "size": 32,
        "access": "",
        "desc": "DBGMCU device ID code register",
        "fields": [
            {
                "name": "DEV_ID",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Device identifier\nThis field indicates the device ID."
            },
            {
                "name": "REV_ID",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Revision identifier\nThis field indicates the revision of the device."
            }
        ]
    },
    "1073829892": {
        "name": "DBGMCU_CR",
        "address": 1073829892,
        "size": 32,
        "access": "",
        "desc": "DBGMCU configuration register",
        "fields": [
            {
                "name": "DBG_STOP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Debug Stop mode\nDebug options in Stop mode."
            },
            {
                "name": "DBG_STANDBY",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Debug Standby and Shutdown modes\nDebug options in Standby or Shutdown mode."
            }
        ]
    },
    "1073829896": {
        "name": "DBGMCU_APB1FZR",
        "address": 1073829896,
        "size": 32,
        "access": "",
        "desc": "DBGMCU APB1 freeze register",
        "fields": [
            {
                "name": "DBG_TIM2_STOP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 stop in debug"
            },
            {
                "name": "DBG_TIM3_STOP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 stop in debug"
            },
            {
                "name": "DBG_TIM4_STOP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TIM4 stop in debug"
            },
            {
                "name": "DBG_TIM6_STOP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 stop in debug"
            },
            {
                "name": "DBG_TIM7_STOP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 stop in debug"
            },
            {
                "name": "DBG_RTC_STOP",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "RTC stop in debug"
            },
            {
                "name": "DBG_WWDG_STOP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "WWDG stop in debug"
            },
            {
                "name": "DBG_IWDG_STOP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "IWDG stop in debug"
            },
            {
                "name": "DBG_I2C3_STOP",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C3 SMBUS timeout stop in debug"
            },
            {
                "name": "DBG_I2C1_STOP",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C1 SMBUS timeout stop in debug"
            },
            {
                "name": "DBG_LPTIM2_STOP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "LPTIM2 stop in debug"
            },
            {
                "name": "DBG_LPTIM1_STOP",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "LPTIM1 stop in debug"
            }
        ]
    },
    "1073829900": {
        "name": "DBGMCU_APB2FZR",
        "address": 1073829900,
        "size": 32,
        "access": "",
        "desc": "DBG APB2 freeze register",
        "fields": [
            {
                "name": "DBG_TIM1_STOP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 stop in debug"
            },
            {
                "name": "DBG_TIM14_STOP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "TIM14 stop in debug"
            },
            {
                "name": "DBG_TIM15_STOP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "TIM15 stop in debug"
            },
            {
                "name": "DBG_TIM16_STOP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 stop in debug"
            },
            {
                "name": "DBG_LPTIM3_STOP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "LPTIM3 stop in debug"
            }
        ]
    },
    "1073830140": {
        "name": "DBGMCU_SR",
        "address": 1073830140,
        "size": 32,
        "access": "",
        "desc": "DBGMCU status register",
        "fields": [
            {
                "name": "AP1_PRESENT",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Identifies whether access port AP1 is present in device"
            },
            {
                "name": "AP0_PRESENT",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Identifies whether access port AP0 is present in device"
            },
            {
                "name": "AP1_ENABLED",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Identifies whether access port AP0 is open (can be accessed via the debug port) or locked (debug access to the AP is blocked)"
            },
            {
                "name": "AP0_ENABLED",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Identifies whether access port AP0 is open (can be accessed via the debug port) or locked (debug access to the AP is blocked)"
            }
        ]
    },
    "1073830144": {
        "name": "DBGMCU_DBG_AUTH_HOST",
        "address": 1073830144,
        "size": 32,
        "access": "",
        "desc": "DBGMCU debug authentication mailbox host register",
        "fields": [
            {
                "name": "MESSAGE",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Debug host to device mailbox message.\nDuring debug authentication the debug host communicates with the device via this register."
            }
        ]
    },
    "1073830148": {
        "name": "DBGMCU_DBG_AUTH_DEVICE",
        "address": 1073830148,
        "size": 32,
        "access": "",
        "desc": "DBGMCU debug authentication mailbox device register",
        "fields": [
            {
                "name": "MESSAGE",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Device to debug host mailbox message.\nDuring debug authentication the device communicates with the debug host via this register."
            }
        ]
    },
    "1073833936": {
        "name": "DBGMCU_PIDR4",
        "address": 1073833936,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight peripheral identity register 4",
        "fields": [
            {
                "name": "JEP106CON",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "JEP106 continuation code"
            },
            {
                "name": "SIZE",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "register file size"
            }
        ]
    },
    "1073833952": {
        "name": "DBGMCU_PIDR0",
        "address": 1073833952,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight peripheral identity register 0",
        "fields": [
            {
                "name": "PARTNUM",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "part number bits [7:0]"
            }
        ]
    },
    "1073833956": {
        "name": "DBGMCU_PIDR1",
        "address": 1073833956,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight peripheral identity register 1",
        "fields": [
            {
                "name": "PARTNUM",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "part number bits [11:8]"
            },
            {
                "name": "JEP106ID",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "JEP106 identity code bits [3:0]"
            }
        ]
    },
    "1073833960": {
        "name": "DBGMCU_PIDR2",
        "address": 1073833960,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight peripheral identity register 2",
        "fields": [
            {
                "name": "JEP106ID",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "JEP106 identity code bits [6:4]"
            },
            {
                "name": "JEDEC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "JEDEC assigned value"
            },
            {
                "name": "REVISION",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "component revision number"
            }
        ]
    },
    "1073833964": {
        "name": "DBGMCU_PIDR3",
        "address": 1073833964,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight peripheral identity register 3",
        "fields": [
            {
                "name": "CMOD",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "customer modified"
            },
            {
                "name": "REVAND",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "metal fix version"
            }
        ]
    },
    "1073833968": {
        "name": "DBGMCU_CIDR0",
        "address": 1073833968,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight component identity register 0",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "component identification bits [7:0]"
            }
        ]
    },
    "1073833972": {
        "name": "DBGMCU_CIDR1",
        "address": 1073833972,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight component identity register 1",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "component identification bits [11:8]"
            },
            {
                "name": "CLASS",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "component identification bits [15:12] - component class"
            }
        ]
    },
    "1073833976": {
        "name": "DBGMCU_CIDR2",
        "address": 1073833976,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight component identity register 2",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "component identification bits [23:16]"
            }
        ]
    },
    "1073833980": {
        "name": "DBGMCU_CIDR3",
        "address": 1073833980,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight component identity register 3",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "component identification bits [31:24]"
            }
        ]
    },
    "1073874944": {
        "name": "DMAMUX_C0CR",
        "address": 1073874944,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 0 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874948": {
        "name": "DMAMUX_C1CR",
        "address": 1073874948,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 1 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874952": {
        "name": "DMAMUX_C2CR",
        "address": 1073874952,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 2 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874956": {
        "name": "DMAMUX_C3CR",
        "address": 1073874956,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 3 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874960": {
        "name": "DMAMUX_C4CR",
        "address": 1073874960,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 4 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874964": {
        "name": "DMAMUX_C5CR",
        "address": 1073874964,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 5 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874968": {
        "name": "DMAMUX_C6CR",
        "address": 1073874968,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 6 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874972": {
        "name": "DMAMUX_C7CR",
        "address": 1073874972,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 7 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874976": {
        "name": "DMAMUX_C8CR",
        "address": 1073874976,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 8 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874980": {
        "name": "DMAMUX_C9CR",
        "address": 1073874980,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 9 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874984": {
        "name": "DMAMUX_C10CR",
        "address": 1073874984,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 10 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073874988": {
        "name": "DMAMUX_C11CR",
        "address": 1073874988,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer channel 11 configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "DMA request identification\nSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\nDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\nDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\nThis field must only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\nSelects the synchronization input (see Table137: DMAMUX: assignment of synchronization inputs to resources)."
            }
        ]
    },
    "1073875072": {
        "name": "DMAMUX_CSR",
        "address": 1073875072,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer interrupt channel status register",
        "fields": [
            {
                "name": "SOF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\nThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\nThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            }
        ]
    },
    "1073875076": {
        "name": "DMAMUX_CFR",
        "address": 1073875076,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request line multiplexer interrupt clear flag register",
        "fields": [
            {
                "name": "CSOF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            }
        ]
    },
    "1073875200": {
        "name": "DMAMUX_RG0CR",
        "address": 1073875200,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request generator channel 0 configuration register",
        "fields": [
            {
                "name": "SIG_ID",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator"
            },
            {
                "name": "OIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Trigger overrun interrupt enable"
            },
            {
                "name": "GE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "DMA request generator channel x enable"
            },
            {
                "name": "GPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input"
            },
            {
                "name": "GNBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field must be written only when GE bit is disabled."
            }
        ]
    },
    "1073875204": {
        "name": "DMAMUX_RG1CR",
        "address": 1073875204,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request generator channel 1 configuration register",
        "fields": [
            {
                "name": "SIG_ID",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator"
            },
            {
                "name": "OIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Trigger overrun interrupt enable"
            },
            {
                "name": "GE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "DMA request generator channel x enable"
            },
            {
                "name": "GPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input"
            },
            {
                "name": "GNBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field must be written only when GE bit is disabled."
            }
        ]
    },
    "1073875208": {
        "name": "DMAMUX_RG2CR",
        "address": 1073875208,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request generator channel 2 configuration register",
        "fields": [
            {
                "name": "SIG_ID",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator"
            },
            {
                "name": "OIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Trigger overrun interrupt enable"
            },
            {
                "name": "GE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "DMA request generator channel x enable"
            },
            {
                "name": "GPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input"
            },
            {
                "name": "GNBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field must be written only when GE bit is disabled."
            }
        ]
    },
    "1073875212": {
        "name": "DMAMUX_RG3CR",
        "address": 1073875212,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request generator channel 3 configuration register",
        "fields": [
            {
                "name": "SIG_ID",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator"
            },
            {
                "name": "OIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Trigger overrun interrupt enable"
            },
            {
                "name": "GE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "DMA request generator channel x enable"
            },
            {
                "name": "GPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input"
            },
            {
                "name": "GNBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field must be written only when GE bit is disabled."
            }
        ]
    },
    "1073875264": {
        "name": "DMAMUX_RGSR",
        "address": 1073875264,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request generator interrupt status register",
        "fields": [
            {
                "name": "OF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register."
            },
            {
                "name": "OF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register."
            },
            {
                "name": "OF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register."
            },
            {
                "name": "OF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register."
            }
        ]
    },
    "1073875268": {
        "name": "DMAMUX_RGCFR",
        "address": 1073875268,
        "size": 32,
        "access": "",
        "desc": "DMAMUX request generator interrupt clear flag register",
        "fields": [
            {
                "name": "COF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register."
            },
            {
                "name": "COF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register."
            },
            {
                "name": "COF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register."
            },
            {
                "name": "COF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register."
            }
        ]
    },
    "1073872896": {
        "name": "DMA_ISR",
        "address": 1073872896,
        "size": 32,
        "access": "",
        "desc": "DMA interrupt status register",
        "fields": [
            {
                "name": "GIF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Global interrupt flag for channel 1"
            },
            {
                "name": "TCIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transfer complete (TC) flag for channel 1"
            },
            {
                "name": "HTIF1",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Half transfer (HT) flag for channel 1"
            },
            {
                "name": "TEIF1",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transfer error (TE) flag for channel 1"
            },
            {
                "name": "GIF2",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Global interrupt flag for channel 2"
            },
            {
                "name": "TCIF2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Transfer complete (TC) flag for channel 2"
            },
            {
                "name": "HTIF2",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Half transfer (HT) flag for channel 2"
            },
            {
                "name": "TEIF2",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transfer error (TE) flag for channel 2"
            },
            {
                "name": "GIF3",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Global interrupt flag for channel 3"
            },
            {
                "name": "TCIF3",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Transfer complete (TC) flag for channel 3"
            },
            {
                "name": "HTIF3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Half transfer (HT) flag for channel 3"
            },
            {
                "name": "TEIF3",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Transfer error (TE) flag for channel 3"
            },
            {
                "name": "GIF4",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "global interrupt flag for channel 4"
            },
            {
                "name": "TCIF4",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Transfer complete (TC) flag for channel 4"
            },
            {
                "name": "HTIF4",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Half transfer (HT) flag for channel 4"
            },
            {
                "name": "TEIF4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Transfer error (TE) flag for channel 4"
            },
            {
                "name": "GIF5",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "global interrupt flag for channel 5"
            },
            {
                "name": "TCIF5",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Transfer complete (TC) flag for channel 5"
            },
            {
                "name": "HTIF5",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Half transfer (HT) flag for channel 5"
            },
            {
                "name": "TEIF5",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Transfer error (TE) flag for channel 5"
            },
            {
                "name": "GIF6",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Global interrupt flag for channel 6"
            },
            {
                "name": "TCIF6",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Transfer complete (TC) flag for channel 6"
            },
            {
                "name": "HTIF6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Half transfer (HT) flag for channel 6"
            },
            {
                "name": "TEIF6",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transfer error (TE) flag for channel 6"
            },
            {
                "name": "GIF7",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Global interrupt flag for channel 7"
            },
            {
                "name": "TCIF7",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transfer complete (TC) flag for channel 7"
            },
            {
                "name": "HTIF7",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Half transfer (HT) flag for channel 7"
            },
            {
                "name": "TEIF7",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Transfer error (TE) flag for channel 7"
            }
        ]
    },
    "1073872900": {
        "name": "DMA_IFCR",
        "address": 1073872900,
        "size": 32,
        "access": "",
        "desc": "DMA interrupt flag clear register",
        "fields": [
            {
                "name": "CGIF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Global interrupt flag clear for channel 1"
            },
            {
                "name": "CTCIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transfer complete flag clear for channel 1"
            },
            {
                "name": "CHTIF1",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Half transfer flag clear for channel 1"
            },
            {
                "name": "CTEIF1",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transfer error flag clear for channel 1"
            },
            {
                "name": "CGIF2",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Global interrupt flag clear for channel 2"
            },
            {
                "name": "CTCIF2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Transfer complete flag clear for channel 2"
            },
            {
                "name": "CHTIF2",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Half transfer flag clear for channel 2"
            },
            {
                "name": "CTEIF2",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transfer error flag clear for channel 2"
            },
            {
                "name": "CGIF3",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Global interrupt flag clear for channel 3"
            },
            {
                "name": "CTCIF3",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Transfer complete flag clear for channel 3"
            },
            {
                "name": "CHTIF3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Half transfer flag clear for channel 3"
            },
            {
                "name": "CTEIF3",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Transfer error flag clear for channel 3"
            },
            {
                "name": "CGIF4",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Global interrupt flag clear for channel 4"
            },
            {
                "name": "CTCIF4",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Transfer complete flag clear for channel 4"
            },
            {
                "name": "CHTIF4",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Half transfer flag clear for channel 4"
            },
            {
                "name": "CTEIF4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Transfer error flag clear for channel 4"
            },
            {
                "name": "CGIF5",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Global interrupt flag clear for channel 5"
            },
            {
                "name": "CTCIF5",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Transfer complete flag clear for channel 5"
            },
            {
                "name": "CHTIF5",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Half transfer flag clear for channel 5"
            },
            {
                "name": "CTEIF5",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Transfer error flag clear for channel 5"
            },
            {
                "name": "CGIF6",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Global interrupt flag clear for channel 6"
            },
            {
                "name": "CTCIF6",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Transfer complete flag clear for channel 6"
            },
            {
                "name": "CHTIF6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Half transfer flag clear for channel 6"
            },
            {
                "name": "CTEIF6",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transfer error flag clear for channel 6"
            },
            {
                "name": "CGIF7",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Global interrupt flag clear for channel 7"
            },
            {
                "name": "CTCIF7",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transfer complete flag clear for channel 7"
            },
            {
                "name": "CHTIF7",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Half transfer flag clear for channel 7"
            },
            {
                "name": "CTEIF7",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Transfer error flag clear for channel 7"
            }
        ]
    },
    "1073872904": {
        "name": "DMA_CCR1",
        "address": 1073872904,
        "size": 32,
        "access": "",
        "desc": "DMA channel 1 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register).\nNote: This bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872908": {
        "name": "DMA_CNDTR1",
        "address": 1073872908,
        "size": 32,
        "access": "",
        "desc": "DMA channel 1 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Number of data to transfer "
            }
        ]
    },
    "1073872912": {
        "name": "DMA_CPAR1",
        "address": 1073872912,
        "size": 32,
        "access": "",
        "desc": "DMA channel 1 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872916": {
        "name": "DMA_CMAR1",
        "address": 1073872916,
        "size": 32,
        "access": "",
        "desc": "DMA channel 1 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872924": {
        "name": "DMA_CCR2",
        "address": 1073872924,
        "size": 32,
        "access": "",
        "desc": "DMA channel 2 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register).\nNote: This bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872928": {
        "name": "DMA_CNDTR2",
        "address": 1073872928,
        "size": 32,
        "access": "",
        "desc": "DMA channel 2 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Number of data to transfer "
            }
        ]
    },
    "1073872932": {
        "name": "DMA_CPAR2",
        "address": 1073872932,
        "size": 32,
        "access": "",
        "desc": "DMA channel 2 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872936": {
        "name": "DMA_CMAR2",
        "address": 1073872936,
        "size": 32,
        "access": "",
        "desc": "DMA channel 2 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872944": {
        "name": "DMA_CCR3",
        "address": 1073872944,
        "size": 32,
        "access": "",
        "desc": "DMA channel 3 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register).\nNote: This bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872948": {
        "name": "DMA_CNDTR3",
        "address": 1073872948,
        "size": 32,
        "access": "",
        "desc": "DMA channel 3 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Number of data to transfer"
            }
        ]
    },
    "1073872952": {
        "name": "DMA_CPAR3",
        "address": 1073872952,
        "size": 32,
        "access": "",
        "desc": "DMA channel 3 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872956": {
        "name": "DMA_CMAR3",
        "address": 1073872956,
        "size": 32,
        "access": "",
        "desc": "DMA channel 3 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872964": {
        "name": "DMA_CCR4",
        "address": 1073872964,
        "size": 32,
        "access": "",
        "desc": "DMA channel 4 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register).\nNote: This bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872968": {
        "name": "DMA_CNDTR4",
        "address": 1073872968,
        "size": 32,
        "access": "",
        "desc": "DMA channel 4 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Number of data to transfer"
            }
        ]
    },
    "1073872972": {
        "name": "DMA_CPAR4",
        "address": 1073872972,
        "size": 32,
        "access": "",
        "desc": "DMA channel 4 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872976": {
        "name": "DMA_CMAR4",
        "address": 1073872976,
        "size": 32,
        "access": "",
        "desc": "DMA channel 4 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872984": {
        "name": "DMA_CCR5",
        "address": 1073872984,
        "size": 32,
        "access": "",
        "desc": "DMA channel 5 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register).\nNote: This bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872988": {
        "name": "DMA_CNDTR5",
        "address": 1073872988,
        "size": 32,
        "access": "",
        "desc": "DMA channel 5 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Number of data to transfer"
            }
        ]
    },
    "1073872992": {
        "name": "DMA_CPAR5",
        "address": 1073872992,
        "size": 32,
        "access": "",
        "desc": "DMA channel 5 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073872996": {
        "name": "DMA_CMAR5",
        "address": 1073872996,
        "size": 32,
        "access": "",
        "desc": "DMA channel 5 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073873004": {
        "name": "DMA_CCR6",
        "address": 1073873004,
        "size": 32,
        "access": "",
        "desc": "DMA channel 6 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register).\nNote: This bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073873008": {
        "name": "DMA_CNDTR6",
        "address": 1073873008,
        "size": 32,
        "access": "",
        "desc": "DMA channel 6 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Number of data to transfer "
            }
        ]
    },
    "1073873012": {
        "name": "DMA_CPAR6",
        "address": 1073873012,
        "size": 32,
        "access": "",
        "desc": "DMA channel 6 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073873016": {
        "name": "DMA_CMAR6",
        "address": 1073873016,
        "size": 32,
        "access": "",
        "desc": "DMA channel 6 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073873024": {
        "name": "DMA_CCR7",
        "address": 1073873024,
        "size": 32,
        "access": "",
        "desc": "DMA channel 7 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by1setting the CTEIFx bit of the DMA_IFCR register).\nNote: This bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transfer complete interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Half transfer interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transfer error interrupt enable\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Circular mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this bit identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bit identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bit identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this bitfield identifies the memory destination if DIR = 1 and the memory source if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this bitfield identifies the memory source if DIR = 1 and the memory destination if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Priority level\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Memory-to-memory mode\nNote: This bit is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073873028": {
        "name": "DMA_CNDTR7",
        "address": 1073873028,
        "size": 32,
        "access": "",
        "desc": "DMA channel 7 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Number of data to transfer "
            }
        ]
    },
    "1073873032": {
        "name": "DMA_CPAR7",
        "address": 1073873032,
        "size": 32,
        "access": "",
        "desc": "DMA channel 7 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the peripheral data register from/to which the data is read/written.\nWhen PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE[1:0] = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral destination address if DIR1= 1 and the peripheral source address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073873036": {
        "name": "DMA_CMAR7",
        "address": 1073873036,
        "size": 32,
        "access": "",
        "desc": "DMA channel 7 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral address\nIt contains the base address of the memory from/to which the data is read/written.\nWhen MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE[1:0] = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this bitfield identifies the memory source address if DIR = 1 and the memory destination address if DIR1=10.\nIn peripheral-to-peripheral mode, this bitfield identifies the peripheral source address if DIR1=11 and the peripheral destination address if DIR = 0.\nNote: This bitfield is set and cleared by software. It must not be written when the channel is enabled (EN = 1). It is not read-only when the channel is enabled (EN = 1)."
            }
        ]
    },
    "1073879040": {
        "name": "EXTI_RTSR1",
        "address": 1073879040,
        "size": 32,
        "access": "",
        "desc": "EXTI rising trigger selection register",
        "fields": [
            {
                "name": "RT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RT21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the rising edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            }
        ]
    },
    "1073879044": {
        "name": "EXTI_FTSR1",
        "address": 1073879044,
        "size": 32,
        "access": "",
        "desc": "EXTI falling trigger selection register 1",
        "fields": [
            {
                "name": "FT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FT21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line x (x1=1211to10)\nEach bit enables/disables the falling edge trigger for the event and interrupt on the corresponding line.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            }
        ]
    },
    "1073879048": {
        "name": "EXTI_SWIER1",
        "address": 1073879048,
        "size": 32,
        "access": "",
        "desc": "EXTI software interrupt event register 1",
        "fields": [
            {
                "name": "SWI0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "SWI21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line x (x1=1211to10)\nSetting of any bit by software triggers a rising edge event on the corresponding line x, resulting in an interrupt, independently of EXTI_RTSR1 and EXTI_FTSR1 settings. The bits are automatically cleared by HW. Reading of any bit always returns 0.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            }
        ]
    },
    "1073879052": {
        "name": "EXTI_RPR1",
        "address": 1073879052,
        "size": 32,
        "access": "",
        "desc": "EXTI rising edge pending register 1",
        "fields": [
            {
                "name": "RPIF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "RPIF21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a rising edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            }
        ]
    },
    "1073879056": {
        "name": "EXTI_FPR1",
        "address": 1073879056,
        "size": 32,
        "access": "",
        "desc": "EXTI falling edge pending register 1",
        "fields": [
            {
                "name": "FPIF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            },
            {
                "name": "FPIF21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line x (x1=1211to10)\nEach bit is set upon a falling edge event generated by hardware or by software (through the EXTI_SWIER1 register) on the corresponding line. Each bit is cleared by writing 1 into it.\nBits 18 and 19 are available only on STM32U0x3xx devices. They are reserved on STM32U031xx devices."
            }
        ]
    },
    "1073879136": {
        "name": "EXTI_EXTICR1",
        "address": 1073879136,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register 1",
        "fields": [
            {
                "name": "EXTI0",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI0 GPIO port selection\nThese bits are written by software to select the source input for EXTI0 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI1",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI1 GPIO port selection\nThese bits are written by software to select the source input for EXTI1 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI2",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI2 GPIO port selection\nThese bits are written by software to select the source input for EXTI2 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI3",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI3 GPIO port selection\nThese bits are written by software to select the source input for EXTI3 external interrupt.\nOthers reserved"
            }
        ]
    },
    "1073879140": {
        "name": "EXTI_EXTICR2",
        "address": 1073879140,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register 2",
        "fields": [
            {
                "name": "EXTI4",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI4 GPIO port selection\nThese bits are written by software to select the source input for EXTI4 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI5",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI5 GPIO port selection\nThese bits are written by software to select the source input for EXTI5 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI6",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI6 GPIO port selection\nThese bits are written by software to select the source input for EXTI6 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI7",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI7 GPIO port selection\nThese bits are written by software to select the source input for EXTI7 external interrupt.\nOthers reserved"
            }
        ]
    },
    "1073879144": {
        "name": "EXTI_EXTICR3",
        "address": 1073879144,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register 3",
        "fields": [
            {
                "name": "EXTI8",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI8 GPIO port selection\nThese bits are written by software to select the source input for EXTI8 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI9",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI9 GPIO port selection\nThese bits are written by software to select the source input for EXTI9 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI10",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI10 GPIO port selection\nThese bits are written by software to select the source input for EXTI10 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI11",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI11 GPIO port selection\nThese bits are written by software to select the source input for EXTI11 external interrupt.\nOthers reserved"
            }
        ]
    },
    "1073879148": {
        "name": "EXTI_EXTICR4",
        "address": 1073879148,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register 4",
        "fields": [
            {
                "name": "EXTI12",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI12 GPIO port selection\nThese bits are written by software to select the source input for EXTI12 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI13",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI13 GPIO port selection\nThese bits are written by software to select the source input for EXTI13 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI14",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI14 GPIO port selection\nThese bits are written by software to select the source input for EXTI14 external interrupt.\nOthers reserved"
            },
            {
                "name": "EXTI15",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI15 GPIO port selection\nThese bits are written by software to select the source input for EXTI15 external interrupt.\nOthers reserved"
            }
        ]
    },
    "1073879168": {
        "name": "EXTI_IMR1",
        "address": 1073879168,
        "size": 32,
        "access": "",
        "desc": "EXTI CPU wake-up with interrupt mask register",
        "fields": [
            {
                "name": "IM0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "IM31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=131 to 0)\nSetting/clearing each bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            }
        ]
    },
    "1073879172": {
        "name": "EXTI_EMR1",
        "address": 1073879172,
        "size": 32,
        "access": "",
        "desc": "EXTI CPU wake-up with event mask register",
        "fields": [
            {
                "name": "EM0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            },
            {
                "name": "EM31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x (x1=1311to10)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBits 18, 19, 22 and 26 are available only on STM32U0x3xx devices, they are reserved on STM32U031xx devices."
            }
        ]
    },
    "1073879184": {
        "name": "EXTI_IMR2",
        "address": 1073879184,
        "size": 32,
        "access": "",
        "desc": "EXTI CPU wake-up with interrupt mask register",
        "fields": [
            {
                "name": "IM32",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=1371to132)\nSetting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            },
            {
                "name": "IM33",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=1371to132)\nSetting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            },
            {
                "name": "IM34",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=1371to132)\nSetting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            },
            {
                "name": "IM35",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=1371to132)\nSetting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            },
            {
                "name": "IM36",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=1371to132)\nSetting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            },
            {
                "name": "IM37",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wake-up with interrupt mask on line x (x1=1371to132)\nSetting/clearing this bit unmasks/masks the CPU wake-up with interrupt, by an event on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            }
        ]
    },
    "1073879188": {
        "name": "EXTI_EMR2",
        "address": 1073879188,
        "size": 32,
        "access": "",
        "desc": "EXTI CPU wake-up with event mask register",
        "fields": [
            {
                "name": "EM32",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x, (x1=1371to132)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            },
            {
                "name": "EM33",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x, (x1=1371to132)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            },
            {
                "name": "EM34",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x, (x1=1371to132)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            },
            {
                "name": "EM35",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x, (x1=1371to132)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            },
            {
                "name": "EM36",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x, (x1=1371to132)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            },
            {
                "name": "EM37",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wake-up with event generation mask on line x, (x1=1371to132)\nSetting/clearing each bit unmasks/masks the CPU wake-up with event generation on the corresponding line.\nBit IM36 is available only on STM32U0x3xx devices, it is reserved on STM32U031xx devices."
            }
        ]
    },
    "1073881088": {
        "name": "FLASH_ACR",
        "address": 1073881088,
        "size": 32,
        "access": "",
        "desc": "FLASH access control register",
        "fields": [
            {
                "name": "LATENCY",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Flash memory access latency\nThe value in this bitfield represents the number of CPU wait states when accessing the flash memory.\nOther: Reserved\nA new write into the bitfield becomes effective when it returns the same value upon read."
            },
            {
                "name": "PRFTEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU Prefetch enable"
            },
            {
                "name": "ICEN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU Instruction cache enable"
            },
            {
                "name": "ICRST",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CPU Instruction cache reset\nThis bit can be written only when the instruction cache is disabled."
            },
            {
                "name": "EMPTY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Main flash memory area empty\nThis bit indicates whether the first location of the main flash memory area is erased or has a programmed value.\nThe bit can be set and reset by software."
            },
            {
                "name": "DBG_SWEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Debug access software enable\nSoftware may use this bit to enable/disable the debugger read access."
            }
        ]
    },
    "1073881096": {
        "name": "FLASH_KEYR",
        "address": 1073881096,
        "size": 32,
        "access": "",
        "desc": "FLASH key register",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "FLASH key\nThe following values must be written consecutively to unlock the FLASH control register (FLASH_CR), thus enabling programming/erasing operations:\nKEY1: 0x4567 0123\nKEY2: 0xCDEF 89AB"
            }
        ]
    },
    "1073881100": {
        "name": "FLASH_OPTKEYR",
        "address": 1073881100,
        "size": 32,
        "access": "",
        "desc": "FLASH option key register",
        "fields": [
            {
                "name": "OPTKEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Option byte key\nThe following values must be written consecutively to unlock the flash memory option registers, enabling option byte programming/erasing operations:\nKEY1: 0x0819 2A3B\nKEY2: 0x4C5D 6E7F"
            }
        ]
    },
    "1073881104": {
        "name": "FLASH_SR",
        "address": 1073881104,
        "size": 32,
        "access": "",
        "desc": "FLASH status register",
        "fields": [
            {
                "name": "EOP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "End of operation\nSet by hardware when one or more flash memory operation (programming / erase) has been completed successfully.\nThis bit is set only if the end of operation interrupts are enabled (EOPIE=1).\nCleared by writing 1."
            },
            {
                "name": "OPERR",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Operation error\nSet by hardware when a flash memory operation (program / erase) completes unsuccessfully.\nThis bit is set only if error interrupts are enabled (ERRIE=1).\nCleared by writing 1."
            },
            {
                "name": "PROGERR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Programming error\nSet by hardware when a double-word address to be programmed contains a value different from '0xFFFF FFFF' before programming, except if the data to write is '0x0000 0000'.\nCleared by writing 1."
            },
            {
                "name": "WRPERR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Write protection error\nSet by hardware when an address to be erased/programmed belongs to a write-protected part (by WRP, PCROP or RDP Level 1) of the flash memory.\nCleared by writing 1."
            },
            {
                "name": "PGAERR",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Programming alignment error\nSet by hardware when the data to program cannot be contained in the same double word (64-bit) flash memory in case of standard programming, or if there is a change of page during fast programming.\nCleared by writing 1."
            },
            {
                "name": "SIZERR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Size error\nSet by hardware when the size of the access is a byte or half-word during a program or a fast program sequence. Only double word programming is allowed (consequently: word access).\nCleared by writing 1."
            },
            {
                "name": "PGSERR",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Programming sequence error\nSet by hardware when a write access to the flash memory is performed by the code while PG or FSTPG have not been set previously. Set also by hardware when PROGERR, SIZERR, PGAERR, WRPERR, MISSERR or FASTERR is set due to a previous programming error.\nCleared by writing 1."
            },
            {
                "name": "MISSERR",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Fast programming data miss error\nIn Fast programming mode, 16 double words (128 bytes) must be sent to flash memory successively, and the new data must be sent to the logic control before the current data is fully programmed. MISSERR is set by hardware when the new data is not present in time.\nCleared by writing 1."
            },
            {
                "name": "FASTERR",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Fast programming error\nSet by hardware when a fast programming sequence (activated by FSTPG) is interrupted due to an error (alignment, size, write protection or data miss). The corresponding status bit (PGAERR, SIZERR, WRPERR or MISSERR) is set at the same time.\nCleared by writing 1."
            },
            {
                "name": "RDERR",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "PCROP read error\nSet by hardware when an address to be read belongs to a read protected area of the flash memory (PCROP protection). An interrupt is generated if RDERRIE is set in FLASH_CR.\nCleared by writing 1."
            },
            {
                "name": "OPTVERR",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Option and Engineering bits loading validity error "
            },
            {
                "name": "BSY1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Busy\nThis flag indicates that a flash memory operation requested by FLASH control register (FLASH_CR) is in progress. This bit is set at the beginning of the flash memory operation, and cleared when the operation finishes or when an error occurs."
            },
            {
                "name": "CFGBSY",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Programming or erase configuration busy.\nThis flag is set and cleared by hardware. It is set when the first word is sent for program or when setting the STRT bit of FLASH control register (FLASH_CR) for erase. It is cleared when the flash memory program or erase operation completes or ends with an error.\nWhen set, launching any other operation through the FLASH control register (FLASH_CR) is impossible, and must be postponed (a programming or erase operation is ongoing).\nWhen cleared, the program and erase settings in the FLASH control register (FLASH_CR) can be modified."
            }
        ]
    },
    "1073881108": {
        "name": "FLASH_CR",
        "address": 1073881108,
        "size": 32,
        "access": "",
        "desc": "FLASH control register",
        "fields": [
            {
                "name": "PG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Flash memory programming enable"
            },
            {
                "name": "PER",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Page erase enable"
            },
            {
                "name": "MER1",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Mass erase\nWhen set, this bit triggers the mass erase, that is, all user pages."
            },
            {
                "name": "PNB",
                "bitOffset": 3,
                "bitWidth": 7,
                "desc": "Page number selection\nThese bits select the page to erase:\n...\nNote: Values corresponding to addresses outside the main memory are not allowed."
            },
            {
                "name": "STRT",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Start erase operation\nThis bit triggers an erase operation when set.\nThis bit is possible to set only by software and to clear only by hardware. The hardware clears it when one of BSY1 and BSY2 flags in the FLASH_SR register transits to zero."
            },
            {
                "name": "OPTSTRT",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Start of modification of option bytes\nThis bit triggers an options operation when set.\nThis bit is set only by software, and is cleared when the BSY1 bit is cleared in FLASH_SR."
            },
            {
                "name": "FSTPG",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Fast programming enable"
            },
            {
                "name": "EOPIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "End-of-operation interrupt enable\nThis bit enables the interrupt generation upon setting the EOP flag in the FLASH_SR register."
            },
            {
                "name": "ERRIE",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Error interrupt enable\nThis bit enables the interrupt generation upon setting the OPERR flag in the FLASH_SR register."
            },
            {
                "name": "RDERRIE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "PCROP read error interrupt enable\nThis bit enables the interrupt generation upon setting the RDERR flag in the FLASH_SR register."
            },
            {
                "name": "OBL_LAUNCH",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Option byte load launch\nWhen set, this bit triggers the load of option bytes into option registers. It is automatically cleared upon the completion of the load. The high state of the bit indicates pending option byte load.\nThe bit cannot be cleared by software. It cannot be written as long as OPTLOCK is set."
            },
            {
                "name": "SEC_PROT",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Securable memory area protection enable\nThis bit enables the protection on securable area, provided that a non-null securable memory area size (SEC_SIZE[4:0]) is defined in option bytes.\nThis bit is possible to set only by software and to clear only through a system reset."
            },
            {
                "name": "OPTLOCK",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Options Lock\nThis bit is set only. When set, all bits concerning user option in FLASH_CR register and so option page are locked. This bit is cleared by hardware after detecting the unlock sequence. The LOCK bit must be cleared before doing the unlock sequence for OPTLOCK bit.\nIn case of an unsuccessful unlock operation, this bit remains set until the next reset."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "FLASH_CR Lock\nThis bit is set only. When set, the FLASH_CR register is locked. It is cleared by hardware after detecting the unlock sequence.\nIn case of an unsuccessful unlock operation, this bit remains set until the next system reset."
            }
        ]
    },
    "1073881112": {
        "name": "FLASH_ECCR",
        "address": 1073881112,
        "size": 32,
        "access": "",
        "desc": "FLASH ECC register",
        "fields": [
            {
                "name": "ADDR_ECC",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "ECC fail double-word address offset\n In case of ECC error or ECC correction detected, this bitfield contains double-word offset (multiple of 64 bits) to main Flash memory."
            },
            {
                "name": "SYSF_ECC",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "System Flash memory ECC fail\nThis bit indicates that the ECC error correction or double ECC error detection is located in the system Flash memory."
            },
            {
                "name": "ECCCIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "ECC correction interrupt enable"
            },
            {
                "name": "ECCC",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "ECC correction\nSet by hardware when one ECC error has been detected and corrected. An interrupt is generated if ECCIE is set.\nCleared by writing 1."
            },
            {
                "name": "ECCD",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "ECC detection\nSet by hardware when two ECC errors have been detected. When this bit is set, a NMI is generated.\nCleared by writing 1."
            }
        ]
    },
    "1073881120": {
        "name": "FLASH_OPTR",
        "address": 1073881120,
        "size": 32,
        "access": "",
        "desc": "FLASH option register",
        "fields": [
            {
                "name": "RDP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Read protection level\nOther: Level 1, memories read protection active"
            },
            {
                "name": "BORR_LEV",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "BOR reset level"
            },
            {
                "name": "NRST_STOP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Reset generated when entering Stop mode"
            },
            {
                "name": "NRST_STDBY",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Reset generated when entering Standby mode"
            },
            {
                "name": "NRST_SHDW",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Reset generated when entering Shutdown mode"
            },
            {
                "name": "IWDG_SW",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Independent watchdog selection"
            },
            {
                "name": "IWDG_STOP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Independent watchdog counter freeze in Stop mode"
            },
            {
                "name": "IWDG_STDBY",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Independent watchdog counter freeze in Standby mode"
            },
            {
                "name": "WWDG_SW",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Window watchdog selection"
            },
            {
                "name": "BDRST",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Backup domain reset"
            },
            {
                "name": "RAM_PARITY_CHECK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "SRAM parity check control enable/disable"
            },
            {
                "name": "BKPSRAM_HW_ERASE_DISABLE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Backup SRAM erase prevention"
            },
            {
                "name": "NBOOT_SEL",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "BOOT0 signal source selection\nThis option bit defines the source of the BOOT0 signal."
            },
            {
                "name": "NBOOT1",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Boot configuration\nTogether with the BOOT0 pin or option bit NBOOT0 (depending on NBOOT_SEL option bit configuration), this bit selects boot mode from the main flash memory, SRAM or the system memory. Refer to Section12.5: Boot configuration."
            },
            {
                "name": "NBOOT0",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "NBOOT0 option bit"
            },
            {
                "name": "NRST_MODE",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "NRST pin configuration"
            },
            {
                "name": "IRHEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Internal reset holder enable bit"
            }
        ]
    },
    "1073881132": {
        "name": "FLASH_WRP1AR",
        "address": 1073881132,
        "size": 32,
        "access": "",
        "desc": "FLASH WRP area A address register",
        "fields": [
            {
                "name": "WRP1A_STRT",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "WRP area A start offset\nThis bitfield contains the offset of the first page of the WRP area A.\nNote: The number of effective bits depends on the size of the flash memory in the device."
            },
            {
                "name": "WRP1A_END",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "WRP area A end offset\nThis bitfield contains the offset of the last page of the WRP area A.\nNote: The number of effective bits depends on the size of the flash memory in the device."
            }
        ]
    },
    "1073881136": {
        "name": "FLASH_WRP1BR",
        "address": 1073881136,
        "size": 32,
        "access": "",
        "desc": "FLASH WRP area B address register",
        "fields": [
            {
                "name": "WRP1B_STRT",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "WRP area B start offset\nThis bitfield contains the offset of the first page of the WRP area B.\nNote: The number of effective bits depends on the size of the flash memory in the device."
            },
            {
                "name": "WRP1B_END",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "WRP area B end offset\nThis bitfield contains the offset of the last page of the WRP area B.\nNote: The number of effective bits depends on the size of the flash memory in the device."
            }
        ]
    },
    "1073881216": {
        "name": "FLASH_SECR",
        "address": 1073881216,
        "size": 32,
        "access": "",
        "desc": "FLASH security register",
        "fields": [
            {
                "name": "HDP1_PEND",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Last page of the first hide protection area"
            },
            {
                "name": "BOOT_LOCK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "used to force boot from user area\nIf the bit is set in association with RDP level 1, the debug capabilities are disabled, except in the case of a bad OBL (mismatch)."
            },
            {
                "name": "HDP1EN",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Hide protection area enable"
            }
        ]
    },
    "1342177280": {
        "name": "GPIOA_MODER",
        "address": 1342177280,
        "size": 32,
        "access": "",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            }
        ]
    },
    "1342177284": {
        "name": "GPIOA_OTYPER",
        "address": 1342177284,
        "size": 32,
        "access": "",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            }
        ]
    },
    "1342177288": {
        "name": "GPIOA_OSPEEDR",
        "address": 1342177288,
        "size": 32,
        "access": "",
        "desc": "GPIO port output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            }
        ]
    },
    "1342177292": {
        "name": "GPIOA_PUPDR",
        "address": 1342177292,
        "size": 32,
        "access": "",
        "desc": "GPIO port pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            }
        ]
    },
    "1342177296": {
        "name": "GPIOA_IDR",
        "address": 1342177296,
        "size": 32,
        "access": "",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            }
        ]
    },
    "1342177300": {
        "name": "GPIOA_ODR",
        "address": 1342177300,
        "size": 32,
        "access": "",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            }
        ]
    },
    "1342177304": {
        "name": "GPIOA_BSRR",
        "address": 1342177304,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            }
        ]
    },
    "1342177308": {
        "name": "GPIOA_LCKR",
        "address": 1342177308,
        "size": 32,
        "access": "",
        "desc": "GPIO port configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\nRD LCKR\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nNote: Any error in the lock sequence aborts the lock.\nNote: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1342177312": {
        "name": "GPIOA_AFRL",
        "address": 1342177312,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342177316": {
        "name": "GPIOA_AFRH",
        "address": 1342177316,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342177320": {
        "name": "GPIOA_BRR",
        "address": 1342177320,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            }
        ]
    },
    "1342178304": {
        "name": "GPIOB_MODER",
        "address": 1342178304,
        "size": 32,
        "access": "",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            }
        ]
    },
    "1342178308": {
        "name": "GPIOB_OTYPER",
        "address": 1342178308,
        "size": 32,
        "access": "",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            }
        ]
    },
    "1342178312": {
        "name": "GPIOB_OSPEEDR",
        "address": 1342178312,
        "size": 32,
        "access": "",
        "desc": "GPIO port output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            }
        ]
    },
    "1342178316": {
        "name": "GPIOB_PUPDR",
        "address": 1342178316,
        "size": 32,
        "access": "",
        "desc": "GPIO port pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            }
        ]
    },
    "1342178320": {
        "name": "GPIOB_IDR",
        "address": 1342178320,
        "size": 32,
        "access": "",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            }
        ]
    },
    "1342178324": {
        "name": "GPIOB_ODR",
        "address": 1342178324,
        "size": 32,
        "access": "",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            }
        ]
    },
    "1342178328": {
        "name": "GPIOB_BSRR",
        "address": 1342178328,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            }
        ]
    },
    "1342178332": {
        "name": "GPIOB_LCKR",
        "address": 1342178332,
        "size": 32,
        "access": "",
        "desc": "GPIO port configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\nRD LCKR\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nNote: Any error in the lock sequence aborts the lock.\nNote: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1342178336": {
        "name": "GPIOB_AFRL",
        "address": 1342178336,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342178340": {
        "name": "GPIOB_AFRH",
        "address": 1342178340,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342178344": {
        "name": "GPIOB_BRR",
        "address": 1342178344,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            }
        ]
    },
    "1342179328": {
        "name": "GPIOC_MODER",
        "address": 1342179328,
        "size": 32,
        "access": "",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            }
        ]
    },
    "1342179332": {
        "name": "GPIOC_OTYPER",
        "address": 1342179332,
        "size": 32,
        "access": "",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            }
        ]
    },
    "1342179336": {
        "name": "GPIOC_OSPEEDR",
        "address": 1342179336,
        "size": 32,
        "access": "",
        "desc": "GPIO port output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            }
        ]
    },
    "1342179340": {
        "name": "GPIOC_PUPDR",
        "address": 1342179340,
        "size": 32,
        "access": "",
        "desc": "GPIO port pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            }
        ]
    },
    "1342179344": {
        "name": "GPIOC_IDR",
        "address": 1342179344,
        "size": 32,
        "access": "",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            }
        ]
    },
    "1342179348": {
        "name": "GPIOC_ODR",
        "address": 1342179348,
        "size": 32,
        "access": "",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            }
        ]
    },
    "1342179352": {
        "name": "GPIOC_BSRR",
        "address": 1342179352,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            }
        ]
    },
    "1342179356": {
        "name": "GPIOC_LCKR",
        "address": 1342179356,
        "size": 32,
        "access": "",
        "desc": "GPIO port configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\nRD LCKR\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nNote: Any error in the lock sequence aborts the lock.\nNote: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1342179360": {
        "name": "GPIOC_AFRL",
        "address": 1342179360,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342179364": {
        "name": "GPIOC_AFRH",
        "address": 1342179364,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342179368": {
        "name": "GPIOC_BRR",
        "address": 1342179368,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            }
        ]
    },
    "1342180352": {
        "name": "GPIOD_MODER",
        "address": 1342180352,
        "size": 32,
        "access": "",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            }
        ]
    },
    "1342180356": {
        "name": "GPIOD_OTYPER",
        "address": 1342180356,
        "size": 32,
        "access": "",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            }
        ]
    },
    "1342180360": {
        "name": "GPIOD_OSPEEDR",
        "address": 1342180360,
        "size": 32,
        "access": "",
        "desc": "GPIO port output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            }
        ]
    },
    "1342180364": {
        "name": "GPIOD_PUPDR",
        "address": 1342180364,
        "size": 32,
        "access": "",
        "desc": "GPIO port pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            }
        ]
    },
    "1342180368": {
        "name": "GPIOD_IDR",
        "address": 1342180368,
        "size": 32,
        "access": "",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            }
        ]
    },
    "1342180372": {
        "name": "GPIOD_ODR",
        "address": 1342180372,
        "size": 32,
        "access": "",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            }
        ]
    },
    "1342180376": {
        "name": "GPIOD_BSRR",
        "address": 1342180376,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            }
        ]
    },
    "1342180380": {
        "name": "GPIOD_LCKR",
        "address": 1342180380,
        "size": 32,
        "access": "",
        "desc": "GPIO port configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\nRD LCKR\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nNote: Any error in the lock sequence aborts the lock.\nNote: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1342180384": {
        "name": "GPIOD_AFRL",
        "address": 1342180384,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342180388": {
        "name": "GPIOD_AFRH",
        "address": 1342180388,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342180392": {
        "name": "GPIOD_BRR",
        "address": 1342180392,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            }
        ]
    },
    "1342181376": {
        "name": "GPIOE_MODER",
        "address": 1342181376,
        "size": 32,
        "access": "",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            }
        ]
    },
    "1342181380": {
        "name": "GPIOE_OTYPER",
        "address": 1342181380,
        "size": 32,
        "access": "",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            }
        ]
    },
    "1342181384": {
        "name": "GPIOE_OSPEEDR",
        "address": 1342181384,
        "size": 32,
        "access": "",
        "desc": "GPIO port output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            }
        ]
    },
    "1342181388": {
        "name": "GPIOE_PUPDR",
        "address": 1342181388,
        "size": 32,
        "access": "",
        "desc": "GPIO port pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            }
        ]
    },
    "1342181392": {
        "name": "GPIOE_IDR",
        "address": 1342181392,
        "size": 32,
        "access": "",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            }
        ]
    },
    "1342181396": {
        "name": "GPIOE_ODR",
        "address": 1342181396,
        "size": 32,
        "access": "",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            }
        ]
    },
    "1342181400": {
        "name": "GPIOE_BSRR",
        "address": 1342181400,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            }
        ]
    },
    "1342181404": {
        "name": "GPIOE_LCKR",
        "address": 1342181404,
        "size": 32,
        "access": "",
        "desc": "GPIO port configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\nRD LCKR\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nNote: Any error in the lock sequence aborts the lock.\nNote: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1342181408": {
        "name": "GPIOE_AFRL",
        "address": 1342181408,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342181412": {
        "name": "GPIOE_AFRH",
        "address": 1342181412,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342181416": {
        "name": "GPIOE_BRR",
        "address": 1342181416,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            }
        ]
    },
    "1342182400": {
        "name": "GPIOF_MODER",
        "address": 1342182400,
        "size": 32,
        "access": "",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O mode."
            }
        ]
    },
    "1342182404": {
        "name": "GPIOF_OTYPER",
        "address": 1342182404,
        "size": 32,
        "access": "",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output type."
            }
        ]
    },
    "1342182408": {
        "name": "GPIOF_OSPEEDR",
        "address": 1342182408,
        "size": 32,
        "access": "",
        "desc": "GPIO port output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.."
            }
        ]
    },
    "1342182412": {
        "name": "GPIOF_PUPDR",
        "address": 1342182412,
        "size": 32,
        "access": "",
        "desc": "GPIO port pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y\nThese bits are written by software to configure the I/O pull-up or pull-down"
            }
        ]
    },
    "1342182416": {
        "name": "GPIOF_IDR",
        "address": 1342182416,
        "size": 32,
        "access": "",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port."
            }
        ]
    },
    "1342182420": {
        "name": "GPIOF_ODR",
        "address": 1342182420,
        "size": 32,
        "access": "",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR register (x = A..F)."
            }
        ]
    },
    "1342182424": {
        "name": "GPIOF_BSRR",
        "address": 1342182424,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSx and BRx are set, BSx has priority."
            }
        ]
    },
    "1342182428": {
        "name": "GPIOF_LCKR",
        "address": 1342182428,
        "size": 32,
        "access": "",
        "desc": "GPIO port configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nLOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\nRD LCKR\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nNote: Any error in the lock sequence aborts the lock.\nNote: After the first lock sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1342182432": {
        "name": "GPIOF_AFRL",
        "address": 1342182432,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342182436": {
        "name": "GPIOF_AFRH",
        "address": 1342182436,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y\nThese bits are written by software to configure alternate function I/Os."
            }
        ]
    },
    "1342182440": {
        "name": "GPIOF_BRR",
        "address": 1342182440,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y\nThese bits are write-only. A read to these bits returns the value 0x0000."
            }
        ]
    },
    "1073754112": {
        "name": "IWDG_KR",
        "address": 1073754112,
        "size": 32,
        "access": "",
        "desc": "IWDG key register",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Key value (write only, read 0x0000)\nThese bits can be used for several functions, depending upon the value written by the application:\n- 0xAAAA: reloads the RL[11:0] value into the IWDCNT down-counter (watchdog refresh), and write-protects registers. This value must be written by software at regular intervals, otherwise the watchdog generates a reset when the counter reaches 0.\n- 0x5555: enables write-accesses to the registers.\n- 0xCCCC: enables the watchdog (except if the hardware watchdog option is selected) and write-protects registers.\n- values different from 0x5555: write-protects registers.\nNote that only IWDG_PR, IWDG_RLR, IWDG_EWCR and IWDG_WINR registers have a write-protection mechanism."
            }
        ]
    },
    "1073754116": {
        "name": "IWDG_PR",
        "address": 1073754116,
        "size": 32,
        "access": "",
        "desc": "IWDG prescaler register",
        "fields": [
            {
                "name": "PR",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Prescaler divider\nThese bits are write access protected, see Section126.4.6. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the IWDG status register (IWDG_SR) must be reset to be able to change the prescaler divider.\nOthers: divider / 1024\nNote: Reading this register returns the prescaler value from the V<sub>DD</sub> voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG status register (IWDG_SR) is reset."
            }
        ]
    },
    "1073754120": {
        "name": "IWDG_RLR",
        "address": 1073754120,
        "size": 32,
        "access": "",
        "desc": "IWDG reload register",
        "fields": [
            {
                "name": "RL",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter reload value\nThese bits are write access protected, see Section126.4.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG key register (IWDG_KR). The watchdog counter counts down from this value. The timeout period is a function of this value and the prescaler.clock. It is not recommended to set RL[11:0] to a value lower than 2.\nThe RVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.\nNote: Reading this register returns the reload value from the V<sub>DD</sub> voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the RVU bit in the IWDG status register (IWDG_SR) is reset."
            }
        ]
    },
    "1073754124": {
        "name": "IWDG_SR",
        "address": 1073754124,
        "size": 32,
        "access": "",
        "desc": "IWDG status register",
        "fields": [
            {
                "name": "PVU",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Watchdog prescaler value update\nThis bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the V<sub>DD</sub> voltage domain (takes up to six periods of the IWDG kernel clock iwdg_ker_ck).\nThe prescaler value can be updated only when PVU bit is reset."
            },
            {
                "name": "RVU",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Watchdog counter reload value update\nThis bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the V<sub>DD</sub> voltage domain (takes up to six periods of the IWDG kernel clock iwdg_ker_ck).\nThe reload value can be updated only when RVU bit is reset."
            },
            {
                "name": "WVU",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Watchdog counter window value update\nThis bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the V<sub>DD</sub> voltage domain (takes up to one period of presc_ck and two periods of the IWDG kernel clock iwdg_ker_ck).\nThe window value can be updated only when WVU bit is reset.\nThis bit is generated only if generic window = 1."
            },
            {
                "name": "EWU",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Watchdog interrupt comparator value update\nThis bit is set by hardware to indicate that an update of the interrupt comparator value (EWIT[11:0]) or an update of the EWIE is ongoing. It is reset by hardware when the update operation is completed in the V<sub>DD</sub> voltage domain (takes up to one period of presc_ck and two periods of the IWDG kernel clock iwdg_ker_ck).\nThe EWIT[11:0] and EWIE fields can be updated only when EWU bit is reset."
            },
            {
                "name": "ONF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Watchdog enable status bit\nSet to 1 by hardware as soon as the IWDG is started. In software mode, it remains to '1' until the IWDG is reset. In hardware mode, this bit is always set to '1'."
            },
            {
                "name": "EWIF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Watchdog early interrupt flag\nThis bit is set to 1 by hardware in order to indicate that an early interrupt is pending. This bit must be cleared by the software by writing the bit EWIC of IWDG_EWCR register to 1."
            }
        ]
    },
    "1073754128": {
        "name": "IWDG_WINR",
        "address": 1073754128,
        "size": 32,
        "access": "",
        "desc": "IWDG window register",
        "fields": [
            {
                "name": "WIN",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter window value\nThese bits are write access protected, see Section126.4.6.They contain the high limit of the window value to be compared with the downcounter.\nTo prevent a reset, the IWDCNT downcounter must be reloaded when its value is lower than WIN[11:0]1+11 and greater than 1.\nThe WVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.\nNote: Reading this register returns the reload value from the V<sub>DD</sub> voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG status register (IWDG_SR) is reset."
            }
        ]
    },
    "1073754132": {
        "name": "IWDG_EWCR",
        "address": 1073754132,
        "size": 32,
        "access": "",
        "desc": "IWDG early wake-up interrupt register",
        "fields": [
            {
                "name": "EWIT",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter window value\nThese bits are write access protected (see Section126.4.6). They are written by software to define at which position of the IWDCNT down-counter the early wake-up interrupt must be generated. The early interrupt is generated when the IWDCNT is lower or equal to EWIT[11:0]1-11.\nEWIT[11:0] must be bigger than 1.\nAn interrupt is generated only if EWIE = 1.\nThe EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.\nNote: Reading this register returns the Early wake-up comparator value and the Interrupt enable bit from the V<sub>DD</sub> voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the EWU bit in the IWDG status register (IWDG_SR) is reset."
            },
            {
                "name": "EWIC",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Watchdog early interrupt acknowledge\nThe software must write a 1 into this bit in order to acknowledge the early wake-up interrupt and to clear the EWIF flag. Writing 0 has not effect, reading this flag returns a 0."
            },
            {
                "name": "EWIE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Watchdog early interrupt enable\nSet and reset by software.\nThe EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the value of this bit."
            }
        ]
    },
    "1073763328": {
        "name": "I2C_CR1",
        "address": 1073763328,
        "size": 32,
        "access": "",
        "desc": "I2C control register 1",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Peripheral enable\nNote: When PE = 0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least three APB clock cycles."
            },
            {
                "name": "TXIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TX interrupt enable"
            },
            {
                "name": "RXIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "RX interrupt enable"
            },
            {
                "name": "ADDRIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address match interrupt enable (slave only)"
            },
            {
                "name": "NACKIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not acknowledge received interrupt enable"
            },
            {
                "name": "STOPIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Stop detection interrupt enable"
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transfer complete interrupt enable\nNote: Any of these events generate an interrupt:\nNote: Transfer complete (TC)\nNote: Transfer complete reload (TCR)"
            },
            {
                "name": "ERRIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Error interrupts enable\nNote: Any of these errors generate an interrupt:\nNote: Arbitration loss (ARLO)\nNote: Bus error detection (BERR)\nNote: Overrun/Underrun (OVR)"
            },
            {
                "name": "DNF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Digital noise filter\nThese bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * t<sub>I2CCLK</sub>\n<sub>...</sub>\nNote: If the analog filter is enabled, the digital filter is added to it. This filter can be programmed only when the I2C is disabled (PE = 0)."
            },
            {
                "name": "ANFOFF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Analog noise filter OFF\nNote: This bit can be programmed only when the I2C is disabled (PE = 0)."
            },
            {
                "name": "TXDMAEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "DMA transmission requests enable"
            },
            {
                "name": "RXDMAEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DMA reception requests enable"
            },
            {
                "name": "SBC",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Slave byte control\nThis bit is used to enable hardware byte control in slave mode."
            },
            {
                "name": "NOSTRETCH",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Clock stretching disable\nThis bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.\nNote: This bit can be programmed only when the I2C is disabled (PE = 0)."
            },
            {
                "name": "WUPEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Wake-up from Stop mode enable"
            },
            {
                "name": "GCEN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "General call enable"
            },
            {
                "name": "FMP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Fast-mode Plus 20 mA drive enable"
            },
            {
                "name": "ADDRACLR",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Address match flag (ADDR) automatic clear"
            },
            {
                "name": "STOPFACLR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "STOP detection flag (STOPF) automatic clear"
            }
        ]
    },
    "1073763332": {
        "name": "I2C_CR2",
        "address": 1073763332,
        "size": 32,
        "access": "",
        "desc": "I2C control register 2",
        "fields": [
            {
                "name": "SADD",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Slave address (master mode)\nIn 7-bit addressing mode (ADD10 = 0):\nSADD[7:1] must be written with the 7-bit slave address to be sent. Bits SADD[9], SADD[8] and SADD[0] are don't care.\nIn 10-bit addressing mode (ADD10 = 1):\nSADD[9:0] must be written with the 10-bit slave address to be sent.\nNote: Changing these bits when the START bit is set is not allowed."
            },
            {
                "name": "RD_WRN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Transfer direction (master mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "ADD10",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "10-bit addressing mode (master mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "HEAD10R",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "10-bit address header only read direction (master receiver mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "START",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Start generation\nThis bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0.\nIf the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated start condition when RELOAD = 0, after the end of the NBYTES transfer.\nOtherwise, setting this bit generates a START condition once the bus is free.\nNote: Writing 0 to this bit has no effect.\nNote: The START bit can be set even if the bus is BUSY or I2C is in slave mode.\nNote: This bit has no effect when RELOAD is set."
            },
            {
                "name": "STOP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Stop generation (master mode)\nThe bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.\nIn master mode:\nNote: Writing 0 to this bit has no effect."
            },
            {
                "name": "NACK",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "NACK generation (slave mode)\nThe bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE = 0.\nNote: Writing 0 to this bit has no effect.\nNote: This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value.\nNote: When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated, whatever the NACK bit value.\nNote: When hardware PEC checking is enabled (PECBYTE = 1), the PEC acknowledge value does not depend on the NACK value."
            },
            {
                "name": "NBYTES",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Number of bytes"
            },
            {
                "name": "RELOAD",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "NBYTES reload mode\nThis bit is set and cleared by software."
            },
            {
                "name": "AUTOEND",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Automatic end mode (master mode)\nThis bit is set and cleared by software.\nNote: This bit has no effect in slave mode or when the RELOAD bit is set."
            }
        ]
    },
    "1073763336": {
        "name": "I2C_OAR1",
        "address": 1073763336,
        "size": 32,
        "access": "",
        "desc": "I2C own address 1 register",
        "fields": [
            {
                "name": "OA1",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Interface own slave address\n7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. Bits OA1[9], OA1[8] and OA1[0] are don't care.\n10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.\nNote: These bits can be written only when OA1EN = 0."
            },
            {
                "name": "OA1MODE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Own address 1 10-bit mode\nNote: This bit can be written only when OA1EN = 0."
            },
            {
                "name": "OA1EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Own address 1 enable"
            }
        ]
    },
    "1073763340": {
        "name": "I2C_OAR2",
        "address": 1073763340,
        "size": 32,
        "access": "",
        "desc": "I2C own address 2 register",
        "fields": [
            {
                "name": "OA2",
                "bitOffset": 1,
                "bitWidth": 7,
                "desc": "Interface address\n7-bit addressing mode: 7-bit address\nNote: These bits can be written only when OA2EN = 0."
            },
            {
                "name": "OA2MSK",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "Own address 2 masks\nNote: These bits can be written only when OA2EN = 0.\nNote: As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches."
            },
            {
                "name": "OA2EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Own address 2 enable"
            }
        ]
    },
    "1073763344": {
        "name": "I2C_TIMINGR",
        "address": 1073763344,
        "size": 32,
        "access": "",
        "desc": "I2C timing register",
        "fields": [
            {
                "name": "SCLL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "SCL low period (master mode)\nThis field is used to generate the SCL low period in master mode.\nt<sub>SCLL </sub>= (SCLL + 1) x t<sub>PRESC</sub>\nNote: SCLL is also used to generate t<sub>BUF </sub>and t<sub>SU:STA </sub>timings."
            },
            {
                "name": "SCLH",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "SCL high period (master mode)\nThis field is used to generate the SCL high period in master mode.\nt<sub>SCLH </sub>= (SCLH + 1) x t<sub>PRESC</sub>\nNote: SCLH is also used to generate t<sub>SU:STO </sub>and t<sub>HD:STA </sub>timing."
            },
            {
                "name": "SDADEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Data hold time\nThis field is used to generate the delay t<sub>SDADEL </sub>between SCL falling edge and SDA edge. In master and in slave modes with NOSTRETCH = 0, the SCL line is stretched low during t<sub>SDADEL</sub>.\nt<sub>SDADEL</sub>= SDADEL x t<sub>PRESC</sub>\nNote: SDADEL is used to generate t<sub>HD:DAT </sub>timing."
            },
            {
                "name": "SCLDEL",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Data setup time\nThis field is used to generate a delay t<sub>SCLDEL </sub>between SDA edge and SCL rising edge. In master and in slave modes with NOSTRETCH = 0, the SCL line is stretched low during t<sub>SCLDEL</sub>.\nt<sub>SCLDEL </sub>= (SCLDEL + 1) x t<sub>PRESC</sub>\nNote: t<sub>SCLDEL</sub> is used to generate t<sub>SU:DAT </sub>timing."
            },
            {
                "name": "PRESC",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Timing prescaler\nThis field is used to prescale I2CCLK to generate the clock period t<sub>PRESC </sub>used for data setup and hold counters (refer to I2C timings) and for SCL high and low level counters (refer to I2C master initialization).\nt<sub>PRESC </sub>= (PRESC + 1) x t<sub>I2CCLK</sub>"
            }
        ]
    },
    "1073763348": {
        "name": "I2C_TIMEOUTR",
        "address": 1073763348,
        "size": 32,
        "access": "",
        "desc": "I2C timeout register",
        "fields": [
            {
                "name": "TIMEOUTA",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Bus timeout A\nThis field is used to configure:\nThe SCL low timeout condition t<sub>TIMEOUT</sub> when TIDLE = 0\nt<sub>TIMEOUT</sub>= (TIMEOUTA + 1) x 2048 x t<sub>I2CCLK</sub>\nThe bus idle condition (both SCL and SDA high) when TIDLE = 1\nt<sub>IDLE</sub>= (TIMEOUTA + 1) x 4 x t<sub>I2CCLK</sub>\nNote: These bits can be written only when TIMOUTEN = 0."
            },
            {
                "name": "TIDLE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Idle clock timeout detection\nNote: This bit can be written only when TIMOUTEN = 0."
            },
            {
                "name": "TIMOUTEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Clock timeout enable"
            },
            {
                "name": "TIMEOUTB",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Bus timeout B\nThis field is used to configure the cumulative clock extension timeout:\nIn master mode, the master cumulative clock low extend time (t<sub>LOW:MEXT</sub>) is detected\nIn slave mode, the slave cumulative clock low extend time (t<sub>LOW:SEXT</sub>) is detected\nt<sub>LOW:EXT </sub>= (TIMEOUTB + TIDLE = 01) x 2048 x t<sub>I2CCLK</sub>\nNote: These bits can be written only when TEXTEN = 0."
            },
            {
                "name": "TEXTEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Extended clock timeout enable"
            }
        ]
    },
    "1073763352": {
        "name": "I2C_ISR",
        "address": 1073763352,
        "size": 32,
        "access": "",
        "desc": "I2C interrupt and status register",
        "fields": [
            {
                "name": "TXE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Transmit data register empty (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register.\nThis bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR.\nNote: This bit is set by hardware when PE = 0."
            },
            {
                "name": "TXIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transmit interrupt status (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register.\nThis bit can be written to 1 by software only when NOSTRETCH = 1, to generate a TXIS event (interrupt if TXIE = 1 or DMA request if TXDMAEN = 1).\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "RXNE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receive data register not empty (receivers)\nThis bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "ADDR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address matched (slave mode)\nThis bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "NACKF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not Acknowledge received flag\nThis flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "STOPF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Stop detection flag\nThis flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer:\neither as a master, provided that the STOP condition is generated by the peripheral.\nor as a slave, provided that the peripheral has been addressed previously during this transfer.\nIt is cleared by software by setting the STOPCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transfer Complete (master mode)\nThis flag is set by hardware when RELOAD = 0, AUTOEND = 0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "TCR",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transfer Complete Reload\nThis flag is set by hardware when RELOAD = 1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value.\nNote: This bit is cleared by hardware when PE = 0.\nNote: This flag is only for master mode, or for slave mode when the SBC bit is set."
            },
            {
                "name": "BERR",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Bus error\nThis flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "ARLO",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Arbitration lost\nThis flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "OVR",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Overrun/Underrun (slave mode)\nThis flag is set by hardware in slave mode with NOSTRETCH = 1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "BUSY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Bus busy\nThis flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected, and cleared by hardware when a STOP condition is detected, or when PE = 0."
            },
            {
                "name": "DIR",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Transfer direction (slave mode)\nThis flag is updated when an address match event occurs (ADDR = 1)."
            },
            {
                "name": "ADDCODE",
                "bitOffset": 17,
                "bitWidth": 7,
                "desc": "Address match code (slave mode)\nThese bits are updated with the received address when an address match event occurs (ADDR = 1).\nIn the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the two MSBs of the address."
            }
        ]
    },
    "1073763356": {
        "name": "I2C_ICR",
        "address": 1073763356,
        "size": 32,
        "access": "",
        "desc": "I2C interrupt clear register",
        "fields": [
            {
                "name": "ADDRCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address matched flag clear\nWriting 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register."
            },
            {
                "name": "NACKCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not Acknowledge flag clear\nWriting 1 to this bit clears the NACKF flag in I2C_ISR register."
            },
            {
                "name": "STOPCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "STOP detection flag clear\nWriting 1 to this bit clears the STOPF flag in the I2C_ISR register."
            },
            {
                "name": "BERRCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Bus error flag clear\nWriting 1 to this bit clears the BERRF flag in the I2C_ISR register."
            },
            {
                "name": "ARLOCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Arbitration lost flag clear\nWriting 1 to this bit clears the ARLO flag in the I2C_ISR register."
            },
            {
                "name": "OVRCF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Overrun/Underrun flag clear\nWriting 1 to this bit clears the OVR flag in the I2C_ISR register."
            }
        ]
    },
    "1073763360": {
        "name": "I2C_PECR",
        "address": 1073763360,
        "size": 32,
        "access": "",
        "desc": "I2C PEC register",
        "fields": [
            {
                "name": "PEC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Packet error checking register\nThis field contains the internal PEC when PECEN=1.\nThe PEC is cleared by hardware when PE = 0."
            }
        ]
    },
    "1073763364": {
        "name": "I2C_RXDR",
        "address": 1073763364,
        "size": 32,
        "access": "",
        "desc": "I2C receive data register",
        "fields": [
            {
                "name": "RXDATA",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit receive data\nData byte received from the I<sup>2</sup>C bus"
            }
        ]
    },
    "1073763368": {
        "name": "I2C_TXDR",
        "address": 1073763368,
        "size": 32,
        "access": "",
        "desc": "I2C transmit data register",
        "fields": [
            {
                "name": "TXDATA",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit transmit data\nData byte to be transmitted to the I<sup>2</sup>C bus\nNote: These bits can be written only when TXE = 1."
            }
        ]
    },
    "1073751040": {
        "name": "LCD_CR",
        "address": 1073751040,
        "size": 32,
        "access": "",
        "desc": "LCD control register",
        "fields": [
            {
                "name": "LCDEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LCD controller enable\nThis bit is set by software to enable the LCD controller/driver. It is cleared by software to turn off the LCD at the beginning of the next frame. When the LCD is disabled, all COM and SEG pins are driven to V<sub>SS</sub>."
            },
            {
                "name": "VSEL",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Voltage source selection\nThis bit determines the voltage source for the LCD."
            },
            {
                "name": "DUTY",
                "bitOffset": 2,
                "bitWidth": 3,
                "desc": "Duty selection\nThese bits determine the duty cycle. Values 101, 110 and 111 are forbidden.\nOthers: Reserved"
            },
            {
                "name": "BIAS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Bias selector\nThese bits determine the bias used. Value 11 is forbidden."
            },
            {
                "name": "MUX_SEG",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Mux segment enable\nThis bit is used to enable SEG pin remapping. Four SEG pins can be multiplexed with1SEG[31:28] or SEG[15:12]. See Section118.3.7."
            },
            {
                "name": "BUFEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Voltage output buffer enable\nThis bit is used to enable/disable the voltage output buffer for higher driving capability."
            }
        ]
    },
    "1073751044": {
        "name": "LCD_FCR",
        "address": 1073751044,
        "size": 32,
        "access": "",
        "desc": "LCD frame control register",
        "fields": [
            {
                "name": "HD",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "High drive enable\nThis bit is written by software to enable a low resistance divider. Displays with high internal resistance may need a longer drive time to achieve satisfactory contrast. This bit is useful in this case if some additional power consumption can be tolerated."
            },
            {
                "name": "SOFIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Start of frame interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "UDDIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Update display done interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PON",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Pulse ON duration\nThese bits are written by software to define the pulse duration in terms of ck_ps pulses. A1short pulse leads to lower power consumption, but displays with high internal resistance may need a longer pulse to achieve satisfactory contrast.\nNote that the pulse is never longer than one half prescaled LCD clock period.\nPON duration example with LCDCLK = 32.7681kHz and PS=0x03:"
            },
            {
                "name": "DEAD",
                "bitOffset": 7,
                "bitWidth": 3,
                "desc": "Dead time duration\nThese bits are written by software to configure the length of the dead time between frames. During the dead time the COM and SEG voltage levels are held at 0 V to reduce the contrast without modifying the frame rate.\n......"
            },
            {
                "name": "CC",
                "bitOffset": 10,
                "bitWidth": 3,
                "desc": "Contrast control\nThese bits specify one of the V<sub>LCD </sub>maximum voltages (independent of V<sub>DD</sub>). It ranges from12.60 V to 3.51V.\nNote: Refer to the datasheet for the V<sub>LCDx</sub> values."
            },
            {
                "name": "BLINKF",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Blink frequency selection"
            },
            {
                "name": "BLINK",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Blink mode selection"
            },
            {
                "name": "DIV",
                "bitOffset": 18,
                "bitWidth": 4,
                "desc": "DIV clock divider\nThese bits are written by software to define the division factor of the DIV divider (see1Section118.3.2.)\n..."
            },
            {
                "name": "PS",
                "bitOffset": 22,
                "bitWidth": 4,
                "desc": "PS 16-bit prescaler\nThese bits are written by software to define the division factor of the PS 16-bit prescaler.\nck_ps = LCDCLK/(2<sup>PS[3:0]</sup>). See<sub> </sub>Section118.3.2.\n..."
            }
        ]
    },
    "1073751048": {
        "name": "LCD_SR",
        "address": 1073751048,
        "size": 32,
        "access": "",
        "desc": "LCD status register",
        "fields": [
            {
                "name": "ENS",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LCD enabled status\nThis bit is set and cleared by hardware. It indicates the LCD controller status.\nNote: This bit is set immediately when LCDEN in LCD_CR goes from 0 to 1. On deactivation, it reflects the real LCD status. It becomes 0 at the end of the last displayed frame."
            },
            {
                "name": "SOF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Start-of-frame flag\nThis bit is set by hardware at the beginning of a new frame, at the same time as the display data is updated. It is cleared by writing a 1 to SOFC in LCD_CLR. The bit clear has priority over the set."
            },
            {
                "name": "UDR",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update display request\nEach time software modifies the LCD_RAM, it must set this bit to transfer the updated data to the second level buffer. This bit stays set until the end of the update. During this time,\nthe LCD_RAM is write protected.\nWhen the display is disabled, the update is performed for all LCD_DISPLAY locations. When the display is enabled, the update is performed only for locations for which commons are active (depending on DUTY). For example if DUTY = 1/2,\nNote: only the LCD_DISPLAY of COM0 and COM1 are updated.\nNote: Writing 0 on this bit or writing 1 when it is already 1 has no effect. This bit can be cleared by hardware only. It can be cleared only when LCDEN = 1"
            },
            {
                "name": "UDD",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Update display done\nThis bit is set by hardware. It is cleared by writing 1 to UDDC in LCD_CLR. The bit set has priority over the clear.\nNote: If the device is in Stop mode (PCLK not provided), UDD does not generate an interrupt even if UDDIE = 1. If the display is not enabled, the UDD interrupt never occurs."
            },
            {
                "name": "RDY",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Ready flag\nThis bit is set and cleared by hardware. It indicates the status of the stepup converter."
            },
            {
                "name": "FCRSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LCD frame control register synchronization flag\nThis bit is set by hardware each time the LCD_FCR register is updated in the LCDCLK domain. It is cleared by hardware when writing to the LCD_FCR register."
            }
        ]
    },
    "1073751052": {
        "name": "LCD_CLR",
        "address": 1073751052,
        "size": 32,
        "access": "",
        "desc": "LCD clear register",
        "fields": [
            {
                "name": "SOFC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Start-of-frame flag clear\nThis bit is written by software to clear SOF in LCD_SR."
            },
            {
                "name": "UDDC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Update display done clear\nThis bit is written by software to clear UDD in LCD_SR."
            }
        ]
    },
    "1073751060": {
        "name": "LCD_RAM0",
        "address": 1073751060,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751064": {
        "name": "LCD_RAM1",
        "address": 1073751064,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751068": {
        "name": "LCD_RAM2",
        "address": 1073751068,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751072": {
        "name": "LCD_RAM3",
        "address": 1073751072,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751076": {
        "name": "LCD_RAM4",
        "address": 1073751076,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751080": {
        "name": "LCD_RAM5",
        "address": 1073751080,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751084": {
        "name": "LCD_RAM6",
        "address": 1073751084,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751088": {
        "name": "LCD_RAM7",
        "address": 1073751088,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751092": {
        "name": "LCD_RAM8",
        "address": 1073751092,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751096": {
        "name": "LCD_RAM9",
        "address": 1073751096,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751100": {
        "name": "LCD_RAM10",
        "address": 1073751100,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751104": {
        "name": "LCD_RAM11",
        "address": 1073751104,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751108": {
        "name": "LCD_RAM12",
        "address": 1073751108,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751112": {
        "name": "LCD_RAM13",
        "address": 1073751112,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751116": {
        "name": "LCD_RAM14",
        "address": 1073751116,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073751120": {
        "name": "LCD_RAM15",
        "address": 1073751120,
        "size": 32,
        "access": "",
        "desc": "LCD display memory",
        "fields": [
            {
                "name": "SEGMENT_DATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Each bit corresponds to one pixel of the LCD display."
            }
        ]
    },
    "1073773568": {
        "name": "LPTIM1_ISR_OUTPUT",
        "address": 1073773568,
        "size": 32,
        "access": "",
        "desc": "LPTIM1 interrupt and status register [alternate]",
        "fields": [
            {
                "name": "CC1IF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Compare 1 interrupt flag\nIf channel CC1 is configured as output:\nThe CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register."
            },
            {
                "name": "ARRM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match\nARRM is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register."
            },
            {
                "name": "EXTTRIG",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger edge event\nEXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CMP1OK",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK\nCMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "ARROK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK\nARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "UP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Counter direction change down to up\nIn Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DOWN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Counter direction change up to down\nIn Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPTIM update event occurred\nUE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA."
            },
            {
                "name": "REPOK",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK\nREPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CC2IF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Compare 2 interrupt flag\nIf channel CC2 is configured as output:\nThe CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the\ncompare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC3IF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Compare 3 interrupt flag\nIf channel CC3 is configured as output:\nThe CC3IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC3IF flag can be cleared by writing 1 to the CC3CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC4IF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Compare 4 interrupt flag\nIf channel CC4 is configured as output:\nThe CC4IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC4IF flag can be cleared by writing 1 to the CC4CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP2OK",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK\nCMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP3OK",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Compare register 3 update OK\nCMP3OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR3 register has been successfully completed. CMP3OK flag can be cleared by writing 1 to the CMP3OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP4OK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Compare register 4 update OK\nCMP4OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR4 register has been successfully completed. CMP4OK flag can be cleared by writing 1 to the CMP4OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DIEROK",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Interrupt enable register update OK\nDIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register."
            }
        ]
    },
    "1073773572": {
        "name": "LPTIM1_ICR_OUTPUT",
        "address": 1073773572,
        "size": 32,
        "access": "",
        "desc": "LPTIM1 interrupt clear register [alternate]",
        "fields": [
            {
                "name": "CC1CF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 clear flag\nWriting 1 to this bit clears the CC1IF flag in the LPTIM_ISR register."
            },
            {
                "name": "ARRMCF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match clear flag\nWriting 1 to this bit clears the ARRM flag in the LPTIM_ISR register"
            },
            {
                "name": "EXTTRIGCF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge clear flag\nWriting 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register"
            },
            {
                "name": "CMP1OKCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK clear flag\nWriting 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register."
            },
            {
                "name": "ARROKCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK clear flag\nWriting 1 to this bit clears the ARROK flag in the LPTIM_ISR register"
            },
            {
                "name": "UPCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP clear flag\nWriting 1 to this bit clear the UP flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DOWNCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down clear flag\nWriting 1 to this bit clear the DOWN flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UECF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Update event clear flag\nWriting 1 to this bit clear the UE flag in the LPTIM_ISR register."
            },
            {
                "name": "REPOKCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK clear flag\nWriting 1 to this bit clears the REPOK flag in the LPTIM_ISR register."
            },
            {
                "name": "CC2CF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 2 clear flag\nWriting 1 to this bit clears the CC2IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC3CF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 3 clear flag\nWriting 1 to this bit clears the CC3IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC4CF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 4 clear flag\nWriting 1 to this bit clears the CC4IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP2OKCF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK clear flag\nWriting 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP3OKCF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Compare register 3 update OK clear flag\nWriting 1 to this bit clears the CMP3OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP4OKCF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Compare register 4 update OK clear flag\nWriting 1 to this bit clears the CMP4OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DIEROKCF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Interrupt enable register update OK clear flag\nWriting 1 to this bit clears the DIEROK flag in the LPTIM_ISR register."
            }
        ]
    },
    "1073773576": {
        "name": "LPTIM1_DIER_OUTPUT",
        "address": 1073773576,
        "size": 32,
        "access": "",
        "desc": "LPTIM1 interrupt enable register [alternate]",
        "fields": [
            {
                "name": "CC1IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt enable"
            },
            {
                "name": "ARRMIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match Interrupt Enable"
            },
            {
                "name": "EXTTRIGIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge Interrupt Enable"
            },
            {
                "name": "CMP1OKIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK interrupt enable"
            },
            {
                "name": "ARROKIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK Interrupt Enable"
            },
            {
                "name": "UPIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DOWNIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UEIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Update event interrupt enable"
            },
            {
                "name": "REPOKIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK interrupt Enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 2 interrupt enable\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC3IE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 3 interrupt enable\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC4IE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 4 interrupt enable\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP2OKIE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK interrupt enable\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP3OKIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Compare register 3 update OK interrupt enable\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP4OKIE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Compare register 4 update OK interrupt enable\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UEDE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Update event DMA request enable\nNote: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3."
            }
        ]
    },
    "1073773580": {
        "name": "LPTIM1_CFGR",
        "address": 1073773580,
        "size": 32,
        "access": "",
        "desc": "LPTIM configuration register",
        "fields": [
            {
                "name": "CKSEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clock selector\nThe CKSEL bit selects which clock source the LPTIM uses:"
            },
            {
                "name": "CKPOL",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Clock Polarity\nWhen the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active.\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active.\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active.\nRefer to Section125.4.15: Encoder mode for more details about Encoder mode sub-modes."
            },
            {
                "name": "CKFLT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Configurable digital filter for external clock\nThe CKFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature"
            },
            {
                "name": "TRGFLT",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Configurable digital filter for trigger\nThe TRGFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature"
            },
            {
                "name": "PRESC",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "Clock prescaler\nThe PRESC bits configure the prescaler division factor. It can be one among the following division factors:"
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Trigger selector\nThe TRIGSEL bits select the trigger source that serves as a trigger event for the LPTIM among the below 8 available sources:\nSee Section125.4.3: LPTIM input and trigger mapping for details."
            },
            {
                "name": "TRIGEN",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Trigger enable and polarity\nThe TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:"
            },
            {
                "name": "TIMOUT",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Timeout enable\nThe TIMOUT bit controls the Timeout feature"
            },
            {
                "name": "WAVE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Waveform shape\nThe WAVE bit controls the output shape"
            },
            {
                "name": "PRELOAD",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Registers update mode\nThe PRELOAD bit controls the LPTIM1_ARR, LPTIM1_RCR and the LPTIM1_CCRx registers update modality"
            },
            {
                "name": "COUNTMODE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "counter mode enabled\nThe COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:"
            },
            {
                "name": "ENC",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Encoder mode enable\nThe ENC bit controls the Encoder mode\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            }
        ]
    },
    "1073773584": {
        "name": "LPTIM1_CR",
        "address": 1073773584,
        "size": 32,
        "access": "",
        "desc": "LPTIM control register",
        "fields": [
            {
                "name": "ENABLE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPTIM enable\nThe ENABLE bit is set and cleared by software."
            },
            {
                "name": "SNGSTRT",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPTIM start in Single mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.\nIf the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.\nIf this bit is set when the LPTIM is in continuous counting mode, then the LPTIM stops at the following match between LPTIM1_ARR and LPTIM1_CNT registers.\nThis bit can only be set when the LPTIM is enabled. It is automatically reset by hardware."
            },
            {
                "name": "CNTSTRT",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Timer start in Continuous mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.\nIf the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.\nIf this bit is set when a single pulse mode counting is ongoing, then the timer does not stop at the next match between the LPTIM1_ARR and LPTIM1_CNT registers and the LPTIM counter keeps counting in Continuous mode.\nThis bit can be set only when the LPTIM is enabled. It is automatically reset by hardware."
            },
            {
                "name": "COUNTRST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Counter reset\nThis bit is set by software and cleared by hardware. When set to '1' this bit triggers a synchronous reset of the LPTIM1_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock).\nThis bit can be set only when the LPTIM is enabled. It is automatically reset by hardware.\nCOUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software must consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'."
            },
            {
                "name": "RSTARE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Reset after read enable\nThis bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM1_CNT register asynchronously resets LPTIM1_CNT register content.\nThis bit can be set only when the LPTIM is enabled."
            }
        ]
    },
    "1073773588": {
        "name": "LPTIM1_CCR1",
        "address": 1073773588,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the capture/compare 1 register.\nDepending on the PRELOAD option, the CCR1 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 1 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC1 output.\nIf channel CC1 is configured as input:\nCCR1 becomes read-only, it contains the counter value transferred by the last input capture 1 event. The LPTIM1_CCR1 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073773592": {
        "name": "LPTIM1_ARR",
        "address": 1073773592,
        "size": 32,
        "access": "",
        "desc": "LPTIM autoreload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto reload value\nARR is the autoreload value for the LPTIM.\nThis value must be strictly greater than the CCRx[15:0] value."
            }
        ]
    },
    "1073773596": {
        "name": "LPTIM1_CNT",
        "address": 1073773596,
        "size": 32,
        "access": "",
        "desc": "LPTIM counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value\nWhen the LPTIM is running with an asynchronous clock, reading the LPTIM1_CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical."
            }
        ]
    },
    "1073773604": {
        "name": "LPTIM1_CFGR2",
        "address": 1073773604,
        "size": 32,
        "access": "",
        "desc": "LPTIM configuration register 2",
        "fields": [
            {
                "name": "IN1SEL",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "LPTIM input 1 selection\nThe IN1SEL bits control the LPTIM input 1 multiplexer, which connects LPTIM input 1 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            },
            {
                "name": "IN2SEL",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "LPTIM input 2 selection\nThe IN2SEL bits control the LPTIM input 2 multiplexer, which connects LPTIM input 2 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            },
            {
                "name": "IC1SEL",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "LPTIM input capture 1 selection\nThe IC1SEL bits control the LPTIM Input capture 1 multiplexer, which connects LPTIM Input capture\n1 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            },
            {
                "name": "IC2SEL",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "LPTIM input capture 2 selection\nThe IC2SEL bits control the LPTIM Input capture 2 multiplexer, which connects LPTIM Input capture\n2 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            }
        ]
    },
    "1073773608": {
        "name": "LPTIM1_RCR",
        "address": 1073773608,
        "size": 32,
        "access": "",
        "desc": "LPTIM repetition register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Repetition register value\nREP is the repetition value for the LPTIM."
            }
        ]
    },
    "1073773612": {
        "name": "LPTIM1_CCMR1",
        "address": 1073773612,
        "size": 32,
        "access": "",
        "desc": "LPTIM capture/compare mode register 1",
        "fields": [
            {
                "name": "CC1SEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 selection\nThis bitfield defines the direction of the channel input (capture) or output mode."
            },
            {
                "name": "CC1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 output enable.\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (LPTIM1_CCR1) or not."
            },
            {
                "name": "CC1P",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Capture/compare 1 output polarity.\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nThis field is used to select the IC1 polarity for capture operations."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC1 input (IC1)."
            },
            {
                "name": "IC1F",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Input capture 1 filter\nThis bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            },
            {
                "name": "CC2SEL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/compare 2 selection\nThis bitfield defines the direction of the channel, input (capture) or output mode."
            },
            {
                "name": "CC2E",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/compare 2 output enable.\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 2 (LPTIM1_CCR2) or not."
            },
            {
                "name": "CC2P",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Capture/compare 2 output polarity.\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nThis field is used to select the IC2 polarity for capture operations."
            },
            {
                "name": "IC2PSC",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC2 input (IC2)."
            },
            {
                "name": "IC2F",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Input capture 2 filter\nThis bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            }
        ]
    },
    "1073773616": {
        "name": "LPTIM1_CCMR2",
        "address": 1073773616,
        "size": 32,
        "access": "",
        "desc": "LPTIM capture/compare mode register 2",
        "fields": [
            {
                "name": "CC3SEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 3 selection\nThis bitfield defines the direction of the channel input (capture) or output mode."
            },
            {
                "name": "CC3E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 3 output enable.\nCondition: CC3 as output:\nCondition: CC3 as input:\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 3 (LPTIM1_CCR3) or not."
            },
            {
                "name": "CC3P",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Capture/compare 3 output polarity.\nCondition: CC3 as output:\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nCondition: CC3 as input:\nThis field is used to select the IC3 polarity for capture operations."
            },
            {
                "name": "IC3PSC",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC3 input (IC3)."
            },
            {
                "name": "IC3F",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Input capture 3 filter\nThis bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            },
            {
                "name": "CC4SEL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/compare 4 selection\nThis bitfield defines the direction of the channel, input (capture) or output mode."
            },
            {
                "name": "CC4E",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/compare 4 output enable.\nCondition: CC4 as output:\nCondition: CC4 as input:\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 4 (LPTIM1_CCR4) or not."
            },
            {
                "name": "CC4P",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Capture/compare 4 output polarity.\nCondition: CC4 as output:\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nCondition: CC4 as input:\nThis field is used to select the IC4 polarity for capture operations."
            },
            {
                "name": "IC4PSC",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC4 input (IC4)."
            },
            {
                "name": "IC4F",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Input capture 4 filter\nThis bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            }
        ]
    },
    "1073773620": {
        "name": "LPTIM1_CCR2",
        "address": 1073773620,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 2 value\nIf channel CC2 is configured as output:\nCCR2 is the value to be loaded in the capture/compare 2 register.\nDepending on the PRELOAD option, the CCR2 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 2 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC2 output.\nIf channel CC2 is configured as input:\nCCR2 becomes read-only, it contains the counter value transferred by the last input capture 2 event. The LPTIM1_CCR2 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073773624": {
        "name": "LPTIM1_CCR3",
        "address": 1073773624,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 3 value\nIf channel CC3 is configured as output:\nCCR3 is the value to be loaded in the capture/compare 3 register.\nDepending on the PRELOAD option, the CCR3 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 3 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC3 output.\nIf channel CC3 is configured as input:\nCCR3 becomes read-only, it contains the counter value transferred by the last input capture 3 event. The LPTIM1_CCR3 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073773628": {
        "name": "LPTIM1_CCR4",
        "address": 1073773628,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 4 value\nIf channel CC4 is configured as output:\nCCR4 is the value to be loaded in the capture/compare 4 register.\nDepending on the PRELOAD option, the CCR4 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 4 contains the value to be compared to the counter LPTIM1_CNT and signaled on OC4 output.\nIf channel CC4 is configured as input:\nCCR4 becomes read-only, it contains the counter value transferred by the last input capture 4 event. The LPTIM1_CCR4 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073779712": {
        "name": "LPTIM2_ISR_OUTPUT",
        "address": 1073779712,
        "size": 32,
        "access": "",
        "desc": "LPTIM2 interrupt and status register [alternate]",
        "fields": [
            {
                "name": "CC1IF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Compare 1 interrupt flag\nIf channel CC1 is configured as output:\nThe CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register."
            },
            {
                "name": "ARRM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match\nARRM is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register."
            },
            {
                "name": "EXTTRIG",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger edge event\nEXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CMP1OK",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK\nCMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "ARROK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK\nARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "UP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Counter direction change down to up\nIn Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DOWN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Counter direction change up to down\nIn Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPTIM update event occurred\nUE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA."
            },
            {
                "name": "REPOK",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK\nREPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CC2IF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Compare 2 interrupt flag\nIf channel CC2 is configured as output:\nThe CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the\ncompare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC3IF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Compare 3 interrupt flag\nIf channel CC3 is configured as output:\nThe CC3IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC3IF flag can be cleared by writing 1 to the CC3CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC4IF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Compare 4 interrupt flag\nIf channel CC4 is configured as output:\nThe CC4IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC4IF flag can be cleared by writing 1 to the CC4CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP2OK",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK\nCMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP3OK",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Compare register 3 update OK\nCMP3OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR3 register has been successfully completed. CMP3OK flag can be cleared by writing 1 to the CMP3OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP4OK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Compare register 4 update OK\nCMP4OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR4 register has been successfully completed. CMP4OK flag can be cleared by writing 1 to the CMP4OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DIEROK",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Interrupt enable register update OK\nDIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register."
            }
        ]
    },
    "1073779716": {
        "name": "LPTIM2_ICR_OUTPUT",
        "address": 1073779716,
        "size": 32,
        "access": "",
        "desc": "LPTIM2 interrupt clear register [alternate]",
        "fields": [
            {
                "name": "CC1CF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 clear flag\nWriting 1 to this bit clears the CC1IF flag in the LPTIM_ISR register."
            },
            {
                "name": "ARRMCF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match clear flag\nWriting 1 to this bit clears the ARRM flag in the LPTIM_ISR register"
            },
            {
                "name": "EXTTRIGCF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge clear flag\nWriting 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register"
            },
            {
                "name": "CMP1OKCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK clear flag\nWriting 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register."
            },
            {
                "name": "ARROKCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK clear flag\nWriting 1 to this bit clears the ARROK flag in the LPTIM_ISR register"
            },
            {
                "name": "UPCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP clear flag\nWriting 1 to this bit clear the UP flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DOWNCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down clear flag\nWriting 1 to this bit clear the DOWN flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UECF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Update event clear flag\nWriting 1 to this bit clear the UE flag in the LPTIM_ISR register."
            },
            {
                "name": "REPOKCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK clear flag\nWriting 1 to this bit clears the REPOK flag in the LPTIM_ISR register."
            },
            {
                "name": "CC2CF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 2 clear flag\nWriting 1 to this bit clears the CC2IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC3CF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 3 clear flag\nWriting 1 to this bit clears the CC3IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC4CF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 4 clear flag\nWriting 1 to this bit clears the CC4IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP2OKCF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK clear flag\nWriting 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP3OKCF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Compare register 3 update OK clear flag\nWriting 1 to this bit clears the CMP3OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP4OKCF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Compare register 4 update OK clear flag\nWriting 1 to this bit clears the CMP4OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DIEROKCF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Interrupt enable register update OK clear flag\nWriting 1 to this bit clears the DIEROK flag in the LPTIM_ISR register."
            }
        ]
    },
    "1073779720": {
        "name": "LPTIM2_DIER_OUTPUT",
        "address": 1073779720,
        "size": 32,
        "access": "",
        "desc": "LPTIM2 interrupt enable register [alternate]",
        "fields": [
            {
                "name": "CC1IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt enable"
            },
            {
                "name": "ARRMIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match Interrupt Enable"
            },
            {
                "name": "EXTTRIGIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge Interrupt Enable"
            },
            {
                "name": "CMP1OKIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK interrupt enable"
            },
            {
                "name": "ARROKIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK Interrupt Enable"
            },
            {
                "name": "UPIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DOWNIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UEIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Update event interrupt enable"
            },
            {
                "name": "REPOKIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK interrupt Enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 2 interrupt enable\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC3IE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 3 interrupt enable\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC4IE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 4 interrupt enable\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP2OKIE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK interrupt enable\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP3OKIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Compare register 3 update OK interrupt enable\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP4OKIE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Compare register 4 update OK interrupt enable\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UEDE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Update event DMA request enable\nNote: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3."
            }
        ]
    },
    "1073779724": {
        "name": "LPTIM2_CFGR",
        "address": 1073779724,
        "size": 32,
        "access": "",
        "desc": "LPTIM configuration register",
        "fields": [
            {
                "name": "CKSEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clock selector\nThe CKSEL bit selects which clock source the LPTIM uses:"
            },
            {
                "name": "CKPOL",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Clock Polarity\nWhen the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active.\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active.\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active.\nRefer to Section125.4.15: Encoder mode for more details about Encoder mode sub-modes."
            },
            {
                "name": "CKFLT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Configurable digital filter for external clock\nThe CKFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature"
            },
            {
                "name": "TRGFLT",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Configurable digital filter for trigger\nThe TRGFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature"
            },
            {
                "name": "PRESC",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "Clock prescaler\nThe PRESC bits configure the prescaler division factor. It can be one among the following division factors:"
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Trigger selector\nThe TRIGSEL bits select the trigger source that serves as a trigger event for the LPTIM among the below 8 available sources:\nSee Section125.4.3: LPTIM input and trigger mapping for details."
            },
            {
                "name": "TRIGEN",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Trigger enable and polarity\nThe TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:"
            },
            {
                "name": "TIMOUT",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Timeout enable\nThe TIMOUT bit controls the Timeout feature"
            },
            {
                "name": "WAVE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Waveform shape\nThe WAVE bit controls the output shape"
            },
            {
                "name": "PRELOAD",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Registers update mode\nThe PRELOAD bit controls the LPTIM2_ARR, LPTIM2_RCR and the LPTIM2_CCRx registers update modality"
            },
            {
                "name": "COUNTMODE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "counter mode enabled\nThe COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:"
            },
            {
                "name": "ENC",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Encoder mode enable\nThe ENC bit controls the Encoder mode\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            }
        ]
    },
    "1073779728": {
        "name": "LPTIM2_CR",
        "address": 1073779728,
        "size": 32,
        "access": "",
        "desc": "LPTIM control register",
        "fields": [
            {
                "name": "ENABLE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPTIM enable\nThe ENABLE bit is set and cleared by software."
            },
            {
                "name": "SNGSTRT",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPTIM start in Single mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.\nIf the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.\nIf this bit is set when the LPTIM is in continuous counting mode, then the LPTIM stops at the following match between LPTIM2_ARR and LPTIM2_CNT registers.\nThis bit can only be set when the LPTIM is enabled. It is automatically reset by hardware."
            },
            {
                "name": "CNTSTRT",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Timer start in Continuous mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.\nIf the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.\nIf this bit is set when a single pulse mode counting is ongoing, then the timer does not stop at the next match between the LPTIM2_ARR and LPTIM2_CNT registers and the LPTIM counter keeps counting in Continuous mode.\nThis bit can be set only when the LPTIM is enabled. It is automatically reset by hardware."
            },
            {
                "name": "COUNTRST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Counter reset\nThis bit is set by software and cleared by hardware. When set to '1' this bit triggers a synchronous reset of the LPTIM2_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock).\nThis bit can be set only when the LPTIM is enabled. It is automatically reset by hardware.\nCOUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software must consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'."
            },
            {
                "name": "RSTARE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Reset after read enable\nThis bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM2_CNT register asynchronously resets LPTIM2_CNT register content.\nThis bit can be set only when the LPTIM is enabled."
            }
        ]
    },
    "1073779732": {
        "name": "LPTIM2_CCR1",
        "address": 1073779732,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the capture/compare 1 register.\nDepending on the PRELOAD option, the CCR1 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 1 contains the value to be compared to the counter LPTIM2_CNT and signaled on OC1 output.\nIf channel CC1 is configured as input:\nCCR1 becomes read-only, it contains the counter value transferred by the last input capture 1 event. The LPTIM2_CCR1 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073779736": {
        "name": "LPTIM2_ARR",
        "address": 1073779736,
        "size": 32,
        "access": "",
        "desc": "LPTIM autoreload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto reload value\nARR is the autoreload value for the LPTIM.\nThis value must be strictly greater than the CCRx[15:0] value."
            }
        ]
    },
    "1073779740": {
        "name": "LPTIM2_CNT",
        "address": 1073779740,
        "size": 32,
        "access": "",
        "desc": "LPTIM counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value\nWhen the LPTIM is running with an asynchronous clock, reading the LPTIM2_CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical."
            }
        ]
    },
    "1073779748": {
        "name": "LPTIM2_CFGR2",
        "address": 1073779748,
        "size": 32,
        "access": "",
        "desc": "LPTIM configuration register 2",
        "fields": [
            {
                "name": "IN1SEL",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "LPTIM input 1 selection\nThe IN1SEL bits control the LPTIM input 1 multiplexer, which connects LPTIM input 1 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            },
            {
                "name": "IN2SEL",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "LPTIM input 2 selection\nThe IN2SEL bits control the LPTIM input 2 multiplexer, which connects LPTIM input 2 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            },
            {
                "name": "IC1SEL",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "LPTIM input capture 1 selection\nThe IC1SEL bits control the LPTIM Input capture 1 multiplexer, which connects LPTIM Input capture\n1 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            },
            {
                "name": "IC2SEL",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "LPTIM input capture 2 selection\nThe IC2SEL bits control the LPTIM Input capture 2 multiplexer, which connects LPTIM Input capture\n2 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            }
        ]
    },
    "1073779752": {
        "name": "LPTIM2_RCR",
        "address": 1073779752,
        "size": 32,
        "access": "",
        "desc": "LPTIM repetition register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Repetition register value\nREP is the repetition value for the LPTIM."
            }
        ]
    },
    "1073779756": {
        "name": "LPTIM2_CCMR1",
        "address": 1073779756,
        "size": 32,
        "access": "",
        "desc": "LPTIM capture/compare mode register 1",
        "fields": [
            {
                "name": "CC1SEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 selection\nThis bitfield defines the direction of the channel input (capture) or output mode."
            },
            {
                "name": "CC1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 output enable.\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (LPTIM2_CCR1) or not."
            },
            {
                "name": "CC1P",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Capture/compare 1 output polarity.\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nThis field is used to select the IC1 polarity for capture operations."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC1 input (IC1)."
            },
            {
                "name": "IC1F",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Input capture 1 filter\nThis bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            },
            {
                "name": "CC2SEL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/compare 2 selection\nThis bitfield defines the direction of the channel, input (capture) or output mode."
            },
            {
                "name": "CC2E",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/compare 2 output enable.\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 2 (LPTIM2_CCR2) or not."
            },
            {
                "name": "CC2P",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Capture/compare 2 output polarity.\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nThis field is used to select the IC2 polarity for capture operations."
            },
            {
                "name": "IC2PSC",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC2 input (IC2)."
            },
            {
                "name": "IC2F",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Input capture 2 filter\nThis bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            }
        ]
    },
    "1073779760": {
        "name": "LPTIM2_CCMR2",
        "address": 1073779760,
        "size": 32,
        "access": "",
        "desc": "LPTIM capture/compare mode register 2",
        "fields": [
            {
                "name": "CC3SEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 3 selection\nThis bitfield defines the direction of the channel input (capture) or output mode."
            },
            {
                "name": "CC3E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 3 output enable.\nCondition: CC3 as output:\nCondition: CC3 as input:\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 3 (LPTIM2_CCR3) or not."
            },
            {
                "name": "CC3P",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Capture/compare 3 output polarity.\nCondition: CC3 as output:\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nCondition: CC3 as input:\nThis field is used to select the IC3 polarity for capture operations."
            },
            {
                "name": "IC3PSC",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC3 input (IC3)."
            },
            {
                "name": "IC3F",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Input capture 3 filter\nThis bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            },
            {
                "name": "CC4SEL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/compare 4 selection\nThis bitfield defines the direction of the channel, input (capture) or output mode."
            },
            {
                "name": "CC4E",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/compare 4 output enable.\nCondition: CC4 as output:\nCondition: CC4 as input:\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 4 (LPTIM2_CCR4) or not."
            },
            {
                "name": "CC4P",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Capture/compare 4 output polarity.\nCondition: CC4 as output:\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nCondition: CC4 as input:\nThis field is used to select the IC4 polarity for capture operations."
            },
            {
                "name": "IC4PSC",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC4 input (IC4)."
            },
            {
                "name": "IC4F",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Input capture 4 filter\nThis bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            }
        ]
    },
    "1073779764": {
        "name": "LPTIM2_CCR2",
        "address": 1073779764,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 2 value\nIf channel CC2 is configured as output:\nCCR2 is the value to be loaded in the capture/compare 2 register.\nDepending on the PRELOAD option, the CCR2 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 2 contains the value to be compared to the counter LPTIM2_CNT and signaled on OC2 output.\nIf channel CC2 is configured as input:\nCCR2 becomes read-only, it contains the counter value transferred by the last input capture 2 event. The LPTIM2_CCR2 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073779768": {
        "name": "LPTIM2_CCR3",
        "address": 1073779768,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 3 value\nIf channel CC3 is configured as output:\nCCR3 is the value to be loaded in the capture/compare 3 register.\nDepending on the PRELOAD option, the CCR3 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 3 contains the value to be compared to the counter LPTIM2_CNT and signaled on OC3 output.\nIf channel CC3 is configured as input:\nCCR3 becomes read-only, it contains the counter value transferred by the last input capture 3 event. The LPTIM2_CCR3 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073779772": {
        "name": "LPTIM2_CCR4",
        "address": 1073779772,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 4 value\nIf channel CC4 is configured as output:\nCCR4 is the value to be loaded in the capture/compare 4 register.\nDepending on the PRELOAD option, the CCR4 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 4 contains the value to be compared to the counter LPTIM2_CNT and signaled on OC4 output.\nIf channel CC4 is configured as input:\nCCR4 becomes read-only, it contains the counter value transferred by the last input capture 4 event. The LPTIM2_CCR4 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073778688": {
        "name": "LPTIM3_ISR_OUTPUT",
        "address": 1073778688,
        "size": 32,
        "access": "",
        "desc": "LPTIM3 interrupt and status register [alternate]",
        "fields": [
            {
                "name": "CC1IF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Compare 1 interrupt flag\nIf channel CC1 is configured as output:\nThe CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register."
            },
            {
                "name": "ARRM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match\nARRM is set by hardware to inform application that LPTIM_CNT registers value reached the LPTIM_ARR registers value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register."
            },
            {
                "name": "EXTTRIG",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger edge event\nEXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CMP1OK",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK\nCMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "ARROK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK\nARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "UP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Counter direction change down to up\nIn Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DOWN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Counter direction change up to down\nIn Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPTIM update event occurred\nUE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA."
            },
            {
                "name": "REPOK",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK\nREPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CC2IF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Compare 2 interrupt flag\nIf channel CC2 is configured as output:\nThe CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the\ncompare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC3IF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Compare 3 interrupt flag\nIf channel CC3 is configured as output:\nThe CC3IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC3IF flag can be cleared by writing 1 to the CC3CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC4IF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Compare 4 interrupt flag\nIf channel CC4 is configured as output:\nThe CC4IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC4IF flag can be cleared by writing 1 to the CC4CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP2OK",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK\nCMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP3OK",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Compare register 3 update OK\nCMP3OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR3 register has been successfully completed. CMP3OK flag can be cleared by writing 1 to the CMP3OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP4OK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Compare register 4 update OK\nCMP4OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR4 register has been successfully completed. CMP4OK flag can be cleared by writing 1 to the CMP4OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DIEROK",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Interrupt enable register update OK\nDIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register."
            }
        ]
    },
    "1073778692": {
        "name": "LPTIM3_ICR_OUTPUT",
        "address": 1073778692,
        "size": 32,
        "access": "",
        "desc": "LPTIM3 interrupt clear register [alternate]",
        "fields": [
            {
                "name": "CC1CF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 clear flag\nWriting 1 to this bit clears the CC1IF flag in the LPTIM_ISR register."
            },
            {
                "name": "ARRMCF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match clear flag\nWriting 1 to this bit clears the ARRM flag in the LPTIM_ISR register"
            },
            {
                "name": "EXTTRIGCF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge clear flag\nWriting 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register"
            },
            {
                "name": "CMP1OKCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK clear flag\nWriting 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register."
            },
            {
                "name": "ARROKCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK clear flag\nWriting 1 to this bit clears the ARROK flag in the LPTIM_ISR register"
            },
            {
                "name": "UPCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP clear flag\nWriting 1 to this bit clear the UP flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DOWNCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down clear flag\nWriting 1 to this bit clear the DOWN flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UECF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Update event clear flag\nWriting 1 to this bit clear the UE flag in the LPTIM_ISR register."
            },
            {
                "name": "REPOKCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK clear flag\nWriting 1 to this bit clears the REPOK flag in the LPTIM_ISR register."
            },
            {
                "name": "CC2CF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 2 clear flag\nWriting 1 to this bit clears the CC2IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC3CF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 3 clear flag\nWriting 1 to this bit clears the CC3IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC4CF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 4 clear flag\nWriting 1 to this bit clears the CC4IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP2OKCF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK clear flag\nWriting 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP3OKCF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Compare register 3 update OK clear flag\nWriting 1 to this bit clears the CMP3OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP4OKCF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Compare register 4 update OK clear flag\nWriting 1 to this bit clears the CMP4OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DIEROKCF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Interrupt enable register update OK clear flag\nWriting 1 to this bit clears the DIEROK flag in the LPTIM_ISR register."
            }
        ]
    },
    "1073778696": {
        "name": "LPTIM3_DIER_OUTPUT",
        "address": 1073778696,
        "size": 32,
        "access": "",
        "desc": "LPTIM3 interrupt enable register [alternate]",
        "fields": [
            {
                "name": "CC1IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt enable"
            },
            {
                "name": "ARRMIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match Interrupt Enable"
            },
            {
                "name": "EXTTRIGIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge Interrupt Enable"
            },
            {
                "name": "CMP1OKIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK interrupt enable"
            },
            {
                "name": "ARROKIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK Interrupt Enable"
            },
            {
                "name": "UPIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "DOWNIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UEIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Update event interrupt enable"
            },
            {
                "name": "REPOKIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK interrupt Enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 2 interrupt enable\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC3IE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 3 interrupt enable\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CC4IE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 4 interrupt enable\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP2OKIE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK interrupt enable\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP3OKIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Compare register 3 update OK interrupt enable\nNote: If LPTIM does not implement at least 3 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "CMP4OKIE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Compare register 4 update OK interrupt enable\nNote: If LPTIM does not implement at least 4 channels this bit is reserved. Refer to Section125.3."
            },
            {
                "name": "UEDE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Update event DMA request enable\nNote: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section125.3."
            }
        ]
    },
    "1073778700": {
        "name": "LPTIM3_CFGR",
        "address": 1073778700,
        "size": 32,
        "access": "",
        "desc": "LPTIM configuration register",
        "fields": [
            {
                "name": "CKSEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clock selector\nThe CKSEL bit selects which clock source the LPTIM uses:"
            },
            {
                "name": "CKPOL",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Clock Polarity\nWhen the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active.\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active.\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 3 is active.\nRefer to Section125.4.15: Encoder mode for more details about Encoder mode sub-modes."
            },
            {
                "name": "CKFLT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Configurable digital filter for external clock\nThe CKFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature"
            },
            {
                "name": "TRGFLT",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Configurable digital filter for trigger\nThe TRGFLT value sets the number of consecutive equal samples that are detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature"
            },
            {
                "name": "PRESC",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "Clock prescaler\nThe PRESC bits configure the prescaler division factor. It can be one among the following division factors:"
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Trigger selector\nThe TRIGSEL bits select the trigger source that serves as a trigger event for the LPTIM among the below 8 available sources:\nSee Section125.4.3: LPTIM input and trigger mapping for details."
            },
            {
                "name": "TRIGEN",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Trigger enable and polarity\nThe TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:"
            },
            {
                "name": "TIMOUT",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Timeout enable\nThe TIMOUT bit controls the Timeout feature"
            },
            {
                "name": "WAVE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Waveform shape\nThe WAVE bit controls the output shape"
            },
            {
                "name": "PRELOAD",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Registers update mode\nThe PRELOAD bit controls the LPTIM3_ARR, LPTIM3_RCR and the LPTIM3_CCRx registers update modality"
            },
            {
                "name": "COUNTMODE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "counter mode enabled\nThe COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:"
            },
            {
                "name": "ENC",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Encoder mode enable\nThe ENC bit controls the Encoder mode\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section125.3."
            }
        ]
    },
    "1073778704": {
        "name": "LPTIM3_CR",
        "address": 1073778704,
        "size": 32,
        "access": "",
        "desc": "LPTIM control register",
        "fields": [
            {
                "name": "ENABLE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPTIM enable\nThe ENABLE bit is set and cleared by software."
            },
            {
                "name": "SNGSTRT",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPTIM start in Single mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in single pulse mode.\nIf the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.\nIf this bit is set when the LPTIM is in continuous counting mode, then the LPTIM stops at the following match between LPTIM3_ARR and LPTIM3_CNT registers.\nThis bit can only be set when the LPTIM is enabled. It is automatically reset by hardware."
            },
            {
                "name": "CNTSTRT",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Timer start in Continuous mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = 00), setting this bit starts the LPTIM in Continuous mode.\nIf the software start is disabled (TRIGEN[1:0] different than 00), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.\nIf this bit is set when a single pulse mode counting is ongoing, then the timer does not stop at the next match between the LPTIM3_ARR and LPTIM3_CNT registers and the LPTIM counter keeps counting in Continuous mode.\nThis bit can be set only when the LPTIM is enabled. It is automatically reset by hardware."
            },
            {
                "name": "COUNTRST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Counter reset\nThis bit is set by software and cleared by hardware. When set to '1' this bit triggers a synchronous reset of the LPTIM3_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock).\nThis bit can be set only when the LPTIM is enabled. It is automatically reset by hardware.\nCOUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software must consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'."
            },
            {
                "name": "RSTARE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Reset after read enable\nThis bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM3_CNT register asynchronously resets LPTIM3_CNT register content.\nThis bit can be set only when the LPTIM is enabled."
            }
        ]
    },
    "1073778708": {
        "name": "LPTIM3_CCR1",
        "address": 1073778708,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the capture/compare 1 register.\nDepending on the PRELOAD option, the CCR1 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 1 contains the value to be compared to the counter LPTIM3_CNT and signaled on OC1 output.\nIf channel CC1 is configured as input:\nCCR1 becomes read-only, it contains the counter value transferred by the last input capture 1 event. The LPTIM3_CCR1 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073778712": {
        "name": "LPTIM3_ARR",
        "address": 1073778712,
        "size": 32,
        "access": "",
        "desc": "LPTIM autoreload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto reload value\nARR is the autoreload value for the LPTIM.\nThis value must be strictly greater than the CCRx[15:0] value."
            }
        ]
    },
    "1073778716": {
        "name": "LPTIM3_CNT",
        "address": 1073778716,
        "size": 32,
        "access": "",
        "desc": "LPTIM counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value\nWhen the LPTIM is running with an asynchronous clock, reading the LPTIM3_CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical."
            }
        ]
    },
    "1073778724": {
        "name": "LPTIM3_CFGR2",
        "address": 1073778724,
        "size": 32,
        "access": "",
        "desc": "LPTIM configuration register 2",
        "fields": [
            {
                "name": "IN1SEL",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "LPTIM input 1 selection\nThe IN1SEL bits control the LPTIM input 1 multiplexer, which connects LPTIM input 1 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            },
            {
                "name": "IN2SEL",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "LPTIM input 2 selection\nThe IN2SEL bits control the LPTIM input 2 multiplexer, which connects LPTIM input 2 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            },
            {
                "name": "IC1SEL",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "LPTIM input capture 1 selection\nThe IC1SEL bits control the LPTIM Input capture 1 multiplexer, which connects LPTIM Input capture\n1 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            },
            {
                "name": "IC2SEL",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "LPTIM input capture 2 selection\nThe IC2SEL bits control the LPTIM Input capture 2 multiplexer, which connects LPTIM Input capture\n2 to one of the available inputs.\nFor connection details refer to Section125.4.3: LPTIM input and trigger mapping."
            }
        ]
    },
    "1073778728": {
        "name": "LPTIM3_RCR",
        "address": 1073778728,
        "size": 32,
        "access": "",
        "desc": "LPTIM repetition register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Repetition register value\nREP is the repetition value for the LPTIM."
            }
        ]
    },
    "1073778732": {
        "name": "LPTIM3_CCMR1",
        "address": 1073778732,
        "size": 32,
        "access": "",
        "desc": "LPTIM capture/compare mode register 1",
        "fields": [
            {
                "name": "CC1SEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 selection\nThis bitfield defines the direction of the channel input (capture) or output mode."
            },
            {
                "name": "CC1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 output enable.\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (LPTIM3_CCR1) or not."
            },
            {
                "name": "CC1P",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Capture/compare 1 output polarity.\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nThis field is used to select the IC1 polarity for capture operations."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC1 input (IC1)."
            },
            {
                "name": "IC1F",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Input capture 1 filter\nThis bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            },
            {
                "name": "CC2SEL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/compare 2 selection\nThis bitfield defines the direction of the channel, input (capture) or output mode."
            },
            {
                "name": "CC2E",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/compare 2 output enable.\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 2 (LPTIM3_CCR2) or not."
            },
            {
                "name": "CC2P",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Capture/compare 2 output polarity.\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nThis field is used to select the IC2 polarity for capture operations."
            },
            {
                "name": "IC2PSC",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC2 input (IC2)."
            },
            {
                "name": "IC2F",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Input capture 2 filter\nThis bitfield defines the number of consecutive equal samples that are detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            }
        ]
    },
    "1073778736": {
        "name": "LPTIM3_CCMR2",
        "address": 1073778736,
        "size": 32,
        "access": "",
        "desc": "LPTIM capture/compare mode register 2",
        "fields": [
            {
                "name": "CC3SEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 3 selection\nThis bitfield defines the direction of the channel input (capture) or output mode."
            },
            {
                "name": "CC3E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 3 output enable.\nCondition: CC3 as output:\nCondition: CC3 as input:\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 3 (LPTIM3_CCR3) or not."
            },
            {
                "name": "CC3P",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Capture/compare 3 output polarity.\nCondition: CC3 as output:\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nCondition: CC3 as input:\nThis field is used to select the IC3 polarity for capture operations."
            },
            {
                "name": "IC3PSC",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC3 input (IC3)."
            },
            {
                "name": "IC3F",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Input capture 3 filter\nThis bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            },
            {
                "name": "CC4SEL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/compare 4 selection\nThis bitfield defines the direction of the channel, input (capture) or output mode."
            },
            {
                "name": "CC4E",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/compare 4 output enable.\nCondition: CC4 as output:\nCondition: CC4 as input:\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 4 (LPTIM3_CCR4) or not."
            },
            {
                "name": "CC4P",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Capture/compare 4 output polarity.\nCondition: CC4 as output:\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nCondition: CC4 as input:\nThis field is used to select the IC4 polarity for capture operations."
            },
            {
                "name": "IC4PSC",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC4 input (IC4)."
            },
            {
                "name": "IC4F",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Input capture 4 filter\nThis bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            }
        ]
    },
    "1073778740": {
        "name": "LPTIM3_CCR2",
        "address": 1073778740,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 2 value\nIf channel CC2 is configured as output:\nCCR2 is the value to be loaded in the capture/compare 2 register.\nDepending on the PRELOAD option, the CCR2 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 2 contains the value to be compared to the counter LPTIM3_CNT and signaled on OC2 output.\nIf channel CC2 is configured as input:\nCCR2 becomes read-only, it contains the counter value transferred by the last input capture 2 event. The LPTIM3_CCR2 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073778744": {
        "name": "LPTIM3_CCR3",
        "address": 1073778744,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 3 value\nIf channel CC3 is configured as output:\nCCR3 is the value to be loaded in the capture/compare 3 register.\nDepending on the PRELOAD option, the CCR3 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 3 contains the value to be compared to the counter LPTIM3_CNT and signaled on OC3 output.\nIf channel CC3 is configured as input:\nCCR3 becomes read-only, it contains the counter value transferred by the last input capture 3 event. The LPTIM3_CCR3 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073778748": {
        "name": "LPTIM3_CCR4",
        "address": 1073778748,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 4 value\nIf channel CC4 is configured as output:\nCCR4 is the value to be loaded in the capture/compare 4 register.\nDepending on the PRELOAD option, the CCR4 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 4 contains the value to be compared to the counter LPTIM3_CNT and signaled on OC4 output.\nIf channel CC4 is configured as input:\nCCR4 becomes read-only, it contains the counter value transferred by the last input capture 4 event. The LPTIM3_CCR4 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073774592": {
        "name": "LPUART_CR1",
        "address": 1073774592,
        "size": 32,
        "access": "",
        "desc": "LPUART control register 1",
        "fields": [
            {
                "name": "UE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPUART enable\nWhen this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software.\nNote: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit.\nNote: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit."
            },
            {
                "name": "UESM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPUART enable in low-power mode\nWhen this bit is cleared, the LPUART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the LPUART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\nNote: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode."
            },
            {
                "name": "RE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software."
            },
            {
                "name": "TE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register.\nNote: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts."
            },
            {
                "name": "IDLEIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "IDLE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFNEIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFNFIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PEIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "PE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "PCE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "WAKE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver wake-up method\nThis bit determines the LPUART wake-up method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "M0",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description).\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "MME",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Mute mode enable\nThis bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software."
            },
            {
                "name": "CMIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Character match interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "DEDT",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Driver Enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section132.4.14: RS232 Hardware flow control and RS485 Driver Enable.\nIf the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DEAT",
                "bitOffset": 21,
                "bitWidth": 5,
                "desc": "Driver Enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section131.5.21: RS232 Hardware flow control and RS485 Driver Enable.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "M1",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] = 00: 1 Start bit, 8 Data bits, n Stop bit\nM[1:0] = 01: 1 Start bit, 9 Data bits, n Stop bit\nM[1:0] = 10: 1 Start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the LPUART is disabled (UE=0).\nNote: In 7-bit data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported."
            },
            {
                "name": "FIFOEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "FIFO mode enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFEIE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TXFIFO empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFFIE",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RXFIFO Full interrupt enable\nThis bit is set and cleared by software."
            }
        ]
    },
    "1073774596": {
        "name": "LPUART_CR2",
        "address": 1073774596,
        "size": 32,
        "access": "",
        "desc": "LPUART control register 2",
        "fields": [
            {
                "name": "ADDM7",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "7-bit Address Detection/4-bit Address Detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\nThis bit can only be written when the LPUART is disabled (UE=0)\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively."
            },
            {
                "name": "STOP",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "STOP bits\nThese bits are used for programming the stop bits.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "SWAP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Swap TX/RX pins\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "RXINV",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "RX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "TXINV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DATAINV",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Binary data inversion\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "MSBFIRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Most significant bit first\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "ADD",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Address of the LPUART node\nThese bits give the address of the LPUART node in Mute mode or a character code to be recognized in low-power or Run mode:\nIn Mute mode: they are used in multiprocessor communication to wake up from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.\nIn low-power mode: they are used for wake up from low-power mode on character match.\nWhen WUS[1:0] is programmed to 0b00 (WUF active on address match), the wake-up from low-power mode is performed when the received character corresponds to the character programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1.\nIn Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.\nThese bits can only be written when the reception is disabled (RE1=10) or when the USART is disabled (UE1=10)."
            }
        ]
    },
    "1073774600": {
        "name": "LPUART_CR3",
        "address": 1073774600,
        "size": 32,
        "access": "",
        "desc": "LPUART control register 3",
        "fields": [
            {
                "name": "EIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FE=1 or ORE=1 or NE=1 in the LPUART_ISR register)."
            },
            {
                "name": "HDSEL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Half-duplex selection\nSelection of Single-wire Half-duplex mode\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DMAR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA enable receiver\nThis bit is set/reset by software"
            },
            {
                "name": "DMAT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA enable transmitter\nThis bit is set/reset by software"
            },
            {
                "name": "RTSE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "RTS enable\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "CTSE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS enable\nThis bit can only be written when the LPUART is disabled (UE=0)"
            },
            {
                "name": "CTSIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS interrupt enable"
            },
            {
                "name": "OVRDIS",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun Disable\nThis bit is used to disable the receive overrun detection.\nthe ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register.\nThis bit can only be written when the LPUART is disabled (UE=0).\nNote: This control bit enables checking the communication flow w/o reading the data."
            },
            {
                "name": "DDRE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DMA Disable on Reception Error\nThis bit can only be written when the LPUART is disabled (UE=0).\nNote: The reception errors are: parity error, framing error or noise error."
            },
            {
                "name": "DEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DEP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Driver enable polarity selection\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "WUS0",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wake-up from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (Wake-up from low-power mode flag).\nThis bitfield can only be written when the LPUART is disabled (UE=0).\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914."
            },
            {
                "name": "WUS1",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Wake-up from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (Wake-up from low-power mode flag).\nThis bitfield can only be written when the LPUART is disabled (UE=0).\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914."
            },
            {
                "name": "WUFIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Wake-up from low-power mode interrupt enable\nThis bit is set and cleared by software.\nNote: WUFIE must be set before entering in low-power mode.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914."
            },
            {
                "name": "TXFTIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFTCFG",
                "bitOffset": 25,
                "bitWidth": 3,
                "desc": "Receive FIFO threshold configuration\nRemaining combinations: Reserved."
            },
            {
                "name": "RXFTIE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "RXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFTCFG",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "TXFIFO threshold configuration\nRemaining combinations: Reserved."
            }
        ]
    },
    "1073774604": {
        "name": "LPUART_BRR",
        "address": 1073774604,
        "size": 32,
        "access": "",
        "desc": "LPUART baud rate register",
        "fields": [
            {
                "name": "BRR",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "LPUART baud rate division (LPUARTDIV)"
            }
        ]
    },
    "1073774616": {
        "name": "LPUART_RQR",
        "address": 1073774616,
        "size": 32,
        "access": "",
        "desc": "LPUART request register",
        "fields": [
            {
                "name": "SBKRQ",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\nNote: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software must wait for the TXE flag assertion before setting the SBKRQ bit."
            },
            {
                "name": "MMRQ",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Mute mode request\nWriting 1 to this bit puts the LPUART in Mute mode and resets the RWU flag."
            },
            {
                "name": "RXFRQ",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Receive data flush request\nWriting 1 to this bit clears the RXNE flag.\nThis enables discarding the received data without reading it, and avoid an overrun condition."
            },
            {
                "name": "TXFRQ",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Transmit data flush request\nThis bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register).\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register."
            }
        ]
    },
    "1073774620": {
        "name": "LPUART_ISR",
        "address": 1073774620,
        "size": 32,
        "access": "",
        "desc": "LPUART interrupt and status register",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error\nThis bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register.\nAn interrupt is generated if PEIE = 1 in the LPUART_CR1 register.\nNote: This error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "FE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE1=11 in the LPUART_CR3 register.\nNote: This error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Start bit noise detection flag\nThis bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NFCF bit in the LPUART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.\nNote: This error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "ORE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the LPUART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register.\nAn interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register, or EIE = 1 in the LPUART_CR3 register.\nNote: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.\nNote: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register."
            },
            {
                "name": "IDLE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected\nThis bit is set by hardware when an Idle line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register.\nNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).\nNote: If Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set."
            },
            {
                "name": "RXFNE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty\nRXFNE bit is set by hardware when the RXFIFO is not empty, and so data can be read from the LPUART_RDR register. Every read of the LPUART_RDR frees a location in the RXFIFO. It is cleared when the RXFIFO is empty.\nThe RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register.\nAn interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete\nThis bit indicates that the last data written in the LPUART_TDR has been transmitted out of the shift register. The TC flag behaves as follows:\nWhen TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXFE is set.\nWhen TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached.\nWhen TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred.\nWhen TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty.\nAn interrupt is generated if TCIE=1 in the LPUART_CR1 register.\nTC bit is cleared by software by writing 1 to the TCCF in the LPUART_ICR register or by writing to the LPUART_TDR register."
            },
            {
                "name": "TXFNF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full\nTXFNF is set by hardware when TXFIFO is not full, and so data can be written in the LPUART_TDR. Every write in the LPUART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the LPUART_TDR.\nThe TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF must be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time).\nAn interrupt is generated if the TXFNFIE bit =1 in the LPUART_CR1 register.\nNote: This bit is used during single buffer transmission."
            },
            {
                "name": "CTSIF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS interrupt flag\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register.\nAn interrupt is generated if CTSIE=1 in the LPUART_CR3 register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "CTS",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "BUSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not)."
            },
            {
                "name": "CMF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register.\nAn interrupt is generated if CMIE=1in the LPUART_CR1 register."
            },
            {
                "name": "SBKF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission."
            },
            {
                "name": "RWU",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Receiver wake-up from Mute mode\nThis bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wake-up/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register.\nWhen wake-up on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register.\nNote: If the LPUART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "WUF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wake-up from low-power mode flag\nThis bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the LPUART_ICR register.\nAn interrupt is generated if WUFIE=1 in the LPUART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section132.3: LPUART implementation on page1914."
            },
            {
                "name": "TEACK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART.\nIt can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period."
            },
            {
                "name": "REACK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART.\nIt can be used to verify that the LPUART is ready for reception before entering low-power mode.\nNote: If the LPUART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "TXFE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO Empty\nThis bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the LPUART_RQR register.\nAn interrupt is generated if the TXFEIE bit =1 (bit 30) in the LPUART_CR1 register."
            },
            {
                "name": "RXFF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "RXFIFO Full\nThis bit is set by hardware when the number of received data corresponds to RXFIFO1size1+11 (RXFIFO full + 1 data in the LPUART_RDR register.\nAn interrupt is generated if the RXFFIE bit =1 in the LPUART_CR1 register."
            },
            {
                "name": "RXFT",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "RXFIFO threshold flag\nThis bit is set by hardware when the RXFIFO reaches the threshold programmed in RXFTCFG in LPUART_CR3 register i.e. the Receive FIFO contains RXFTCFG data. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the LPUART_CR3 register."
            },
            {
                "name": "TXFT",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "TXFIFO threshold flag\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG in LPUART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the LPUART_CR3 register."
            }
        ]
    },
    "1073774624": {
        "name": "LPUART_ICR",
        "address": 1073774624,
        "size": 32,
        "access": "",
        "desc": "LPUART interrupt flag clear register",
        "fields": [
            {
                "name": "PECF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error clear flag\nWriting 1 to this bit clears the PE flag in the LPUART_ISR register."
            },
            {
                "name": "FECF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error clear flag\nWriting 1 to this bit clears the FE flag in the LPUART_ISR register."
            },
            {
                "name": "NECF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the LPUART_ISR register."
            },
            {
                "name": "ORECF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the LPUART_ISR register."
            },
            {
                "name": "IDLECF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the LPUART_ISR register."
            },
            {
                "name": "TCCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the LPUART_ISR register."
            },
            {
                "name": "CTSCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the LPUART_ISR register."
            },
            {
                "name": "CMCF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match clear flag\nWriting 1 to this bit clears the CMF flag in the LPUART_ISR register."
            },
            {
                "name": "WUCF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wake-up from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the USART_ISR register.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section132.3: LPUART implementation on page1914."
            }
        ]
    },
    "1073774628": {
        "name": "LPUART_RDR",
        "address": 1073774628,
        "size": 32,
        "access": "",
        "desc": "LPUART receive data register",
        "fields": [
            {
                "name": "RDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Receive data value\nContains the received data character.\nThe RDR register provides the parallel interface between the input shift register and the internal bus (see Figure1254).\nWhen receiving with the parity enabled, the value read in the MSB bit is the received parity bit."
            }
        ]
    },
    "1073774632": {
        "name": "LPUART_TDR",
        "address": 1073774632,
        "size": 32,
        "access": "",
        "desc": "LPUART transmit data register",
        "fields": [
            {
                "name": "TDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Transmit data value\nContains the data character to be transmitted.\nThe TDR register provides the parallel interface between the internal bus and the output shift register (see Figure1254).\nWhen transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.\nNote: This register must be written only when TXE/TXFNF=1."
            }
        ]
    },
    "1073774636": {
        "name": "LPUART_PRESC",
        "address": 1073774636,
        "size": 32,
        "access": "",
        "desc": "LPUART prescaler register",
        "fields": [
            {
                "name": "PRESCALER",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Clock prescaler\nThe LPUART input clock can be divided by a prescaler:\nRemaining combinations: Reserved.\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256."
            }
        ]
    },
    "1073772544": {
        "name": "OPAMP_CSR",
        "address": 1073772544,
        "size": 32,
        "access": "",
        "desc": "OPAMP control/status register",
        "fields": [
            {
                "name": "OPAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Operational amplifier Enable"
            },
            {
                "name": "OPALPM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Operational amplifier Low Power Mode\nThe operational amplifier must be disable to change this configuration."
            },
            {
                "name": "OPAMODE",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Operational amplifier PGA mode"
            },
            {
                "name": "PGA_GAIN",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Operational amplifier Programmable amplifier gain value"
            },
            {
                "name": "VM_SEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Inverting input selection\nThese bits are used only when OPAMODE = 00, 01 or 10.\n1x:\tInverting input not externally connected. These configurations are valid only when OPAMODE = 10 (PGA mode)"
            },
            {
                "name": "VP_SEL",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Non inverted input selection"
            },
            {
                "name": "CALON",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Calibration mode enabled"
            },
            {
                "name": "CALSEL",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Calibration selection"
            },
            {
                "name": "USERTRIM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "allows to switch from factory AOP offset trimmed values to AOP offset user trimmed values\nThis bit is active for both mode normal and low-power."
            },
            {
                "name": "CALOUT",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Operational amplifier calibration output\nDuring calibration mode offset is trimmed when this signal toggle."
            },
            {
                "name": "OPA_RANGE",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Operational amplifier power supply range for stability\nAll AOP must be in power down to allow AOP-RANGE bit write. It applies to all AOP embedded in the product."
            }
        ]
    },
    "1073772548": {
        "name": "OPAMP_OTR",
        "address": 1073772548,
        "size": 32,
        "access": "",
        "desc": "OPAMP offset trimming register in normal mode",
        "fields": [
            {
                "name": "TRIMOFFSETN",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Trim for NMOS differential pairs"
            },
            {
                "name": "TRIMOFFSETP",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "Trim for PMOS differential pairs"
            }
        ]
    },
    "1073772552": {
        "name": "OPAMP_LPOTR",
        "address": 1073772552,
        "size": 32,
        "access": "",
        "desc": "OPAMP offset trimming register in low-power mode",
        "fields": [
            {
                "name": "TRIMLPOFFSETN",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Low-power mode trim for NMOS differential pairs"
            },
            {
                "name": "TRIMLPOFFSETP",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "Low-power mode trim for PMOS differential pairs"
            }
        ]
    },
    "1073770496": {
        "name": "PWR_CR1",
        "address": 1073770496,
        "size": 32,
        "access": "",
        "desc": "Power control register 1",
        "fields": [
            {
                "name": "LPMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Low-power mode selection\nThese bits select the low-power mode entered when CPU enters the deepsleep mode.\n1xx: Shutdown mode\nNote: If LPR bit is set, Stop 2 mode cannot be selected and Stop 1 mode shall be entered instead of Stop 2.\nNote: In Standby mode, SRAM2 can be preserved or not, depending on RRS bit configuration in PWR_CR3."
            },
            {
                "name": "FPD_STOP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Flash memory powered down during Stop mode.\nThis bit determines whether the flash memory is put in power-down mode or remains in idle mode when the device enters Stop mode."
            },
            {
                "name": "FPD_LPRUN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Flash memory powered down during Low-power run mode.\nThis bit determines whether the flash memory is put in power-down mode or remains in idle mode when the device enters Low-power sleep mode."
            },
            {
                "name": "FPD_LPSLP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Flash memory powered down during Low-power sleep mode.\nThis bit determines whether the flash memory is put in power-down mode or remains in idle mode when the device enters Low-power sleep mode."
            },
            {
                "name": "DBP",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Disable backup domain write protection\nIn reset state, the RTC and backup registers are protected against parasitic write access. This bit must be set to enable write access to these registers."
            },
            {
                "name": "VOS",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "Voltage scaling range selection"
            },
            {
                "name": "LPR",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Low-power run\nWhen this bit is set, the regulator is switched from main mode (MR) to low-power mode (LPR).\nNote: Stop 2 mode cannot be entered when LPR bit is set. Stop 1 is entered instead."
            }
        ]
    },
    "1073770500": {
        "name": "PWR_CR2",
        "address": 1073770500,
        "size": 32,
        "access": "",
        "desc": "Power control register 2",
        "fields": [
            {
                "name": "PVDE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Programmable voltage detector enable\nNote: This bit is write-protected when the bit PVDL (PVD Lock) is set in the SYSCFG_CBR register.\nNote: This bit is reset only by a system reset."
            },
            {
                "name": "PLS",
                "bitOffset": 1,
                "bitWidth": 3,
                "desc": "Programmable voltage detector level selection.\nThese bits select the voltage threshold detected by the programmable voltage detector:\nNote: These bits are write-protected when the bit PVDL (PVD Lock) is set in the SYSCFG_CBR register.\nNote: These bits are reset only by a system reset."
            },
            {
                "name": "PVME1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Peripheral voltage monitoring 1 enable: V<sub>DDUSB</sub> vs. 1.21V"
            },
            {
                "name": "PVME3",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Peripheral voltage monitoring 3 enable: V<sub>DDA</sub> vs. 1.621V"
            },
            {
                "name": "PVME4",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Peripheral voltage monitoring 4 enable: V<sub>DDA</sub> vs. 1.861V"
            },
            {
                "name": "USV",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "V<sub>DDUSB</sub> USB supply valid\nThis bit is used to validate the V<sub>DDUSB</sub> supply for electrical and logical isolation purpose.\nSetting this bit is mandatory to use the USB FS peripheral. If V<sub>DDUSB</sub> is not always\npresent in the application, the PVM can be used to determine whether this supply is ready or\nnot."
            }
        ]
    },
    "1073770504": {
        "name": "PWR_CR3",
        "address": 1073770504,
        "size": 32,
        "access": "",
        "desc": "Power control register 3",
        "fields": [
            {
                "name": "EWUP1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Enable Wake-up pin WKUP1\nWhen this bit is set, the external wake-up pin WKUP1 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP1 bit in the PWR_CR4 register."
            },
            {
                "name": "EWUP2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Enable Wake-up pin WKUP2\nWhen this bit is set, the external wake-up pin WKUP2 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP2 bit in the PWR_CR4 register."
            },
            {
                "name": "EWUP3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Enable Wake-up pin WKUP3\nWhen this bit is set, the external wake-up pin WKUP3 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP3 bit in the PWR_CR4 register."
            },
            {
                "name": "EWUP4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Enable Wake-up pin WKUP4\nWhen this bit is set, the external wake-up pin WKUP4 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs. The active edge is configured via the WP4 bit in the PWR_CR4 register."
            },
            {
                "name": "EWUP5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Enable Wake-up pin WKUP5\nWhen this bit is set, the external wake-up pin WKUP5 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs.The active edge is configured via the WP5 bit in the PWR_CR4 register."
            },
            {
                "name": "EWUP7",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Enable Wake-up pin WKUP7.\nWhen this bit is set, the external wake-up pin WKUP7 is enabled and triggers a wake-up from Standby or Shutdown event when a rising or a falling edge occurs.The active edge is configured via the WP7 bit in the PWR_CR4 register."
            },
            {
                "name": "RRS",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM2 retention in Standby mode"
            },
            {
                "name": "ENULP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Enable ULP sampling\nWhen this bit is set, the BORL, BORH and PVD are periodically sampled instead continuous monitoring to reduce power consumption. Fast supply drop between two sample/compare phases is not detected in this mode. This bit has impact only on STOP2, Standby and shutdown low power modes."
            },
            {
                "name": "APC",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Apply pull-up and pull-down configuration\nWhen this bit is set, the I/O pull-up and pull-down configurations defined in the PWR_PUCRx\nand PWR_PDCRx registers are applied. When this bit is cleared, the PWR_PUCRx and PWR_PDCRx registers are not applied to the I/Os, instead the I/Os are in floating mode during Standby or configured according GPIO controller GPIOx_PUPDR register during RUN mode."
            },
            {
                "name": "EIWUL",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Enable internal wake-up line"
            }
        ]
    },
    "1073770508": {
        "name": "PWR_CR4",
        "address": 1073770508,
        "size": 32,
        "access": "",
        "desc": "Power control register 4",
        "fields": [
            {
                "name": "WP1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Wake-up pin WKUP1 polarity\nThis bit defines the polarity used for an event detection on external wake-up pin, WKUP1"
            },
            {
                "name": "WP2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Wake-up pin WKUP2 polarity\nThis bit defines the polarity used for an event detection on external wake-up pin, WKUP2"
            },
            {
                "name": "WP3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wake-up pin WKUP3 polarity\nThis bit defines the polarity used for an event detection on external wake-up pin, WKUP3"
            },
            {
                "name": "WP4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Wake-up pin WKUP4 polarity\nThis bit defines the polarity used for an event detection on external wake-up pin, WKUP4"
            },
            {
                "name": "WP5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Wake-up pin WKUP5 polarity\nThis bit defines the polarity used for an event detection on external wake-up pin, WKUP5"
            },
            {
                "name": "WP7",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Wake-up pin WKUP7 polarity\nThis bit defines the polarity used for an event detection on external wake-up pin, WKUP7"
            },
            {
                "name": "VBE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "V<sub>BAT</sub> battery charging enable"
            },
            {
                "name": "VBRS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "V<sub>BAT</sub> battery charging resistor selection"
            }
        ]
    },
    "1073770512": {
        "name": "PWR_SR1",
        "address": 1073770512,
        "size": 32,
        "access": "",
        "desc": "Power status register 1",
        "fields": [
            {
                "name": "WUF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Wake-up flag 1\nThis bit is set when a wake-up event is detected on wake-up pin, WKUP1. It is cleared by writing 1 in the CWUF1 bit of the PWR_SCR register."
            },
            {
                "name": "WUF2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Wake-up flag 2\nThis bit is set when a wake-up event is detected on wake-up pin, WKUP2. It is cleared by writing 1 in the CWUF2 bit of the PWR_SCR register."
            },
            {
                "name": "WUF3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wake-up flag 3\nThis bit is set when a wake-up event is detected on wake-up pin, WKUP3. It is cleared by writing 1 in the CWUF3 bit of the PWR_SCR register."
            },
            {
                "name": "WUF4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Wake-up flag 4\nThis bit is set when a wake-up event is detected on wake-up pin,WKUP4. It is cleared by writing 1 in the CWUF4 bit of the PWR_SCR register."
            },
            {
                "name": "WUF5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Wake-up flag 5\nThis bit is set when a wake-up event is detected on wake-up pin, WKUP5. It is cleared by writing 1 in the CWUF5 bit of the PWR_SCR register."
            },
            {
                "name": "WUF7",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Wake-up flag 7\nThis bit is set when a wake-up event is detected on wake-up pin, WKUP7. It is cleared by writing 1 in the CWUF7 bit of the PWR_SCR register."
            },
            {
                "name": "SBF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Standby flag\nThis bit is set by hardware when the device enters the Standby mode and is cleared by setting the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset."
            },
            {
                "name": "STOPF",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "Stop Flags\nThese bits are set by hardware when the device enters any stop mode and are cleared by setting the CSBF bit in the PWR_SCR register, or by a power-on reset. It is not cleared by the system reset."
            },
            {
                "name": "WUFI",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Wake-up flag internal\nThis bit is set when a wake-up is detected on the internal wake-up line. It is cleared when all internal wake-up sources are cleared."
            }
        ]
    },
    "1073770516": {
        "name": "PWR_SR2",
        "address": 1073770516,
        "size": 32,
        "access": "",
        "desc": "Power status register 2",
        "fields": [
            {
                "name": "FLASH_RDY",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Flash ready flag\nThis bit is set by hardware to indicate when the flash memory is readey to be accessed after wake-up from power-down. To place the flash memory in power-down, set either FPD_LPRUN, FPD_LPSLP or FPD_STP bits.\nNote : If the system boots from SRAM, the user application must wait until the FLASH_RDY bit is set, prior to jumping to flash memory."
            },
            {
                "name": "REGLPS",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Low-power regulator started\nThis bit provides the information whether the low-power regulator is ready after a power-on\nreset or a Standby/Shutdown. If the Standby mode is entered while REGLPS bit is still cleared, the wake-up from Standby mode time may be increased."
            },
            {
                "name": "REGLPF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Low-power regulator flag\nThis bit is set by hardware when the MCU is in Low-power run mode. When the MCU exits\nfrom the Low-power run mode, this bit remains at 1 until the regulator is ready in main mode. A polling on this bit must be done before increasing the product frequency.\nThis bit is cleared by hardware when the regulator is ready."
            },
            {
                "name": "VOSF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Voltage scaling flag\nA delay is required for the internal regulator to be ready after the voltage scaling has been changed. VOSF indicates that the regulator reached the voltage level defined with VOS bits of the PWR_CR1 register."
            },
            {
                "name": "PVDO",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Programmable voltage detector output"
            },
            {
                "name": "PVMO1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Peripheral voltage monitoring output: V<sub>DDUSB</sub> vs. 1.2 V\nNote: PVMO1 is cleared when PVM1 is disabled (PVME1 = 0). After enabling PVM1, the PVM1 output is valid after the PVM1 wake-up time."
            },
            {
                "name": "PVMO3",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 1.621V\nNote: PVMO3 is cleared when PVM3 is disabled (PVME3 = 0). After enabling PVM3, the PVM3 output is valid after the PVM3 wake-up time."
            },
            {
                "name": "PVMO4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Peripheral voltage monitoring output: V<sub>DDA</sub> vs. 2.21V\nNote: PVMO4 is cleared when PVM4 is disabled (PVME4 = 0). After enabling PVM4, the PVM4 output is valid after the PVM4 wake-up time."
            }
        ]
    },
    "1073770520": {
        "name": "PWR_SCR",
        "address": 1073770520,
        "size": 32,
        "access": "",
        "desc": "Power status clear register",
        "fields": [
            {
                "name": "CWUF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear wake-up flag 1\nSetting this bit clears the WUF1 flag in the PWR_SR1 register."
            },
            {
                "name": "CWUF2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear wake-up flag 2\nSetting this bit clears the WUF2 flag in the PWR_SR1 register."
            },
            {
                "name": "CWUF3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear wake-up flag 3\nSetting this bit clears the WUF3 flag in the PWR_SR1 register."
            },
            {
                "name": "CWUF4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear wake-up flag 4\nSetting this bit clears the WUF4 flag in the PWR_SR1 register."
            },
            {
                "name": "CWUF5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear wake-up flag 5\nSetting this bit clears the WUF5 flag in the PWR_SR1 register."
            },
            {
                "name": "CWUF7",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Clear wake-up flag 7\nSetting this bit clears the WUF7 flag in the PWR_SR1 register."
            },
            {
                "name": "CSBF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Clear standby flag\nSetting this bit clears the SBF flag in the PWR_SR1 register."
            }
        ]
    },
    "1073770528": {
        "name": "PWR_PUCRA",
        "address": 1073770528,
        "size": 32,
        "access": "",
        "desc": "Power Port A pull-up control register",
        "fields": [
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y (y1=115 to 0)\nWhen set, this bit activates the pull-up on PA[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            }
        ]
    },
    "1073770532": {
        "name": "PWR_PDCRA",
        "address": 1073770532,
        "size": 32,
        "access": "",
        "desc": "Power Port A pull-down control register",
        "fields": [
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\nWhen set, this bit activates the pull-down on PA[y] when APC bit is set in PWR_CR3 register."
            }
        ]
    },
    "1073770536": {
        "name": "PWR_PUCRB",
        "address": 1073770536,
        "size": 32,
        "access": "",
        "desc": "Power Port B pull-up control register",
        "fields": [
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PU15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\nWhen set, this bit activates the pull-up on PB[y] when APC bit is set in PWR_CR3 register."
            }
        ]
    },
    "1073770540": {
        "name": "PWR_PDCRB",
        "address": 1073770540,
        "size": 32,
        "access": "",
        "desc": "Power Port B pull-down control register",
        "fields": [
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\nWhen set, this bit activates the pull-down on PB[y] when APC bit is set in PWR_CR3 register."
            }
        ]
    },
    "1073770544": {
        "name": "PWR_PUCRC",
        "address": 1073770544,
        "size": 32,
        "access": "",
        "desc": "Power Port C pull-up control register",
        "fields": [
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\nWhen set, this bit activates the pull-up on PC[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            }
        ]
    },
    "1073770548": {
        "name": "PWR_PDCRC",
        "address": 1073770548,
        "size": 32,
        "access": "",
        "desc": "Power Port C pull-down control register",
        "fields": [
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\nWhen set, this bit activates the pull-down on PC[y] when APC bit is set in PWR_CR3 register."
            }
        ]
    },
    "1073770552": {
        "name": "PWR_PUCRD",
        "address": 1073770552,
        "size": 32,
        "access": "",
        "desc": "Power Port D pull-up control register",
        "fields": [
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\nWhen set, this bit activates the pull-up on PD[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            }
        ]
    },
    "1073770556": {
        "name": "PWR_PDCRD",
        "address": 1073770556,
        "size": 32,
        "access": "",
        "desc": "Power Port D pull-down control register",
        "fields": [
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\nWhen set, this bit activates the pull-down on PD[y] when APC bit is set in PWR_CR3 register."
            }
        ]
    },
    "1073770560": {
        "name": "PWR_PUCRE",
        "address": 1073770560,
        "size": 32,
        "access": "",
        "desc": "Power Port E pull-up control register",
        "fields": [
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port E pull-up bit 3\nWhen set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\nWhen set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\nWhen set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\nWhen set, this bit activates the pull-up on PE[y] when APC bit is set in PWR_CR3 register. If the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            }
        ]
    },
    "1073770564": {
        "name": "PWR_PDCRE",
        "address": 1073770564,
        "size": 32,
        "access": "",
        "desc": "Power Port E pull-down control register",
        "fields": [
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port E pull-down bit 3\nWhen set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\nWhen set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\nWhen set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\nWhen set, this bit activates the pull-down on PE[y] when APC bit is set in PWR_CR3 register."
            }
        ]
    },
    "1073770568": {
        "name": "PWR_PUCRF",
        "address": 1073770568,
        "size": 32,
        "access": "",
        "desc": "Power Port F pull-up control register",
        "fields": [
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\nWhen set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register.\nIf the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\nWhen set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register.\nIf the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\nWhen set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register.\nIf the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\nWhen set, this bit activates the pull-up on PH[y] when APC bit is set in PWR_CR3 register.\nIf the corresponding PDy bit is also set, the pull-up is not activated and the pull-down is activated instead with highest priority."
            }
        ]
    },
    "1073770572": {
        "name": "PWR_PDCRF",
        "address": 1073770572,
        "size": 32,
        "access": "",
        "desc": "Power Port F pull-down control register",
        "fields": [
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\nWhen set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\nWhen set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\nWhen set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register."
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\nWhen set, this bit activates the pull-down on PH[y] when APC bit is set in PWR_CR3 register."
            }
        ]
    },
    "1073876992": {
        "name": "RCC_CR",
        "address": 1073876992,
        "size": 32,
        "access": "",
        "desc": "Clock control register",
        "fields": [
            {
                "name": "MSION",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "MSI clock enable\nThis bit is set and cleared by software.\nCleared by hardware to stop the MSI oscillator when entering Stop, Standby or Shutdown mode.\nSet by hardware to force the MSI oscillator ON when exiting Standby or Shutdown mode.\nSet by hardware to force the MSI oscillator ON when STOPWUCK=0 when exiting from Stop modes, or in case of a failure of the HSE oscillator\nSet by hardware when used directly or indirectly as system clock."
            },
            {
                "name": "MSIRDY",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "MSI clock ready flag\nThis bit is set by hardware to indicate that the MSI oscillator is stable.\nNote: Once the MSION bit is cleared, MSIRDY goes low after 6 MSI clock cycles."
            },
            {
                "name": "MSIPLLEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "MSI clock PLL enable\nSet and cleared by software to enable/ disable the PLL part of the MSI clock source.\nMSIPLLEN must be enabled after LSE is enabled (LSEON enabled) and ready (LSERDY set by hardware).There is a hardware protection to avoid enabling MSIPLLEN if LSE is not ready.\nThis bit is cleared by hardware when LSE is disabled (LSEON = 0) or when the Clock Security System on LSE detects a LSE failure (refer to RCC_CSR register)."
            },
            {
                "name": "MSIRGSEL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "MSI clock range selection\nSet by software to select the MSI clock range with MSIRANGE[3:0]. Write 0 has no effect.\nAfter a standby or a reset MSIRGSEL is at 0 and the MSI range value is provided by MSISRANGE in CSR register."
            },
            {
                "name": "MSIRANGE",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "MSI clock ranges\nThese bits are configured by software to choose the frequency range of MSI when MSIRGSEL is set.12 frequency ranges are available:\nothers: not allowed (hardware write protection)\nNote: Warning: MSIRANGE can be modified when MSI is OFF (MSION=0) or when MSI is ready (MSIRDY=1). MSIRANGE must NOT be modified when MSI is ON and NOT ready (MSION=1 and MSIRDY=0)"
            },
            {
                "name": "HSION",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "HSI16 clock enable\nSet and cleared by software.\nCleared by hardware to stop the HSI16 oscillator when entering Stop, Standby, or Shutdown mode.\nForced by hardware to keep the HSI16 oscillator ON when it is used directly or indirectly as system clock (also when leaving Stop, Standby, or Shutdown modes, or in case of failure of the HSE oscillator used for system clock)."
            },
            {
                "name": "HSIKERON",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "HSI16 always enable for peripheral kernels.\nSet and cleared by software to force HSI16 ON even in Stop modes. The HSI16 can only feed USART1, USART2, CEC and I2C1 peripherals configured with HSI16 as kernel clock. Keeping the HSI16 ON in Stop mode allows avoiding to slow down the communication speed because of the HSI16 startup time. This bit has no effect on HSION value."
            },
            {
                "name": "HSIRDY",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "HSI16 clock ready flag\nSet by hardware to indicate that HSI16 oscillator is stable. This bit is set only when HSI16 is enabled by software by setting HSION.\nNote: Once the HSION bit is cleared, HSIRDY goes low after 6 HSI16 clock cycles."
            },
            {
                "name": "HSIASFS",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "HSI16 automatic start from Stop\nSet and cleared by software. When the system wake-up clock is MSI, this bit is used to wake up the HSI16 is parallel of the system wake-up."
            },
            {
                "name": "HSEON",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "HSE clock enable\nSet and cleared by software.\nCleared by hardware to stop the HSE oscillator when entering Stop, Standby, or Shutdown mode. This bit cannot be reset if the HSE oscillator is used directly or indirectly as the system clock."
            },
            {
                "name": "HSERDY",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "HSE clock ready flag\nSet by hardware to indicate that the HSE oscillator is stable.\nNote: Once the HSEON bit is cleared, HSERDY goes low after 6 HSE clock cycles."
            },
            {
                "name": "HSEBYP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "HSE crystal oscillator bypass\nSet and cleared by software to bypass the oscillator with an external clock. The external clock must be enabled with the HSEON bit set, to be used by the device. The HSEBYP bit can be written only if the HSE oscillator is disabled."
            },
            {
                "name": "CSSON",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Clock security system enable\nSet by software to enable the clock security system. When CSSON is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. This bit is set only and is cleared by reset."
            },
            {
                "name": "PLLON",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "PLL enable\nSet and cleared by software to enable the PLL.\nCleared by hardware when entering Stop, Standby or Shutdown mode. This bit cannot be reset if the PLL clock is used as the system clock."
            },
            {
                "name": "PLLRDY",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "PLL clock ready flag\nSet by hardware to indicate that the PLL is locked."
            }
        ]
    },
    "1073876996": {
        "name": "RCC_ICSCR",
        "address": 1073876996,
        "size": 32,
        "access": "",
        "desc": "Internal clock sources calibration register",
        "fields": [
            {
                "name": "MSICAL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "MSI clock calibration\nThese bits are initialized at startup with the factory-programmed MSI calibration trim value. When MSITRIM is written, MSICAL is updated with the sum of MSITRIM and the factory trim value."
            },
            {
                "name": "MSITRIM",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "MSI clock trimming\nThese bits provide an additional user-programmable trimming value that is added to the MSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature that influence the frequency of the MSI."
            },
            {
                "name": "HSICAL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "HSI16 clock calibration\nThese bits are initialized at startup with the factory-programmed HSI16 calibration trim value. When HSITRIM is written, HSICAL is updated with the sum of HSITRIM and the factory trim value."
            },
            {
                "name": "HSITRIM",
                "bitOffset": 24,
                "bitWidth": 7,
                "desc": "HSI16 clock trimming\nThese bits provide an additional user-programmable trimming value that is added to the HSICAL[7:0] bits. It can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI16.\nThe default value is 64 when added to the HSICAL value,  trim the HSI16 to 161MHz 1 11%."
            }
        ]
    },
    "1073877000": {
        "name": "RCC_CFGR",
        "address": 1073877000,
        "size": 32,
        "access": "",
        "desc": "Clock configuration register",
        "fields": [
            {
                "name": "SW",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "System clock switch\nThis bitfield is controlled by software and hardware. The bitfield selects the clock for SYSCLK as follows:\nOthers: Reserved\nThe setting is forced by hardware to 000 (HSISYS selected) when the MCU exits Stop, Standby, or Shutdown mode, or when the setting is 001 (HSE selected) and HSE oscillator failure is detected."
            },
            {
                "name": "SWS",
                "bitOffset": 3,
                "bitWidth": 3,
                "desc": "System clock switch status\nThis bitfield is controlled by hardware to indicate the clock source used as system clock:\nOthers: Reserved"
            },
            {
                "name": "HPRE",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "AHB prescaler\nThis bitfield is controlled by software. To produce HCLK clock, it sets the division factor of SYSCLK clock as follows:\n0xxx: 1\nCaution: Depending on the device voltage range, the software has to set correctly these bits to ensure that the system frequency does not exceed the maximum allowed frequency (for more details, refer to Section14.1.4: Dynamic voltage scaling management). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value has been taken into account."
            },
            {
                "name": "PPRE",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "APB prescaler\nThis bitfield is controlled by software. To produce PCLK clock, it sets the division factor of HCLK clock as follows:\n0xx: 1"
            },
            {
                "name": "STOPWUCK",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Wake-up from Stop and CSS backup clock selection\nSet and cleared by software to select the system clock used when exiting Stop mode.\nThe selected clock is also used as emergency clock for the Clock Security System on HSE. Warning: STOPWUCK must not be modified when the Clock Security System is enabled by HSECSSON in RCC_CR register and the system clock is HSE (SWS=10) or a switch on HSE is requested (SW=10)."
            },
            {
                "name": "MCO2SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Microcontroller clock output 2 clock selector\nThis bitfield is controlled by software. It sets the clock selector for MCO2 output as follows:\nOthers: Reserved\nNote: This clock output may have some truncated cycles at startup or during MCO2 clock source switching."
            },
            {
                "name": "MCO2PRE",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Microcontroller clock output 2 prescaler\nThis bitfield is controlled by software. It sets the division factor of the clock sent to the MCO2 output as follows:\n...\nOthers: reserved\nIt is highly recommended to set this field before the MCO2 output is enabled."
            },
            {
                "name": "MCOSEL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Microcontroller clock output clock selector\nThis bitfield is controlled by software. It sets the clock selector for MCO output as follows:\nOthers: Reserved\nNote: This clock output may have some truncated cycles at startup or during MCO clock source switching."
            },
            {
                "name": "MCOPRE",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Microcontroller clock output prescaler\nThis bitfield is controlled by software. It sets the division factor of the clock sent to the MCO output as follows:\n...\nOthers: reserved\nIt is highly recommended to set this field before the MCO output is enabled."
            }
        ]
    },
    "1073877004": {
        "name": "RCC_PLLCFGR",
        "address": 1073877004,
        "size": 32,
        "access": "",
        "desc": "PLL configuration register",
        "fields": [
            {
                "name": "PLLSRC",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "PLL input clock source\nThis bit is controlled by software to select PLL clock source, as follows:\nThe bitfield can be written only when the PLL is disabled.\nWhen the PLL is not used, selecting 00 allows saving power."
            },
            {
                "name": "PLLM",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Division factor M of the PLL input clock divider\nThis bit is controlled by software to divide the PLL input clock before the actual phase-locked loop, as follows:\nThe bitfield can be written only when the PLL is disabled.\nCaution: The software must set these bits so that the PLL input frequency after the /M divider is between 2.66 and 161MHz."
            },
            {
                "name": "PLLN",
                "bitOffset": 8,
                "bitWidth": 7,
                "desc": "PLL frequency multiplication factor N\nThis bit is controlled by software to set the division factor of the f<sub>VCO</sub> feedback divider (that determines the PLL multiplication ratio) as follows:\n...\n...\nThe bitfield can be written only when the PLL is disabled.\nCaution: The software must set these bits so that the VCO output frequency is between 96 and 3441MHz."
            },
            {
                "name": "PLLPEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "PLLPCLK clock output enable\nThis bit is controlled by software to enable/disable the PLLPCLK clock output of the PLL:\nDisabling the PLLPCLK clock output, when not used, allows saving power."
            },
            {
                "name": "PLLP",
                "bitOffset": 17,
                "bitWidth": 5,
                "desc": "PLL VCO division factor P for PLLPCLK clock output\nThis bitfield is controlled by software. It sets the PLL VCO division factor P as follows:\n...\nThe bitfield can be written only when the PLL is disabled.\nCaution: The software must set this bitfield so as not to exceed 541MHz on this clock."
            },
            {
                "name": "PLLQEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "PLLQCLK clock output enable\nThis bit is controlled by software to enable/disable the PLLQCLK clock output of the PLL:\nDisabling the PLLQCLK clock output, when not used, allows saving power."
            },
            {
                "name": "PLLQ",
                "bitOffset": 25,
                "bitWidth": 3,
                "desc": "PLL VCO division factor Q for PLLQCLK clock output\nThis bitfield is controlled by software. It sets the PLL VCO division factor Q as follows:\nThe bitfield can be written only when the PLL is disabled.\nCaution: The software must set this bitfield so as not to exceed 541MHz on this clock."
            },
            {
                "name": "PLLREN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "PLLRCLK clock output enable\nThis bit is controlled by software to enable/disable the PLLRCLK clock output of the PLL:\nThis bit cannot be written when PLLRCLK output of the PLL is selected for system clock.\nDisabling the PLLRCLK clock output, when not used, allows saving power."
            },
            {
                "name": "PLLR",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "PLL VCO division factor R for PLLRCLK clock output\nThis bitfield is controlled by software. It sets the PLL VCO division factor R as follows:\nThe bitfield can be written only when the PLL is disabled.\nThe PLLRCLK clock can be selected as system clock.\nCaution: The software must set this bitfield so as not to exceed 122MHz on this clock."
            }
        ]
    },
    "1073877016": {
        "name": "RCC_CIER",
        "address": 1073877016,
        "size": 32,
        "access": "",
        "desc": "Clock interrupt enable register",
        "fields": [
            {
                "name": "LSIRDYIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization:"
            },
            {
                "name": "LSERDYIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization:"
            },
            {
                "name": "MSIRDYIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "MSI ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the MSI oscillator stabilization."
            },
            {
                "name": "HSIRDYIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI16 ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization:"
            },
            {
                "name": "HSERDYIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization:"
            },
            {
                "name": "PLLRDYIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "PLL ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by PLL lock:"
            },
            {
                "name": "LSECSSIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "LSE clock security system interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the clock security system on LSE."
            },
            {
                "name": "HSI48RDYIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "HSI48 ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the internal HSI48 oscillator."
            }
        ]
    },
    "1073877020": {
        "name": "RCC_CIFR",
        "address": 1073877020,
        "size": 32,
        "access": "",
        "desc": "Clock interrupt flag register",
        "fields": [
            {
                "name": "LSIRDYF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI ready interrupt flag\nSet by hardware when the LSI clock becomes stable and LSIRDYDIE is set.\nCleared by software setting the LSIRDYC bit."
            },
            {
                "name": "LSERDYF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt flag\nSet by hardware when the LSE clock becomes stable and LSERDYDIE is set.\nCleared by software setting the LSERDYC bit."
            },
            {
                "name": "MSIRDYF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "MSI ready interrupt flag\nSet by hardware when the MSI clock becomes stable and MSIRDYDIE is set.\nCleared by software setting the MSIRDYC bit."
            },
            {
                "name": "HSIRDYF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI16 ready interrupt flag\nSet by hardware when the HSI16 clock becomes stable and HSIRDYIE is set in a response to setting the HSION (refer to Clock control register (RCC_CR)). When HSION is not set but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated.\nCleared by software setting the HSIRDYC bit."
            },
            {
                "name": "HSERDYF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE ready interrupt flag\nSet by hardware when the HSE clock becomes stable and HSERDYIE is set.\nCleared by software setting the HSERDYC bit."
            },
            {
                "name": "PLLRDYF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "PLL ready interrupt flag\nSet by hardware when the PLL locks and PLLRDYIE is set.\nCleared by software setting the PLLRDYC bit."
            },
            {
                "name": "CSSF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "HSE clock security system interrupt flag\nSet by hardware when a failure is detected in the HSE oscillator.\nCleared by software setting the CSSC bit."
            },
            {
                "name": "LSECSSF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "LSE clock security system interrupt flag\nSet by hardware when a failure is detected in the LSE oscillator.\nCleared by software by setting the LSECSSC bit."
            },
            {
                "name": "HSI48RDYF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "HSI48 ready interrupt flag\nSet by hardware when the HSI48 clock becomes stable and HSI48RDYIE is set in a response to setting the HSI48ON (refer to RCC clock recovery RC register (RCC_CRRCR)).\nCleared by software setting the HSI48RDYC bit."
            }
        ]
    },
    "1073877024": {
        "name": "RCC_CICR",
        "address": 1073877024,
        "size": 32,
        "access": "",
        "desc": "Clock interrupt clear register",
        "fields": [
            {
                "name": "LSIRDYC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI ready interrupt clear\nThis bit is set by software to clear the LSIRDYF flag."
            },
            {
                "name": "LSERDYC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt clear\nThis bit is set by software to clear the LSERDYF flag."
            },
            {
                "name": "MSIRDYC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "MSI ready interrupt clear\nThis bit is set by software to clear the MSIRDYF flag."
            },
            {
                "name": "HSIRDYC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI16 ready interrupt clear\nThis bit is set software to clear the HSIRDYF flag."
            },
            {
                "name": "HSERDYC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE ready interrupt clear\nThis bit is set by software to clear the HSERDYF flag."
            },
            {
                "name": "PLLRDYC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "PLL ready interrupt clear\nThis bit is set by software to clear the PLLRDYF flag."
            },
            {
                "name": "CSSC",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Clock security system interrupt clear\nThis bit is set by software to clear the HSECSSF flag."
            },
            {
                "name": "LSECSSC",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "LSE Clock security system interrupt clear\nThis bit is set by software to clear the LSECSSF flag."
            },
            {
                "name": "HSI48RDYC",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "HSI48 oscillator ready interrupt clear\nThis bit is set by software to clear the HSI48RDYF flag."
            }
        ]
    },
    "1073877032": {
        "name": "RCC_AHBRSTR",
        "address": 1073877032,
        "size": 32,
        "access": "",
        "desc": "AHB peripheral reset register",
        "fields": [
            {
                "name": "DMA1RST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMA1 and DMAMUX reset\nSet and cleared by software."
            },
            {
                "name": "DMA2RST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DMA2 and DMAMUX reset\nSet and cleared by software."
            },
            {
                "name": "FLASHRST",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Flash memory interface reset\nSet and cleared by software.\nThis bit can only be set when the flash memory is in power down mode."
            },
            {
                "name": "CRCRST",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC reset\nSet and cleared by software."
            },
            {
                "name": "AESRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "AES hardware accelerator reset\nSet and cleared by software."
            },
            {
                "name": "RNGRST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Random number generator reset\nSet and cleared by software."
            },
            {
                "name": "TSCRST",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Touch sensing controller reset\nSet and cleared by software."
            }
        ]
    },
    "1073877036": {
        "name": "RCC_IOPRSTR",
        "address": 1073877036,
        "size": 32,
        "access": "",
        "desc": "I/O port reset register",
        "fields": [
            {
                "name": "GPIOARST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I/O port A reset\nThis bit is set and cleared by software."
            },
            {
                "name": "GPIOBRST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "I/O port B reset\nThis bit is set and cleared by software."
            },
            {
                "name": "GPIOCRST",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "I/O port C reset\nThis bit is set and cleared by software."
            },
            {
                "name": "GPIODRST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "I/O port D reset\nThis bit is set and cleared by software."
            },
            {
                "name": "GPIOERST",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "I/O port E reset\nThis bit is set and cleared by software."
            },
            {
                "name": "GPIOFRST",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "I/O port F reset\nThis bit is set and cleared by software."
            }
        ]
    },
    "1073877048": {
        "name": "RCC_APBRSTR1",
        "address": 1073877048,
        "size": 32,
        "access": "",
        "desc": "APB peripheral reset register 1",
        "fields": [
            {
                "name": "TIM2RST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 timer reset\nSet and cleared by software."
            },
            {
                "name": "TIM3RST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 timer reset\nSet and cleared by software."
            },
            {
                "name": "TIM6RST",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 timer reset\nSet and cleared by software."
            },
            {
                "name": "TIM7RST",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 timer reset\nSet and cleared by software."
            },
            {
                "name": "LPUART2RST",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPUART2 reset\nSet and cleared by software."
            },
            {
                "name": "LCDRST",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "LCD reset<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "LPUART3RST",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "LPUART3 reset<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "USBRST",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "USB reset<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "SPI2RST",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SPI2 reset\nSet and cleared by software."
            },
            {
                "name": "SPI3RST",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SPI3 reset<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "CRSRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CRS reset<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "USART2RST",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 reset\nSet and cleared by software."
            },
            {
                "name": "USART3RST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "USART3 reset\nSet and cleared by software."
            },
            {
                "name": "USART4RST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "USART4 reset\nSet and cleared by software."
            },
            {
                "name": "LPUART1RST",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "LPUART1 reset\nSet and cleared by software."
            },
            {
                "name": "I2C1RST",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 reset\nSet and cleared by software."
            },
            {
                "name": "I2C2RST",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C2 reset\nSet and cleared by software."
            },
            {
                "name": "I2C3RST",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "I2C3 reset\nSet and cleared by software."
            },
            {
                "name": "OPAMPRST",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "OPAMP reset\nSet and cleared by software."
            },
            {
                "name": "I2C4RST",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "I2C4 reset<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "LPTIM3RST",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "LPTIM3 reset\nSet and cleared by software."
            },
            {
                "name": "PWRRST",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Power interface reset\nSet and cleared by software."
            },
            {
                "name": "DAC1RST",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "DAC1 interface reset\nSet and cleared by software."
            },
            {
                "name": "LPTIM2RST",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Low Power Timer 2 reset\nSet and cleared by software."
            },
            {
                "name": "LPTIM1RST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Low Power Timer 1 reset\nSet and cleared by software."
            }
        ]
    },
    "1073877056": {
        "name": "RCC_APBRSTR2",
        "address": 1073877056,
        "size": 32,
        "access": "",
        "desc": "APB peripheral reset register 2",
        "fields": [
            {
                "name": "SYSCFGRST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYSCFG, COMP and VREFBUF reset\nSet and cleared by software."
            },
            {
                "name": "TIM1RST",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 timer reset\nSet and cleared by software."
            },
            {
                "name": "SPI1RST",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 reset\nSet and cleared by software."
            },
            {
                "name": "USART1RST",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 reset\nSet and cleared by software."
            },
            {
                "name": "TIM15RST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "TIM15 timer reset\nSet and cleared by software."
            },
            {
                "name": "TIM16RST",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 timer reset\nSet and cleared by software."
            },
            {
                "name": "ADCRST",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "ADC reset\nSet and cleared by software."
            }
        ]
    },
    "1073877064": {
        "name": "RCC_AHBENR",
        "address": 1073877064,
        "size": 32,
        "access": "",
        "desc": "AHB peripheral clock enable register",
        "fields": [
            {
                "name": "DMA1EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMA1 and DMAMUX clock enable\nSet and cleared by software.\nDMAMUX is enabled as long as at least one DMA peripheral is enabled."
            },
            {
                "name": "DMA2EN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DMA2 and DMAMUX clock enable\nSet and cleared by software.\nDMAMUX is enabled as long as at least one DMA peripheral is enabled."
            },
            {
                "name": "FLASHEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Flash memory interface clock enable\nSet and cleared by software.\nThis bit can only be cleared when the flash memory is in power down mode."
            },
            {
                "name": "CRCEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC clock enable\nSet and cleared by software."
            },
            {
                "name": "AESEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "AES hardware accelerator\nSet and cleared by software."
            },
            {
                "name": "RNGEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Random number generator clock enable\nSet and cleared by software."
            },
            {
                "name": "TSCEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Touch sensing controller clock enable\nSet and cleared by software."
            }
        ]
    },
    "1073877068": {
        "name": "RCC_IOPENR",
        "address": 1073877068,
        "size": 32,
        "access": "",
        "desc": "I/O port clock enable register",
        "fields": [
            {
                "name": "GPIOAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I/O port A clock enable\nThis bit is set and cleared by software."
            },
            {
                "name": "GPIOBEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "I/O port B clock enable\nThis bit is set and cleared by software."
            },
            {
                "name": "GPIOCEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "I/O port C clock enable\nThis bit is set and cleared by software."
            },
            {
                "name": "GPIODEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "I/O port D clock enable\nThis bit is set and cleared by software."
            },
            {
                "name": "GPIOEEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "I/O port E clock enable<sup>(1)</sup>\nThis bit is set and cleared by software."
            },
            {
                "name": "GPIOFEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "I/O port F clock enable\nThis bit is set and cleared by software."
            }
        ]
    },
    "1073877072": {
        "name": "RCC_DBGCFGR",
        "address": 1073877072,
        "size": 32,
        "access": "",
        "desc": "Debug configuration register",
        "fields": [
            {
                "name": "DBGEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Debug support clock enable\nSet and cleared by software."
            },
            {
                "name": "DBGRST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Debug support reset\nSet and cleared by software."
            }
        ]
    },
    "1073877080": {
        "name": "RCC_APBENR1",
        "address": 1073877080,
        "size": 32,
        "access": "",
        "desc": "APB peripheral clock enable register 1",
        "fields": [
            {
                "name": "TIM2EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 timer clock enable\nSet and cleared by software."
            },
            {
                "name": "TIM3EN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 timer clock enable\nSet and cleared by software."
            },
            {
                "name": "TIM6EN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 timer clock enable\nSet and cleared by software."
            },
            {
                "name": "TIM7EN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 timer clock enable\nSet and cleared by software."
            },
            {
                "name": "LPUART2EN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPUART2 clock enable\nSet and cleared by software."
            },
            {
                "name": "LCDEN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "LCD clock enable<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "RTCAPBEN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "RTC APB clock enable\nSet and cleared by software."
            },
            {
                "name": "WWDGEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "WWDG clock enable\nSet by software to enable the window watchdog clock. Cleared by hardware system reset\nThis bit can also be set by hardware if the WWDG_SW option bit is 0."
            },
            {
                "name": "LPUART3EN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "LPUART3 clock enable\nSet and cleared by software."
            },
            {
                "name": "USBEN",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "USB clock enable<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "SPI2EN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SPI2 clock enable\nSet and cleared by software."
            },
            {
                "name": "SPI3EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SPI3 clock enable<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "CRSEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CRS clock enable<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "USART2EN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 clock enable\nSet and cleared by software."
            },
            {
                "name": "USART3EN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "USART3 clock enable\nSet and cleared by software."
            },
            {
                "name": "USART4EN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "USART4 clock enable\nSet and cleared by software."
            },
            {
                "name": "LPUART1EN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "LPUART1 clock enable\nSet and cleared by software."
            },
            {
                "name": "I2C1EN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 clock enable\nSet and cleared by software."
            },
            {
                "name": "I2C2EN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C2 clock enable\nSet and cleared by software."
            },
            {
                "name": "I2C3EN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "I2C3 clock enable\nSet and cleared by software."
            },
            {
                "name": "OPAMPEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "OPAMP clock enable\nSet and cleared by software."
            },
            {
                "name": "I2C4EN",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "I2C4EN clock enable<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "LPTIM3EN",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "LPTIM3 clock enable\nSet and cleared by software."
            },
            {
                "name": "PWREN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Power interface clock enable\nSet and cleared by software."
            },
            {
                "name": "DAC1EN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "DAC1 interface clock enable\nSet and cleared by software."
            },
            {
                "name": "LPTIM2EN",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "LPTIM2 clock enable\nSet and cleared by software."
            },
            {
                "name": "LPTIM1EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "LPTIM1 clock enable\nSet and cleared by software."
            }
        ]
    },
    "1073877088": {
        "name": "RCC_APBENR2",
        "address": 1073877088,
        "size": 32,
        "access": "",
        "desc": "APB peripheral clock enable register 2",
        "fields": [
            {
                "name": "SYSCFGEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYSCFG, COMP and VREFBUF clock enable\nSet and cleared by software."
            },
            {
                "name": "TIM1EN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 timer clock enable\nSet and cleared by software."
            },
            {
                "name": "SPI1EN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 clock enable\nSet and cleared by software."
            },
            {
                "name": "USART1EN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 clock enable\nSet and cleared by software."
            },
            {
                "name": "TIM15EN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "TIM15 timer clock enable\nSet and cleared by software."
            },
            {
                "name": "TIM16EN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 timer clock enable\nSet and cleared by software."
            },
            {
                "name": "ADCEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "ADC clock enable\nSet and cleared by software."
            }
        ]
    },
    "1073877096": {
        "name": "RCC_AHBSMENR",
        "address": 1073877096,
        "size": 32,
        "access": "",
        "desc": "AHB peripheral clock enable in Sleep/Stop mode register",
        "fields": [
            {
                "name": "DMA1SMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMA1 and DMAMUX clock enable during Sleep mode\nSet and cleared by software.\nClock to DMAMUX during Sleep mode is enabled as long as the clock in Sleep mode is enabled to at least one DMA peripheral."
            },
            {
                "name": "DMA2SMEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DMA2 and DMAMUX clock enable during Sleep mode\nSet and cleared by software.\nClock to DMAMUX during Sleep mode is enabled as long as the clock in Sleep mode is enabled to at least one DMA peripheral."
            },
            {
                "name": "FLASHSMEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Flash memory interface clock enable during Sleep mode\nSet and cleared by software.\nThis bit can be activated only when the flash memory is in power down mode."
            },
            {
                "name": "SRAMSMEN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "SRAM clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "CRCSMEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "AESSMEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "AES hardware accelerator clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "RNGSMEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "RNG clock enable during Sleep and Stop mode\nSet and cleared by software."
            },
            {
                "name": "TSCSMEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "TSC clock enable during Sleep and Stop mode\nSet and cleared by software."
            }
        ]
    },
    "1073877100": {
        "name": "RCC_IOPSMENR",
        "address": 1073877100,
        "size": 32,
        "access": "",
        "desc": "I/O port in Sleep mode clock enable register",
        "fields": [
            {
                "name": "GPIOASMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I/O port A clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "GPIOBSMEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "I/O port B clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "GPIOCSMEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "I/O port C clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "GPIODSMEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "I/O port D clock enable during Sleep mode<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "GPIOESMEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "I/O port E clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "GPIOFSMEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "I/O port F clock enable during Sleep mode\nSet and cleared by software."
            }
        ]
    },
    "1073877112": {
        "name": "RCC_APBSMENR1",
        "address": 1073877112,
        "size": 32,
        "access": "",
        "desc": "APB peripheral clock enable in Sleep/Stop mode register 1",
        "fields": [
            {
                "name": "TIM2SMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 timer clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "TIM3SMEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 timer clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "TIM6SMEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 timer clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "TIM7SMEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 timer clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "LPUART2SMEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPUART2 clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "LCDSMEN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "LCD clock enable during Sleep mode<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "RTCAPBSMEN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "RTC APB clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "WWDGSMEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "WWDG clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "LPUART3SMEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "LPUART3 clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "USBSMEN",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "USB clock enable during Sleep mode<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "SPI2SMEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SPI2 clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "SPI3SMEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SPI3 clock enable during Sleep mode<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "CRSSMEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CRS clock enable during Sleep and Stop modes<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "USART2SMEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "USART3SMEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "USART3 clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "USART4SMEN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "USART4 clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "LPUART1SMEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "LPUART1 clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "I2C1SMEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "I2C2SMEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C2 clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "I2C3SMEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "I2C3 clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "OPAMPSMEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "OPAMP clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "I2C4SMEN",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "I2C4 clock enable during Sleep mode<sup>(1)</sup>\nSet and cleared by software."
            },
            {
                "name": "LPTIM3SMEN",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Low power timer 3 clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "PWRSMEN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Power interface clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "DAC1SMEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "DAC1 interface clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "LPTIM2SMEN",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Low Power Timer 2 clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "LPTIM1SMEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Low Power Timer 1 clock enable during Sleep and Stop modes\nSet and cleared by software."
            }
        ]
    },
    "1073877120": {
        "name": "RCC_APBSMENR2",
        "address": 1073877120,
        "size": 32,
        "access": "",
        "desc": "APB peripheral clock enable in Sleep/Stop mode register 2",
        "fields": [
            {
                "name": "SYSCFGSMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYSCFG, COMP and VREFBUF clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "TIM1SMEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 timer clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "SPI1SMEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "USART1SMEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 clock enable during Sleep and Stop modes\nSet and cleared by software."
            },
            {
                "name": "TIM15SMEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "TIM15 timer clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "TIM16SMEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 timer clock enable during Sleep mode\nSet and cleared by software."
            },
            {
                "name": "ADCSMEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "ADC clock enable during Sleep mode\nSet and cleared by software."
            }
        ]
    },
    "1073877128": {
        "name": "RCC_CCIPR",
        "address": 1073877128,
        "size": 32,
        "access": "",
        "desc": "Peripherals independent clock configuration register",
        "fields": [
            {
                "name": "USART1SEL",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "USART1 clock source selection\nThis bitfield is controlled by software to select USART1 clock source as follows:"
            },
            {
                "name": "USART2SEL",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "USART2 clock source selection\nThis bitfield is controlled by software to select USART2 clock source as follows:"
            },
            {
                "name": "LPUART3SEL",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "LPUART3 clock source selection<sup>(1)</sup>\nThis bitfield is controlled by software to select LPUART3 clock source as follows:"
            },
            {
                "name": "LPUART2SEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "LPUART2 clock source selection\nThis bitfield is controlled by software to select LPUART2 clock source as follows:"
            },
            {
                "name": "LPUART1SEL",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "LPUART1 clock source selection\nThis bitfield is controlled by software to select LPUART1 clock source as follows:"
            },
            {
                "name": "I2C1SEL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "I2C1 clock source selection\nThis bitfield is controlled by software to select I2C1 clock source as follows:"
            },
            {
                "name": "I2C3SEL",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "I2C3 clock source selection\nThis bitfield is controlled by software to select I2C3 clock source as follows:"
            },
            {
                "name": "LPTIM1SEL",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "LPTIM1 clock source selection\nThis bitfield is controlled by software to select LPTIM1 clock source as follows:"
            },
            {
                "name": "LPTIM2SEL",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "LPTIM2 clock source selection\nThis bitfield is controlled by software to select LPTIM2 clock source as follows:"
            },
            {
                "name": "LPTIM3SEL",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "LPTIM3 clock source selection\nThis bitfield is controlled by software to select LPTIM3 clock source as follows:"
            },
            {
                "name": "TIM1SEL",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "TIM1 clock source selection\nThis bit is set and cleared by software. It selects TIM1 clock source as follows:"
            },
            {
                "name": "TIM15SEL",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "TIM15 clock source selection\nThis bit is set and cleared by software. It selects TIM15 clock source as follows:"
            },
            {
                "name": "CLK48SEL",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "481MHz clock source selection\nThis bitfield is controlled by software to select the 481MHz clock source used by the USB FS and the RNG:"
            },
            {
                "name": "ADCSEL",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "ADCs clock source selection\nThis bitfield is controlled by software to select the clock source for ADC:"
            }
        ]
    },
    "1073877136": {
        "name": "RCC_BDCR",
        "address": 1073877136,
        "size": 32,
        "access": "",
        "desc": "RTC domain control register",
        "fields": [
            {
                "name": "LSEON",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSE oscillator enable\nSet and cleared by software to enable LSE oscillator:"
            },
            {
                "name": "LSERDY",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE oscillator ready\nSet and cleared by hardware to indicate when the external 321kHz oscillator is ready (stable):\nAfter the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles."
            },
            {
                "name": "LSEBYP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "LSE oscillator bypass\nSet and cleared by software to bypass the LSE oscillator (in debug mode).\nThis bit can be written only when the external 321kHz oscillator is disabled (LSEON=0 and LSERDY=0)."
            },
            {
                "name": "LSEDRV",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "LSE oscillator drive capability\nSet by software to select the LSE oscillator drive capability as follows:\nApplicable when the LSE oscillator is in Xtal mode, as opposed to bypass mode."
            },
            {
                "name": "LSECSSON",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CSS on LSE enable\nSet by software to enable the clock security system on LSE (321kHz) oscillator as follows:\nLSECSSON must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware), and after the RTCSEL bit is selected.\nOnce enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD\n=1). In that case the software must disable the LSECSSON bit."
            },
            {
                "name": "LSECSSD",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CSS on LSE failure Detection\nSet by hardware to indicate when a failure is detected by the clock security system\non the external 321kHz oscillator (LSE):"
            },
            {
                "name": "LSESYSEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LSE clock enable for system usage\nThis bit must be set by software to enable the LSE clock for a system usage."
            },
            {
                "name": "RTCSEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "RTC clock source selection\nSet by software to select the clock source for the RTC as follows:\nOnce the RTC clock source is selected, it cannot be changed anymore unless the RTC domain is reset, or unless a failure is detected on LSE (LSECSSD is set). The BDRST bit can be used to reset this bitfield to 00."
            },
            {
                "name": "LSESYSRDY",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "LSE clock ready for system usage\nThis flag is set by hardware to indicate that the LSE clock is ready for being used by the system (see LSESYSEN bit). This flag is set when LSE clock is ready (LSEON1=11 and LSERDY1=11) and two LSE clock cycles after that LSESYSEN is set.\nCleared by hardware to indicate that the LSE clock is not ready to be used by the system."
            },
            {
                "name": "RTCEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "RTC clock enable\nSet and cleared by software. The bit enables clock to RTC and TAMP."
            },
            {
                "name": "BDRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "RTC domain software reset\nSet and cleared by software to reset the RTC domain:"
            },
            {
                "name": "LSCOEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low-speed clock output (LSCO) enable\nSet and cleared by software."
            },
            {
                "name": "LSCOSEL",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Low-speed clock output selection\nSet and cleared by software to select the low-speed output clock:"
            }
        ]
    },
    "1073877140": {
        "name": "RCC_CSR",
        "address": 1073877140,
        "size": 32,
        "access": "",
        "desc": "Control/status register",
        "fields": [
            {
                "name": "LSION",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI oscillator enable\nSet and cleared by software to enable/disable the LSI oscillator:"
            },
            {
                "name": "LSIRDY",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSI oscillator ready\nSet and cleared by hardware to indicate when the LSI oscillator is ready (stable):\nAfter the LSION bit is cleared, LSIRDY goes low after 3 LSI oscillator clock cycles. This bit can be set even if LSION = 0 if the LSI is requested by the Clock Security System on LSE, by the Independent Watchdog or by the RTC."
            },
            {
                "name": "LSIPREDIV",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Internal low-speed oscillator pre-divided by 128\nSet and reset by hardware to indicate when the low-speed internal RC oscillator has to be divided by 128. The software has to switch off the LSI before changing this bit."
            },
            {
                "name": "MSISRANGE",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "MSI range after Standby mode\nSet by software to chose the MSI frequency at startup. This range is used after exiting Standby mode until MSIRGSEL is set. After a pad or a power-on reset, the range is always 41MHz. MSISRANGE[3:0] can be written only when MSIRGSEL1=11.\nOthers: Reserved\nNote: Changing the MSISRANGE[3:0] does not change the current MSI frequency."
            },
            {
                "name": "RMVF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Remove reset flags\nSet by software to clear the reset flags."
            },
            {
                "name": "OBLRSTF",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Option byte loader reset flag\nSet by hardware when a reset from the Option byte loading occurs.\nCleared by setting the RMVF bit."
            },
            {
                "name": "PINRSTF",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Pin reset flag\nSet by hardware when a reset from the NRST pin occurs.\nCleared by setting the RMVF bit."
            },
            {
                "name": "PWRRSTF",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "BOR or POR/PDR flag\nSet by hardware when a BOR or POR/PDR occurs.\nCleared by setting the RMVF bit."
            },
            {
                "name": "SFTRSTF",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Software reset flag\nSet by hardware when a software reset occurs.\nCleared by setting the RMVF bit."
            },
            {
                "name": "IWDGRSTF",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Independent window watchdog reset flag\nSet by hardware when an independent watchdog reset domain occurs.\nCleared by setting the RMVF bit."
            },
            {
                "name": "WWDGRSTF",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Window watchdog reset flag\nSet by hardware when a window watchdog reset occurs.\nCleared by setting the RMVF bit."
            },
            {
                "name": "LPWRRSTF",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Low-power reset flag\nSet by hardware when a reset occurs due to illegal Stop, Standby, or Shutdown mode entry.\nCleared by setting the RMVF bit.\nThis operates only if nRST_STOP, nRST_STDBY or nRST_SHDW option bits are cleared."
            }
        ]
    },
    "1073877144": {
        "name": "RCC_CRRCR",
        "address": 1073877144,
        "size": 32,
        "access": "",
        "desc": "RCC clock recovery RC register",
        "fields": [
            {
                "name": "HSI48ON",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "HSI48 RC oscillator enable<sup>(1)</sup>"
            },
            {
                "name": "HSI48RDY",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "HSI48 clock ready flag<sup>(1)</sup>\nThe flag is set when the HSI48 clock is ready for use."
            },
            {
                "name": "HSI48CAL",
                "bitOffset": 7,
                "bitWidth": 9,
                "desc": "HSI48 clock calibration\nThese bits are initialized at startup with the factory-programmed HSI48 calibration trim value."
            }
        ]
    },
    "1073893376": {
        "name": "RNG_CR",
        "address": 1073893376,
        "size": 32,
        "access": "",
        "desc": "RNG control register",
        "fields": [
            {
                "name": "RNGEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "True random number generator enable"
            },
            {
                "name": "IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Interrupt enable"
            },
            {
                "name": "CED",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clock error detection\nThe clock error detection cannot be enabled nor disabled on-the-fly when the RNG is enabled, that is to enable or disable CED, the RNG must be disabled.\nWriting this bit is taken into account only if the CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11."
            },
            {
                "name": "ARDIS",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto reset disable\nWhen auto-reset is enabled the application still need to clear the SEIS bit after a noise source error.\nWriting this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11."
            },
            {
                "name": "RNG_CONFIG3",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "RNG configuration 3\nReserved to the RNG configuration (bitfield 3). Refer to RNG_CONFIG1 bitfield for details.\nIf the NISTC bit is cleared in this register RNG_CONFIG3 bitfield values are ignored by RNG."
            },
            {
                "name": "NISTC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "NIST custom\ntwo conditioning loops are performed and 256 bits of noise source are used.\nWriting this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11."
            },
            {
                "name": "RNG_CONFIG2",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "RNG configuration 2\nReserved to the RNG configuration (bitfield 2). Bit 13 can be set when RNG power consumption is critical. See Section120.3.8: RNG low-power use. Refer to the RNG_CONFIG1 bitfield for details."
            },
            {
                "name": "CLKDIV",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Clock divider factor\nThis value used to configure an internal programmable divider (from 1 to 16) acting on the incoming RNG clock. These bits can be written only when the core is disabled (RNGEN1=10).\n...\nWriting these bits is taken into account only if the CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11."
            },
            {
                "name": "RNG_CONFIG1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "RNG configuration 1\nReserved to the RNG configuration (bitfield 1). Must be initialized using the recommended value documented in Section120.6: RNG entropy source validation.\nWriting any bit of RNG_CONFIG1 is taken into account only if the CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK1=11."
            },
            {
                "name": "CONDRST",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Conditioning soft reset\nWrite 1 and then write 0 to reset the conditioning logic, clear all the FIFOs and start a new RNG initialization process, with RNG_SR cleared. Registers RNG_CR and RNG_HTCR are not changed by CONDRST.\nThis bit must be set to 1 in the same access that set any configuration bits [29:4]. In other words, when CONDRST bit is set to 1 correct configuration in bits [29:4] must also be written.\nWhen CONDRST is set to 0 by the software, its value goes to 0 when the reset process is done. It takes about 2 AHB clock cycles + 2 RNG clock cycles."
            },
            {
                "name": "CONFIGLOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RNG Config lock\nThis bitfield is set once: if this bit is set it can only be reset to 0 if RNG is reset."
            }
        ]
    },
    "1073893380": {
        "name": "RNG_SR",
        "address": 1073893380,
        "size": 32,
        "access": "",
        "desc": "RNG status register",
        "fields": [
            {
                "name": "DRDY",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Data ready\nOnce the output buffer becomes empty (after reading the RNG_DR register), this bit returns to 0 until a new random value is generated.\nNote: The DRDY bit can rise when the peripheral is disabled (RNGEN1=10 in the RNG_CR register).\nIf IE=1 in the RNG_CR register, an interrupt is generated when DRDY1=11."
            },
            {
                "name": "CECS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clock error current status\nNote: CECS bit is valid only if the CED bit in the RNG_CR register is set to 0."
            },
            {
                "name": "SECS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Seed error current status\nRuntime repetition count test failed (noise source has provided more than 24 consecutive bits at a constant value 0 or 1, or more than 32 consecutive occurrence of two bits patterns 01 or 10)\nStartup or continuous adaptive proportion test on noise source failed.\nStartup post-processing/conditioning sanity check failed."
            },
            {
                "name": "CEIS",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clock error interrupt status\nThis bit is set at the same time as CECS. It is cleared by writing 0. Writing 1 has no effect.\nAn interrupt is pending if IE = 1 in the RNG_CR register."
            },
            {
                "name": "SEIS",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Seed error interrupt status\nThis bit is set at the same time as SECS. It is cleared by writing 0 (unless CONDRST is used). Writing 1 has no effect.\nAn interrupt is pending if IE = 1 in the RNG_CR register."
            }
        ]
    },
    "1073893384": {
        "name": "RNG_DR",
        "address": 1073893384,
        "size": 32,
        "access": "",
        "desc": "RNG data register",
        "fields": [
            {
                "name": "RNDATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Random data\n32-bit random data, which are valid when DRDY1=11. When DRDY1=10, the RNDATA value is1zero.\nWhen DRDY is set, it is recommended to always verify that RNG_DR is different from zero. Because when it is the case a seed error occurred between RNG_SR polling and RND_DR output reading (rare event)."
            }
        ]
    },
    "1073893392": {
        "name": "RNG_HTCR",
        "address": 1073893392,
        "size": 32,
        "access": "",
        "desc": "RNG health test control register",
        "fields": [
            {
                "name": "HTCFG",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "health test configuration\nThis configuration is used by RNG to configure the health tests. See Section120.6: RNG entropy source validation for the recommended value.\nNote: The RNG behavior, including the read to this register, is not guaranteed if a different value from the recommended value is written."
            }
        ]
    },
    "1073752064": {
        "name": "RTC_TR",
        "address": 1073752064,
        "size": 32,
        "access": "",
        "desc": "RTC time register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format"
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            }
        ]
    },
    "1073752068": {
        "name": "RTC_DR",
        "address": 1073752068,
        "size": 32,
        "access": "",
        "desc": "RTC date register",
        "fields": [
            {
                "name": "DU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Date units in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "MU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Month units in BCD format"
            },
            {
                "name": "MT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Month tens in BCD format"
            },
            {
                "name": "WDU",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Week day units\n..."
            },
            {
                "name": "YU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Year units in BCD format"
            },
            {
                "name": "YT",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Year tens in BCD format"
            }
        ]
    },
    "1073752072": {
        "name": "RTC_SSR",
        "address": 1073752072,
        "size": 32,
        "access": "",
        "desc": "RTC subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Synchronous binary counter\nSS[31:16]: Synchronous binary counter MSB values\nWhen Binary or Mixed mode is selected (BIN = 01 or 10 or 11):\nSS[31:16] are the 16 MSB of the SS[31:0] free-running down-counter.\nWhen BCD mode is selected (BIN=00):\nSS[31:16] are forced by hardware to 0x0000.\nSS[15:0]: Subsecond value/synchronous binary counter LSB values\nWhen Binary mode is selected (BIN = 01 or 10 or 11):\nSS[15:0] are the 16 LSB of the SS[31:0] free-running down-counter.\nWhen BCD mode is selected (BIN=00):\nSS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below:\nSecond fraction = (PREDIV_S - SS) / (PREDIV_S + 1)\nSS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR."
            }
        ]
    },
    "1073752076": {
        "name": "RTC_ICSR",
        "address": 1073752076,
        "size": 32,
        "access": "",
        "desc": "RTC initialization control and status register",
        "fields": [
            {
                "name": "WUTWF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wake-up timer write flag\nThis bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode."
            },
            {
                "name": "SHPF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Shift operation pending\nThis flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect."
            },
            {
                "name": "INITS",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Initialization status flag\nThis bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state)."
            },
            {
                "name": "RSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Registers synchronization flag\nThis bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software.\nIt is cleared either by software or by hardware in initialization mode."
            },
            {
                "name": "INITF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Initialization flag\nWhen this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated."
            },
            {
                "name": "INIT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Initialization mode"
            },
            {
                "name": "BIN",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Binary mode"
            },
            {
                "name": "BCDU",
                "bitOffset": 10,
                "bitWidth": 3,
                "desc": "BCD update (BIN = 10 or 11)\nIn mixed mode when both BCD calendar and binary extended counter are used (BIN = 10 or 11), the calendar second is incremented using the SSR Least Significant Bits."
            },
            {
                "name": "RECALPF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Recalibration pending Flag\nThe RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly."
            }
        ]
    },
    "1073752080": {
        "name": "RTC_PRER",
        "address": 1073752080,
        "size": 32,
        "access": "",
        "desc": "RTC prescaler register",
        "fields": [
            {
                "name": "PREDIV_S",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Synchronous prescaler factor\nThis is the synchronous division factor:\nck_spre frequency = ck_apre frequency/(PREDIV_S+1)"
            },
            {
                "name": "PREDIV_A",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Asynchronous prescaler factor\nThis is the asynchronous division factor:\nck_apre frequency = RTCCLK frequency/(PREDIV_A+1)"
            }
        ]
    },
    "1073752084": {
        "name": "RTC_WUTR",
        "address": 1073752084,
        "size": 32,
        "access": "",
        "desc": "RTC wake-up timer register",
        "fields": [
            {
                "name": "WUT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Wake-up auto-reload value bits\nWhen the wake-up timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]1+11) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register.\nWhen WUCKSEL[2] = 1, the wake-up timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer.\nThe first assertion of WUTF occurs between WUT and (WUT + 2) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden."
            },
            {
                "name": "WUTOCLR",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Wake-up auto-reload output clear value\nWhen WUTOCLR[15:0] is different from 0x0000, WUTF is set by hardware when the auto-reload down-counter reaches 0 and is cleared by hardware when the auto-reload downcounter reaches WUTOCLR[15:0].\nWhen WUTOCLR[15:0] = 0x0000, WUTF is set by hardware when the WUT down-counter\nreaches 0 and is cleared by software."
            }
        ]
    },
    "1073752088": {
        "name": "RTC_CR",
        "address": 1073752088,
        "size": 32,
        "access": "",
        "desc": "RTC control register",
        "fields": [
            {
                "name": "WUCKSEL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "ck_wut wake-up clock selection\n10x: ck_spre (usually 11Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU.\n11x: ck_spre (usually 1 Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU. Furthermore, 2<sup>16</sup> is added to the WUT counter value."
            },
            {
                "name": "TSEDGE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp event active edge\nTSE must be reset when TSEDGE is changed to avoid unwanted TSF setting."
            },
            {
                "name": "REFCKON",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "RTC_REFIN reference clock detection enable (50 or 601Hz)\nNote: BIN must be 0x00 and PREDIV_S must be 0x00FF."
            },
            {
                "name": "BYPSHAD",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Bypass the shadow registers\nNote: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1."
            },
            {
                "name": "FMT",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Hour format"
            },
            {
                "name": "SSRUIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "SSR underflow interrupt enable"
            },
            {
                "name": "ALRAE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Alarm A enable"
            },
            {
                "name": "ALRBE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Alarm B enable"
            },
            {
                "name": "WUTE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Wake-up timer enable\nNote: When the wake-up timer is disabled, wait for WUTWF = 1 before enabling it again."
            },
            {
                "name": "TSE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "timestamp enable"
            },
            {
                "name": "ALRAIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Alarm A interrupt enable"
            },
            {
                "name": "ALRBIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Alarm B interrupt enable"
            },
            {
                "name": "WUTIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Wake-up timer interrupt enable"
            },
            {
                "name": "TSIE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Timestamp interrupt enable"
            },
            {
                "name": "ADD1H",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Add 1 hour (summer time change)\nWhen this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0."
            },
            {
                "name": "SUB1H",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Subtract 1 hour (winter time change)\nWhen this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0.\nSetting this bit has no effect when current hour is 0."
            },
            {
                "name": "BKP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Backup\nThis bit can be written by the user to memorize whether the daylight saving time change has been performed or not."
            },
            {
                "name": "COSEL",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Calibration output selection\nWhen COE = 1, this bit selects which signal is output on CALIB.\nThese frequencies are valid for RTCCLK at 32.7681kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to Section128.3.16: Calibration clock output."
            },
            {
                "name": "POL",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Output polarity\nThis bit is used to configure the polarity of TAMPALRM output."
            },
            {
                "name": "OSEL",
                "bitOffset": 21,
                "bitWidth": 2,
                "desc": "Output selection\nThese bits are used to select the flag to be routed to TAMPALRM output."
            },
            {
                "name": "COE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Calibration output enable\nThis bit enables the CALIB output"
            },
            {
                "name": "ITSE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "timestamp on internal event enable"
            },
            {
                "name": "TAMPTS",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Activate timestamp on tamper detection event\nTAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set up to 3 ck_apre cycles after the tamper flags.\nNote: TAMPTS must be cleared before entering RTC initialization mode."
            },
            {
                "name": "TAMPOE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Tamper detection output enable on TAMPALRM"
            },
            {
                "name": "ALRAFCLR",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Alarm A flag automatic clear"
            },
            {
                "name": "ALRBFCLR",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Alarm B flag automatic clear"
            },
            {
                "name": "TAMPALRM_PU",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "TAMPALRM pull-up enable"
            },
            {
                "name": "TAMPALRM_TYPE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TAMPALRM output type"
            },
            {
                "name": "OUT2EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RTC_OUT2 output enable"
            }
        ]
    },
    "1073752100": {
        "name": "RTC_WPR",
        "address": 1073752100,
        "size": 32,
        "access": "",
        "desc": "RTC write protection register",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Write protection key\nThis byte is written by software.\nReading this byte always returns 0x00.\nRefer to RTC register write protection for a description of how to unlock RTC register write protection."
            }
        ]
    },
    "1073752104": {
        "name": "RTC_CALR",
        "address": 1073752104,
        "size": 32,
        "access": "",
        "desc": "RTC calibration register",
        "fields": [
            {
                "name": "CALM",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Calibration minus\nThe frequency of the calendar is reduced by masking CALM out of 2<sup>20</sup> RTCCLK pulses (321seconds if the input frequency is 327681Hz). This decreases the frequency of the calendar with a resolution of 0.95371ppm.\nTo increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section128.3.14: RTC smooth digital calibration on page1733."
            },
            {
                "name": "LPCAL",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "RTC low-power mode"
            },
            {
                "name": "CALW16",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Use a 16-second calibration cycle period\nWhen CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1.\nNote: CALM[0] is stuck at 0 when CALW16 = 1. Refer to Section128.3.14: RTC smooth digital calibration."
            },
            {
                "name": "CALW8",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Use an 8-second calibration cycle period\nWhen CALW8 is set to 1, the 8-second calibration cycle period is selected.\nNote: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to Section128.3.14: RTC smooth digital calibration."
            },
            {
                "name": "CALP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Increase frequency of RTC by 488.51ppm."
            }
        ]
    },
    "1073752108": {
        "name": "RTC_SHIFTR",
        "address": 1073752108,
        "size": 32,
        "access": "",
        "desc": "RTC shift control register",
        "fields": [
            {
                "name": "SUBFS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Subtract a fraction of a second\nThese bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThe value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by:\nDelay (seconds) = SUBFS / (PREDIV_S + 1)\nA fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by:\nAdvance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))).\nIn mixed BCD-binary mode (BIN=10 or 11), the SUBFS[14:BCDU+8] must be written with 0.\nNote: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time."
            },
            {
                "name": "ADD1S",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Add one second\nThis bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThis function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation."
            }
        ]
    },
    "1073752112": {
        "name": "RTC_TSTR",
        "address": 1073752112,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp time register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format."
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format."
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format."
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format."
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format."
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format."
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            }
        ]
    },
    "1073752116": {
        "name": "RTC_TSDR",
        "address": 1073752116,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp date register",
        "fields": [
            {
                "name": "DU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Date units in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "MU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Month units in BCD format"
            },
            {
                "name": "MT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Month tens in BCD format"
            },
            {
                "name": "WDU",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Week day units"
            }
        ]
    },
    "1073752120": {
        "name": "RTC_TSSSR",
        "address": 1073752120,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Subsecond value/synchronous binary counter values\nSS[31:0] is the value of the synchronous prescaler counter when the timestamp event occurred."
            }
        ]
    },
    "1073752128": {
        "name": "RTC_ALRMAR",
        "address": 1073752128,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format."
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format."
            },
            {
                "name": "MSK1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Alarm A seconds mask"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "MSK2",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Alarm A minutes mask"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            },
            {
                "name": "MSK3",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Alarm A hours mask"
            },
            {
                "name": "DU",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Date units or day in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "WDSEL",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Week day selection"
            },
            {
                "name": "MSK4",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Alarm A date mask"
            }
        ]
    },
    "1073752132": {
        "name": "RTC_ALRMASSR",
        "address": 1073752132,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Subseconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.\nThis field is the mirror of SS[14:0] in the RTC_ALRABINR, and so can also be read or written through RTC_ALRABINR."
            },
            {
                "name": "MASKSS",
                "bitOffset": 24,
                "bitWidth": 6,
                "desc": "Mask the most-significant bits starting at this bit\n...\nFrom 32 to 63: All 32 SS bits are compared and must match to activate alarm.\nNote: In BCD mode (BIN=00) the overflow bits of the synchronous counter (bits 31:15) are never compared. These bits can be different from 0 only after a shift operation."
            },
            {
                "name": "SSCLR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Clear synchronous counter on alarm (Binary mode only)\nNote: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11)."
            }
        ]
    },
    "1073752136": {
        "name": "RTC_ALRMBR",
        "address": 1073752136,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format"
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format"
            },
            {
                "name": "MSK1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Alarm B seconds mask"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "MSK2",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Alarm B minutes mask"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            },
            {
                "name": "MSK3",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Alarm B hours mask"
            },
            {
                "name": "DU",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Date units or day in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "WDSEL",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Week day selection"
            },
            {
                "name": "MSK4",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Alarm B date mask"
            }
        ]
    },
    "1073752140": {
        "name": "RTC_ALRMBSSR",
        "address": 1073752140,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Subseconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.\nThis field is the mirror of SS[14:0] in the RTC_ALRBBINR, and so can also be read or written through RTC_ALRBBINR."
            },
            {
                "name": "MASKSS",
                "bitOffset": 24,
                "bitWidth": 6,
                "desc": "Mask the most-significant bits starting at this bit\n...\nFrom 32 to 63: All 32 SS bits are compared and must match to activate alarm.\nNote: In BCD mode (BIN=00)The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation."
            },
            {
                "name": "SSCLR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Clear synchronous counter on alarm (Binary mode only)\nNote: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11)."
            }
        ]
    },
    "1073752144": {
        "name": "RTC_SR",
        "address": 1073752144,
        "size": 32,
        "access": "",
        "desc": "RTC status register",
        "fields": [
            {
                "name": "ALRAF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR)."
            },
            {
                "name": "ALRBF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR)."
            },
            {
                "name": "WUTF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wake-up timer flag\nThis flag is set by hardware when the wake-up auto-reload counter reaches 0.\nIf WUTOCLR[15:0] is different from 0x0000, WUTF is cleared by hardware when the wake-up auto-reload counter reaches WUTOCLR value.\nIf WUTOCLR[15:0] is 0x0000, WUTF must be cleared by software.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
            },
            {
                "name": "TSF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp flag\nThis flag is set by hardware when a timestamp event occurs.\nIf ITSF flag is set, TSF must be cleared together with ITSF.\nNote: TSF is not set if TAMPTS1=11 and the tamper flag is read during the 3 ck_apre cycles following tamper event. Refer to Timestamp on tamper event for more details."
            },
            {
                "name": "TSOVF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Timestamp overflow flag\nThis flag is set by hardware when a timestamp event occurs while TSF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "ITSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Internal timestamp flag\nThis flag is set by hardware when a timestamp on the internal event occurs."
            },
            {
                "name": "SSRUF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SSR underflow flag\nThis flag is set by hardware when the SSR rolls under 0. SSRUF is not set when SSCLR=1."
            }
        ]
    },
    "1073752148": {
        "name": "RTC_MISR",
        "address": 1073752148,
        "size": 32,
        "access": "",
        "desc": "RTC masked interrupt status register",
        "fields": [
            {
                "name": "ALRAMF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A masked flag\nThis flag is set by hardware when the alarm A interrupt occurs."
            },
            {
                "name": "ALRBMF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B masked flag\nThis flag is set by hardware when the alarm B interrupt occurs."
            },
            {
                "name": "WUTMF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wake-up timer masked flag\nThis flag is set by hardware when the wake-up timer interrupt occurs.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
            },
            {
                "name": "TSMF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp masked flag\nThis flag is set by hardware when a timestamp interrupt occurs.\nIf ITSF flag is set, TSF must be cleared together with ITSF."
            },
            {
                "name": "TSOVMF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Timestamp overflow masked flag\nThis flag is set by hardware when a timestamp interrupt occurs while TSMF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "ITSMF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Internal timestamp masked flag\nThis flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised."
            },
            {
                "name": "SSRUMF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SSR underflow masked flag\nThis flag is set by hardware when the SSR underflow interrupt occurs."
            }
        ]
    },
    "1073752156": {
        "name": "RTC_SCR",
        "address": 1073752156,
        "size": 32,
        "access": "",
        "desc": "RTC status clear register",
        "fields": [
            {
                "name": "CALRAF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear alarm A flag\nWriting 1 in this bit clears the ALRAF bit in the RTC_SR register."
            },
            {
                "name": "CALRBF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear alarm B flag\nWriting 1 in this bit clears the ALRBF bit in the RTC_SR register."
            },
            {
                "name": "CWUTF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear wake-up timer flag\nWriting 1 in this bit clears the WUTF bit in the RTC_SR register."
            },
            {
                "name": "CTSF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear timestamp flag\nWriting 1 in this bit clears the TSF bit in the RTC_SR register.\nIf ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF."
            },
            {
                "name": "CTSOVF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear timestamp overflow flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "CITSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clear internal timestamp flag\nWriting 1 in this bit clears the ITSF bit in the RTC_SR register."
            },
            {
                "name": "CSSRUF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Clear SSR underflow flag\nWriting 1 in this bit clears the SSRUF in the RTC_SR register."
            }
        ]
    },
    "1073752176": {
        "name": "RTC_ALRABINR",
        "address": 1073752176,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A binary mode register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Synchronous counter alarm value in Binary mode\nThis value is compared with the contents of the synchronous counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.\nSS[14:0] is the mirror of SS[14:0] in the RTC_ALRMASSRR, and so can also be read or written through RTC_ALRMASSR."
            }
        ]
    },
    "1073752180": {
        "name": "RTC_ALRBBINR",
        "address": 1073752180,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B binary mode register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Synchronous counter alarm value in Binary mode\nThis value is compared with the contents of the synchronous counter to determine if Alarm Bis to be activated. Only bits 0 up MASKSS-1 are compared.\nSS[14:0] is the mirror of SS[14:0] in the RTC_ALRMBSSRR, and so can also be read or written through RTC_ALRMBSSR."
            }
        ]
    },
    "1073819648": {
        "name": "SPI_CR1",
        "address": 1073819648,
        "size": 22,
        "access": "",
        "desc": "SPI control register 1",
        "fields": [
            {
                "name": "CPHA",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clock phase\nNote: This bit should not be changed when communication is ongoing.\nNote: This bit is not used in SPI TI mode except the case when CRC is applied at TI mode."
            },
            {
                "name": "CPOL",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clock polarity\nNote: This bit should not be changed when communication is ongoing.\nNote: This bit is not used in SPI TI mode except the case when CRC is applied at TI mode."
            },
            {
                "name": "MSTR",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Master selection\nNote: This bit should not be changed when communication is ongoing."
            },
            {
                "name": "BR",
                "bitOffset": 3,
                "bitWidth": 3,
                "desc": "Baud rate control\nNote: These bits should not be changed when communication is ongoing."
            },
            {
                "name": "SPE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SPI enable\nNote: When disabling the SPI, follow the procedure described in Procedure for disabling the SPI on page1954."
            },
            {
                "name": "LSBFIRST",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Frame format\nNote: 1. This bit should not be changed when communication is ongoing.\nNote: 2. This bit is not used in SPI TI mode."
            },
            {
                "name": "SSI",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Internal slave select\nThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the I/O value of the NSS pin is ignored.\nNote: This bit is not used in SPI TI mode."
            },
            {
                "name": "SSM",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Software slave management\nWhen the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit.\nNote: This bit is not used in SPI TI mode."
            },
            {
                "name": "RXONLY",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Receive only mode enabled.\nThis bit enables simplex communication using a single unidirectional line to receive data exclusively. Keep BIDIMODE bit clear when receive only mode is active.This bit is also useful in a multislave system in which this particular slave is not accessed, the output from the accessed slave is not corrupted."
            },
            {
                "name": "CRCL",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CRC length\nThis bit is set and cleared by software to select the CRC length.\nNote: This bit should be written only when SPI is disabled (SPE = 0) for correct operation."
            },
            {
                "name": "CRCNEXT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Transmit CRC next\nNote: This bit has to be written as soon as the last data is written in the SPI_DR register."
            },
            {
                "name": "CRCEN",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Hardware CRC calculation enable\nNote: This bit should be written only when SPI is disabled (SPE = 0) for correct operation."
            },
            {
                "name": "BIDIOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Output enable in bidirectional mode\nThis bit combined with the BIDIMODE bit selects the direction of transfer in bidirectional mode.\nNote: In master mode, the MOSI pin is used and in slave mode, the MISO pin is used."
            },
            {
                "name": "BIDIMODE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Bidirectional data mode enable.\nThis bit enables half-duplex communication using common single bidirectional data line. Keep RXONLY bit clear when bidirectional mode is active."
            }
        ]
    },
    "1073819652": {
        "name": "SPI_CR2",
        "address": 1073819652,
        "size": 22,
        "access": "",
        "desc": "SPI control register 2",
        "fields": [
            {
                "name": "RXDMAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rx buffer DMA enable\nWhen this bit is set, a DMA request is generated whenever the RXNE flag is set."
            },
            {
                "name": "TXDMAEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tx buffer DMA enable\nWhen this bit is set, a DMA request is generated whenever the TXE flag is set."
            },
            {
                "name": "SSOE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "SS output enable\nNote: This bit is not used in SPI TI mode."
            },
            {
                "name": "NSSP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "NSS pulse management\nThis bit is used in master mode only. it allows the SPI to generate an NSS pulse between two consecutive data when doing continuous transfers. In the case of a single data transfer, it forces the NSS pin high level after the transfer.\nIt has no meaning if CPHA = 1, or FRF = 1.\nNote: 1. This bit must be written only when the SPI is disabled (SPE=0).\nNote: 2. This bit is not used in SPI TI mode."
            },
            {
                "name": "FRF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Frame format\n1 SPI TI mode\nNote: This bit must be written only when the SPI is disabled (SPE=0)."
            },
            {
                "name": "ERRIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Error interrupt enable\nThis bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode)."
            },
            {
                "name": "RXNEIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "RX buffer not empty interrupt enable"
            },
            {
                "name": "TXEIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Tx buffer empty interrupt enable"
            },
            {
                "name": "DS",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Data size\nThese bits configure the data length for SPI transfers.\nIf software attempts to write one of the Not used values, they are forced to the value 0111\n(8-bit)"
            },
            {
                "name": "FRXTH",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "FIFO reception threshold\nThis bit is used to set the threshold of the RXFIFO that triggers an RXNE event"
            },
            {
                "name": "LDMA_RX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Last DMA transfer for reception\nThis bit is used in data packing mode, to define if the total number of data to receive by DMA is odd or even. It has significance only if the RXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register).\nNote: Refer to Procedure for disabling the SPI on page1954 if the CRCEN bit is set."
            },
            {
                "name": "LDMA_TX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Last DMA transfer for transmission\nThis bit is used in data packing mode, to define if the total number of data to transmit by DMA is odd or even. It has significance only if the TXDMAEN bit in the SPI_CR2 register is set and if packing mode is used (data length =< 8-bit and write access to SPI_DR is 16-bit wide). It has to be written when the SPI is disabled (SPE = 0 in the SPI_CR1 register).\nNote: Refer to Procedure for disabling the SPI on page1954 if the CRCEN bit is set."
            }
        ]
    },
    "1073819656": {
        "name": "SPI_SR",
        "address": 1073819656,
        "size": 22,
        "access": "",
        "desc": "SPI status register",
        "fields": [
            {
                "name": "RXNE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Receive buffer not empty"
            },
            {
                "name": "TXE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transmit buffer empty"
            },
            {
                "name": "CRCERR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CRC error flag\nNote: This flag is set by hardware and cleared by software writing 0."
            },
            {
                "name": "MODF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Mode fault\nThis flag is set by hardware and reset by a software sequence. Refer to Section1: Mode fault (MODF) on page1964 for the software sequence."
            },
            {
                "name": "OVR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Overrun flag\nThis flag is set by hardware and reset by a software sequence."
            },
            {
                "name": "BSY",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Busy flag\nThis flag is set and cleared by hardware.\nNote: The BSY flag must be used with caution: refer to Section133.4.10: SPI status flags and Procedure for disabling the SPI on page1954."
            },
            {
                "name": "FRE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Frame format error\nThis flag is used for SPI in TI slave mode. Refer to Section133.4.11: SPI error flags.\nThis flag is set by hardware and reset when SPI_SR is read by software."
            },
            {
                "name": "FRLVL",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "FIFO reception level\nThese bits are set and cleared by hardware.\nNote: These bits are not used in SPI receive-only mode while CRC calculation is enabled."
            },
            {
                "name": "FTLVL",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "FIFO transmission level\nThese bits are set and cleared by hardware."
            }
        ]
    },
    "1073819660": {
        "name": "SPI_DR",
        "address": 1073819660,
        "size": 22,
        "access": "",
        "desc": "SPI data register",
        "fields": [
            {
                "name": "DR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Data register\nData received or to be transmitted\nThe data register serves as an interface between the Rx and Tx FIFOs. When the data register is read, RxFIFO is accessed while the write to data register accesses TxFIFO (See Section133.4.9: Data transmission and reception procedures).\nNote: Data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read. The Rx threshold setting must always correspond with the read access currently used."
            }
        ]
    },
    "1073819664": {
        "name": "SPI_CRCPR",
        "address": 1073819664,
        "size": 22,
        "access": "",
        "desc": "SPI CRC polynomial register",
        "fields": [
            {
                "name": "CRCPOLY",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "CRC polynomial register\nThis register contains the polynomial for the CRC calculation.\nThe CRC polynomial (0x0007) is the reset value of this register. Another polynomial can be configured as required."
            }
        ]
    },
    "1073819668": {
        "name": "SPI_RXCRCR",
        "address": 1073819668,
        "size": 22,
        "access": "",
        "desc": "SPI Rx CRC register",
        "fields": [
            {
                "name": "RXCRC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Rx CRC register\nWhen CRC calculation is enabled, the RXCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPI_CR1 register is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register.\nOnly the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard.\nThe entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard.\nNote: A read to this register when the BSY Flag is set could return an incorrect value."
            }
        ]
    },
    "1073819672": {
        "name": "SPI_TXCRCR",
        "address": 1073819672,
        "size": 22,
        "access": "",
        "desc": "SPI Tx CRC register",
        "fields": [
            {
                "name": "TXCRC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Tx CRC register\nWhen CRC calculation is enabled, the TXCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPI_CR1 is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register.\nOnly the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard.\nThe entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard.\nNote: A read to this register when the BSY flag is set could return an incorrect value."
            }
        ]
    },
    "1073807360": {
        "name": "SYSCFG_CFGR1",
        "address": 1073807360,
        "size": 32,
        "access": "",
        "desc": "SYSCFG configuration register 1",
        "fields": [
            {
                "name": "MEM_MODE",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Memory mapping selection bits\nThese bits are set and cleared by software. They control the memory internal mapping at address 0x000010000. After reset these bits take on the value selected by the actual boot mode configuration. Refer to Section12.5: Boot configuration for more details.\nX0: Main flash memory mapped at 0x000010000"
            },
            {
                "name": "PA11_RMP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "PA11 pin remapping\nThis bit is set and cleared by software. When set, it remaps the PA11 pin to operate as PA9 GPIO port, instead as PA11 GPIO port."
            },
            {
                "name": "PA12_RMP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "PA12 pin remapping\nThis bit is set and cleared by software. When set, it remaps the PA12 pin to operate as PA10 GPIO port, instead as PA12 GPIO port."
            },
            {
                "name": "IR_POL",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "IR output polarity selection"
            },
            {
                "name": "IR_MOD",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "IR Modulation Envelope signal selection\nThis bitfield selects the signal for IR modulation envelope:"
            },
            {
                "name": "BOOSTEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "I/O analog switch voltage booster enable\nThis bit selects the way of supplying I/O analog switches:\nWhen using the analog inputs , setting to 0 is recommended for high V<sub>DD</sub>, setting to 1 for low V<sub>DD</sub> (less than 2.4 V)."
            },
            {
                "name": "I2C_PB6_FMP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Fast Mode Plus (FM+) enable for PB6\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB6 I/O port.\nWith this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored.\nNote: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead."
            },
            {
                "name": "I2C_PB7_FMP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Fast Mode Plus (FM+) enable for PB7\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB7 I/O port.\nWith this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored.\nNote: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead."
            },
            {
                "name": "I2C_PB8_FMP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Fast Mode Plus (FM+) enable for PB8\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB8 I/O port.\nWith this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored.\nNote: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead."
            },
            {
                "name": "I2C_PB9_FMP",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Fast Mode Plus (FM+) enable for PB9\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PB9 I/O port.\nWith this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored.\nNote: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead."
            },
            {
                "name": "I2C_PA9_FMP",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Fast Mode Plus (FM+) enable for PA9\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PA9 I/O port.\nWith this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored.\nNote: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead."
            },
            {
                "name": "I2C_PA10_FMP",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Fast Mode Plus (FM+) enable for PA10\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on PA10 I/O port.\nWith this bit in disable state, the I<sup>2</sup>C FM+ driving capability on this I/O port can be enabled through one of I2Cx_FMP bits. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored.\nNote: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead."
            },
            {
                "name": "I2C3_FMP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Fast Mode Plus (FM+) enable for I2C3\nThis bit is set and cleared by software. It enables I<sup>2</sup>C FM+ driving capability on I/O ports configured as I2C3 through GPIOx_AFR registers.\nWith this bit in disable state, the I<sup>2</sup>C FM+ driving capability on I/O ports configured as I2C3 can be enabled through their corresponding I2Cx_FMP bit. When I<sup>2</sup>C FM+ is enabled, the speed control is ignored.\nNote: This control bit is kept for legacy reasons. It is recommended to use the FMP bit of the I2Cx_CR1 register instead."
            }
        ]
    },
    "1073807384": {
        "name": "SYSCFG_CFGR2",
        "address": 1073807384,
        "size": 32,
        "access": "",
        "desc": "SYSCFG configuration register 2",
        "fields": [
            {
                "name": "CCL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Cortex<Superscript>1<Default 1 Font>-M0+ LOCKUP bit enable bit\nThis bit is set by software and cleared by a system reset. It can be use to enable and lock the connection of Cortex<Superscript>1<Default 1 Font>-M0+ LOCKUP (Hardfault) output to TIM1/15/16 Break input."
            },
            {
                "name": "SPL",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SRAM1 parity lock bit\nThis bit is set by software and cleared by a system reset. It can be used to enable and lock the SRAM1 parity error signal connection to TIM1/15/16 Break input."
            },
            {
                "name": "PVDL",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "PVD lock enable bit\nThis bit is set by software and cleared by a system reset. It can be used to enable and lock the PVD connection to TIM1/15/16 Break input, as well as the PVDE and PLS[2:0] in the PWR_CR register."
            },
            {
                "name": "ECCL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "ECC error lock bit\nThis bit is set by software and cleared by a system reset. It can be used to enable and lock the flash ECC 2-bit error detection signal connection to TIM1/15/16 Break input."
            },
            {
                "name": "BKPL",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Backup SRAM2 parity lock\nThis bit is set by software and cleared by a system reset. It can be used to enable and lock the SRAM2 parity error signal connection to TIM1/15/16 Break input."
            },
            {
                "name": "BKPF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Backup SRAM2 parity error flag\nThis bit is set by hardware when an SRAM2 parity error is detected. It is cleared by software by writing 1."
            },
            {
                "name": "SPF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM1 parity error flag\nThis bit is set by hardware when an SRAM1 parity error is detected. It is cleared by software by writing 1."
            }
        ]
    },
    "1073807388": {
        "name": "SYSCFG_SCSR",
        "address": 1073807388,
        "size": 32,
        "access": "",
        "desc": "SYSCFG SRAM2 control and status register",
        "fields": [
            {
                "name": "SRAM2ER",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SRAM2 erase\nSetting this bit starts a hardware SRAM2 erase operation. This bit is automatically cleared at the end of the SRAM2 erase operation.\nNote: This bit is write-protected: setting this bit is possible only after the correct key sequence is written in the SYSCFG_SKR register."
            },
            {
                "name": "SRAM2BSY",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SRAM2 busy by erase operation"
            }
        ]
    },
    "1073807392": {
        "name": "SYSCFG_SKR",
        "address": 1073807392,
        "size": 32,
        "access": "",
        "desc": "SYSCFG SRAM2 key register",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "SRAM2 write protection key for software erase\nThe following steps are required to unlock the write protection of the SRAM2ER bit in the SYSCFG_CFGR2 register:\nWrite 0xCA into KEY[7:0]\nWrite 0x53 into KEY[7:0]\nWriting a wrong key reactivates the write protection."
            }
        ]
    },
    "1073807396": {
        "name": "SYSCFG_TSCCR",
        "address": 1073807396,
        "size": 32,
        "access": "",
        "desc": "SYSCFG TSC comparator register",
        "fields": [
            {
                "name": "G2_IO1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Comparator mode for group 2 on I/O 1"
            },
            {
                "name": "G2_IO3",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Comparator mode for group 2 on I/O 3"
            },
            {
                "name": "G4_IO3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Comparator mode for group 4 on I/O 3"
            },
            {
                "name": "G6_IO1",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Comparator mode for group 6 on I/O 1"
            },
            {
                "name": "G7_IO1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Comparator mode for group 7 on I/O 1"
            },
            {
                "name": "TSC_IOCTRL",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "I/O control in comparator mode\nThe I/O control in comparator mode can be overwritten by hardware."
            }
        ]
    },
    "1073807488": {
        "name": "SYSCFG_ITLINE0",
        "address": 1073807488,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 0 status register",
        "fields": [
            {
                "name": "WWDG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Window watchdog interrupt pending flag"
            }
        ]
    },
    "1073807492": {
        "name": "SYSCFG_ITLINE1",
        "address": 1073807492,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 1 status register",
        "fields": [
            {
                "name": "PVDOUT",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "PVD supply monitoring interrupt request pending (EXTI line 16)."
            },
            {
                "name": "PVMOUT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "V<sub>DDUSB</sub> supply monitoring interrupt request pending (EXTI line 19)"
            },
            {
                "name": "PVMOUT3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "ADC supply monitoring interrupt request pending (EXTI line 20)"
            },
            {
                "name": "PVMOUT4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "DAC supply monitoring interrupt request pending (EXTI line 21)"
            }
        ]
    },
    "1073807496": {
        "name": "SYSCFG_ITLINE2",
        "address": 1073807496,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 2 status register",
        "fields": [
            {
                "name": "TAMP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper interrupt request pending (EXTI line 21)"
            },
            {
                "name": "RTC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "RTC interrupt request pending (EXTI line 19)"
            }
        ]
    },
    "1073807500": {
        "name": "SYSCFG_ITLINE3",
        "address": 1073807500,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 3 status register",
        "fields": [
            {
                "name": "FLASH_ITF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Flash interface interrupt request pending"
            },
            {
                "name": "FLASH_ECC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Flash interface ECC interrupt request pending"
            }
        ]
    },
    "1073807504": {
        "name": "SYSCFG_ITLINE4",
        "address": 1073807504,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 4 status register",
        "fields": [
            {
                "name": "RCC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Reset and clock control interrupt request pending"
            },
            {
                "name": "CRS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CRS interrupt request pending"
            }
        ]
    },
    "1073807508": {
        "name": "SYSCFG_ITLINE5",
        "address": 1073807508,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 5 status register",
        "fields": [
            {
                "name": "EXTI0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "EXTI line 0 interrupt request pending"
            },
            {
                "name": "EXTI1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "EXTI line 1 interrupt request pending"
            }
        ]
    },
    "1073807512": {
        "name": "SYSCFG_ITLINE6",
        "address": 1073807512,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 6 status register",
        "fields": [
            {
                "name": "EXTI2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "EXTI line 2 interrupt request pending"
            },
            {
                "name": "EXTI3",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "EXTI line 3 interrupt request pending"
            }
        ]
    },
    "1073807516": {
        "name": "SYSCFG_ITLINE7",
        "address": 1073807516,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 7 status register",
        "fields": [
            {
                "name": "EXTI4",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "EXTI line 4 interrupt request pending"
            },
            {
                "name": "EXTI5",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "EXTI line 5 interrupt request pending"
            },
            {
                "name": "EXTI6",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "EXTI line 6 interrupt request pending"
            },
            {
                "name": "EXTI7",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "EXTI line 7 interrupt request pending"
            },
            {
                "name": "EXTI8",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "EXTI line 8 interrupt request pending"
            },
            {
                "name": "EXTI9",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "EXTI line 9 interrupt request pending"
            },
            {
                "name": "EXTI10",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "EXTI line 10 interrupt request pending"
            },
            {
                "name": "EXTI11",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "EXTI line 11 interrupt request pending"
            },
            {
                "name": "EXTI12",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "EXTI line 12 interrupt request pending"
            },
            {
                "name": "EXTI13",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "EXTI line 13 interrupt request pending"
            },
            {
                "name": "EXTI14",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "EXTI line 14 interrupt request pending"
            },
            {
                "name": "EXTI15",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "EXTI line 15 interrupt request pending"
            }
        ]
    },
    "1073807520": {
        "name": "SYSCFG_ITLINE8",
        "address": 1073807520,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 8 status register",
        "fields": [
            {
                "name": "USB",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USB interrupt request pending"
            }
        ]
    },
    "1073807524": {
        "name": "SYSCFG_ITLINE9",
        "address": 1073807524,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 9 status register",
        "fields": [
            {
                "name": "DMA1_CH1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMA1 channel 1 interrupt request pending"
            }
        ]
    },
    "1073807528": {
        "name": "SYSCFG_ITLINE10",
        "address": 1073807528,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 10 status register",
        "fields": [
            {
                "name": "DMA1_CH2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMA1 channel 2 interrupt request pending"
            },
            {
                "name": "DMA1_CH3",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DMA1 channel 3 interrupt request pending"
            }
        ]
    },
    "1073807532": {
        "name": "SYSCFG_ITLINE11",
        "address": 1073807532,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 11 status register",
        "fields": [
            {
                "name": "DMAMUX",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMAMUX interrupt request pending"
            },
            {
                "name": "DMA1_CH4",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DMA1 channel 4 interrupt request pending"
            },
            {
                "name": "DMA1_CH5",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "DMA1 channel 5 interrupt request pending"
            },
            {
                "name": "DMA1_CH6",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "DMA1 channel 6 interrupt request pending"
            },
            {
                "name": "DMA1_CH7",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "DMA1 channel 7 interrupt request pending"
            },
            {
                "name": "DMA2_CH1",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "DMA2 channel 1 interrupt request pending"
            },
            {
                "name": "DMA2_CH2",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA2 channel 2 interrupt request pending"
            },
            {
                "name": "DMA2_CH3",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA2 channel 3 interrupt request pending"
            },
            {
                "name": "DMA2_CH4",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "DMA2 channel 4 interrupt request pending"
            },
            {
                "name": "DMA2_CH5",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "DMA2 channel 5 interrupt request pending"
            }
        ]
    },
    "1073807536": {
        "name": "SYSCFG_ITLINE12",
        "address": 1073807536,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 12 status register",
        "fields": [
            {
                "name": "ADC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC interrupt request pending"
            },
            {
                "name": "COMP1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Comparator 1 interrupt request pending (EXTI line 17)"
            },
            {
                "name": "COMP2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Comparator 2 interrupt request pending (EXTI line 18)"
            }
        ]
    },
    "1073807540": {
        "name": "SYSCFG_ITLINE13",
        "address": 1073807540,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 13 status register",
        "fields": [
            {
                "name": "TIM1_CCU",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Timer 1 commutation interrupt request pending"
            },
            {
                "name": "TIM1_TRG",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Timer 1 trigger interrupt request pending"
            },
            {
                "name": "TIM1_UPD",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Timer 1 update interrupt request pending"
            },
            {
                "name": "TIM1_BRK",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timer 1 break interrupt request pending"
            }
        ]
    },
    "1073807544": {
        "name": "SYSCFG_ITLINE14",
        "address": 1073807544,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 14 status register",
        "fields": [
            {
                "name": "TIM1_CC1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Timer 1 capture compare 1 interrupt request pending"
            },
            {
                "name": "TIM1_CC2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Timer 1 capture compare 2 interrupt request pending"
            },
            {
                "name": "TIM1_CC3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Timer 1 capture compare 3 interrupt request pending"
            },
            {
                "name": "TIM1_CC4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timer 1 capture compare 4 interrupt request pending"
            }
        ]
    },
    "1073807548": {
        "name": "SYSCFG_ITLINE15",
        "address": 1073807548,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 15 status register",
        "fields": [
            {
                "name": "TIM2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Timer 2 interrupt request pending"
            }
        ]
    },
    "1073807552": {
        "name": "SYSCFG_ITLINE16",
        "address": 1073807552,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 16 status register",
        "fields": [
            {
                "name": "TIM3",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Timer 3 interrupt request pending"
            }
        ]
    },
    "1073807556": {
        "name": "SYSCFG_ITLINE17",
        "address": 1073807556,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 17 status register",
        "fields": [
            {
                "name": "TIM6",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Timer 6 interrupt request pending"
            },
            {
                "name": "DAC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DAC underrun interrupt request pending"
            },
            {
                "name": "LPTIM1",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Low-power timer 1 interrupt request pending (EXTI line 29)"
            }
        ]
    },
    "1073807560": {
        "name": "SYSCFG_ITLINE18",
        "address": 1073807560,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 18 status register",
        "fields": [
            {
                "name": "TIM7",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Timer 7 interrupt request pending"
            },
            {
                "name": "LPTIM2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Low-power timer 2 interrupt request pending (EXTI line 30)"
            }
        ]
    },
    "1073807564": {
        "name": "SYSCFG_ITLINE19",
        "address": 1073807564,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 19 status register",
        "fields": [
            {
                "name": "TIM15",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Timer 15 interrupt request pending"
            },
            {
                "name": "LPTIM3",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Low-power timer 3 interrupt request pending"
            }
        ]
    },
    "1073807568": {
        "name": "SYSCFG_ITLINE20",
        "address": 1073807568,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 20 status register",
        "fields": [
            {
                "name": "TIM16",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Timer 16 interrupt request pending"
            }
        ]
    },
    "1073807572": {
        "name": "SYSCFG_ITLINE21",
        "address": 1073807572,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 21 status register",
        "fields": [
            {
                "name": "TSC_MCE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TSC max count error interrupt request pending"
            },
            {
                "name": "TSC_EOA",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TSC end of acquisition interrupt request pending"
            }
        ]
    },
    "1073807576": {
        "name": "SYSCFG_ITLINE22",
        "address": 1073807576,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 22 status register",
        "fields": [
            {
                "name": "LCD",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LCD interrupt request pending"
            }
        ]
    },
    "1073807580": {
        "name": "SYSCFG_ITLINE23",
        "address": 1073807580,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 23 status register",
        "fields": [
            {
                "name": "I2C1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I2C1 interrupt request pending (EXTI line 33)"
            }
        ]
    },
    "1073807584": {
        "name": "SYSCFG_ITLINE24",
        "address": 1073807584,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 24 status register",
        "fields": [
            {
                "name": "I2C2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I2C2 interrupt request pending"
            },
            {
                "name": "I2C4",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "I2C4 interrupt request pending"
            },
            {
                "name": "I2C3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "I2C3 interrupt request pending (EXTI line 23)"
            }
        ]
    },
    "1073807588": {
        "name": "SYSCFG_ITLINE25",
        "address": 1073807588,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 25 status register",
        "fields": [
            {
                "name": "SPI1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SPI1 interrupt request pending"
            }
        ]
    },
    "1073807592": {
        "name": "SYSCFG_ITLINE26",
        "address": 1073807592,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 26 status register",
        "fields": [
            {
                "name": "SPI2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SPI2 interrupt request pending"
            },
            {
                "name": "SPI3",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SPI3 interrupt request pending"
            }
        ]
    },
    "1073807596": {
        "name": "SYSCFG_ITLINE27",
        "address": 1073807596,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 27 status register",
        "fields": [
            {
                "name": "USART1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART1 interrupt request pending, combined with EXTI line 25"
            }
        ]
    },
    "1073807600": {
        "name": "SYSCFG_ITLINE28",
        "address": 1073807600,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 28 status register",
        "fields": [
            {
                "name": "USART2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART2 interrupt request pending (EXTI line 35)"
            },
            {
                "name": "LPUART2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPUART2 interrupt request pending (EXTI line 31)"
            }
        ]
    },
    "1073807604": {
        "name": "SYSCFG_ITLINE29",
        "address": 1073807604,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 29 status register",
        "fields": [
            {
                "name": "USART3",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART3 interrupt request pending"
            },
            {
                "name": "LPUART1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPUART1 interrupt request pending (EXTI line 30)"
            }
        ]
    },
    "1073807608": {
        "name": "SYSCFG_ITLINE30",
        "address": 1073807608,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 30 status register",
        "fields": [
            {
                "name": "USART4",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART4 interrupt request pending"
            },
            {
                "name": "LPUART3",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPUART3 interrupt request pending (EXTI line 32)"
            }
        ]
    },
    "1073807612": {
        "name": "SYSCFG_ITLINE31",
        "address": 1073807612,
        "size": 32,
        "access": "",
        "desc": "SYSCFG interrupt line 31 status register",
        "fields": [
            {
                "name": "RNG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RNG interrupt request pending"
            },
            {
                "name": "AES",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "AES interrupt request pending"
            }
        ]
    },
    "1073786880": {
        "name": "TAMP_CR1",
        "address": 1073786880,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 1",
        "fields": [
            {
                "name": "TAMP1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN1 enable"
            },
            {
                "name": "TAMP2E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN2 enable<sup>(1)</sup>"
            },
            {
                "name": "TAMP3E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN3 enable<sup>(1)</sup>"
            },
            {
                "name": "TAMP4E",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN4 enable<sup>(1)</sup>"
            },
            {
                "name": "TAMP5E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN5 enable<sup>(1)</sup>"
            },
            {
                "name": "ITAMP3E",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 enable"
            },
            {
                "name": "ITAMP4E",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Internal tamper 4 enable"
            },
            {
                "name": "ITAMP5E",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 enable"
            },
            {
                "name": "ITAMP6E",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 enable"
            }
        ]
    },
    "1073786884": {
        "name": "TAMP_CR2",
        "address": 1073786884,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 2",
        "fields": [
            {
                "name": "TAMP1POM",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper 1 potential mode"
            },
            {
                "name": "TAMP2POM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper 2 potential mode"
            },
            {
                "name": "TAMP3POM",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Tamper 3 potential mode"
            },
            {
                "name": "TAMP4POM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Tamper 4 potential mode"
            },
            {
                "name": "TAMP5POM",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Tamper 5 potential mode"
            },
            {
                "name": "TAMP1MSK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Tamper 1 mask\nThe tamper 1 interrupt must not be enabled when TAMP1MSK is set."
            },
            {
                "name": "TAMP2MSK",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Tamper 2 mask\nThe tamper 2 interrupt must not be enabled when TAMP2MSK is set."
            },
            {
                "name": "TAMP3MSK",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Tamper 3 mask\nThe tamper 3 interrupt must not be enabled when TAMP3MSK is set."
            },
            {
                "name": "BKBLOCK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Backup registers and device secrets<sup>(1)</sup> access blocked"
            },
            {
                "name": "BKERASE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Backup registers and device secrets<sup>(1)</sup> erase\nWriting 1 to this bit reset the backup registers and device secrets<sup>(1)</sup>. Writing 0 has no effect. This bit is always read as 0."
            },
            {
                "name": "TAMP1TRG",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Active level for tamper 1 input\nIf TAMPFLT1=100 tamper 1 input rising edge triggers a tamper detection event.\nIf TAMPFLT1=100 tamper 1 input falling edge triggers a tamper detection event."
            },
            {
                "name": "TAMP2TRG",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Active level for tamper 2 input\nIf TAMPFLT = 00 tamper 2 input rising edge triggers a tamper detection event.\nIf TAMPFLT1=100 tamper 2 input falling edge triggers a tamper detection event."
            },
            {
                "name": "TAMP3TRG",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Active level for tamper 3 input\nIf TAMPFLT1=100 tamper 3 input rising edge triggers a tamper detection event.\nIf TAMPFLT1=100 tamper 3 input falling edge triggers a tamper detection event."
            },
            {
                "name": "TAMP4TRG",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Active level for tamper 4 input (active mode disabled)\nIf TAMPFLT1=100 tamper 4 input rising edge triggers a tamper detection event.\nIf TAMPFLT1=100 tamper 4 input falling edge triggers a tamper detection event."
            },
            {
                "name": "TAMP5TRG",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Active level for tamper 5 input (active mode disabled)\nIf TAMPFLT1=100 tamper 5 input rising edge triggers a tamper detection event.\nIf TAMPFLT1=100 tamper 5 input falling edge triggers a tamper detection event."
            }
        ]
    },
    "1073786888": {
        "name": "TAMP_CR3",
        "address": 1073786888,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 3",
        "fields": [
            {
                "name": "ITAMP3POM",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Internal tamper 3 potential mode"
            },
            {
                "name": "ITAMP4POM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Internal tamper 4 potential mode"
            },
            {
                "name": "ITAMP5POM",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Internal tamper 5 potential mode"
            },
            {
                "name": "ITAMP6POM",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Internal tamper 6 potential mode"
            }
        ]
    },
    "1073786892": {
        "name": "TAMP_FLTCR",
        "address": 1073786892,
        "size": 32,
        "access": "",
        "desc": "TAMP filter control register",
        "fields": [
            {
                "name": "TAMPFREQ",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Tamper sampling frequency\nDetermines the frequency at which each of the TAMP_INx inputs are sampled."
            },
            {
                "name": "TAMPFLT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "TAMP_INx filter count\nThese bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs."
            },
            {
                "name": "TAMPPRCH",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "TAMP_INx precharge duration\nThese bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs."
            },
            {
                "name": "TAMPPUDIS",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TAMP_INx pull-up disable\nThis bit determines if each of the TAMPx pins are precharged before each sample."
            }
        ]
    },
    "1073786924": {
        "name": "TAMP_IER",
        "address": 1073786924,
        "size": 32,
        "access": "",
        "desc": "TAMP interrupt enable register",
        "fields": [
            {
                "name": "TAMP1IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper 1 interrupt enable"
            },
            {
                "name": "TAMP2IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper 2 interrupt enable"
            },
            {
                "name": "TAMP3IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Tamper 3 interrupt enable"
            },
            {
                "name": "TAMP4IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Tamper 4 interrupt enable"
            },
            {
                "name": "TAMP5IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Tamper 5 interrupt enable"
            },
            {
                "name": "ITAMP3IE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 interrupt enable"
            },
            {
                "name": "ITAMP4IE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Internal tamper 4 interrupt enable"
            },
            {
                "name": "ITAMP5IE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 interrupt enable"
            },
            {
                "name": "ITAMP6IE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 interrupt enable"
            }
        ]
    },
    "1073786928": {
        "name": "TAMP_SR",
        "address": 1073786928,
        "size": 32,
        "access": "",
        "desc": "TAMP status register",
        "fields": [
            {
                "name": "TAMP1F",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TAMP1 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP1 input."
            },
            {
                "name": "TAMP2F",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TAMP2 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP2 input."
            },
            {
                "name": "TAMP3F",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TAMP3 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP3 input."
            },
            {
                "name": "TAMP4F",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "TAMP4 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP4 input."
            },
            {
                "name": "TAMP5F",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TAMP5 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP5 input."
            },
            {
                "name": "ITAMP3F",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 3."
            },
            {
                "name": "ITAMP4F",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Internal tamper 4 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 4."
            },
            {
                "name": "ITAMP5F",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 5."
            },
            {
                "name": "ITAMP6F",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 6."
            }
        ]
    },
    "1073786932": {
        "name": "TAMP_MISR",
        "address": 1073786932,
        "size": 32,
        "access": "",
        "desc": "TAMP masked interrupt status register",
        "fields": [
            {
                "name": "TAMP1MF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TAMP1 interrupt masked flag\nThis flag is set by hardware when the tamper 1 interrupt is raised."
            },
            {
                "name": "TAMP2MF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TAMP2 interrupt masked flag\nThis flag is set by hardware when the tamper 2 interrupt is raised."
            },
            {
                "name": "TAMP3MF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TAMP3 interrupt masked flag\nThis flag is set by hardware when the tamper 3 interrupt is raised."
            },
            {
                "name": "TAMP4MF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "TAMP4 interrupt masked flag\nThis flag is set by hardware when the tamper 4 interrupt is raised."
            },
            {
                "name": "TAMP5MF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TAMP5 interrupt masked flag\nThis flag is set by hardware when the tamper 5 interrupt is raised."
            },
            {
                "name": "ITAMP3MF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3  interrupt masked flag\nThis flag is set by hardware when the internal tamper 3 interrupt is raised."
            },
            {
                "name": "ITAMP4MF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Internal tamper 4  interrupt masked flag\nThis flag is set by hardware when the internal tamper 4 interrupt is raised."
            },
            {
                "name": "ITAMP5MF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5  interrupt masked flag\nThis flag is set by hardware when the internal tamper 5 interrupt is raised."
            },
            {
                "name": "ITAMP6MF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6  interrupt masked flag\nThis flag is set by hardware when the internal tamper 6 interrupt is raised."
            }
        ]
    },
    "1073786940": {
        "name": "TAMP_SCR",
        "address": 1073786940,
        "size": 32,
        "access": "",
        "desc": "TAMP status clear register",
        "fields": [
            {
                "name": "CTAMP1F",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear TAMP1 detection flag\nWriting 1 in this bit clears the TAMP1F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP2F",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear TAMP2 detection flag\nWriting 1 in this bit clears the TAMP2F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP3F",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear TAMP3 detection flag\nWriting 1 in this bit clears the TAMP3F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP4F",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear TAMP4 detection flag\nWriting 1 in this bit clears the TAMP4F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP5F",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear TAMP5 detection flag\nWriting 1 in this bit clears the TAMP5F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP3F",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Clear ITAMP3 detection flag\nWriting 1 in this bit clears the ITAMP3F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP4F",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Clear ITAMP4 detection flag\nWriting 1 in this bit clears the ITAMP4F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP5F",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Clear ITAMP5 detection flag\nWriting 1 in this bit clears the ITAMP5F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP6F",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Clear ITAMP6 detection flag\nWriting 1 in this bit clears the ITAMP6F bit in the TAMP_SR register."
            }
        ]
    },
    "1073787136": {
        "name": "TAMP_BKP0R",
        "address": 1073787136,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 0 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787140": {
        "name": "TAMP_BKP1R",
        "address": 1073787140,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 1 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787144": {
        "name": "TAMP_BKP2R",
        "address": 1073787144,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 2 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787148": {
        "name": "TAMP_BKP3R",
        "address": 1073787148,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 3 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787152": {
        "name": "TAMP_BKP4R",
        "address": 1073787152,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 4 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787156": {
        "name": "TAMP_BKP5R",
        "address": 1073787156,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 5 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787160": {
        "name": "TAMP_BKP6R",
        "address": 1073787160,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 6 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787164": {
        "name": "TAMP_BKP7R",
        "address": 1073787164,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 7 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787168": {
        "name": "TAMP_BKP8R",
        "address": 1073787168,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 8 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073818624": {
        "name": "TIM1_CR1",
        "address": 1073818624,
        "size": 22,
        "access": "",
        "desc": "TIM1 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One pulse mode"
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction\nNote: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode."
            },
            {
                "name": "CMS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Center-aligned mode selection\nNote: Switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1) is not allowed"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (t<sub>DTS</sub>)used by the dead-time generators and the digital filters (ETR, TIx):\nNote: t<sub>DTS</sub> = 1/f<sub>DTS</sub>, t<sub>CK_INT</sub> = 1/f<sub>CK_INT</sub>."
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073818628": {
        "name": "TIM1_CR2",
        "address": 1073818628,
        "size": 32,
        "access": "",
        "desc": "TIM1 control register 2",
        "fields": [
            {
                "name": "CCPC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare preloaded control\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCUS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare control update selection\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\nThese bits allow selected information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TI1 selection"
            },
            {
                "name": "OIS1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1 output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OIS1N",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1N output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OIS2",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output Idle state 2 (OC2 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS2N",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output Idle state 2 (OC2N output)\nRefer to OIS1N bit"
            },
            {
                "name": "OIS3",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Output Idle state 3 (OC3 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS3N",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Output Idle state 3 (OC3N output)\nRefer to OIS1N bit"
            },
            {
                "name": "OIS4",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Output Idle state 4 (OC4 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS5",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output Idle state 5 (OC5 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS6",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Output Idle state 6 (OC6 output)\nRefer to OIS1 bit"
            },
            {
                "name": "MMS2",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Master mode selection 2\nThese bits allow the information to be sent to ADC for synchronization (TRGO2) to be selected. The combination is as follows:\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            }
        ]
    },
    "1073818632": {
        "name": "TIM1_SMCR",
        "address": 1073818632,
        "size": 32,
        "access": "",
        "desc": "TIM1 slave mode control register",
        "fields": [
            {
                "name": "SMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "SMS[0]: Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nCodes above 1000: Reserved.\nNote: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "OCCS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "OCREF clear selection\nThis bit is used to select the OCREF clear source."
            },
            {
                "name": "TS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "TS[0]: Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee Table1118: TIM1 internal trigger connection on page1561 for more details on ITRx meaning for each Timer.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/slave mode"
            },
            {
                "name": "ETF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "External trigger filter\nThis bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "ETPS",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "External trigger prescaler\nExternal trigger signal ETRP frequency must be at most 1/4 of f<sub>CK_INT</sub> frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks."
            },
            {
                "name": "ECE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "External clock enable\nThis bit enables External clock mode 2.\nNote: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111).\nIt is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111).\nNote: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF."
            },
            {
                "name": "ETP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "External trigger polarity\nThis bit selects whether ETR or ETR is used for trigger operations"
            },
            {
                "name": "SMS_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "SMS[3]"
            },
            {
                "name": "TS_1",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "TS[4:3]"
            }
        ]
    },
    "1073818636": {
        "name": "TIM1_DIER",
        "address": 1073818636,
        "size": 22,
        "access": "",
        "desc": "TIM1 DMA/interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt enable"
            },
            {
                "name": "CC3IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt enable"
            },
            {
                "name": "CC4IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt enable"
            },
            {
                "name": "COMIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "BIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 DMA request enable"
            },
            {
                "name": "CC3DE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 DMA request enable"
            },
            {
                "name": "CC4DE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 DMA request enable"
            },
            {
                "name": "COMDE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "COM DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            }
        ]
    },
    "1073818640": {
        "name": "TIM1_SR",
        "address": 1073818640,
        "size": 32,
        "access": "",
        "desc": "TIM1 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by a trigger event (refer to Section122.4.3: TIM1 slave mode control register (TIM1_SMCR)), if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC3IF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC4IF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "COMIF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt flag\nThis flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software."
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\nThis flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software."
            },
            {
                "name": "BIF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt flag\nThis flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active."
            },
            {
                "name": "B2IF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Break 2 interrupt flag\nThis flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to 0."
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 overcapture flag\nRefer to CC1OF description"
            },
            {
                "name": "CC3OF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 overcapture flag\nRefer to CC1OF description"
            },
            {
                "name": "CC4OF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 overcapture flag\nRefer to CC1OF description"
            },
            {
                "name": "SBIF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "System Break interrupt flag\nThis flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active.\nThis flag must be reset to re-start PWM operation."
            },
            {
                "name": "CC5IF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Compare 5 interrupt flag\nRefer to CC1IF description (Note: Channel 5 can only be configured as output)"
            },
            {
                "name": "CC6IF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Compare 6 interrupt flag\nRefer to CC1IF description (Note: Channel 6 can only be configured as output)"
            }
        ]
    },
    "1073818644": {
        "name": "TIM1_EGR",
        "address": 1073818644,
        "size": 22,
        "access": "",
        "desc": "TIM1 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 generation\nRefer to CC1G description"
            },
            {
                "name": "CC3G",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 generation\nRefer to CC1G description"
            },
            {
                "name": "CC4G",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 generation\nRefer to CC1G description"
            },
            {
                "name": "COMG",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare control update generation\nThis bit can be set by software, it is automatically cleared by hardware\nNote: This bit acts only on channels having a complementary output."
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            },
            {
                "name": "BG",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            },
            {
                "name": "B2G",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Break 2 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073818648": {
        "name": "TIM1_CCMR1_INPUT",
        "address": 1073818648,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare mode register 1",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 Selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register)."
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\nThis bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC2PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler\nRefer to IC1PSC[1:0] description."
            },
            {
                "name": "IC2F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 2 filter\nRefer to IC1F[3:0] description."
            }
        ]
    },
    "1073818652": {
        "name": "TIM1_CCMR2_INPUT",
        "address": 1073818652,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare mode register 2",
        "fields": [
            {
                "name": "CC3S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC3PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler\nRefer to IC1PSC[1:0] description."
            },
            {
                "name": "IC3F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 3 filter\nRefer to IC1F[3:0] description."
            },
            {
                "name": "CC4S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC4PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler\nRefer to IC1PSC[1:0] description."
            },
            {
                "name": "IC4F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 4 filter\nRefer to IC1F[3:0] description."
            }
        ]
    },
    "1073818656": {
        "name": "TIM1_CCER",
        "address": 1073818656,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable\nWhen CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to Table1119 for details.\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output polarity\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\nCC1NP=1, CC1P=1:\tnon-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\nCC1NP=1, CC1P=0:\tThe configuration is reserved, it must not be used.\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output enable\nOn channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output polarity\nCC1 channel configured as output:\nCC1 channel configured as input:\nThis bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description.\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (channel configured as output).\nOn channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC2NE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 complementary output enable\nRefer to CC1NE description"
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 complementary output polarity\nRefer to CC1NP description"
            },
            {
                "name": "CC3E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC3P",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC3NE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 complementary output enable\nRefer to CC1NE description"
            },
            {
                "name": "CC3NP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 complementary output polarity\nRefer to CC1NP description"
            },
            {
                "name": "CC4E",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC4NP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 complementary output polarity\nRefer to CC1NP description"
            },
            {
                "name": "CC5E",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/Compare 5 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC5P",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/Compare 5 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC6E",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Capture/Compare 6 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC6P",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Capture/Compare 6 output polarity\nRefer to CC1P description"
            }
        ]
    },
    "1073818660": {
        "name": "TIM1_CNT",
        "address": 1073818660,
        "size": 32,
        "access": "",
        "desc": "TIM1 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value"
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0."
            }
        ]
    },
    "1073818664": {
        "name": "TIM1_PSC",
        "address": 1073818664,
        "size": 22,
        "access": "",
        "desc": "TIM1 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\nThe counter clock frequency (CK_CNT) is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in reset mode)."
            }
        ]
    },
    "1073818668": {
        "name": "TIM1_ARR",
        "address": 1073818668,
        "size": 22,
        "access": "",
        "desc": "TIM1 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the Section122.3.1: Time-base unit on page1497 for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null."
            }
        ]
    },
    "1073818672": {
        "name": "TIM1_RCR",
        "address": 1073818672,
        "size": 22,
        "access": "",
        "desc": "TIM1 repetition counter register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Repetition counter value\nThese bits allow the user to set-up the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable, as well as the update interrupt generation rate, if this interrupt is enable.\nEach time the REP_CNT related downcounter reaches zero, an update event is generated and it restarts counting from REP value. As REP_CNT is reloaded with REP value only at the repetition update event U_RC, any write to the TIMx_RCR register is not taken in account until the next repetition update event.\nIt means in PWM mode (REP+1) corresponds to:\nthe number of PWM periods in edge-aligned mode\nthe number of half PWM period in center-aligned mode."
            }
        ]
    },
    "1073818676": {
        "name": "TIM1_CCR1",
        "address": 1073818676,
        "size": 22,
        "access": "",
        "desc": "TIM1 capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 1 value\nIf channel CC1 is configured as output: CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.\nIf channel CC1 is configured as input: CR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073818680": {
        "name": "TIM1_CCR2",
        "address": 1073818680,
        "size": 22,
        "access": "",
        "desc": "TIM1 capture/compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 2 value\nIf channel CC2 is configured as output: CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC2 output.\nIf channel CC2 is configured as input: CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073818684": {
        "name": "TIM1_CCR3",
        "address": 1073818684,
        "size": 22,
        "access": "",
        "desc": "TIM1 capture/compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare value\nIf channel CC3 is configured as output: CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC3 output.\nIf channel CC3 is configured as input: CCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073818688": {
        "name": "TIM1_CCR4",
        "address": 1073818688,
        "size": 22,
        "access": "",
        "desc": "TIM1 capture/compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare value\nIf channel CC4 is configured as output: CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC4 output.\nIf channel CC4 is configured as input: CCR4 is the counter value transferred by the last input capture 4 event (IC4). The TIMx_CCR4 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073818692": {
        "name": "TIM1_BDTR",
        "address": 1073818692,
        "size": 32,
        "access": "",
        "desc": "TIM1 break and dead-time register",
        "fields": [
            {
                "name": "DTG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time generator setup"
            },
            {
                "name": "LOCK",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Lock configuration\nThese bits offer a write protection against software errors.\nNote: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset."
            },
            {
                "name": "OSSI",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Off-state selection for Idle mode\nThis bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs.\nSee OC/OCN enable description for more details (Section122.4.11: TIM1 capture/compare enable register (TIM1_CCER)).\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OSSR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Off-state selection for Run mode\nThis bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.\nSee OC/OCN enable description for more details (Section122.4.11: TIM1 capture/compare enable register (TIM1_CCER)).\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Break enable\nThis bit enables the complete break protection (including all sources connected to bk_acth and BRK sources, as per Figure1152: Break and Break2 circuitry overview).\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Break polarity\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "AOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Automatic output enable\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "MOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Main output enable\nThis bit is cleared asynchronously by hardware as soon as one of the break inputs is active (BRK or BRK2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.\nIn response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.\nSee OC/OCN enable description for more details (Section122.4.11: TIM1 capture/compare enable register (TIM1_CCER))."
            },
            {
                "name": "BKF",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Break filter\nThis bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2F",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Break 2 filter\nThis bit-field defines the frequency used to sample BRK2 input and the length of the digital filter applied to BRK2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2E",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Break 2 enable\nNote: The BRK2 must only be used with OSSR = OSSI = 1.\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2P",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Break 2 polarity\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKDSRM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Break Disarm\nThis bit is cleared by hardware when no break source is active.\nThe BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2DSRM",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Break2 Disarm\nRefer to BKDSRM description"
            },
            {
                "name": "BKBID",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Break Bidirectional\nIn the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2BID",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Break2 bidirectional\nRefer to BKBID description"
            }
        ]
    },
    "1073818696": {
        "name": "TIM1_DCR",
        "address": 1073818696,
        "size": 22,
        "access": "",
        "desc": "TIM1 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\nThis 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n..."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\nThis 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).\n...\nExample: Let us consider the following transfer: DBL = 7 bytes & DBA = TIMx_CR1.\nIf DBL = 7 bytes and DBA = TIMx_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:\n(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL\nIn this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data is copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA\nAccording to the configuration of the DMA Data Size, several cases may occur:\nIf the DMA Data Size is configured in half-words, 16-bit data is transferred to each of the 7 registers.\nIf the DMA Data Size is configured in bytes, the data is also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA."
            }
        ]
    },
    "1073818700": {
        "name": "TIM1_DMAR",
        "address": 1073818700,
        "size": 32,
        "access": "",
        "desc": "TIM1 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "DMA register for burst accesses\nA read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR)."
            }
        ]
    },
    "1073818704": {
        "name": "TIM1_OR1",
        "address": 1073818704,
        "size": 32,
        "access": "",
        "desc": "TIM1 option register 1",
        "fields": [
            {
                "name": "OCREF_CLR",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Ocref_clr source selection\nThis bit selects the ocref_clr input source.\nOthers: Reserved\nNote: COMP3 is available on STM32G0B1xx and STM32G0C1xx salestypes only."
            }
        ]
    },
    "1073818708": {
        "name": "TIM1_CCMR3",
        "address": 1073818708,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare mode register 3",
        "fields": [
            {
                "name": "OC5FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output compare 5 fast enable\nRefer to OC1FE description."
            },
            {
                "name": "OC5PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output compare 5 preload enable\nRefer to OC1PE description."
            },
            {
                "name": "OC5M",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "OC5M[0]: Output compare 5 mode\nRefer to OC1M description."
            },
            {
                "name": "OC5CE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Output compare 5 clear enable\nRefer to OC1CE description."
            },
            {
                "name": "OC6FE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output compare 6 fast enable\nRefer to OC1FE description."
            },
            {
                "name": "OC6PE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output compare 6 preload enable\nRefer to OC1PE description."
            },
            {
                "name": "OC6M",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "OC6M[0]: Output compare 6 mode\nRefer to OC1M description."
            },
            {
                "name": "OC6CE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Output compare 6 clear enable\nRefer to OC1CE description."
            },
            {
                "name": "OC5M_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "OC5M[3]"
            },
            {
                "name": "OC6M_1",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "OC6M[3]"
            }
        ]
    },
    "1073818712": {
        "name": "TIM1_CCR5",
        "address": 1073818712,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare register 5",
        "fields": [
            {
                "name": "CCR5",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 5 value\nCCR5 is the value to be loaded in the actual capture/compare 5 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC5 output."
            },
            {
                "name": "GC5C1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Group Channel 5 and Channel 1\nDistortion on Channel 1 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).\nNote: it is also possible to apply this distortion on combined PWM signals."
            },
            {
                "name": "GC5C2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Group Channel 5 and Channel 2\nDistortion on Channel 2 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).\nNote: it is also possible to apply this distortion on combined PWM signals."
            },
            {
                "name": "GC5C3",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Group Channel 5 and Channel 3\nDistortion on Channel 3 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2).\nNote: it is also possible to apply this distortion on combined PWM signals."
            }
        ]
    },
    "1073818716": {
        "name": "TIM1_CCR6",
        "address": 1073818716,
        "size": 22,
        "access": "",
        "desc": "TIM1 capture/compare register 6",
        "fields": [
            {
                "name": "CCR6",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 6 value\nCCR6 is the value to be loaded in the actual capture/compare 6 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC6PE). Else the preload value is copied in the active capture/compare 6 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC6 output."
            }
        ]
    },
    "1073818720": {
        "name": "TIM1_AF1",
        "address": 1073818720,
        "size": 32,
        "access": "",
        "desc": "TIM1 alternate function option register 1",
        "fields": [
            {
                "name": "BKINE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "BRK BKIN input enable\nThis bit enables the BKIN alternate function input for the timers BRK input. BKIN input is ORed with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "BRK COMP1 enable\nThis bit enables the COMP1 for the timers BRK input. COMP1 output is ORed with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "BRK COMP2 enable\nThis bit enables the COMP2 for the timers BRK input. COMP2 output is ORed with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKINP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "BRK BKIN input polarity\nThis bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "BRK COMP1 input polarity\nThis bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "BRK COMP2 input polarity\nThis bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "ETRSEL",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "ETR source selection\nThese bits select the ETR input source.\nOthers: Reserved\nNote: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073818724": {
        "name": "TIM1_AF2",
        "address": 1073818724,
        "size": 32,
        "access": "",
        "desc": "TIM1 Alternate function register 2",
        "fields": [
            {
                "name": "BK2INE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "BRK2 BKIN input enable\nThis bit enables the BKIN2 alternate function input for the timers BRK2 input. BKIN2 input is ORed with the other BRK2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "BRK2 COMP1 enable\nThis bit enables the COMP1 for the timers BRK2 input. COMP1 output is ORed with the other BRK2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "BRK2 COMP2 enable\nThis bit enables the COMP2 for the timers BRK2 input. COMP2 output is ORed with the other BRK2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2INP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "BRK2 BKIN2 input polarity\nThis bit selects the BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "BRK2 COMP1 input polarity\nThis bit selects the COMP1 input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "BRK2 COMP2 input polarity\nThis bit selects the COMP2 input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073818728": {
        "name": "TIM1_TISEL",
        "address": 1073818728,
        "size": 32,
        "access": "",
        "desc": "TIM1 timer input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "selects TI1[0] to TI1[15] input\nOthers: Reserved"
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "selects TI2[0] to TI2[15] input\nOthers: Reserved"
            },
            {
                "name": "TI3SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "selects TI3[0] to TI3[15] input\nOthers: Reserved"
            },
            {
                "name": "TI4SEL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "selects TI4[0] to TI4[15] input\nOthers: Reserved"
            }
        ]
    },
    "1073741824": {
        "name": "TIM2_CR1",
        "address": 1073741824,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable"
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\n\t"
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\n\t"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction\n\t"
            },
            {
                "name": "CMS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Center-aligned mode selection\n\t"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\n\t"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073741828": {
        "name": "TIM2_CR2",
        "address": 1073741828,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 control register 2",
        "fields": [
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\n\t"
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TI1 selection"
            }
        ]
    },
    "1073741832": {
        "name": "TIM2_SMCR",
        "address": 1073741832,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 slave mode control register",
        "fields": [
            {
                "name": "SMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "SMS[2:0]: Slave mode selection\n\t"
            },
            {
                "name": "OCCS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "OCREF clear selection\n\t"
            },
            {
                "name": "TS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "TS[2:0]: Trigger selection\n\t"
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/Slave mode"
            },
            {
                "name": "ETF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "External trigger filter\n\t"
            },
            {
                "name": "ETPS",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "External trigger prescaler\n\t"
            },
            {
                "name": "ECE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "External clock enable\n\t"
            },
            {
                "name": "ETP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "External trigger polarity\n\t"
            },
            {
                "name": "SMS_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "SMS[3]"
            },
            {
                "name": "TS_1",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "TS[4:3]"
            }
        ]
    },
    "1073741836": {
        "name": "TIM2_DIER",
        "address": 1073741836,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt enable"
            },
            {
                "name": "CC3IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt enable"
            },
            {
                "name": "CC4IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 DMA request enable"
            },
            {
                "name": "CC3DE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 DMA request enable"
            },
            {
                "name": "CC4DE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            }
        ]
    },
    "1073741840": {
        "name": "TIM2_SR",
        "address": 1073741840,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\n\t"
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt flag\n\t"
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt flag\n\t"
            },
            {
                "name": "CC3IF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt flag\n\t"
            },
            {
                "name": "CC4IF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt flag\n\t"
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\n\t"
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\n\t"
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 2 overcapture flag\n\t"
            },
            {
                "name": "CC3OF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 overcapture flag\n\t"
            },
            {
                "name": "CC4OF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 overcapture flag\n\t"
            }
        ]
    },
    "1073741844": {
        "name": "TIM2_EGR",
        "address": 1073741844,
        "size": 22,
        "access": "write-only",
        "desc": "TIM2 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\n\t"
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 generation\n\t"
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 generation\n\t"
            },
            {
                "name": "CC3G",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 generation\n\t"
            },
            {
                "name": "CC4G",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 generation\n\t"
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\n\t"
            }
        ]
    },
    "1073741848": {
        "name": "TIM2_CCMR1",
        "address": 1073741848,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare mode register 1",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\n\t"
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\n\t"
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\n\t"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/compare 2 selection\n\t"
            },
            {
                "name": "IC2PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler"
            },
            {
                "name": "IC2F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 2 filter"
            }
        ]
    },
    "1073741852": {
        "name": "TIM2_CCMR2",
        "address": 1073741852,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare mode register 2",
        "fields": [
            {
                "name": "CC3S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 3 selection\n\t"
            },
            {
                "name": "IC3PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler"
            },
            {
                "name": "IC3F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 3 filter"
            },
            {
                "name": "CC4S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 4 selection\n\t"
            },
            {
                "name": "IC4PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler"
            },
            {
                "name": "IC4F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 4 filter"
            }
        ]
    },
    "1073741856": {
        "name": "TIM2_CCER",
        "address": 1073741856,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output enable."
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity."
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity."
            },
            {
                "name": "CC3E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output enable."
            },
            {
                "name": "CC3P",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity."
            },
            {
                "name": "CC3NP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity."
            },
            {
                "name": "CC4E",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output enable."
            },
            {
                "name": "CC4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity."
            },
            {
                "name": "CC4NP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity."
            }
        ]
    },
    "1073741860": {
        "name": "TIM2_CNT",
        "address": 1073741860,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Least significant part of counter value"
            }
        ]
    },
    "1073741864": {
        "name": "TIM2_PSC",
        "address": 1073741864,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\t"
            }
        ]
    },
    "1073741868": {
        "name": "TIM2_ARR",
        "address": 1073741868,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Low Auto-reload value\n\t"
            }
        ]
    },
    "1073741876": {
        "name": "TIM2_CCR1",
        "address": 1073741876,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Low Capture/Compare 1 value\n\t"
            }
        ]
    },
    "1073741880": {
        "name": "TIM2_CCR2",
        "address": 1073741880,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Low Capture/Compare 2 value\n\t"
            }
        ]
    },
    "1073741884": {
        "name": "TIM2_CCR3",
        "address": 1073741884,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Low Capture/Compare value\n\t"
            }
        ]
    },
    "1073741888": {
        "name": "TIM2_CCR4",
        "address": 1073741888,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Low Capture/Compare value\n\t"
            }
        ]
    },
    "1073741896": {
        "name": "TIM2_DCR",
        "address": 1073741896,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\n\t"
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\n\t"
            }
        ]
    },
    "1073741900": {
        "name": "TIM2_DMAR",
        "address": 1073741900,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "DMA register for burst accesses\n\t"
            }
        ]
    },
    "1073741904": {
        "name": "TIM2_OR1",
        "address": 1073741904,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 option register 1",
        "fields": [
            {
                "name": "OCREF_CLR",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Ocref_clr source selection\n\t"
            }
        ]
    },
    "1073741920": {
        "name": "TIM2_AF1",
        "address": 1073741920,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 alternate function option register 1",
        "fields": [
            {
                "name": "ETRSEL",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "ETR source selection\n\t"
            }
        ]
    },
    "1073741928": {
        "name": "TIM2_TISEL",
        "address": 1073741928,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 timer input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "TI1[0] to TI1[15] input selection\n\t"
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "TI2[0] to TI2[15] input selection\n\t"
            },
            {
                "name": "TI3SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "TI3[0] to TI3[15] input selection\n\t"
            }
        ]
    },
    "1073742848": {
        "name": "TIM3_CR1",
        "address": 1073742848,
        "size": 22,
        "access": "read-write",
        "desc": "TIM3 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\n\t"
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\n\t"
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\n\t"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction\n\t"
            },
            {
                "name": "CMS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Center-aligned mode selection\n\t"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\n\t"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073742852": {
        "name": "TIM3_CR2",
        "address": 1073742852,
        "size": 22,
        "access": "read-write",
        "desc": "TIM3 control register 2",
        "fields": [
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\n\t"
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TI1 selection"
            }
        ]
    },
    "1073742856": {
        "name": "TIM3_SMCR",
        "address": 1073742856,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 slave mode control register",
        "fields": [
            {
                "name": "SMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "SMS[2:0]: Slave mode selection\n\t"
            },
            {
                "name": "OCCS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "OCREF clear selection\n\t"
            },
            {
                "name": "TS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "TS[2:0]: Trigger selection\n\t"
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/Slave mode"
            },
            {
                "name": "ETF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "External trigger filter\n\t"
            },
            {
                "name": "ETPS",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "External trigger prescaler\n\t"
            },
            {
                "name": "ECE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "External clock enable\n\t"
            },
            {
                "name": "ETP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "External trigger polarity\n\t"
            },
            {
                "name": "SMS_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "SMS[3]"
            },
            {
                "name": "TS_1",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "TS[4:3]"
            }
        ]
    },
    "1073742860": {
        "name": "TIM3_DIER",
        "address": 1073742860,
        "size": 22,
        "access": "read-write",
        "desc": "TIM3 DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt enable"
            },
            {
                "name": "CC3IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt enable"
            },
            {
                "name": "CC4IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 DMA request enable"
            },
            {
                "name": "CC3DE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 DMA request enable"
            },
            {
                "name": "CC4DE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            }
        ]
    },
    "1073742864": {
        "name": "TIM3_SR",
        "address": 1073742864,
        "size": 22,
        "access": "read-write",
        "desc": "TIM3 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\n\t"
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt flag\n\t"
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt flag\n\t"
            },
            {
                "name": "CC3IF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt flag\n\t"
            },
            {
                "name": "CC4IF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt flag\n\t"
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\n\t"
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\n\t"
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 2 overcapture flag\n\t"
            },
            {
                "name": "CC3OF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 overcapture flag\n\t"
            },
            {
                "name": "CC4OF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 overcapture flag\n\t"
            }
        ]
    },
    "1073742868": {
        "name": "TIM3_EGR",
        "address": 1073742868,
        "size": 22,
        "access": "write-only",
        "desc": "TIM3 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\n\t"
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 generation\n\t"
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 generation\n\t"
            },
            {
                "name": "CC3G",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 generation\n\t"
            },
            {
                "name": "CC4G",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 generation\n\t"
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\n\t"
            }
        ]
    },
    "1073742872": {
        "name": "TIM3_CCMR1",
        "address": 1073742872,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 capture/compare mode register 1",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\n\t"
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\n\t"
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\n\t"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/compare 2 selection\n\t"
            },
            {
                "name": "IC2PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler"
            },
            {
                "name": "IC2F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 2 filter"
            }
        ]
    },
    "1073742876": {
        "name": "TIM3_CCMR2",
        "address": 1073742876,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 capture/compare mode register 2",
        "fields": [
            {
                "name": "CC3S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 3 selection\n\t"
            },
            {
                "name": "IC3PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler"
            },
            {
                "name": "IC3F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 3 filter"
            },
            {
                "name": "CC4S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 4 selection\n\t"
            },
            {
                "name": "IC4PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler"
            },
            {
                "name": "IC4F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 4 filter"
            }
        ]
    },
    "1073742880": {
        "name": "TIM3_CCER",
        "address": 1073742880,
        "size": 22,
        "access": "read-write",
        "desc": "TIM3 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output enable."
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity."
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity."
            },
            {
                "name": "CC3E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output enable."
            },
            {
                "name": "CC3P",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity."
            },
            {
                "name": "CC3NP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity."
            },
            {
                "name": "CC4E",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output enable."
            },
            {
                "name": "CC4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity."
            },
            {
                "name": "CC4NP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity."
            }
        ]
    },
    "1073742884": {
        "name": "TIM3_CNT",
        "address": 1073742884,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Least significant part of counter value"
            }
        ]
    },
    "1073742888": {
        "name": "TIM3_PSC",
        "address": 1073742888,
        "size": 22,
        "access": "read-write",
        "desc": "TIM3 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\t"
            }
        ]
    },
    "1073742892": {
        "name": "TIM3_ARR",
        "address": 1073742892,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Low Auto-reload value\n\t"
            }
        ]
    },
    "1073742900": {
        "name": "TIM3_CCR1",
        "address": 1073742900,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Low Capture/Compare 1 value\n\t"
            }
        ]
    },
    "1073742904": {
        "name": "TIM3_CCR2",
        "address": 1073742904,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 capture/compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Low Capture/Compare 2 value\n\t"
            }
        ]
    },
    "1073742908": {
        "name": "TIM3_CCR3",
        "address": 1073742908,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 capture/compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Low Capture/Compare value\n\t"
            }
        ]
    },
    "1073742912": {
        "name": "TIM3_CCR4",
        "address": 1073742912,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 capture/compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Low Capture/Compare value\n\t"
            }
        ]
    },
    "1073742920": {
        "name": "TIM3_DCR",
        "address": 1073742920,
        "size": 22,
        "access": "read-write",
        "desc": "TIM3 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\n\t"
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\n\t"
            }
        ]
    },
    "1073742924": {
        "name": "TIM3_DMAR",
        "address": 1073742924,
        "size": 22,
        "access": "read-write",
        "desc": "TIM3 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "DMA register for burst accesses\n\t"
            }
        ]
    },
    "1073742928": {
        "name": "TIM3_OR1",
        "address": 1073742928,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 option register 1",
        "fields": [
            {
                "name": "OCREF_CLR",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Ocref_clr source selection\n\t"
            }
        ]
    },
    "1073742944": {
        "name": "TIM3_AF1",
        "address": 1073742944,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 alternate function option register 1",
        "fields": [
            {
                "name": "ETRSEL",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "ETR source selection\n\t"
            }
        ]
    },
    "1073742952": {
        "name": "TIM3_TISEL",
        "address": 1073742952,
        "size": 32,
        "access": "read-write",
        "desc": "TIM3 timer input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "TI1[0] to TI1[15] input selection\n\t"
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "TI2[0] to TI2[15] input selection\n\t"
            },
            {
                "name": "TI3SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "TI3[0] to TI3[15] input selection\n\t"
            }
        ]
    },
    "1073745920": {
        "name": "TIM6_CR1",
        "address": 1073745920,
        "size": 22,
        "access": "",
        "desc": "TIM6 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\n\tNote: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\n\tCEN is cleared automatically in one-pulse mode, when an update event occurs."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\n\tThis bit is set and cleared by software to enable/disable UEV event generation.\n\tCounter overflow/underflow\n\tSetting the UG bit\n\tUpdate generation through the slave mode controller\n\tBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\n\tThis bit is set and cleared by software to select the UEV event sources.\n\tCounter overflow/underflow\n\tSetting the UG bit\n\tUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073745924": {
        "name": "TIM6_CR2",
        "address": 1073745924,
        "size": 22,
        "access": "",
        "desc": "TIM6 control register 2",
        "fields": [
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\n\tThese bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\n\tWhen the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register).\n\tNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            }
        ]
    },
    "1073745932": {
        "name": "TIM6_DIER",
        "address": 1073745932,
        "size": 22,
        "access": "",
        "desc": "TIM6 DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            }
        ]
    },
    "1073745936": {
        "name": "TIM6_SR",
        "address": 1073745936,
        "size": 22,
        "access": "",
        "desc": "TIM6 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\n\tThis bit is set by hardware on an update event. It is cleared by software.\n\tAt overflow or underflow regarding the repetition counter value and if UDIS = 0 in the TIMx_CR1 register.\n\tWhen CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS1=10 and UDIS1=10 in the TIMx_CR1 register."
            }
        ]
    },
    "1073745940": {
        "name": "TIM6_EGR",
        "address": 1073745940,
        "size": 22,
        "access": "",
        "desc": "TIM6 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\n\tThis bit can be set by software, it is automatically cleared by hardware."
            }
        ]
    },
    "1073745956": {
        "name": "TIM6_CNT",
        "address": 1073745956,
        "size": 32,
        "access": "",
        "desc": "TIM6 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value"
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF Copy\n\tThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0."
            }
        ]
    },
    "1073745960": {
        "name": "TIM6_PSC",
        "address": 1073745960,
        "size": 22,
        "access": "",
        "desc": "TIM6 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\tThe counter clock frequency CK_CNT is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1).\n\tPSC contains the value to be loaded into the active prescaler register at each update event.\n\t(including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in reset mode)."
            }
        ]
    },
    "1073745964": {
        "name": "TIM6_ARR",
        "address": 1073745964,
        "size": 22,
        "access": "",
        "desc": "TIM6 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\tARR is the value to be loaded into the actual auto-reload register.\n\tRefer to Section123.3.1: Time-base unit on page1596 for more details about ARR update and behavior.\n\tThe counter is blocked while the auto-reload value is null."
            }
        ]
    },
    "1073746944": {
        "name": "TIM7_CR1",
        "address": 1073746944,
        "size": 22,
        "access": "",
        "desc": "TIM7 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\n\tNote: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\n\tCEN is cleared automatically in one-pulse mode, when an update event occurs."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\n\tThis bit is set and cleared by software to enable/disable UEV event generation.\n\tCounter overflow/underflow\n\tSetting the UG bit\n\tUpdate generation through the slave mode controller\n\tBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\n\tThis bit is set and cleared by software to select the UEV event sources.\n\tCounter overflow/underflow\n\tSetting the UG bit\n\tUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073746948": {
        "name": "TIM7_CR2",
        "address": 1073746948,
        "size": 22,
        "access": "",
        "desc": "TIM7 control register 2",
        "fields": [
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\n\tThese bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\n\tWhen the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register).\n\tNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            }
        ]
    },
    "1073746956": {
        "name": "TIM7_DIER",
        "address": 1073746956,
        "size": 22,
        "access": "",
        "desc": "TIM7 DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            }
        ]
    },
    "1073746960": {
        "name": "TIM7_SR",
        "address": 1073746960,
        "size": 22,
        "access": "",
        "desc": "TIM7 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\n\tThis bit is set by hardware on an update event. It is cleared by software.\n\tAt overflow or underflow regarding the repetition counter value and if UDIS = 0 in the TIMx_CR1 register.\n\tWhen CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS1=10 and UDIS1=10 in the TIMx_CR1 register."
            }
        ]
    },
    "1073746964": {
        "name": "TIM7_EGR",
        "address": 1073746964,
        "size": 22,
        "access": "",
        "desc": "TIM7 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\n\tThis bit can be set by software, it is automatically cleared by hardware."
            }
        ]
    },
    "1073746980": {
        "name": "TIM7_CNT",
        "address": 1073746980,
        "size": 32,
        "access": "",
        "desc": "TIM7 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value"
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF Copy\n\tThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0."
            }
        ]
    },
    "1073746984": {
        "name": "TIM7_PSC",
        "address": 1073746984,
        "size": 22,
        "access": "",
        "desc": "TIM7 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\tThe counter clock frequency CK_CNT is equal to f<sub>CK_PSC</sub> / (PSC[15:0] + 1).\n\tPSC contains the value to be loaded into the active prescaler register at each update event.\n\t(including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in reset mode)."
            }
        ]
    },
    "1073746988": {
        "name": "TIM7_ARR",
        "address": 1073746988,
        "size": 22,
        "access": "",
        "desc": "TIM7 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\tARR is the value to be loaded into the actual auto-reload register.\n\tRefer to Section123.3.1: Time-base unit on page1596 for more details about ARR update and behavior.\n\tThe counter is blocked while the auto-reload value is null."
            }
        ]
    },
    "1073823744": {
        "name": "TIM15_CR1",
        "address": 1073823744,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\n\t"
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\n\t"
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\n\t"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\n\t"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073823748": {
        "name": "TIM15_CR2",
        "address": 1073823748,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 control register 2",
        "fields": [
            {
                "name": "CCPC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare preloaded control\n\t"
            },
            {
                "name": "CCUS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare control update selection\n\t"
            },
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\n\t"
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TI1 selection"
            },
            {
                "name": "OIS1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1 output)\n\t"
            },
            {
                "name": "OIS1N",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1N output)\n\t"
            },
            {
                "name": "OIS2",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output idle state 2 (OC2 output)\n\t"
            }
        ]
    },
    "1073823752": {
        "name": "TIM15_SMCR",
        "address": 1073823752,
        "size": 32,
        "access": "read-write",
        "desc": "TIM15 slave mode control register",
        "fields": [
            {
                "name": "SMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "SMS[2:0]: Slave mode selection\n\t"
            },
            {
                "name": "TS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "TS[2:0]: Trigger selection\n\t"
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/slave mode"
            },
            {
                "name": "SMS_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "SMS[3]"
            },
            {
                "name": "TS_1",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "TS[4:3]"
            }
        ]
    },
    "1073823756": {
        "name": "TIM15_DIER",
        "address": 1073823756,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 DMA/interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt enable"
            },
            {
                "name": "COMIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "BIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            },
            {
                "name": "COMDE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "COM DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            }
        ]
    },
    "1073823760": {
        "name": "TIM15_SR",
        "address": 1073823760,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\n\t"
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt flag\n\t"
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt flag\n\t"
            },
            {
                "name": "COMIF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt flag\n\t"
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\n\t"
            },
            {
                "name": "BIF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt flag\n\t"
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\n\t"
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 overcapture flag\n\t"
            }
        ]
    },
    "1073823764": {
        "name": "TIM15_EGR",
        "address": 1073823764,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\n\t"
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 generation\n\t"
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 generation\n\t"
            },
            {
                "name": "COMG",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare control update generation\n\t"
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\n\t"
            },
            {
                "name": "BG",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break generation\n\t"
            }
        ]
    },
    "1073823768": {
        "name": "TIM15_CCMR1",
        "address": 1073823768,
        "size": 32,
        "access": "read-write",
        "desc": "TIM15 capture/compare mode register 1",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 Selection\n\t"
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\n\t"
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\n\t"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 2 selection\n\t"
            },
            {
                "name": "IC2PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler"
            },
            {
                "name": "IC2F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 2 filter"
            }
        ]
    },
    "1073823776": {
        "name": "TIM15_CCER",
        "address": 1073823776,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable\n\t"
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output polarity\n\t"
            },
            {
                "name": "CC1NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output enable"
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output polarity\n\t"
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output enable\n\t"
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output polarity\n\t"
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 complementary output polarity\n\t"
            }
        ]
    },
    "1073823780": {
        "name": "TIM15_CNT",
        "address": 1073823780,
        "size": 32,
        "access": "read-write",
        "desc": "TIM15 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value"
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF Copy\n\t"
            }
        ]
    },
    "1073823784": {
        "name": "TIM15_PSC",
        "address": 1073823784,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\t"
            }
        ]
    },
    "1073823788": {
        "name": "TIM15_ARR",
        "address": 1073823788,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto-reload value\n\t"
            }
        ]
    },
    "1073823792": {
        "name": "TIM15_RCR",
        "address": 1073823792,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 repetition counter register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Repetition counter value\n\t"
            }
        ]
    },
    "1073823796": {
        "name": "TIM15_CCR1",
        "address": 1073823796,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 1 value\n\t"
            }
        ]
    },
    "1073823800": {
        "name": "TIM15_CCR2",
        "address": 1073823800,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 capture/compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 2 value\n\t"
            }
        ]
    },
    "1073823812": {
        "name": "TIM15_BDTR",
        "address": 1073823812,
        "size": 32,
        "access": "read-write",
        "desc": "TIM15 break and dead-time register",
        "fields": [
            {
                "name": "DTG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time generator setup\n\t"
            },
            {
                "name": "LOCK",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Lock configuration\n\t"
            },
            {
                "name": "OSSI",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Off-state selection for Idle mode\n\t"
            },
            {
                "name": "OSSR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Off-state selection for Run mode\n\t"
            },
            {
                "name": "BKE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Break enable\n\t"
            },
            {
                "name": "BKP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Break polarity\n\t"
            },
            {
                "name": "AOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Automatic output enable\n\t"
            },
            {
                "name": "MOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Main output enable\n\t"
            },
            {
                "name": "BKF",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Break filter\n\t"
            },
            {
                "name": "BKDSRM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Break Disarm\n\t"
            },
            {
                "name": "BKBID",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Break Bidirectional\n\t"
            }
        ]
    },
    "1073823816": {
        "name": "TIM15_DCR",
        "address": 1073823816,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\n\t"
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\n\t"
            }
        ]
    },
    "1073823820": {
        "name": "TIM15_DMAR",
        "address": 1073823820,
        "size": 22,
        "access": "read-write",
        "desc": "TIM15 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "DMA register for burst accesses\n\t"
            }
        ]
    },
    "1073823840": {
        "name": "TIM15_AF1",
        "address": 1073823840,
        "size": 32,
        "access": "read-write",
        "desc": "TIM15 alternate register 1",
        "fields": [
            {
                "name": "BKINE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "BRK BKIN input enable\n\t"
            },
            {
                "name": "BKCMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "BRK COMP1 enable\n\t"
            },
            {
                "name": "BKCMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "BRK COMP2 enable\n\t"
            },
            {
                "name": "BKINP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "BRK BKIN input polarity\n\t"
            },
            {
                "name": "BKCMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "BRK COMP1 input polarity\n\t"
            },
            {
                "name": "BKCMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "BRK COMP2 input polarity\n\t"
            }
        ]
    },
    "1073823848": {
        "name": "TIM15_TISEL",
        "address": 1073823848,
        "size": 32,
        "access": "read-write",
        "desc": "TIM15 input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "selects TI1[0] to TI1[15] input\n\t"
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "selects TI2[0] to TI2[15] input\n\t"
            }
        ]
    },
    "1073824768": {
        "name": "TIM16_CR1",
        "address": 1073824768,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\n\t"
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\n\t"
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\n\t"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\n\t"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073824772": {
        "name": "TIM16_CR2",
        "address": 1073824772,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 control register 2",
        "fields": [
            {
                "name": "CCPC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare preloaded control\n\t"
            },
            {
                "name": "CCUS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare control update selection\n\t"
            },
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "OIS1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1 output)\n\t"
            },
            {
                "name": "OIS1N",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1N output)\n\t"
            }
        ]
    },
    "1073824780": {
        "name": "TIM16_DIER",
        "address": 1073824780,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 DMA/interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "COMIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt enable"
            },
            {
                "name": "BIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            }
        ]
    },
    "1073824784": {
        "name": "TIM16_SR",
        "address": 1073824784,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\n\t"
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt flag\n\t"
            },
            {
                "name": "COMIF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt flag\n\t"
            },
            {
                "name": "BIF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt flag\n\t"
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\n\t"
            }
        ]
    },
    "1073824788": {
        "name": "TIM16_EGR",
        "address": 1073824788,
        "size": 22,
        "access": "write-only",
        "desc": "TIM16 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\n\t"
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 generation\n\t"
            },
            {
                "name": "COMG",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare control update generation\n\t"
            },
            {
                "name": "BG",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break generation\n\t"
            }
        ]
    },
    "1073824792": {
        "name": "TIM16_CCMR1",
        "address": 1073824792,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 capture/compare mode register 1",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 Selection\n\t"
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\n\t"
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\n\t"
            }
        ]
    },
    "1073824800": {
        "name": "TIM16_CCER",
        "address": 1073824800,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable\n\t"
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output polarity\n\t"
            },
            {
                "name": "CC1NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output enable"
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output polarity\n\t"
            }
        ]
    },
    "1073824804": {
        "name": "TIM16_CNT",
        "address": 1073824804,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value"
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF Copy\n\t"
            }
        ]
    },
    "1073824808": {
        "name": "TIM16_PSC",
        "address": 1073824808,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\t"
            }
        ]
    },
    "1073824812": {
        "name": "TIM16_ARR",
        "address": 1073824812,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto-reload value\n\t"
            }
        ]
    },
    "1073824816": {
        "name": "TIM16_RCR",
        "address": 1073824816,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 repetition counter register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Repetition counter value\n\t"
            }
        ]
    },
    "1073824820": {
        "name": "TIM16_CCR1",
        "address": 1073824820,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 1 value\n\t"
            }
        ]
    },
    "1073824836": {
        "name": "TIM16_BDTR",
        "address": 1073824836,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 break and dead-time register",
        "fields": [
            {
                "name": "DTG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time generator setup\n\t"
            },
            {
                "name": "LOCK",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Lock configuration\n\t"
            },
            {
                "name": "OSSI",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Off-state selection for Idle mode\n\t"
            },
            {
                "name": "OSSR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Off-state selection for Run mode\n\t"
            },
            {
                "name": "BKE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Break enable\n\t"
            },
            {
                "name": "BKP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Break polarity\n\t"
            },
            {
                "name": "AOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Automatic output enable\n\t"
            },
            {
                "name": "MOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Main output enable\n\t"
            },
            {
                "name": "BKF",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Break filter\n\t"
            },
            {
                "name": "BKDSRM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Break Disarm\n\t"
            },
            {
                "name": "BKBID",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Break Bidirectional\n\t"
            }
        ]
    },
    "1073824840": {
        "name": "TIM16_DCR",
        "address": 1073824840,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\n\t"
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\n\t"
            }
        ]
    },
    "1073824844": {
        "name": "TIM16_DMAR",
        "address": 1073824844,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "DMA register for burst accesses\n\t"
            }
        ]
    },
    "1073824864": {
        "name": "TIM16_AF1",
        "address": 1073824864,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 alternate function register 1",
        "fields": [
            {
                "name": "BKINE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "BRK BKIN input enable\n\t"
            },
            {
                "name": "BKCMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "BRK COMP1 enable\n\t"
            },
            {
                "name": "BKCMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "BRK COMP2 enable\n\t"
            },
            {
                "name": "BKINP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "BRK BKIN input polarity\n\t"
            },
            {
                "name": "BKCMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "BRK COMP1 input polarity\n\t"
            },
            {
                "name": "BKCMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "BRK COMP2 input polarity\n\t"
            }
        ]
    },
    "1073824872": {
        "name": "TIM16_TISEL",
        "address": 1073824872,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "selects TI1[0] to TI1[15] input\n\t"
            }
        ]
    },
    "1073889280": {
        "name": "TSC_CR",
        "address": 1073889280,
        "size": 32,
        "access": "",
        "desc": "TSC control register",
        "fields": [
            {
                "name": "TSCE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Touch sensing controller enable\nThis bit is set and cleared by software to enable/disable the touch sensing controller.\nNote: When the touch sensing controller is disabled, TSC registers settings have no effect."
            },
            {
                "name": "START",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Start a new acquisition\nThis bit is set by software to start a new acquisition. It is cleared by hardware as soon as the acquisition is complete or by software to cancel the ongoing acquisition."
            },
            {
                "name": "AM",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Acquisition mode\nThis bit is set and cleared by software to select the acquisition mode.\nNote: This bit must not be modified when an acquisition is ongoing."
            },
            {
                "name": "SYNCPOL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Synchronization pin polarity\nThis bit is set and cleared by software to select the polarity of the synchronization input pin."
            },
            {
                "name": "IODEF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "I/O Default mode\nThis bit is set and cleared by software. It defines the configuration of all the TSC I/Os when there is no ongoing acquisition. When there is an ongoing acquisition, it defines the configuration of all unused I/Os (not defined as sampling capacitor I/O or as channel I/O).\nNote: This bit must not be modified when an acquisition is ongoing."
            },
            {
                "name": "MCV",
                "bitOffset": 5,
                "bitWidth": 3,
                "desc": "Max count value\nThese bits are set and cleared by software. They define the maximum number of charge transfer pulses that can be generated before a max count error is generated.\nNote: These bits must not be modified when an acquisition is ongoing."
            },
            {
                "name": "PGPSC",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Pulse generator prescaler\nThese bits are set and cleared by software.They select the AHB clock divider used to generate the pulse generator clock (PGCLK).\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: Some configurations are forbidden. Refer to the Section119.4.4: Charge transfer acquisition sequence for details."
            },
            {
                "name": "SSPSC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Spread spectrum prescaler\nThis bit is set and cleared by software. It selects the AHB clock divider used to generate the spread spectrum clock (SSCLK).\nNote: This bit must not be modified when an acquisition is ongoing."
            },
            {
                "name": "SSE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Spread spectrum enable\nThis bit is set and cleared by software to enable/disable the spread spectrum feature.\nNote: This bit must not be modified when an acquisition is ongoing."
            },
            {
                "name": "SSD",
                "bitOffset": 17,
                "bitWidth": 7,
                "desc": "Spread spectrum deviation\nThese bits are set and cleared by software. They define the spread spectrum deviation which consists in adding a variable number of periods of the SSCLK clock to the charge transfer pulse high state.\n...\nNote: These bits must not be modified when an acquisition is ongoing."
            },
            {
                "name": "CTPL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Charge transfer pulse low\nThese bits are set and cleared by software. They define the duration of the low state of the charge transfer pulse (transfer of charge from C<sub>X</sub> to C<sub>S</sub>).\n...\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: Some configurations are forbidden. Refer to the Section119.4.4: Charge transfer acquisition sequence for details."
            },
            {
                "name": "CTPH",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Charge transfer pulse high\nThese bits are set and cleared by software. They define the duration of the high state of the charge transfer pulse (charge of C<sub>X</sub>).\n...\nNote: These bits must not be modified when an acquisition is ongoing."
            }
        ]
    },
    "1073889284": {
        "name": "TSC_IER",
        "address": 1073889284,
        "size": 32,
        "access": "",
        "desc": "TSC interrupt enable register",
        "fields": [
            {
                "name": "EOAIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "End of acquisition interrupt enable\nThis bit is set and cleared by software to enable/disable the end of acquisition interrupt."
            },
            {
                "name": "MCEIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Max count error interrupt enable\nThis bit is set and cleared by software to enable/disable the max count error interrupt."
            }
        ]
    },
    "1073889288": {
        "name": "TSC_ICR",
        "address": 1073889288,
        "size": 32,
        "access": "",
        "desc": "TSC interrupt clear register",
        "fields": [
            {
                "name": "EOAIC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "End of acquisition interrupt clear\nThis bit is set by software to clear the end of acquisition flag and it is cleared by hardware when the flag is reset. Writing a 0 has no effect."
            },
            {
                "name": "MCEIC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Max count error interrupt clear\nThis bit is set by software to clear the max count error flag and it is cleared by hardware when the flag is reset. Writing a 0 has no effect."
            }
        ]
    },
    "1073889292": {
        "name": "TSC_ISR",
        "address": 1073889292,
        "size": 32,
        "access": "",
        "desc": "TSC interrupt status register",
        "fields": [
            {
                "name": "EOAF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "End of acquisition flag\nThis bit is set by hardware when the acquisition of all enabled group is complete (all GxS bits of all enabled analog I/O groups are set or when a max count error is detected). It is cleared by software writing 1 to the bit EOAIC of the TSC_ICR register."
            },
            {
                "name": "MCEF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Max count error flag\nThis bit is set by hardware as soon as an analog I/O group counter reaches the max count value specified. It is cleared by software writing 1 to the bit MCEIC of the TSC_ICR register."
            }
        ]
    },
    "1073889296": {
        "name": "TSC_IOHCR",
        "address": 1073889296,
        "size": 32,
        "access": "",
        "desc": "TSC I/O hysteresis control register",
        "fields": [
            {
                "name": "G1_IO1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO3",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO4",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO2",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO4",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO2",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO3",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO2",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO3",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO4",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO1",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO2",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO3",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO4",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G7_IO1",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G7_IO2",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G7_IO3",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G7_IO4",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            }
        ]
    },
    "1073889304": {
        "name": "TSC_IOASCR",
        "address": 1073889304,
        "size": 32,
        "access": "",
        "desc": "TSC I/O analog switch control register",
        "fields": [
            {
                "name": "G1_IO1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO3",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO4",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO2",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO4",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO2",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO3",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO2",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO3",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO4",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO1",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO2",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO3",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO4",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G7_IO1",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G7_IO2",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G7_IO3",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G7_IO4",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            }
        ]
    },
    "1073889312": {
        "name": "TSC_IOSCR",
        "address": 1073889312,
        "size": 32,
        "access": "",
        "desc": "TSC I/O sampling control register",
        "fields": [
            {
                "name": "G1_IO1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO3",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO4",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO2",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO4",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO2",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO3",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO2",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO3",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO4",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO1",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO2",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO3",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO4",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G7_IO1",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G7_IO2",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G7_IO3",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G7_IO4",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            }
        ]
    },
    "1073889320": {
        "name": "TSC_IOCCR",
        "address": 1073889320,
        "size": 32,
        "access": "",
        "desc": "TSC I/O channel control register",
        "fields": [
            {
                "name": "G1_IO1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO3",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO4",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO2",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO4",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO2",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO3",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO2",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO3",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO4",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO1",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO2",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO3",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO4",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G7_IO1",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G7_IO2",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G7_IO3",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G7_IO4",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            }
        ]
    },
    "1073889328": {
        "name": "TSC_IOGCSR",
        "address": 1073889328,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group control status register",
        "fields": [
            {
                "name": "G1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G2E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G3E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G4E",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G5E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G6E",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G7E",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G1S",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G2S",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G3S",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G4S",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G5S",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G6S",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G7S",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            }
        ]
    },
    "1073889332": {
        "name": "TSC_IOG1CR",
        "address": 1073889332,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 1 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold)."
            }
        ]
    },
    "1073889336": {
        "name": "TSC_IOG2CR",
        "address": 1073889336,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 2 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold)."
            }
        ]
    },
    "1073889340": {
        "name": "TSC_IOG3CR",
        "address": 1073889340,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 3 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold)."
            }
        ]
    },
    "1073889344": {
        "name": "TSC_IOG4CR",
        "address": 1073889344,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 4 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold)."
            }
        ]
    },
    "1073889348": {
        "name": "TSC_IOG5CR",
        "address": 1073889348,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 5 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold)."
            }
        ]
    },
    "1073889352": {
        "name": "TSC_IOG6CR",
        "address": 1073889352,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 6 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold)."
            }
        ]
    },
    "1073889356": {
        "name": "TSC_IOG7CR",
        "address": 1073889356,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 7 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across C<sub>S</sub> has reached the threshold)."
            }
        ]
    },
    "1073821696": {
        "name": "USART_CR1",
        "address": 1073821696,
        "size": 32,
        "access": "",
        "desc": "USART control register 1",
        "fields": [
            {
                "name": "UE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.\nNote: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.\nNote: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.\nNote: In Smartcard mode, (SCEN = 1), the CK is always available when CLKEN = 1, regardless of the UE bit value."
            },
            {
                "name": "UESM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\nNote: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode."
            },
            {
                "name": "RE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software."
            },
            {
                "name": "TE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.\nNote: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts."
            },
            {
                "name": "IDLEIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "IDLE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFNEIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFNFIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PEIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "PE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "PCE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "WAKE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver wake-up method\nThis bit determines the USART wake-up method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "M0",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "MME",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Mute mode enable\nThis bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software."
            },
            {
                "name": "CMIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Character match interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "OVER8",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Oversampling mode\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In LIN, IrDA and Smartcard modes, this bit must be kept cleared."
            },
            {
                "name": "DEDT",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Driver Enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nIf the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "DEAT",
                "bitOffset": 21,
                "bitWidth": 5,
                "desc": "Driver Enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "RTOIE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receiver timeout interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section131.4: USART implementation on page1826."
            },
            {
                "name": "EOBIE",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "End of Block interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "M1",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] = 00: 1 start bit, 8 Data bits, n Stop bit\nM[1:0] = 01: 1 start bit, 9 Data bits, n Stop bit\nM[1:0] = 10: 1 start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In 7-bits data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported."
            },
            {
                "name": "FIFOEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "FIFO mode enable\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: FIFO mode can be used on standard UART communication, in SPI Master/Slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes."
            },
            {
                "name": "TXFEIE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TXFIFO empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFFIE",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "None"
            }
        ]
    },
    "1073821700": {
        "name": "USART_CR2",
        "address": 1073821700,
        "size": 32,
        "access": "",
        "desc": "USART control register 2",
        "fields": [
            {
                "name": "SLVEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Synchronous Slave mode enable\nWhen the SLVEN bit is set, the Synchronous slave mode is enabled.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "DIS_NSS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "When the DIS_NSS bit is set, the NSS pin input is ignored.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "ADDM7",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "7-bit Address Detection/4-bit Address Detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\nThis bit can only be written when the USART is disabled (UE=0)\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively."
            },
            {
                "name": "LBDL",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LIN break detection length\nThis bit is for selection between 11 bit or 10 bit break detection.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "LBDIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LIN break detection interrupt enable\nBreak interrupt mask (break detection using break delimiter).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "LBCL",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Last bit clock pulse\nThis bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the CK pin in Synchronous mode.\nThe last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "CPHA",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Clock phase\nThis bit is used to select the phase of the clock output on the CK pin in Synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see Figure1233 and Figure1234)\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "CPOL",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Clock polarity\nThis bit enables the user to select the polarity of the clock output on the CK pin in Synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "CLKEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Clock enable\nThis bit enables the user to enable the CK pin.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If neither Synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826.\nIn Smartcard mode, in order to provide correctly the CK clock to the smartcard, the steps below must be respected:\nUE = 0\nSCEN = 1\nGTPR configuration\nCLKEN= 1\nNote: UE = 1"
            },
            {
                "name": "STOP",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "stop bits\nThese bits are used for programming the stop bits.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "LINEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "LIN mode enable\nThis bit is set and cleared by software.\nThe LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "SWAP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Swap TX/RX pins\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "RXINV",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "RX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "TXINV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "DATAINV",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Binary data inversion\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "MSBFIRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Most significant bit first\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "ABREN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Auto baud rate enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "ABRMOD",
                "bitOffset": 21,
                "bitWidth": 2,
                "desc": "Auto baud rate mode\nThese bits are set and cleared by software.\nThis bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0).\nNote: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example 0xAA for MSBFIRST)\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "RTOEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Receiver timeout enable\nThis bit is set and cleared by software.\nWhen this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register).\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "ADD",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Address of the USART node\nThese bits give the address of the USART node in Mute mode or a character code to be recognized in low-power or Run mode:\nIn Mute mode: they are used in multiprocessor communication to wake up from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.\nIn low-power mode: they are used for wake up from low-power mode on character match.\nWhen WUS[1:0] is programmed to 0b00 (WUF active on address match), the wake-up from low-power mode is performed when the received character corresponds to the character programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1.\nIn Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.\nThese bits can only be written when the reception is disabled (RE1=10) or when the USART is disabled (UE1=10)."
            }
        ]
    },
    "1073821704": {
        "name": "USART_CR3",
        "address": 1073821704,
        "size": 32,
        "access": "",
        "desc": "USART control register 3",
        "fields": [
            {
                "name": "EIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1or UDR = 1 in the USART_ISR register)."
            },
            {
                "name": "IREN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "IrDA mode enable\nThis bit is set and cleared by software.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "IRLP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "IrDA low-power\nThis bit is used for selecting between normal and low-power IrDA modes\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "HDSEL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Half-duplex selection\nSelection of Single-wire Half-duplex mode\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "NACK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Smartcard NACK enable\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "SCEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Smartcard mode enable\nThis bit is used for enabling Smartcard mode.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "DMAR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA enable receiver\nThis bit is set/reset by software"
            },
            {
                "name": "DMAT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA enable transmitter\nThis bit is set/reset by software"
            },
            {
                "name": "RTSE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "RTS enable\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "CTSE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS enable\nThis bit can only be written when the USART is disabled (UE=0)\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "CTSIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS interrupt enable\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "ONEBIT",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "One sample bit method enable\nThis bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "OVRDIS",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun Disable\nThis bit is used to disable the receive overrun detection.\nthe ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data are written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: This control bit enables checking the communication flow w/o reading the data"
            },
            {
                "name": "DDRE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DMA Disable on Reception Error\nThis bit can only be written when the USART is disabled (UE=0).\nNote: The reception errors are: parity error, framing error or noise error."
            },
            {
                "name": "DEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Section131.4: USART implementation on page1826."
            },
            {
                "name": "DEP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Driver enable polarity selection\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "SCARCNT",
                "bitOffset": 17,
                "bitWidth": 3,
                "desc": "Smartcard auto-retry count\nThis bitfield specifies the number of retries for transmission and reception in Smartcard mode.\nIn Transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set).\nIn Reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set).\nThis bitfield must be programmed only when the USART is disabled (UE=0).\nWhen the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to stop retransmission.\n0x1 to 0x7: number of automatic retransmission attempts (before signaling error)\nNote: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "WUS0",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wake-up from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (wake-up from low-power mode flag).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "WUS1",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Wake-up from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (wake-up from low-power mode flag).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "WUFIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Wake-up from low-power mode interrupt enable\nThis bit is set and cleared by software.\nNote: WUFIE must be set before entering in low-power mode.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "TXFTIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TCBGTIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Transmission Complete before guard time, interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "RXFTCFG",
                "bitOffset": 25,
                "bitWidth": 3,
                "desc": "Receive FIFO threshold configuration\nRemaining combinations: Reserved"
            },
            {
                "name": "RXFTIE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "RXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFTCFG",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "TXFIFO threshold configuration\nRemaining combinations: Reserved"
            }
        ]
    },
    "1073821708": {
        "name": "USART_BRR",
        "address": 1073821708,
        "size": 32,
        "access": "",
        "desc": "USART baud rate register",
        "fields": [
            {
                "name": "BRR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "USART baud rate\nBRR[15:4]\nBRR[15:4] correspond to USARTDIV[15:4]\nBRR[3:0]\nWhen OVER8 = 0, BRR[3:0] = USARTDIV[3:0].\nWhen OVER8 = 1:\nBRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.\nBRR[3] must be kept cleared."
            }
        ]
    },
    "1073821712": {
        "name": "USART_GTPR",
        "address": 1073821712,
        "size": 32,
        "access": "",
        "desc": "USART guard time and prescaler register",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Prescaler value\nPSC[7:0] = IrDA Normal and Low-power baud rate\nThis bitfield is used for programming the prescaler for dividing the USART source clock to achieve the low-power frequency:\nThe source clock is divided by the value given in the register (8 significant bits):\n...\nPSC[4:0]: Prescaler value\nThis bitfield is used for programming the prescaler for dividing the USART source clock to provide the Smartcard clock.\nThe value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency:\n...\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: Bits [7:5] must be kept cleared if Smartcard mode is used.\nNote: This bitfield is reserved and forced by hardware to 0 when the Smartcard and IrDA modes are not supported. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "GT",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "Guard time value\nThis bitfield is used to program the Guard time value in terms of number of baud clock periods.\nThis is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            }
        ]
    },
    "1073821716": {
        "name": "USART_RTOR",
        "address": 1073821716,
        "size": 32,
        "access": "",
        "desc": "USART receiver timeout register",
        "fields": [
            {
                "name": "RTO",
                "bitOffset": 0,
                "bitWidth": 24,
                "desc": "Receiver timeout value\nThis bitfield gives the Receiver timeout value in terms of number of bit duration.\nIn Standard mode, the RTOF flag is set if, after the last received character, no new start bit is detected for more than the RTO value.\nIn Smartcard mode, this value is used to implement the CWT and BWT. See Smartcard chapter for more details. In the standard, the CWT/BWT measurement is done starting from the start bit of the last received character.\nNote: This value must only be programmed once per received character."
            },
            {
                "name": "BLEN",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Block Length\nThis bitfield gives the Block length in Smartcard T=1 Reception. Its value equals the number of information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1.\nExamples:\nBLEN = 0 -> 0 information characters + LEC\nBLEN = 1 -> 0 information characters + CRC\nBLEN = 255 -> 254 information characters + CRC (total 256 characters))\nIn Smartcard mode, the Block length counter is reset when TXE=0 (TXFE = 0 in case FIFO mode is enabled).\nThis bitfield can be used also in other modes. In this case, the Block length counter is reset when RE=0 (receiver disabled) and/or when the EOBCF bit is written to 1.\nNote: This value can be programmed after the start of the block reception (using the data from the LEN character in the Prologue Field). It must be programmed only once per received block."
            }
        ]
    },
    "1073821720": {
        "name": "USART_RQR",
        "address": 1073821720,
        "size": 32,
        "access": "",
        "desc": "USART request register",
        "fields": [
            {
                "name": "ABRRQ",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Auto baud rate request\nWriting 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an automatic baud rate measurement on the next received data frame.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "SBKRQ",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\nNote: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software must wait for the TXE flag assertion before setting the SBKRQ bit."
            },
            {
                "name": "MMRQ",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Mute mode request\nWriting 1 to this bit puts the USART in Mute mode and resets the RWU flag."
            },
            {
                "name": "RXFRQ",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Receive data flush request\nWriting 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.\nThis enables to discard the received data without reading them, and avoid an overrun condition."
            },
            {
                "name": "TXFRQ",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Transmit data flush request\nWhen FIFO mode is disabled, writing 1 to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value.\nWhen FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes.\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register."
            }
        ]
    },
    "1073821724": {
        "name": "USART_ISR",
        "address": 1073821724,
        "size": 32,
        "access": "",
        "desc": "USART interrupt and status register",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error\nThis bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\nNote: This error is associated with the character in the USART_RDR."
            },
            {
                "name": "FE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE1=11 in the USART_CR3 register.\nNote: This error is associated with the character in the USART_RDR."
            },
            {
                "name": "NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NFCF bit in the USART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.\nNote: When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Section131.5.9: Tolerance of the USART receiver to clock deviation on page1845).\nNote: This error is associated with the character in the USART_RDR."
            },
            {
                "name": "ORE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.\nAn interrupt is generated if RXFNEIE=1 in the USART_CR1 register, or EIE = 1 in the USART_CR3 register.\nNote: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.\nNote: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register."
            },
            {
                "name": "IDLE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.\nNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).\nNote: If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set."
            },
            {
                "name": "RXFNE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty\nRXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO.\nRXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.\nAn interrupt is generated if RXFNEIE=1 in the USART_CR1 register."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag behaves as follows:\nWhen TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXE/TXFE is set.\nWhen TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached.\nWhen TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred.\nWhen TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty.\nAn interrupt is generated if TCIE=1 in the USART_CR1 register.\nTC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register."
            },
            {
                "name": "TXFNF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full\nTXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR.\nAn interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register.\nNote: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF must be checked prior to writing in TXFIFO (TXFNF and TXFE is set at the same time).\nNote: This bit is used during single buffer transmission."
            },
            {
                "name": "LBDF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\nNote: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "CTSIF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS interrupt flag\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE=1 in the USART_CR3 register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "CTS",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "RTOF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.\nAn interrupt is generated if RTOIE=1 in the USART_CR2 register.\nIn Smartcard mode, the timeout corresponds to the CWT or BWT timings.\nNote: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.\nNote: The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "EOBF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "End of block flag\nThis bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.\nAn interrupt is generated if EOBIE1=11 in the USART_CR1 register.\nIt is cleared by software, writing 1 to EOBCF in the USART_ICR register.\nNote: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "UDR",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SPI slave underrun error flag\nIn Slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.\nNote: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "ABRE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "ABRF",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case)\nIt is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "BUSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not)."
            },
            {
                "name": "CMF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE=1in the USART_CR1 register."
            },
            {
                "name": "SBKF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission."
            },
            {
                "name": "RWU",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Receiver wake-up from Mute mode\nThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wake-up/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.\nWhen wake-up on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "WUF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wake-up from low-power mode flag\nThis bit is set by hardware, when a wake-up event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE=1 in the USART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "TEACK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.\nIt can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period."
            },
            {
                "name": "REACK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.\nIt can be used to verify that the USART is ready for reception before entering low-power mode.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "TXFE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO Empty\nThis bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.\nAn interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register."
            },
            {
                "name": "RXFF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "RXFIFO Full\nThis bit is set by hardware when the number of received data corresponds to RXFIFO1size1+11 (RXFIFO full + 1 data in the USART_RDR register.\nAn interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register."
            },
            {
                "name": "TCBGT",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmission complete before guard time flag\nThis bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.\nIt is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register.\nThis bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.\nNote: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is 1. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "RXFT",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "RXFIFO threshold flag\nThis bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the USART_CR3 register.\nNote: When the RXFTCFG threshold is configured to 101, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data."
            },
            {
                "name": "TXFT",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "TXFIFO threshold flag\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register."
            }
        ]
    },
    "1073821728": {
        "name": "USART_ICR",
        "address": 1073821728,
        "size": 32,
        "access": "",
        "desc": "USART interrupt flag clear register",
        "fields": [
            {
                "name": "PECF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error clear flag\nWriting 1 to this bit clears the PE flag in the USART_ISR register."
            },
            {
                "name": "FECF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error clear flag\nWriting 1 to this bit clears the FE flag in the USART_ISR register."
            },
            {
                "name": "NECF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the USART_ISR register."
            },
            {
                "name": "ORECF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the USART_ISR register."
            },
            {
                "name": "IDLECF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the USART_ISR register."
            },
            {
                "name": "TXFECF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TXFIFO empty clear flag\nWriting 1 to this bit clears the TXFE flag in the USART_ISR register."
            },
            {
                "name": "TCCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the USART_ISR register."
            },
            {
                "name": "TCBGTCF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transmission complete before Guard time clear flag\nWriting 1 to this bit clears the TCBGT flag in the USART_ISR register."
            },
            {
                "name": "LBDCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "LIN break detection clear flag\nWriting 1 to this bit clears the LBDF flag in the USART_ISR register.\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "CTSCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the USART_ISR register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "RTOCF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver timeout clear flag\nWriting 1 to this bit clears the RTOF flag in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "EOBCF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "End of block clear flag\nWriting 1 to this bit clears the EOBF flag in the USART_ISR register.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            },
            {
                "name": "UDRCF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SPI slave underrun clear flag\nWriting 1 to this bit clears the UDRF flag in the USART_ISR register.\nNote: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826"
            },
            {
                "name": "CMCF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match clear flag\nWriting 1 to this bit clears the CMF flag in the USART_ISR register."
            },
            {
                "name": "WUCF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wake-up from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the USART_ISR register.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and must be kept at reset value. Refer to Section131.4: USART implementation on page1826."
            }
        ]
    },
    "1073821732": {
        "name": "USART_RDR",
        "address": 1073821732,
        "size": 32,
        "access": "",
        "desc": "USART receive data register",
        "fields": [
            {
                "name": "RDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Receive data value\nContains the received data character.\nThe RDR register provides the parallel interface between the input shift register and the internal bus (see Figure1227).\nWhen receiving with the parity enabled, the value read in the MSB bit is the received parity bit."
            }
        ]
    },
    "1073821736": {
        "name": "USART_TDR",
        "address": 1073821736,
        "size": 32,
        "access": "",
        "desc": "USART transmit data register",
        "fields": [
            {
                "name": "TDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Transmit data value\nContains the data character to be transmitted.\nThe USART_TDR register provides the parallel interface between the internal bus and the output shift register (see Figure1227).\nWhen transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.\nNote: This register must be written only when TXE/TXFNF=1."
            }
        ]
    },
    "1073821740": {
        "name": "USART_PRESC",
        "address": 1073821740,
        "size": 32,
        "access": "",
        "desc": "USART prescaler register",
        "fields": [
            {
                "name": "PRESCALER",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Clock prescaler\nThe USART input clock can be divided by a prescaler factor:\nRemaining combinations: Reserved\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256."
            }
        ]
    },
    "1073765376": {
        "name": "USB_CHEP0R",
        "address": 1073765376,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 0 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode).\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073765380": {
        "name": "USB_CHEP1R",
        "address": 1073765380,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 1 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode).\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073765384": {
        "name": "USB_CHEP2R",
        "address": 1073765384,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 2 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode).\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073765388": {
        "name": "USB_CHEP3R",
        "address": 1073765388,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 3 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode).\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073765392": {
        "name": "USB_CHEP4R",
        "address": 1073765392,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 4 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode).\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073765396": {
        "name": "USB_CHEP5R",
        "address": 1073765396,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 5 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode).\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073765400": {
        "name": "USB_CHEP6R",
        "address": 1073765400,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 6 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode).\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073765404": {
        "name": "USB_CHEP7R",
        "address": 1073765404,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 7 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint (in device mode) or when a SETUP transaction is acknowledged by the device (in host mode).\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits. Table1217 summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Section134.5.3: Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered STALL instead of ACK. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Table1216: Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in Section134.5.5: Isochronous transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Table1215: Reception status encoding on page11025. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX1=11) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only VALID or DISABLED, so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to STALL or NAK for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application must not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (01=1DATA0, 11=1DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device mode), while it sets this bit to 1 when SETUP transaction is acknowledged by device (in host mode).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Section134.5.3: Double-buffered endpoints and usage in Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Section134.5.5: Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application must consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application must read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application must read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073765440": {
        "name": "USB_CNTR",
        "address": 1073765440,
        "size": 32,
        "access": "",
        "desc": "USB control register",
        "fields": [
            {
                "name": "USBRST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USB Reset\nSoftware can set this bit to reset the USB core, exactly as it happens when receiving a RESET signaling on the USB.The USB peripheral, in response to a RESET, resets its internal protocol state machine. Reception and transmission are disabled until the RST_DCON bit is cleared. All configuration registers do not reset: the microcontroller must explicitly clear these registers (this is to ensure that the RST_DCON interrupt can be safely delivered, and any transaction immediately followed by a RESET can be completed). The function address and endpoint registers are reset by an USB reset event.\nSoftware sets this bit to drive USB reset state on the bus and initialize the device. USB reset terminates as soon as this bit is cleared by software."
            },
            {
                "name": "PDWN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Power down\nThis bit is used to completely switch off all USB-related analog parts if it is required to completely disable the USB peripheral for any reason. When this bit is set, the USB peripheral is disconnected from the transceivers and it cannot be used."
            },
            {
                "name": "SUSPRDY",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Suspend state effective\nThis bit is set by hardware as soon as the suspend state entered through the SUSPEN control gets internally effective. In this state USB activity is suspended, USB clock is gated, transceiver is set in low power mode by disabling the differential receiver. Only asynchronous wake-up logic and single ended receiver is kept alive to detect remote wake-up or resume events.\nSoftware must poll this bit to confirm it to be set before any STOP mode entry.\nThis bit is cleared by hardware simultaneously to the WAKEUP flag being set."
            },
            {
                "name": "SUSPEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Suspend state enable\nSoftware can set this bit when the SUSP interrupt is received, which is issued when no traffic is received by the USB peripheral for 31ms. Software can also set this bit when the L1REQ interrupt is received with positive acknowledge sent.\nAs soon as the suspend state is propagated internally all device activity is stopped, USB clock is gated, USB transceiver is set into low power mode and the SUSPRDY bit is set by hardware. In the case that device application wants to pursue more aggressive power saving by stopping the USB clock source and by moving the microcontroller to stop mode, as in the case of bus powered device application, it must first wait few cycles to see the SUSPRDY1=11 acknowledge the suspend request.\nThis bit is cleared by hardware simultaneous with the WAKEUP flag set.\nSoftware can set this bit when host application has nothing scheduled for the next frames and wants to enter long term power saving. When set, it stops immediately SOF generation and any other host activity, gates the USB clock and sets the transceiver in low power mode. If any USB transaction is on-going at the time SUSPEN is set, suspend is entered at the end of the current transaction.\nAs soon as suspend state is propagated internally and gets effective the SUSPRDY bit is set. In the case that host application wants to pursue more aggressive power saving by stopping the USB clock source and by moving the micro-controller to STOP mode, it must first wait few cycles to see SUSPRDY=1 acknowledge to the suspend request.\nThis bit is cleared by hardware simultaneous with the WAKEUP flag set."
            },
            {
                "name": "L2RES",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "L2 remote wake-up / resume driver\nDevice mode\nThe microcontroller can set this bit to send remote wake-up signaling to the host. It must be activated, according to USB specifications, for no less than 11ms and no more than 151ms after which the host PC is ready to drive the resume sequence up to its end.\nHost mode\nSoftware sets this bit to send resume signaling to the device.\nSoftware clears this bit to send end of resume to device and restart SOF generation.\nIn the context of remote wake up, this bit is to be set following the WAKEUP interrupt."
            },
            {
                "name": "L1RES",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "L1 remote wake-up / resume driver"
            },
            {
                "name": "L1REQM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPM L1 state request interrupt mask"
            },
            {
                "name": "ESOFM",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Expected start of frame interrupt mask"
            },
            {
                "name": "SOFM",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Start of frame interrupt mask"
            },
            {
                "name": "RST_DCONM",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "USB reset request (Device mode) or device connect/disconnect (Host mode) interrupt mask"
            },
            {
                "name": "SUSPM",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Suspend mode interrupt mask"
            },
            {
                "name": "WKUPM",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Wake-up interrupt mask"
            },
            {
                "name": "ERRM",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Error interrupt mask"
            },
            {
                "name": "PMAOVRM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Packet memory area over / underrun interrupt mask"
            },
            {
                "name": "CTRM",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Correct transfer interrupt mask"
            },
            {
                "name": "THR512M",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "512 byte threshold interrupt mask"
            },
            {
                "name": "DDISCM",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Device disconnection mask\nHost mode"
            },
            {
                "name": "HOST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "HOST mode\nHOST bit selects betweens host or device USB mode of operation. It must be set before enabling the USB peripheral by the function enable bit."
            }
        ]
    },
    "1073765444": {
        "name": "USB_ISTR",
        "address": 1073765444,
        "size": 32,
        "access": "",
        "desc": "USB interrupt status register",
        "fields": [
            {
                "name": "IDN",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Device Endpoint / host channel identification number\nThese bits are written by the hardware according to the host channel or device endpoint number, which generated the interrupt request. If several endpoint/channel transactions are pending, the hardware writes the identification number related to the endpoint/channel having the highest priority defined in the following way: two levels are defined, in order of priority: isochronous and double-buffered bulk channels/endpoints are considered first and then the others are examined. If more than one endpoint/channel from the same set is requesting an interrupt, the IDN bits in USB_ISTR register are assigned according to the lowest requesting register, CHEP0R having the highest priority followed by CHEP1R and so on. The application software can assign a register to each endpoint/channel according to this priority scheme, so as to order the concurring endpoint/channel requests in a suitable way. These bits are read only."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction of transaction\nThis bit is written by the hardware according to the direction of the successful transaction, which generated the interrupt request.\nIf DIR bit1=10, VTTX bit is set in the USB_CHEPnR register related to the interrupting endpoint. The interrupting transaction is of IN type (data transmitted by the USB peripheral to the host PC).\nIf DIR bit1=11, VTRX bit or both VTTX/VTRX are set in the USB_CHEPnR register related to the interrupting endpoint. The interrupting transaction is of OUT type (data received by the USB peripheral from the host PC) or two pending transactions are waiting to be processed.\nThis information can be used by the application software to access the USB_CHEPnR bits related to the triggering transaction since it represents the direction having the interrupt pending. This bit is read-only."
            },
            {
                "name": "L1REQ",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPM L1 state request\nDevice mode\nThis bit is set by the hardware when LPM command to enter the L1 state is successfully received and acknowledged. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "ESOF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Expected start of frame\nDevice mode\nThis bit is set by the hardware when an SOF packet is expected but not received. The host sends an SOF packet each 11ms, but if the device does not receive it properly, the suspend timer issues this interrupt. If three consecutive ESOF interrupts are generated (for example three SOF packets are lost) without any traffic occurring in between, a SUSP interrupt is generated. This bit is set even when the missing SOF packets occur while the suspend timer is not yet locked. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "SOF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Start of frame\nThis bit signals the beginning of a new USB frame and it is set when a SOF packet arrives through the USB bus. The interrupt service routine may monitor the SOF events to have a 11ms synchronization event to the USB host and to safely read the USB_FNR register which is updated at the SOF packet reception (this can be useful for isochronous applications). This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "RST_DCON",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "USB reset request (Device mode) or device connect/disconnect (Host mode)\nDevice mode\nThis bit is set by hardware when an USB reset is released by the host and the bus returns to idle. USB reset state is internally detected after the sampling of 60 consecutive SE0 cycles.\nHost mode\nThis bit is set by hardware when device connection or device disconnection is detected. Device connection is signaled after J state is sampled for 22 cycles consecutively from unconnected state. Device disconnection is signaled after SE0 state is seen for 22 bit times consecutively from connected state."
            },
            {
                "name": "SUSP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Suspend mode request\nDevice mode\nThis bit is set by the hardware when no traffic has been received for 31ms, indicating a suspend mode request from the USB bus. The suspend condition check is enabled immediately after any USB reset and it is disabled by the hardware when the suspend mode is active (SUSPEN=1) until the end of resume sequence. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "WKUP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Wake-up\nThis bit is set to 1 by the hardware when, during suspend mode, activity is detected that wakes up the USB peripheral. This event asynchronously clears the SUSPRDY bit in the CTLR register and activates the USB_WAKEUP line, which can be used to notify the rest of the device (for example wake-up unit) about the start of the resume process. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "ERR",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Error\nThis flag is set whenever one of the errors listed below has occurred:\nNANS:\tNo ANSwer. The timeout for a host response has expired.\nCRC:\tCyclic redundancy check error. One of the received CRCs, either in the token or in the data, was wrong.\nBST:\tBit stuffing error. A bit stuffing error was detected anywhere in the PID, data, and/or CRC.\nFVIO:\tFraming format violation. A non-standard frame was received (EOP not in the right place, wrong token sequence, etc.).\nThe USB software can usually ignore errors, since the USB peripheral and the PC host manage retransmission in case of errors in a fully transparent way. This interrupt can be useful during the software development phase, or to monitor the quality of transmission over the USB bus, to flag possible problems to the user (for example loose connector, too noisy environment, broken conductor in the USB cable and so on). This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "PMAOVR",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Packet memory area over / underrun\nThis bit is set if the microcontroller has not been able to respond in time to an USB memory request. The USB peripheral handles this event in the following way: During reception an ACK handshake packet is not sent, during transmission a bit-stuff error is forced on the transmitted stream; in both cases the host retries the transaction. The PMAOVR interrupt must never occur during normal operations. Since the failed transaction is retried by the host, the application software has the chance to speed-up device operations during this interrupt handling, to be ready for the next transaction retry; however this does not happen during isochronous transfers (no isochronous transaction is anyway retried) leading to a loss of data in this case. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "CTR",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Completed transfer in host mode\nThis bit is set by the hardware to indicate that an endpoint/channel has successfully completed a transaction; using DIR and IDN bits software can determine which endpoint/channel requested the interrupt. This bit is read-only."
            },
            {
                "name": "THR512",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "512 byte threshold interrupt\nThis bit is set to 1 by the hardware when 512 bytes have been transmitted or received during isochronous transfers. This bit is read/write but only 0 can be written and writing 1 has no effect. Note that no information is available to indicate the associated channel/endpoint, however in practice only one ISO endpoint/channel with such large packets can be supported, so that channel."
            },
            {
                "name": "DDISC",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Device connection\nHost mode\nThis bit is set when a device connection is detected. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "DCON_STAT",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Device connection status\nHost mode:\nThis bit contains information about device connection status. It is set by hardware when a LS/FS device is attached to the host while it is reset when the device is disconnected."
            },
            {
                "name": "LS_DCON",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Low speed device connected\nHost mode:\nThis bit is set by hardware when an LS device connection is detected. Device connection is signaled after LS J-state is sampled for 22 consecutive cycles of the USB clock (481MHz) from the unconnected state."
            }
        ]
    },
    "1073765448": {
        "name": "USB_FNR",
        "address": 1073765448,
        "size": 32,
        "access": "",
        "desc": "USB frame number register",
        "fields": [
            {
                "name": "FN",
                "bitOffset": 0,
                "bitWidth": 11,
                "desc": "Frame number\nThis bit field contains the 11-bits frame number contained in the last received SOF packet. The frame number is incremented for every frame sent by the host and it is useful for isochronous transfers. This bit field is updated on the generation of an SOF interrupt."
            },
            {
                "name": "LSOF",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "Lost SOF\nDevice mode\nThese bits are written by the hardware when an ESOF interrupt is generated, counting the number of consecutive SOF packets lost. At the reception of an SOF packet, these bits are cleared."
            },
            {
                "name": "LCK",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Locked\nDevice mode\nThis bit is set by the hardware when at least two consecutive SOF packets have been received after the end of an USB reset condition or after the end of an USB resume sequence. Once locked, the frame timer remains in this state until an USB reset or USB suspend event occurs."
            },
            {
                "name": "RXDM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Receive data - line status\nThis bit can be used to observe the status of received data minus upstream port data line. It can be used during end-of-suspend routines to help determining the wake-up event."
            },
            {
                "name": "RXDP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Receive data + line status\nThis bit can be used to observe the status of received data plus upstream port data line. It can be used during end-of-suspend routines to help determining the wake-up event."
            }
        ]
    },
    "1073765452": {
        "name": "USB_DADDR",
        "address": 1073765452,
        "size": 32,
        "access": "",
        "desc": "USB Device address",
        "fields": [
            {
                "name": "ADD",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Device address\nDevice mode\nThese bits contain the USB function address assigned by the host PC during the enumeration process. Both this field and the endpoint/channel address (EA) field in the associated USB_CHEPnR register must match with the information contained in a USB token in order to handle a transaction to the required endpoint.\nHost mode\nThese bits contain the address transmitted with the LPM transaction"
            },
            {
                "name": "EF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Enable function\nThis bit is set by the software to enable the USB Device. The address of this device is contained in the following ADD[6:0] bits. If this bit is at 0 no transactions are handled, irrespective of the settings of USB_CHEPnR registers."
            }
        ]
    },
    "1073765460": {
        "name": "USB_LPMCSR",
        "address": 1073765460,
        "size": 32,
        "access": "",
        "desc": "LPM control and status register",
        "fields": [
            {
                "name": "LPMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPM support enable\nDevice mode\nThis bit is set by the software to enable the LPM support within the USB Device. If this bit is at 0 no LPM transactions are handled."
            },
            {
                "name": "LPMACK",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPM token acknowledge enable\nDevice mode:\nThe NYET/ACK is returned only on a successful LPM transaction:\nNo errors in both the EXT token and the LPM token (else ERROR)\nA valid bLinkState = 0001B (L1) is received (else STALL)"
            },
            {
                "name": "REMWAKE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "bRemoteWake value\nDevice mode\nThis bit contains the bRemoteWake value received with last ACKed LPM Token"
            },
            {
                "name": "BESL",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "BESL value\nDevice mode\nThese bits contain the BESL value received with last ACKed LPM Token"
            }
        ]
    },
    "1073765464": {
        "name": "USB_BCDR",
        "address": 1073765464,
        "size": 32,
        "access": "",
        "desc": "Battery charging detector",
        "fields": [
            {
                "name": "BCDEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Battery charging detector (BCD) enable\nDevice mode\nThis bit is set by the software to enable the BCD support within the USB Device. When enabled, the USB PHY is fully controlled by BCD and cannot be used for normal communication. Once the BCD discovery is finished, the BCD must be placed in OFF mode by clearing this bit to 0 in order to allow the normal USB operation."
            },
            {
                "name": "DCDEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Data contact detection (DCD) mode enable\nDevice mode\nThis bit is set by the software to put the BCD into DCD mode. Only one detection mode (DCD, PD, SD or OFF) must be selected to work correctly."
            },
            {
                "name": "PDEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Primary detection (PD) mode enable\nDevice mode\nThis bit is set by the software to put the BCD into PD mode. Only one detection mode (DCD, PD, SD or OFF) must be selected to work correctly."
            },
            {
                "name": "SDEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Secondary detection (SD) mode enable\nDevice mode\nThis bit is set by the software to put the BCD into SD mode. Only one detection mode (DCD, PD, SD or OFF) must be selected to work correctly."
            },
            {
                "name": "DCDET",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Data contact detection (DCD) status\nDevice mode\nThis bit gives the result of DCD."
            },
            {
                "name": "PDET",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Primary detection (PD) status\nDevice mode\nThis bit gives the result of PD."
            },
            {
                "name": "SDET",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Secondary detection (SD) status\nDevice mode\nThis bit gives the result of SD."
            },
            {
                "name": "PS2DET",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DM pull-up detection status\nDevice mode\nThis bit is active only during PD and gives the result of comparison between DM voltage level and V<sub>LGC</sub> threshold. In normal situation, the DM level must be below this threshold. If it is above, it means that the DM is externally pulled high. This can be caused by connection to a PS2 port (which pulls-up both DP and DM lines) or to some proprietary charger not following the BCD specification."
            },
            {
                "name": "DPPU_DPD",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DP pull-up / DPDM pull-down\nDevice mode\nThis bit is set by software to enable the embedded pull-up on DP line. Clearing it to 0 can be used to signal disconnect to the host when needed by the user software.\nHost mode\nThis bit is set by software to enable the embedded pull-down on DP and DM lines."
            }
        ]
    },
    "1073807408": {
        "name": "VREFBUF_CSR",
        "address": 1073807408,
        "size": 32,
        "access": "",
        "desc": "VREFBUF control and status register",
        "fields": [
            {
                "name": "ENVR",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Voltage reference buffer mode enable\nThis bit is used to enable the voltage reference buffer mode."
            },
            {
                "name": "HIZ",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "High impedance mode\nThis bit controls the analog switch to connect or not the V<sub>REF+</sub> pin.\nRefer to Table172: VREF buffer modes for the mode descriptions depending on ENVR bit configuration."
            },
            {
                "name": "VRS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Voltage reference scale\nThis bit selects the value generated by the voltage reference buffer."
            },
            {
                "name": "VRR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Voltage reference buffer ready"
            }
        ]
    },
    "1073807412": {
        "name": "VREFBUF_CCR",
        "address": 1073807412,
        "size": 32,
        "access": "",
        "desc": "VREFBUF calibration control register",
        "fields": [
            {
                "name": "TRIM",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "None"
            }
        ]
    },
    "1073753088": {
        "name": "WWDG_CR",
        "address": 1073753088,
        "size": 32,
        "access": "",
        "desc": "WWDG control register",
        "fields": [
            {
                "name": "T",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "7-bit counter (MSB to LSB)\nThese bits contain the value of the watchdog counter, decremented every\n(4096 x 2<sup>WDGTB[2:0]</sup>) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared)."
            },
            {
                "name": "WDGA",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Activation bit\nThis bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset."
            }
        ]
    },
    "1073753092": {
        "name": "WWDG_CFR",
        "address": 1073753092,
        "size": 32,
        "access": "",
        "desc": "WWDG configuration register",
        "fields": [
            {
                "name": "W",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "7-bit window value\nThese bits contain the window value to be compared with the down-counter."
            },
            {
                "name": "EWI",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Early wake-up interrupt enable\nSet by software and cleared by hardware after a reset. When set, an interrupt occurs whenever the counter reaches the value 0x40."
            },
            {
                "name": "WDGTB",
                "bitOffset": 11,
                "bitWidth": 3,
                "desc": "Timer base\nThe timebase of the prescaler can be modified as follows:"
            }
        ]
    },
    "1073753096": {
        "name": "WWDG_SR",
        "address": 1073753096,
        "size": 32,
        "access": "",
        "desc": "WWDG status register",
        "fields": [
            {
                "name": "EWIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Early wake-up interrupt flag\nThis bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. Writing 1 has no effect. This bit is also set if the interrupt is not enabled."
            }
        ]
    }
}