{
    "1107460096": {
        "name": "ADC_ISR",
        "address": 1107460096,
        "size": 32,
        "access": "",
        "desc": "ADC interrupt and status register ",
        "fields": [
            {
                "name": "ADRDY",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC ready\nThis bit is set by hardware after the ADC has been enabled (ADEN = 1) and when the ADC reaches a state where it is ready to accept conversion requests.\nIt is cleared by software writing 1 to it."
            },
            {
                "name": "EOSMP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "End of sampling flag\nThis bit is set by hardware during the conversion of any channel (only for regular channels), at the end of the sampling phase."
            },
            {
                "name": "EOC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "End of conversion flag\nThis bit is set by hardware at the end of each regular conversion of a channel when a new data is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register"
            },
            {
                "name": "EOS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "End of regular sequence flag\nThis bit is set by hardware at the end of the conversions of a regular sequence of channels. It is cleared by software writing 1 to it."
            },
            {
                "name": "OVR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "ADC overrun\nThis bit is set by hardware when an overrun occurs on a regular channel, meaning that a new conversion has completed while the EOC flag was already set. It is cleared by software writing 1 to it."
            },
            {
                "name": "JEOC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Injected channel end of conversion flag\nThis bit is set by hardware at the end of each injected conversion of a channel when a new data is available in the corresponding ADC_JDRy register. It is cleared by software writing 1 to it or by reading the corresponding ADC_JDRy register"
            },
            {
                "name": "JEOS",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Injected channel end of sequence flag\nThis bit is set by hardware at the end of the conversions of all injected channels in the group. It is cleared by software writing 1 to it."
            },
            {
                "name": "AWD1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog 1 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in the fields LT1[11:0] and HT1[11:0] of ADC_TR1 register. It is cleared by software. writing 1 to it."
            },
            {
                "name": "AWD2",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog 2 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in the fields LT2[7:0] and HT2[7:0] of ADC_TR2 register. It is cleared by software writing 1 to it."
            },
            {
                "name": "AWD3",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog 3 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in the fields LT3[7:0] and HT3[7:0] of ADC_TR3 register. It is cleared by software writing 1 to it."
            },
            {
                "name": "JQOVF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Injected context queue overflow\nThis bit is set by hardware when an Overflow of the Injected Queue of Context occurs. It is cleared by software writing 1 to it. Refer to  for more information."
            }
        ]
    },
    "1107460100": {
        "name": "ADC_IER",
        "address": 1107460100,
        "size": 32,
        "access": "",
        "desc": "ADC interrupt enable register ",
        "fields": [
            {
                "name": "ADRDYIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC ready interrupt enable\nThis bit is set and cleared by software to enable/disable the ADC Ready interrupt.\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "EOSMPIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "End of sampling flag interrupt enable for regular conversions\nThis bit is set and cleared by software to enable/disable the end of the sampling phase interrupt for regular conversions.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "EOCIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "End of regular conversion interrupt enable\nThis bit is set and cleared by software to enable/disable the end of a regular conversion interrupt.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "EOSIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "End of regular sequence of conversions interrupt enable\nThis bit is set and cleared by software to enable/disable the end of regular sequence of conversions interrupt.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "OVRIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Overrun interrupt enable\nThis bit is set and cleared by software to enable/disable the Overrun interrupt of a regular conversion.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "JEOCIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "End of injected conversion interrupt enable\nThis bit is set and cleared by software to enable/disable the end of an injected conversion interrupt.\nNote: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            },
            {
                "name": "JEOSIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "End of injected sequence of conversions interrupt enable\nThis bit is set and cleared by software to enable/disable the end of injected sequence of conversions interrupt.\nNote: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            },
            {
                "name": "AWD1IE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog 1 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog 1 interrupt.\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2IE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog 2 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog 2 interrupt.\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3IE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog 3 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog 2 interrupt.\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "JQOVFIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Injected context queue overflow interrupt enable\nThis bit is set and cleared by software to enable/disable the Injected Context Queue Overflow interrupt.\nNote: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            }
        ]
    },
    "1107460104": {
        "name": "ADC_CR",
        "address": 1107460104,
        "size": 32,
        "access": "",
        "desc": "ADC control register ",
        "fields": [
            {
                "name": "ADEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC enable control\nThis bit is set by software to enable the ADC. The ADC is effectively ready to operate once the flag ADRDY has been set.\nIt is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.\nNote: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0) except for bit ADVREGEN which must be 1 (and the software must have wait for the startup time of the voltage regulator)"
            },
            {
                "name": "ADDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ADC disable command\nThis bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state).\nIt is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time).\nNote: The software is allowed to set ADDIS only when ADEN = 1 and both ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)"
            },
            {
                "name": "ADSTART",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "ADC start of regular conversion\nThis bit is set by software to start ADC conversion of regular channels. Depending on the configuration bits EXTEN, a conversion immediately starts (software trigger configuration) or once a regular hardware trigger event occurs (hardware trigger configuration).\nIt is cleared by hardware:\nin Single conversion mode when software trigger is selected (EXTSEL = 0x0): at the assertion of the End of Regular Conversion Sequence (EOS) flag.\nin all cases: after the execution of the ADSTP command, at the same time that ADSTP is cleared by hardware.\nNote: The software is allowed to set ADSTART only when ADEN = 1 and ADDIS = 0 (ADC is enabled and there is no pending request to disable the ADC)\nIn auto-injection mode (JAUTO = 1), regular and auto-injected conversions are started by setting bit ADSTART (JADSTART must be kept cleared)"
            },
            {
                "name": "JADSTART",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "ADC start of injected conversion\nThis bit is set by software to start ADC conversion of injected channels. Depending on the configuration bits JEXTEN, a conversion immediately starts (software trigger configuration) or once an injected hardware trigger event occurs (hardware trigger configuration).\nIt is cleared by hardware:\nin Single conversion mode when software trigger is selected (JEXTSEL = 0x0): at the assertion of the End of Injected Conversion Sequence (JEOS) flag.\nin all cases: after the execution of the JADSTP command, at the same time that JADSTP is cleared by hardware.\nNote: The software is allowed to set JADSTART only when ADEN = 1 and ADDIS = 0 (ADC is enabled and there is no pending request to disable the ADC).\nIn auto-injection mode (JAUTO = 1), regular and auto-injected conversions are started by setting bit ADSTART (JADSTART must be kept cleared)"
            },
            {
                "name": "ADSTP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "ADC stop of regular conversion command\nThis bit is set by software to stop and discard an ongoing regular conversion (ADSTP Command).\nIt is cleared by hardware when the conversion is effectively discarded and the ADC regular sequence and triggers can be re-configured. The ADC is then ready to accept a new start of regular conversions (ADSTART command).\nNote: The software is allowed to set ADSTP only when ADSTART = 1 and ADDIS = 0 (ADC is enabled and eventually converting a regular conversion and there is no pending request to disable the ADC).\nIn auto-injection mode (JAUTO = 1), setting ADSTP bit aborts both regular and injected conversions (do not use JADSTP)."
            },
            {
                "name": "JADSTP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "ADC stop of injected conversion command\nThis bit is set by software to stop and discard an ongoing injected conversion (JADSTP Command).\nIt is cleared by hardware when the conversion is effectively discarded and the ADC injected sequence and triggers can be re-configured. The ADC is then ready to accept a new start of injected conversions (JADSTART command).\nNote: The software is allowed to set JADSTP only when JADSTART = 1 and ADDIS = 0 (ADC is enabled and eventually converting an injected conversion and there is no pending request to disable the ADC)\nIn Auto-injection mode (JAUTO = 1), setting ADSTP bit aborts both regular and injected conversions (do not use JADSTP)"
            },
            {
                "name": "ADVREGEN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "ADC voltage regulator enable\nThis bits is set by software to enable the ADC voltage regulator.\nBefore performing any operation such as launching a calibration or enabling the ADC, the ADC voltage regulator must first be enabled and the software must wait for the regulator start-up time.\nFor more details about the ADC voltage regulator enable and disable sequences, refer to (ADVREGEN).\nThe software can program this bit field only when the ADC is disabled (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0)."
            },
            {
                "name": "DEEPPWD",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Deep-power-down enable\nThis bit is set and cleared by software to put the ADC in Deep-power-down mode.\nNote: The software is allowed to write this bit only when the ADC is disabled (ADCAL = 0, JADSTART = 0, JADSTP = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0)."
            },
            {
                "name": "ADCALDIF",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Differential mode for calibration\nThis bit is set and cleared by software to configure the Single-ended or Differential inputs mode for the calibration.\nNote: The software is allowed to write this bit only when the ADC is disabled and is not calibrating (ADCAL = 0, JADSTART = 0, JADSTP = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0)."
            },
            {
                "name": "ADCAL",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "ADC calibration\nThis bit is set by software to start the calibration of the ADC. Program first the bit ADCALDIF to determine if this calibration applies for Single-ended or Differential inputs mode.\nIt is cleared by hardware after calibration is complete.\nNote: The software is allowed to launch a calibration by setting ADCAL only when ADEN = 0.\nThe software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN = 1 and ADSTART = 0 and JADSTART = 0 (ADC enabled and no conversion is ongoing)"
            }
        ]
    },
    "1107460108": {
        "name": "ADC_CFGR",
        "address": 1107460108,
        "size": 32,
        "access": "",
        "desc": "ADC configuration register ",
        "fields": [
            {
                "name": "DMAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Direct memory access enable\nThis bit is set and cleared by software to enable the generation of DMA requests. This allows to use the DMA to manage automatically the converted data. For more details, refer to conversions using the DMA.\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "DMACFG",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Direct memory access configuration\nThis bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN = 1.\nFor more details, refer to\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "RES",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Data resolution\nThese bits are written by software to select the resolution of the conversion.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "EXTSEL",
                "bitOffset": 5,
                "bitWidth": 5,
                "desc": "External trigger selection for regular group\nThese bits select the external event used to trigger the start of conversion of a regular group:\n...\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "EXTEN",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "External trigger enable and polarity selection for regular channels\nThese bits are set and cleared by software to select the external trigger polarity and enable the trigger of a regular group.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "OVRMOD",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun mode\nThis bit is set and cleared by software and configure the way data overrun is managed.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "CONT",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Single / Continuous conversion mode for regular conversions\nThis bit is set and cleared by software. If it is set, regular conversion takes place continuously until it is cleared.\nNote: It is not possible to have both Discontinuous mode and Continuous mode enabled: it is forbidden to set both DISCEN = 1 and CONT = 1.\nThe software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "AUTDLY",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Delayed conversion mode\nThis bit is set and cleared by software to enable/disable the Auto Delayed Conversion mode..\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "ALIGN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Data alignment\nThis bit is set and cleared by software to select right or left alignment. Refer to register, data alignment and offset (ADC_DR, OFFSET, OFFSET_CH, ALIGN).\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "DISCEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Discontinuous mode for regular channels\nThis bit is set and cleared by software to enable/disable Discontinuous mode for regular channels.\nNote: It is not possible to have both Discontinuous mode and Continuous mode enabled: it is forbidden to set both DISCEN = 1 and CONT = 1.\nIt is not possible to use both auto-injected mode and Discontinuous mode simultaneously: the bits DISCEN and JDISCEN must be kept cleared by software when JAUTO is set.\nThe software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "DISCNUM",
                "bitOffset": 17,
                "bitWidth": 3,
                "desc": "Discontinuous mode channel count\nThese bits are written by software to define the number of regular channels to be converted in Discontinuous mode, after receiving an external trigger.\n...\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "JDISCEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Discontinuous mode on injected channels\nThis bit is set and cleared by software to enable/disable Discontinuous mode on the injected channels of a group.\nNote: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing).\nIt is not possible to use both auto-injected mode and Discontinuous mode simultaneously: the bits DISCEN and JDISCEN must be kept cleared by software when JAUTO is set."
            },
            {
                "name": "JQM",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "JSQR queue mode\nThis bit is set and cleared by software.\nIt defines how an empty Queue is managed.\nRefer to  for more information.\nNote: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            },
            {
                "name": "AWD1SGL",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Enable the watchdog 1 on a single channel or on all channels\nThis bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWD1CH[4:0] bits or on all the channels\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD1EN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Analog watchdog 1 enable on regular channels\nThis bit is set and cleared by software\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "JAWD1EN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Analog watchdog 1 enable on injected channels\nThis bit is set and cleared by software\nNote: The software is allowed to write this bit only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            },
            {
                "name": "JAUTO",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Automatic injected group conversion\nThis bit is set and cleared by software to enable/disable automatic injected group conversion after regular group conversion.\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no regular nor injected conversion is ongoing)."
            },
            {
                "name": "AWD1CH",
                "bitOffset": 26,
                "bitWidth": 5,
                "desc": "Analog watchdog 1 channel selection\nThese bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.\n.....\nothers: reserved, must not be used\nNote: Some channels are not connected physically. Keep the corresponding AWD1CH[4:0] setting to the reset value.\nThe channel selected by AWD1CH must be also selected into the SQRi or JSQRi registers.\nThe software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "JQDIS",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Injected Queue disable\nThese bits are set and cleared by software to disable the Injected Queue mechanism :\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no regular nor injected conversion is ongoing).\nA set or reset of JQDIS bit causes the injected queue to be flushed and the JSQR register is cleared."
            }
        ]
    },
    "1107460112": {
        "name": "ADC_CFGR2",
        "address": 1107460112,
        "size": 32,
        "access": "",
        "desc": "ADC configuration register 2 ",
        "fields": [
            {
                "name": "ROVSE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Regular Oversampling Enable\nThis bit is set and cleared by software to enable regular oversampling.\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)"
            },
            {
                "name": "JOVSE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Injected Oversampling Enable\nThis bit is set and cleared by software to enable injected oversampling.\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)"
            },
            {
                "name": "OVSR",
                "bitOffset": 2,
                "bitWidth": 3,
                "desc": "Oversampling ratio\nThis bitfield is set and cleared by software to define the oversampling ratio.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "OVSS",
                "bitOffset": 5,
                "bitWidth": 4,
                "desc": "Oversampling shift\nThis bitfield is set and cleared by software to define the right shifting applied to the raw oversampling result.\nOther codes reserved\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "TROVS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Triggered Regular Oversampling\nThis bit is set and cleared by software to enable triggered oversampling\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "ROVSM",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Regular Oversampling mode\nThis bit is set and cleared by software to select the regular oversampling mode.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SWTRIG",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Software trigger bit for sampling time control trigger mode\nThis bit is set and cleared by software to enable the bulb sampling mode.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "BULB",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Bulb sampling mode\nThis bit is set and cleared by software to enable the bulb sampling mode.\nSAMPTRIG bit must not be set when the BULB bit is set.\nThe very first ADC conversion is performed with the sampling time specified in SMPx bits.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPTRIG",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Sampling time control trigger mode\nThis bit is set and cleared by software to enable the sampling time control trigger mode.\nThe sampling time starts on the trigger rising edge, and the conversion on the trigger falling edge.\nEXTEN bit should be set to 01. BULB bit must not be set when the SMPTRIG bit is set.\nWhen EXTEN bit is set to 00, set SWTRIG to start the sampling and clear SWTRIG bit to start the conversion.\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1107460116": {
        "name": "ADC_SMPR1",
        "address": 1107460116,
        "size": 32,
        "access": "",
        "desc": "ADC sample time register 1 ",
        "fields": [
            {
                "name": "SMP0",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP1",
                "bitOffset": 3,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP2",
                "bitOffset": 6,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP3",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP4",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP5",
                "bitOffset": 15,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP6",
                "bitOffset": 18,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP7",
                "bitOffset": 21,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP8",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP9",
                "bitOffset": 27,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sample cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMPPLUS",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Addition of one clock cycle to the sampling time.\nTo make sure no conversion is ongoing, the software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0."
            }
        ]
    },
    "1107460120": {
        "name": "ADC_SMPR2",
        "address": 1107460120,
        "size": 32,
        "access": "",
        "desc": "ADC sample time register 2 ",
        "fields": [
            {
                "name": "SMP10",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP11",
                "bitOffset": 3,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP12",
                "bitOffset": 6,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP13",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP14",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP15",
                "bitOffset": 15,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP16",
                "bitOffset": 18,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP17",
                "bitOffset": 21,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP18",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            },
            {
                "name": "SMP19",
                "bitOffset": 27,
                "bitWidth": 3,
                "desc": "Channel x sampling time selection\nThese bits are written by software to select the sampling time individually for each channel. During sampling cycles, the channel selection bits must remain unchanged.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically. Keep the corresponding SMPx[2:0] setting to the reset value."
            }
        ]
    },
    "1107460128": {
        "name": "ADC_TR1",
        "address": 1107460128,
        "size": 32,
        "access": "",
        "desc": "ADC watchdog threshold register 1 ",
        "fields": [
            {
                "name": "LT1",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Analog watchdog 1 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog 1.\nRefer to AWD2CH, AWD3CH, AWD_HTx, AWD_LTx, AWDx)\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWDFILT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Analog watchdog filtering parameter\nThis bit is set and cleared by software.\n...\nNote: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "HT1",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Analog watchdog 1 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog 1.\nRefer to AWD2CH, AWD3CH, AWD_HTx, AWD_LTx, AWDx)\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1107460132": {
        "name": "ADC_TR2",
        "address": 1107460132,
        "size": 32,
        "access": "",
        "desc": "ADC watchdog threshold register 2 ",
        "fields": [
            {
                "name": "LT2",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Analog watchdog 2 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog 2.\nRefer to AWD2CH, AWD3CH, AWD_HTx, AWD_LTx, AWDx)\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "HT2",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Analog watchdog 2 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog 2.\nRefer to AWD2CH, AWD3CH, AWD_HTx, AWD_LTx, AWDx)\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1107460136": {
        "name": "ADC_TR3",
        "address": 1107460136,
        "size": 32,
        "access": "",
        "desc": "ADC watchdog threshold register 3 ",
        "fields": [
            {
                "name": "LT3",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Analog watchdog 3 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog 3.\nThis watchdog compares the 8-bit of LT3 with the 8 MSB of the converted data.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "HT3",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Analog watchdog 3 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog 3.\nRefer to AWD2CH, AWD3CH, AWD_HTx, AWD_LTx, AWDx)\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1107460144": {
        "name": "ADC_SQR1",
        "address": 1107460144,
        "size": 32,
        "access": "",
        "desc": "ADC regular sequence register 1 ",
        "fields": [
            {
                "name": "L",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Regular channel sequence length\nThese bits are written by software to define the total number of conversions in the regular channel conversion sequence.\n...\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ1",
                "bitOffset": 6,
                "bitWidth": 5,
                "desc": "1st conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 1st in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ2",
                "bitOffset": 12,
                "bitWidth": 5,
                "desc": "2nd conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 2nd in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ3",
                "bitOffset": 18,
                "bitWidth": 5,
                "desc": "3rd conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 3rd in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ4",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "4th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 4th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            }
        ]
    },
    "1107460148": {
        "name": "ADC_SQR2",
        "address": 1107460148,
        "size": 32,
        "access": "",
        "desc": "ADC regular sequence register 2 ",
        "fields": [
            {
                "name": "SQ5",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "5th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 5th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ6",
                "bitOffset": 6,
                "bitWidth": 5,
                "desc": "6th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 6th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ7",
                "bitOffset": 12,
                "bitWidth": 5,
                "desc": "7th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 7th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ8",
                "bitOffset": 18,
                "bitWidth": 5,
                "desc": "8th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 8th in the regular conversion sequence\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ9",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "9th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 9th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            }
        ]
    },
    "1107460152": {
        "name": "ADC_SQR3",
        "address": 1107460152,
        "size": 32,
        "access": "",
        "desc": "ADC regular sequence register 3 ",
        "fields": [
            {
                "name": "SQ10",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "10th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 10th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ11",
                "bitOffset": 6,
                "bitWidth": 5,
                "desc": "11th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 11th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ12",
                "bitOffset": 12,
                "bitWidth": 5,
                "desc": "12th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 12th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ13",
                "bitOffset": 18,
                "bitWidth": 5,
                "desc": "13th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 13th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ14",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "14th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 14th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            }
        ]
    },
    "1107460156": {
        "name": "ADC_SQR4",
        "address": 1107460156,
        "size": 32,
        "access": "",
        "desc": "ADC regular sequence register 4 ",
        "fields": [
            {
                "name": "SQ15",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "15th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 15th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            },
            {
                "name": "SQ16",
                "bitOffset": 6,
                "bitWidth": 5,
                "desc": "16th conversion in regular sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 16th in the regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART = 0 (which ensures that no regular conversion is ongoing)."
            }
        ]
    },
    "1107460160": {
        "name": "ADC_DR",
        "address": 1107460160,
        "size": 32,
        "access": "",
        "desc": "ADC regular data register ",
        "fields": [
            {
                "name": "RDATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Regular data converted\nThese bits are read-only. They contain the conversion result from the last converted regular channel. The data are left- or right-aligned as described in ."
            }
        ]
    },
    "1107460172": {
        "name": "ADC_JSQR",
        "address": 1107460172,
        "size": 32,
        "access": "",
        "desc": "ADC injected sequence register ",
        "fields": [
            {
                "name": "JL",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Injected channel sequence length\nThese bits are written by software to define the total number of conversions in the injected channel conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            },
            {
                "name": "JEXTSEL",
                "bitOffset": 2,
                "bitWidth": 5,
                "desc": "External Trigger Selection for injected group\nThese bits select the external event used to trigger the start of conversion of an injected group:\n...\nNote: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            },
            {
                "name": "JEXTEN",
                "bitOffset": 7,
                "bitWidth": 2,
                "desc": "External trigger enable and polarity selection for injected channels\nThese bits are set and cleared by software to select the external trigger polarity and enable the trigger of an injected group.\nNote: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing).\nIf JQM = 1 and if the Queue of Context becomes empty, the software and hardware triggers of the injected sequence are both internally disabled (refer to Queue of context for injected conversions)"
            },
            {
                "name": "JSQ1",
                "bitOffset": 9,
                "bitWidth": 5,
                "desc": "1st conversion in the injected sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 1st in the injected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            },
            {
                "name": "JSQ2",
                "bitOffset": 15,
                "bitWidth": 5,
                "desc": "2nd conversion in the injected sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 2nd in the injected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            },
            {
                "name": "JSQ3",
                "bitOffset": 21,
                "bitWidth": 5,
                "desc": "3rd conversion in the injected sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 3rd in the injected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            },
            {
                "name": "JSQ4",
                "bitOffset": 27,
                "bitWidth": 5,
                "desc": "4th conversion in the injected sequence\nThese bits are written by software with the channel number (0 to 19) assigned as the 4th in the injected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART = 0 (which ensures that no injected conversion is ongoing)."
            }
        ]
    },
    "1107460192": {
        "name": "ADC_OFR1",
        "address": 1107460192,
        "size": 32,
        "access": "",
        "desc": "ADC offset 1 register",
        "fields": [
            {
                "name": "OFFSET",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Data offset y for the channel programmed into bits OFFSET_CH[4:0]\nThese bits are written by software to define the offset to be subtracted from the raw converted data when converting a channel (can be regular or injected). The channel to which applies the data offset must be programmed in the bits OFFSET_CH[4:0]. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion).\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nIf several offset (OFFSET) point to the same channel, only the offset with the lowest x value is considered for the subtraction.\nEx: if OFFSET1_CH[4:0] = 4 and OFFSET2_CH[4:0] = 4, this is OFFSET1[11:0] which is subtracted when converting channel 4."
            },
            {
                "name": "OFFSETPOS",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Positive offset\nThis bit is set and cleared by software to enable the positive offset.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SATEN",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Saturation enable\nThis bit is set and cleared by software to enable the saturation at 0x000 and 0xFFF for the offset function.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "OFFSET_CH",
                "bitOffset": 26,
                "bitWidth": 5,
                "desc": "Channel selection for the data offset y\nThese bits are written by software to define the channel to which the offset programmed into bits OFFSET[11:0] applies.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically and must not be selected for the data offset y.\nIf OFFSET_EN is set, it is not allowed to select the same channel for different ADC_OFRy registers."
            },
            {
                "name": "OFFSET_EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Offset y enable\nThis bit is written by software to enable or disable the offset programmed into bits OFFSET[11:0].\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1107460196": {
        "name": "ADC_OFR2",
        "address": 1107460196,
        "size": 32,
        "access": "",
        "desc": "ADC offset 2 register",
        "fields": [
            {
                "name": "OFFSET",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Data offset y for the channel programmed into bits OFFSET_CH[4:0]\nThese bits are written by software to define the offset to be subtracted from the raw converted data when converting a channel (can be regular or injected). The channel to which applies the data offset must be programmed in the bits OFFSET_CH[4:0]. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion).\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nIf several offset (OFFSET) point to the same channel, only the offset with the lowest x value is considered for the subtraction.\nEx: if OFFSET1_CH[4:0] = 4 and OFFSET2_CH[4:0] = 4, this is OFFSET1[11:0] which is subtracted when converting channel 4."
            },
            {
                "name": "OFFSETPOS",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Positive offset\nThis bit is set and cleared by software to enable the positive offset.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SATEN",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Saturation enable\nThis bit is set and cleared by software to enable the saturation at 0x000 and 0xFFF for the offset function.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "OFFSET_CH",
                "bitOffset": 26,
                "bitWidth": 5,
                "desc": "Channel selection for the data offset y\nThese bits are written by software to define the channel to which the offset programmed into bits OFFSET[11:0] applies.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically and must not be selected for the data offset y.\nIf OFFSET_EN is set, it is not allowed to select the same channel for different ADC_OFRy registers."
            },
            {
                "name": "OFFSET_EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Offset y enable\nThis bit is written by software to enable or disable the offset programmed into bits OFFSET[11:0].\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1107460200": {
        "name": "ADC_OFR3",
        "address": 1107460200,
        "size": 32,
        "access": "",
        "desc": "ADC offset 3 register",
        "fields": [
            {
                "name": "OFFSET",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Data offset y for the channel programmed into bits OFFSET_CH[4:0]\nThese bits are written by software to define the offset to be subtracted from the raw converted data when converting a channel (can be regular or injected). The channel to which applies the data offset must be programmed in the bits OFFSET_CH[4:0]. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion).\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nIf several offset (OFFSET) point to the same channel, only the offset with the lowest x value is considered for the subtraction.\nEx: if OFFSET1_CH[4:0] = 4 and OFFSET2_CH[4:0] = 4, this is OFFSET1[11:0] which is subtracted when converting channel 4."
            },
            {
                "name": "OFFSETPOS",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Positive offset\nThis bit is set and cleared by software to enable the positive offset.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SATEN",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Saturation enable\nThis bit is set and cleared by software to enable the saturation at 0x000 and 0xFFF for the offset function.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "OFFSET_CH",
                "bitOffset": 26,
                "bitWidth": 5,
                "desc": "Channel selection for the data offset y\nThese bits are written by software to define the channel to which the offset programmed into bits OFFSET[11:0] applies.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically and must not be selected for the data offset y.\nIf OFFSET_EN is set, it is not allowed to select the same channel for different ADC_OFRy registers."
            },
            {
                "name": "OFFSET_EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Offset y enable\nThis bit is written by software to enable or disable the offset programmed into bits OFFSET[11:0].\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1107460204": {
        "name": "ADC_OFR4",
        "address": 1107460204,
        "size": 32,
        "access": "",
        "desc": "ADC offset 4 register",
        "fields": [
            {
                "name": "OFFSET",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Data offset y for the channel programmed into bits OFFSET_CH[4:0]\nThese bits are written by software to define the offset to be subtracted from the raw converted data when converting a channel (can be regular or injected). The channel to which applies the data offset must be programmed in the bits OFFSET_CH[4:0]. The conversion result can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi registers (injected conversion).\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nIf several offset (OFFSET) point to the same channel, only the offset with the lowest x value is considered for the subtraction.\nEx: if OFFSET1_CH[4:0] = 4 and OFFSET2_CH[4:0] = 4, this is OFFSET1[11:0] which is subtracted when converting channel 4."
            },
            {
                "name": "OFFSETPOS",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Positive offset\nThis bit is set and cleared by software to enable the positive offset.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SATEN",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Saturation enable\nThis bit is set and cleared by software to enable the saturation at 0x000 and 0xFFF for the offset function.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "OFFSET_CH",
                "bitOffset": 26,
                "bitWidth": 5,
                "desc": "Channel selection for the data offset y\nThese bits are written by software to define the channel to which the offset programmed into bits OFFSET[11:0] applies.\nNote: The software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically and must not be selected for the data offset y.\nIf OFFSET_EN is set, it is not allowed to select the same channel for different ADC_OFRy registers."
            },
            {
                "name": "OFFSET_EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Offset y enable\nThis bit is written by software to enable or disable the offset programmed into bits OFFSET[11:0].\nNote: The software is allowed to write this bit only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1107460224": {
        "name": "ADC_JDR1",
        "address": 1107460224,
        "size": 32,
        "access": "",
        "desc": "ADC injected channel 1 data register",
        "fields": [
            {
                "name": "JDATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Injected data\nThese bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in ."
            }
        ]
    },
    "1107460228": {
        "name": "ADC_JDR2",
        "address": 1107460228,
        "size": 32,
        "access": "",
        "desc": "ADC injected channel 2 data register",
        "fields": [
            {
                "name": "JDATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Injected data\nThese bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in ."
            }
        ]
    },
    "1107460232": {
        "name": "ADC_JDR3",
        "address": 1107460232,
        "size": 32,
        "access": "",
        "desc": "ADC injected channel 3 data register",
        "fields": [
            {
                "name": "JDATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Injected data\nThese bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in ."
            }
        ]
    },
    "1107460236": {
        "name": "ADC_JDR4",
        "address": 1107460236,
        "size": 32,
        "access": "",
        "desc": "ADC injected channel 4 data register",
        "fields": [
            {
                "name": "JDATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Injected data\nThese bits are read-only. They contain the conversion result from injected channel y. The data are left -or right-aligned as described in ."
            }
        ]
    },
    "1107460256": {
        "name": "ADC_AWD2CR",
        "address": 1107460256,
        "size": 32,
        "access": "",
        "desc": "ADC Analog Watchdog 2 Configuration Register ",
        "fields": [
            {
                "name": "AWD2CH",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Analog watchdog 2 channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by the analog watchdog 2.\nAWD2CH[i] = 0: ADC analog input channel i is not monitored by AWD2\nAWD2CH[i] = 1: ADC analog input channel i is monitored by AWD2\nWhen AWD2CH[19:0] = 000..0, the analog Watchdog 2 is disabled\nNote: The channels selected by AWD2CH must be also selected into the SQRi or JSQRi registers.\nThe software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically and must not be selected for the analog watchdog."
            }
        ]
    },
    "1107460260": {
        "name": "ADC_AWD3CR",
        "address": 1107460260,
        "size": 32,
        "access": "",
        "desc": "ADC Analog Watchdog 3 Configuration Register ",
        "fields": [
            {
                "name": "AWD3CH",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Analog watchdog 3 channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by the analog watchdog 3.\nAWD3CH[i] = 0: ADC analog input channel i is not monitored by AWD3\nAWD3CH[i] = 1: ADC analog input channel i is monitored by AWD3\nWhen AWD3CH[19:0] = 000..0, the analog Watchdog 3 is disabled\nNote: The channels selected by AWD3CH must be also selected into the SQRi or JSQRi registers.\nThe software is allowed to write these bits only when ADSTART = 0 and JADSTART = 0 (which ensures that no conversion is ongoing).\nSome channels are not connected physically and must not be selected for the analog watchdog."
            }
        ]
    },
    "1107460272": {
        "name": "ADC_DIFSEL",
        "address": 1107460272,
        "size": 32,
        "access": "",
        "desc": "ADC Differential mode Selection Register ",
        "fields": [
            {
                "name": "DIFSEL",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Differential mode for channels 19 to 0.\nThese bits are set and cleared by software. They allow to select if a channel is configured as Single-ended or Differential mode.\nDIFSEL[i] = 0: ADC analog input channel is configured in Single-ended mode\nDIFSEL[i] = 1: ADC analog input channel i is configured in Differential mode\nNote: The DIFSEL bits corresponding to channels that are either connected to a single-ended I/O port or to an internal channel must be kept their reset value (Single-ended input mode).\nThe software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, JADSTART = 0, JADSTP = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0)."
            }
        ]
    },
    "1107460276": {
        "name": "ADC_CALFACT",
        "address": 1107460276,
        "size": 32,
        "access": "",
        "desc": "ADC Calibration Factors ",
        "fields": [
            {
                "name": "CALFACT_S",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Calibration Factors In Single-ended mode\nThese bits are written by hardware or by software.\nOnce a single-ended inputs calibration is complete, they are updated by hardware with the calibration factors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new single-ended calibration is launched.\nNote: The software is allowed to write these bits only when ADEN = 1, ADSTART = 0 and JADSTART = 0 (ADC is enabled and no calibration is ongoing and no conversion is ongoing)."
            },
            {
                "name": "CALFACT_D",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Calibration Factors in differential mode\nThese bits are written by hardware or by software.\nOnce a differential inputs calibration is complete, they are updated by hardware with the calibration factors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new differential calibration is launched.\nNote: The software is allowed to write these bits only when ADEN = 1, ADSTART = 0 and JADSTART = 0 (ADC is enabled and no calibration is ongoing and no conversion is ongoing)."
            }
        ]
    },
    "1107460296": {
        "name": "ADC_OR",
        "address": 1107460296,
        "size": 32,
        "access": "",
        "desc": "ADC option register ",
        "fields": [
            {
                "name": "OP0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Option bit 0"
            },
            {
                "name": "OP1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Option bit 1"
            }
        ]
    },
    "1107460872": {
        "name": "ADC_CCR",
        "address": 1107460872,
        "size": 32,
        "access": "",
        "desc": "ADC common control register ",
        "fields": [
            {
                "name": "CKMODE",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "ADC clock mode\nThese bits are set and cleared by software to define the ADC clock scheme (which is common to both master and slave ADCs):\nIn all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion.\nNote: The software is allowed to write these bits only when the ADCs are disabled (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0)."
            },
            {
                "name": "PRESC",
                "bitOffset": 18,
                "bitWidth": 4,
                "desc": "ADC prescaler\nThese bits are set and cleared by software to select the frequency of the clock to the ADC. The clock is common for all the ADCs.\nother: reserved\nNote: The software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, JADSTART = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0). The ADC prescaler value is applied only when CKMODE[1:0] = 0b00."
            },
            {
                "name": "VREFEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "VREFINT enable\nThis bit is set and cleared by software to enable/disable the VREFINT channel."
            },
            {
                "name": "TSEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "VSENSE enable\nThis bit is set and cleared by software to control VSENSE."
            },
            {
                "name": "VBATEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "VBAT enable\nThis bit is set and cleared by software to control."
            }
        ]
    },
    "1107461104": {
        "name": "ADC_HWCFGR0",
        "address": 1107461104,
        "size": 32,
        "access": "",
        "desc": "ADC hardware configuration register ",
        "fields": [
            {
                "name": "ADCNUM",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Number of ADCs implemented"
            },
            {
                "name": "MULPIPE",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Number of pipeline stages"
            },
            {
                "name": "OPBITS",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Number of option bits\n0002: 2 option bits implemented in the ADC option register (ADC_OR) at address offset 0xC8"
            },
            {
                "name": "IDLEVALUE",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Idle value for non-selected channels"
            }
        ]
    },
    "1107461108": {
        "name": "ADC_VERR",
        "address": 1107461108,
        "size": 32,
        "access": "",
        "desc": "ADC version register ",
        "fields": [
            {
                "name": "MINREV",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Minor revision\nThese bits returns the ADC IP minor revision\n0002: Major revision = X.2"
            },
            {
                "name": "MAJREV",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Major revision\nThese bits returns the ADC IP major revision"
            }
        ]
    },
    "1107461112": {
        "name": "ADC_IPDR",
        "address": 1107461112,
        "size": 32,
        "access": "",
        "desc": "ADC identification register ",
        "fields": [
            {
                "name": "ID",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Peripheral identifier\nThese bits returns the ADC identifier.\nID[31:0] = 0x0011 0006: c7amba_aditf5_90_v1"
            }
        ]
    },
    "1107461116": {
        "name": "ADC_SIDR",
        "address": 1107461116,
        "size": 32,
        "access": "",
        "desc": "ADC size identification register ",
        "fields": [
            {
                "name": "SID",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Size Identification\nSID[31:8]: fixed code that characterizes the ADC_SIDR register. This field is always read at 0xA3C5DD.\nSID[7:0]: read-only numeric field that returns the address offset (in Kbytes) of the identification registers from the IP base address:"
            }
        ]
    },
    "1073758208": {
        "name": "COMP_SR",
        "address": 1073758208,
        "size": 32,
        "access": "",
        "desc": "Comparator status register",
        "fields": [
            {
                "name": "C1VAL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "COMP Channel1 output status bit\nThis bit is read-only. It reflects the current COMP Channel1 output taking into account POLARITY and BLANKING bits effect."
            },
            {
                "name": "C1IF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "COMP Channel1 interrupt flag\nThis bit is set by hardware when the COMP Channel1 output is set\nThis bit is cleared by software writing 1 the CC1IF bit in the COMP_ICFR register."
            }
        ]
    },
    "1073758212": {
        "name": "COMP_ICFR",
        "address": 1073758212,
        "size": 32,
        "access": "",
        "desc": "Comparator interrupt clear flag register",
        "fields": [
            {
                "name": "CC1IF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Clear COMP Channel1 interrupt flag\nWriting 1 clears the C1IF flag in the COMP_SR register."
            }
        ]
    },
    "1073758220": {
        "name": "COMP_CFGR1",
        "address": 1073758220,
        "size": 32,
        "access": "",
        "desc": "Comparator configuration register 1",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "COMP Channel1 enable\nThis bit is set and cleared by software (only if LOCK not set). It enables the COMP Channel1."
            },
            {
                "name": "BRGEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Scaler bridge enable\nThis bit is set and cleared by software (only if LOCK not set). This bit enables the bridge of the scaler.\nIf SCALEN is set and BRGEN is reset, all four scaler outputs provide the same level V REF_COMP  (similar to V REFINT ).\nIf SCALEN and BRGEN are set, the four scaler outputs provide V REF_COMP , 3/4 V REF_COMP , 1/2 V REF_COMP  and 1/4 V REF_COMP  levels, respectively."
            },
            {
                "name": "SCALEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Voltage scaler enable\nThis bit is set and cleared by software (only if LOCK not set). This bit enables the V REFINT  scaler for the COMP channels."
            },
            {
                "name": "POLARITY",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "COMP channel1 polarity selection\nThis bit is set and cleared by software (only if LOCK not set). It inverts COMP channel1 polarity."
            },
            {
                "name": "ITEN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "COMP channel1 interrupt enable\nThis bit is set and cleared by software (only if LOCK not set). This bit enable the interrupt generation of the COMP channel1."
            },
            {
                "name": "HYST",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "COMP channel1 hysteresis selection\nThese bits are set and cleared by software (only if LOCK not set). They select the hysteresis voltage of the COMP channel1."
            },
            {
                "name": "PWRMODE",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Power mode of the COMP channel1\nThese bits are set and cleared by software (only if LOCK not set). They control the power/speed of the COMP channel1."
            },
            {
                "name": "INMSEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "COMP channel1 inverting input selection\nThese bits are set and cleared by software (only if LOCK not set). They select which input is connected to the input minus of the COMP channel.\nNote: See Table 146: COMP1 inverting input assignment for more details."
            },
            {
                "name": "INPSEL1",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "COMP noninverting input selection\nThis bit is set and cleared by software (only if LOCK not set). They select which input is connected to the positive input of COMP channel.\nNote: See Table 145: COMP1 noninverting input assignment for more details."
            },
            {
                "name": "INPSEL2",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "COMP noninverting input selection\nThis bit is set and cleared by software (only if LOCK not set). They select which input is connected to the positive input of the COMP channel.\nSee Table 145: COMP1 noninverting input assignment for more details."
            },
            {
                "name": "BLANKING",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "COMP Channel1 blanking source selection\nBits of this field are set and cleared by software (only if LOCK not set).\nThe field selects the input source for COMP Channel1 output blanking:\nAll other values: reserved"
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock\nThis bit is set by software and cleared by a hardware system reset. It locks the whole content of the COMP Channel1 configuration register COMP_CFGR1[31:0]"
            }
        ]
    },
    "1073758224": {
        "name": "COMP_CFGR2",
        "address": 1073758224,
        "size": 32,
        "access": "",
        "desc": "Comparator configuration register 2",
        "fields": [
            {
                "name": "INPSEL0",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "COMP non-inverting input selection\nThis bit is set and cleared by software (only if LOCK not set). They select which input is connected to the positive input of COMP channel.\nSee Table 145: COMP1 noninverting input assignment for more details."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock\nThis bit is set by software and cleared by a hardware system reset. It locks the whole content\nof the COMP Channel1 configuration register COMP_CFGR2[31:0]"
            }
        ]
    },
    "1073885184": {
        "name": "CRC_DR",
        "address": 1073885184,
        "size": 32,
        "access": "",
        "desc": "CRC data register ",
        "fields": [
            {
                "name": "DR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Data register bits\nThis register is used to write new data to the CRC calculator.\nIt holds the previous CRC calculation result when it is read.\nIf the data size is less than 32 bits, the least significant bits are used to write/read the correct value."
            }
        ]
    },
    "1073885188": {
        "name": "CRC_IDR",
        "address": 1073885188,
        "size": 32,
        "access": "",
        "desc": "CRC independent data register ",
        "fields": [
            {
                "name": "IDR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "General-purpose 32-bit data register bits\nThese bits can be used as a temporary storage location for four bytes.\nThis register is not affected by CRC resets generated by the RESET bit in the CRC_CR register"
            }
        ]
    },
    "1073885192": {
        "name": "CRC_CR",
        "address": 1073885192,
        "size": 32,
        "access": "",
        "desc": "CRC control register ",
        "fields": [
            {
                "name": "RESET",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RESET bit\nThis bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware"
            },
            {
                "name": "POLYSIZE",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Polynomial size\nThese bits control the size of the polynomial."
            },
            {
                "name": "REV_IN",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Reverse input data\nThese bits control the reversal of the bit order of the input data"
            },
            {
                "name": "REV_OUT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Reverse output data\nThis bit controls the reversal of the bit order of the output data."
            }
        ]
    },
    "1073885200": {
        "name": "CRC_INIT",
        "address": 1073885200,
        "size": 32,
        "access": "",
        "desc": "CRC initial value ",
        "fields": [
            {
                "name": "CRC_INIT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Programmable initial CRC value\nThis register is used to write the CRC initial value."
            }
        ]
    },
    "1073885204": {
        "name": "CRC_POL",
        "address": 1073885204,
        "size": 32,
        "access": "",
        "desc": "CRC polynomial ",
        "fields": [
            {
                "name": "POL",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Programmable polynomial\nThis register is used to write the coefficients of the polynomial to be used for CRC calculation.\nIf the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value."
            }
        ]
    },
    "1073766400": {
        "name": "CRS_CR",
        "address": 1073766400,
        "size": 32,
        "access": "",
        "desc": "CRS control register",
        "fields": [
            {
                "name": "SYNCOKIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYNC event OK interrupt enable"
            },
            {
                "name": "SYNCWARNIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SYNC warning interrupt enable"
            },
            {
                "name": "ERRIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Synchronization or trimming error interrupt enable"
            },
            {
                "name": "ESYNCIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Expected SYNC interrupt enable"
            },
            {
                "name": "CEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Frequency error counter enable\nThis bit enables the oscillator clock for the frequency error counter.\nWhen this bit is set, the CRS_CFGR register is write-protected and cannot be modified."
            },
            {
                "name": "AUTOTRIMEN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Automatic trimming enable\nThis bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section 10.5.3 for more details."
            },
            {
                "name": "SWSYNC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Generate software SYNC event\nThis bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware."
            },
            {
                "name": "TRIM",
                "bitOffset": 8,
                "bitWidth": 6,
                "desc": "HSI48 oscillator smooth trimming\nThese bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48 oscillator.\nThe default value is 32, which corresponds to the middle of the trimming interval. The trimming step is specified in the product datasheet. A higher TRIM value corresponds to a higher output frequency.\nWhen the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only."
            }
        ]
    },
    "1073766404": {
        "name": "CRS_CFGR",
        "address": 1073766404,
        "size": 32,
        "access": "",
        "desc": "CRS configuration register",
        "fields": [
            {
                "name": "RELOAD",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter reload value\nRELOAD is the value to be loaded in the frequency error counter with each SYNC event.\nRefer to Section 10.5.2 for more details about counter behavior."
            },
            {
                "name": "FELIM",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Frequency error limit\nFELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section 10.5.3 for more details about FECAP evaluation."
            },
            {
                "name": "SYNCDIV",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "SYNC divider\nThese bits are set and cleared by software to control the division factor of the SYNC signal."
            },
            {
                "name": "SYNCSRC",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "SYNC signal source selection\nThese bits are set and cleared by software to select the SYNC signal source (see Table 68: CRS internal input/output signals for STM32U575/585):\nNote: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF is not generated by the host. No SYNC signal is therefore provided to the CRS to calibrate the HSI48 oscillator on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs must be used as SYNC signal."
            },
            {
                "name": "SYNCPOL",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "SYNC polarity selection\nThis bit is set and cleared by software to select the input polarity for the SYNC signal source."
            }
        ]
    },
    "1073766408": {
        "name": "CRS_ISR",
        "address": 1073766408,
        "size": 32,
        "access": "",
        "desc": "CRS interrupt and status register",
        "fields": [
            {
                "name": "SYNCOKF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYNC event OK flag\nThis flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register."
            },
            {
                "name": "SYNCWARNF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SYNC warning flag\nThis flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register."
            },
            {
                "name": "ERRF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Error flag\nThis flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits."
            },
            {
                "name": "ESYNCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Expected SYNC flag\nThis flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register."
            },
            {
                "name": "SYNCERR",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SYNC error\nThis flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action has to be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register."
            },
            {
                "name": "SYNCMISS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "SYNC missed\nThis flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action has to be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register."
            },
            {
                "name": "TRIMOVF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Trimming overflow or underflow\nThis flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register."
            },
            {
                "name": "FEDIR",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Frequency error direction\nFEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target."
            },
            {
                "name": "FECAP",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Frequency error capture\nFECAP is the frequency error counter value latched in the time of the last SYNC event.\nRefer to Section 10.5.3 for more details about FECAP usage."
            }
        ]
    },
    "1073766412": {
        "name": "CRS_ICR",
        "address": 1073766412,
        "size": 32,
        "access": "",
        "desc": "CRS interrupt flag clear register",
        "fields": [
            {
                "name": "SYNCOKC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYNC event OK clear flag\nWriting 1 to this bit clears the SYNCOKF flag in the CRS_ISR register."
            },
            {
                "name": "SYNCWARNC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SYNC warning clear flag\nWriting 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register."
            },
            {
                "name": "ERRC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Error clear flag\nWriting 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register."
            },
            {
                "name": "ESYNCC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Expected SYNC clear flag\nWriting 1 to this bit clears the ESYNCF flag in the CRS_ISR register."
            }
        ]
    },
    "1107461120": {
        "name": "DAC_CR",
        "address": 1107461120,
        "size": 32,
        "access": "",
        "desc": "DAC control register ",
        "fields": [
            {
                "name": "EN1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DAC channel1 enable\nThis bit is set and cleared by software to enable/disable DAC channel1."
            },
            {
                "name": "TEN1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DAC channel1 trigger enable\nThis bit is set and cleared by software to enable/disable DAC channel1 trigger.\nNote: When software trigger is selected, the transfer from the DAC_DHR1 register to the DAC_DOR1 register takes only one dac_hclk clock cycle."
            },
            {
                "name": "TSEL1",
                "bitOffset": 2,
                "bitWidth": 4,
                "desc": "DAC channel1 trigger selection\nThese bits select the external event used to trigger DAC channel1\n...\nRefer to the trigger selection tables in  for details on trigger configuration and mapping.\nNote: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled)."
            },
            {
                "name": "WAVE1",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "DAC channel1 noise/triangle wave generation enable\nThese bits are set and cleared by software.\n1x: Triangle wave generation enabled\nOnly used if bit TEN1 = 1 (DAC channel1 trigger enabled)."
            },
            {
                "name": "MAMP1",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "DAC channel1 mask/amplitude selector\nThese bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.\ngreater than or equal 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095"
            },
            {
                "name": "DMAEN1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "DAC channel1 DMA enable\nThis bit is set and cleared by software."
            },
            {
                "name": "DMAUDRIE1",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DAC channel1 DMA Underrun Interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "CEN1",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "DAC channel1 calibration enable\nThis bit is set and cleared by software to enable/disable DAC channel1 calibration, it can be written only if bit EN1 = 0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored."
            },
            {
                "name": "EN2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "DAC channel2 enable\nThis bit is set and cleared by software to enable/disable DAC channel2.\nNote: These bits are available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "TEN2",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "DAC channel2 trigger enable\nThis bit is set and cleared by software to enable/disable DAC channel2 trigger\nNote: When software trigger is selected, the transfer from the DAC_DHR2 register to the DAC_DOR2 register takes only one dac_hclk clock cycle.\nThese bits are available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "TSEL2",
                "bitOffset": 18,
                "bitWidth": 4,
                "desc": "DAC channel2 trigger selection\nThese bits select the external event used to trigger DAC channel2\n...\nRefer to the trigger selection tables in  for details on trigger configuration and mapping.\nNote: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).\nThese bits are available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "WAVE2",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "DAC channel2 noise/triangle wave generation enable\nThese bits are set/reset by software.\n1x: Triangle wave generation enabled\nNote: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)\nThese bits are available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "MAMP2",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "DAC channel2 mask/amplitude selector\nThese bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.\ngreater than or equal 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095\nNote: These bits are available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "DMAEN2",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "DAC channel2 DMA enable\nThis bit is set and cleared by software.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "DMAUDRIE2",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "DAC channel2 DMA underrun interrupt enable\nThis bit is set and cleared by software.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "CEN2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "DAC channel2 calibration enable\nThis bit is set and cleared by software to enable/disable DAC channel2 calibration, it can be written only if EN2 bit is set to 0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1107461124": {
        "name": "DAC_SWTRGR",
        "address": 1107461124,
        "size": 32,
        "access": "",
        "desc": "DAC software trigger register ",
        "fields": [
            {
                "name": "SWTRIG1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DAC channel1 software trigger\nThis bit is set by software to trigger the DAC in software trigger mode.\nNote: This bit is cleared by hardware (one dac_hclk clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register."
            },
            {
                "name": "SWTRIG2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DAC channel2 software trigger\nThis bit is set by software to trigger the DAC in software trigger mode.\nNote: This bit is cleared by hardware (one dac_hclk clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.\nThis bit is available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1107461128": {
        "name": "DAC_DHR12R1",
        "address": 1107461128,
        "size": 32,
        "access": "",
        "desc": "DAC channel1 12-bit right-aligned data holding register\t",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit right-aligned data\nThese bits are written by software. They specify 12-bit data for DAC channel1."
            },
            {
                "name": "DACC1DHRB",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit right-aligned data B\nThese bits are written by software. They specify 12-bit data for DAC channel1 when the DAC operates in Double data mode."
            }
        ]
    },
    "1107461132": {
        "name": "DAC_DHR12L1",
        "address": 1107461132,
        "size": 32,
        "access": "",
        "desc": "DAC channel1 12-bit left aligned data holding register\t",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 4,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit left-aligned data\nThese bits are written by software.\nThey specify 12-bit data for DAC channel1."
            },
            {
                "name": "DACC1DHRB",
                "bitOffset": 20,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit left-aligned data B\nThese bits are written by software. They specify 12-bit data for DAC channel1 when the DAC operates in Double data mode."
            }
        ]
    },
    "1107461136": {
        "name": "DAC_DHR8R1",
        "address": 1107461136,
        "size": 32,
        "access": "",
        "desc": "DAC channel1 8-bit right aligned data holding register\t",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "DAC channel1 8-bit right-aligned data\nThese bits are written by software. They specify 8-bit data for DAC channel1."
            },
            {
                "name": "DACC1DHRB",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "DAC channel1 8-bit right-aligned data\nThese bits are written by software. They specify 8-bit data for DAC channel1 when the DAC operates in Double data mode."
            }
        ]
    },
    "1107461140": {
        "name": "DAC_DHR12R2",
        "address": 1107461140,
        "size": 32,
        "access": "",
        "desc": "DAC channel2 12-bit right aligned data holding register\t",
        "fields": [
            {
                "name": "DACC2DHR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel2 12-bit right-aligned data\nThese bits are written by software. They specify 12-bit data for DAC channel2."
            },
            {
                "name": "DACC2DHRB",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "DAC channel2 12-bit right-aligned data\nThese bits are written by software. They specify 12-bit data for DAC channel2 when the DAC operates in DMA Double data mode."
            }
        ]
    },
    "1107461144": {
        "name": "DAC_DHR12L2",
        "address": 1107461144,
        "size": 32,
        "access": "",
        "desc": "DAC channel2 12-bit left aligned data holding register \t",
        "fields": [
            {
                "name": "DACC2DHR",
                "bitOffset": 4,
                "bitWidth": 12,
                "desc": "DAC channel2 12-bit left-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel2."
            },
            {
                "name": "DACC2DHRB",
                "bitOffset": 20,
                "bitWidth": 12,
                "desc": "DAC channel2 12-bit left-aligned data B\nThese bits are written by software. They specify 12-bit data for DAC channel2 when the DAC operates in Double data mode."
            }
        ]
    },
    "1107461148": {
        "name": "DAC_DHR8R2",
        "address": 1107461148,
        "size": 32,
        "access": "",
        "desc": "DAC channel2 8-bit right-aligned data holding register\t",
        "fields": [
            {
                "name": "DACC2DHR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "DAC channel2 8-bit right-aligned data\nThese bits are written by software which specifies 8-bit data for DAC channel2."
            },
            {
                "name": "DACC2DHRB",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "DAC channel2 8-bit right-aligned data\nThese bits are written by software. They specify 8-bit data for DAC channel2 when the DAC operates in Double data mode."
            }
        ]
    },
    "1107461152": {
        "name": "DAC_DHR12RD",
        "address": 1107461152,
        "size": 32,
        "access": "",
        "desc": "Dual DAC 12-bit right-aligned data holding register\t",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit right-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel1."
            },
            {
                "name": "DACC2DHR",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "DAC channel2 12-bit right-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel2."
            }
        ]
    },
    "1107461156": {
        "name": "DAC_DHR12LD",
        "address": 1107461156,
        "size": 32,
        "access": "",
        "desc": "Dual DAC 12-bit left aligned data holding register\t",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 4,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit left-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel1."
            },
            {
                "name": "DACC2DHR",
                "bitOffset": 20,
                "bitWidth": 12,
                "desc": "DAC channel2 12-bit left-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel2."
            }
        ]
    },
    "1107461160": {
        "name": "DAC_DHR8RD",
        "address": 1107461160,
        "size": 32,
        "access": "",
        "desc": "Dual DAC 8-bit right aligned data holding register\t",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "DAC channel1 8-bit right-aligned data\nThese bits are written by software which specifies 8-bit data for DAC channel1."
            },
            {
                "name": "DACC2DHR",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "DAC channel2 8-bit right-aligned data\nThese bits are written by software which specifies 8-bit data for DAC channel2."
            }
        ]
    },
    "1107461164": {
        "name": "DAC_DOR1",
        "address": 1107461164,
        "size": 32,
        "access": "",
        "desc": "DAC channel1 data output register ",
        "fields": [
            {
                "name": "DACC1DOR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel1 data output\nThese bits are read-only, they contain data output for DAC channel1."
            },
            {
                "name": "DACC1DORB",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "DAC channel1 data output\nThese bits are read-only. They contain data output for DAC channel1 B."
            }
        ]
    },
    "1107461168": {
        "name": "DAC_DOR2",
        "address": 1107461168,
        "size": 32,
        "access": "",
        "desc": "DAC channel2 data output register ",
        "fields": [
            {
                "name": "DACC2DOR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel2 data output\nThese bits are read-only, they contain data output for DAC channel2."
            },
            {
                "name": "DACC2DORB",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "DAC channel2 data output\nThese bits are read-only. They contain data output for DAC channel2 B."
            }
        ]
    },
    "1107461172": {
        "name": "DAC_SR",
        "address": 1107461172,
        "size": 32,
        "access": "",
        "desc": "DAC status register ",
        "fields": [
            {
                "name": "DAC1RDY",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "DAC channel1 ready status bit\nThis bit is set and cleared by hardware."
            },
            {
                "name": "DORSTAT1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "DAC channel1 output register status bit\nThis bit is set and cleared by hardware. It is applicable only when the DAC operates in Double data mode."
            },
            {
                "name": "DMAUDR1",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DAC channel1 DMA underrun flag\nThis bit is set by hardware and cleared by software (by writing it to 1)."
            },
            {
                "name": "CAL_FLAG1",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "DAC channel1 calibration offset status\nThis bit is set and cleared by hardware"
            },
            {
                "name": "BWST1",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DAC channel1 busy writing sample time flag\nThis bit is systematically set just after Sample and hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3 LSI/LSE periods of synchronization)."
            },
            {
                "name": "DAC2RDY",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "DAC channel2 ready status bit\nThis bit is set and cleared by hardware.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "DORSTAT2",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "DAC channel2 output register status bit\nThis bit is set and cleared by hardware. It is applicable only when the DAC operates in Double data mode.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "DMAUDR2",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "DAC channel2 DMA underrun flag\nThis bit is set by hardware and cleared by software (by writing it to 1).\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "CAL_FLAG2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "DAC channel2 calibration offset status\nThis bit is set and cleared by hardware\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "BWST2",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "DAC channel2 busy writing sample time flag\nThis bit is systematically set just after Sample and hold mode enable. It is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI/LSE periods of synchronization).\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1107461176": {
        "name": "DAC_CCR",
        "address": 1107461176,
        "size": 32,
        "access": "",
        "desc": "DAC calibration control register ",
        "fields": [
            {
                "name": "OTRIM1",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DAC channel1 offset trimming value"
            },
            {
                "name": "OTRIM2",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "DAC channel2 offset trimming value\nThese bits are available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1107461180": {
        "name": "DAC_MCR",
        "address": 1107461180,
        "size": 32,
        "access": "",
        "desc": "DAC mode control register ",
        "fields": [
            {
                "name": "MODE1",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "DAC channel1 mode\nThese bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1 = 0 and bit CEN1 = 0 in the DAC_CR register). If EN1 = 1 or CEN1 = 1 the write operation is ignored.\nThey can be set and cleared by software to select the DAC channel1 mode:\nDAC channel1 in Normal mode\nDAC channel1 in sample & hold mode\nNote: This register can be modified only when EN1 = 0."
            },
            {
                "name": "DMADOUBLE1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "DAC channel1 DMA double data mode\nThis bit is set and cleared by software."
            },
            {
                "name": "SINFORMAT1",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Enable signed format for DAC channel1\nThis bit is set and cleared by software."
            },
            {
                "name": "HFSEL0",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "High frequency interface mode selection"
            },
            {
                "name": "HFSEL1",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "High frequency interface mode selection"
            },
            {
                "name": "MODE2",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "DAC channel2 mode\nThese bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2 = 0 and bit CEN2 = 0 in the DAC_CR register). If EN2 = 1 or CEN2 = 1 the write operation is ignored.\nThey can be set and cleared by software to select the DAC channel2 mode:\nDAC channel2 in Normal mode\nDAC channel2 in Sample and hold mode\nNote: This register can be modified only when EN2 = 0.\nRefer to  for the availability of DAC channel2."
            },
            {
                "name": "DMADOUBLE2",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "DAC channel2 DMA double data mode\nThis bit is set and cleared by software.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "SINFORMAT2",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Enable signed format for DAC channel2\nThis bit is set and cleared by software.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1107461184": {
        "name": "DAC_SHSR1",
        "address": 1107461184,
        "size": 32,
        "access": "",
        "desc": "DAC channel1 sample and hold sample time register\t",
        "fields": [
            {
                "name": "TSAMPLE1",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "DAC channel1 sample time (only valid in Sample and hold mode)\nThese bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWST1 of DAC_SR register is low, If BWST1 = 1, the write operation is ignored."
            }
        ]
    },
    "1107461188": {
        "name": "DAC_SHSR2",
        "address": 1107461188,
        "size": 32,
        "access": "",
        "desc": "DAC channel2 sample and hold sample time register \t",
        "fields": [
            {
                "name": "TSAMPLE2",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "DAC channel2 sample time (only valid in Sample and hold mode)\nThese bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWST2 of DAC_SR register is low, if BWST2 = 1, the write operation is ignored."
            }
        ]
    },
    "1107461192": {
        "name": "DAC_SHHR",
        "address": 1107461192,
        "size": 32,
        "access": "",
        "desc": "DAC sample and hold time register ",
        "fields": [
            {
                "name": "THOLD1",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "DAC channel1 hold time (only valid in Sample and hold mode)\nHold time = (THOLD[9:0]) x LSI/LSE clock period\nNote: This register can be modified only when EN1 = 0."
            },
            {
                "name": "THOLD2",
                "bitOffset": 16,
                "bitWidth": 10,
                "desc": "DAC channel2 hold time (only valid in Sample and hold mode).\nHold time = (THOLD[9:0]) x LSI/LSE clock period\nNote: This register can be modified only when EN2 = 0.\nThese bits are available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1107461196": {
        "name": "DAC_SHRR",
        "address": 1107461196,
        "size": 32,
        "access": "",
        "desc": "DAC sample and hold refresh time register ",
        "fields": [
            {
                "name": "TREFRESH1",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "DAC channel1 refresh time (only valid in Sample and hold mode)\nRefresh time = (TREFRESH[7:0]) x LSI/LSE clock period\nNote: This register can be modified only when EN1 = 0."
            },
            {
                "name": "TREFRESH2",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "DAC channel2 refresh time (only valid in Sample and hold mode)\nRefresh time = (TREFRESH[7:0]) x LSI/LSE clock period\nNote: This register can be modified only when EN2 = 0.\nThese bits are available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1140998144": {
        "name": "DBGMCU_IDCODE",
        "address": 1140998144,
        "size": 32,
        "access": "",
        "desc": "DBGMCU identity code register",
        "fields": [
            {
                "name": "DEV_ID",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "device identification"
            },
            {
                "name": "REV_ID",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "revision\nThis field indicates the revision of the device."
            }
        ]
    },
    "1140998148": {
        "name": "DBGMCU_CR",
        "address": 1140998148,
        "size": 32,
        "access": "",
        "desc": "DBGMCU configuration register",
        "fields": [
            {
                "name": "DBG_STOP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Allows debug in Stop mode\nAll clocks are disabled automatically in Stop mode.\nAll active clocks and oscillators continue to run during Stop mode, allowing full debug capability. On exit from Stop mode, the clock settings are set to the Stop mode exit state."
            },
            {
                "name": "DBG_STANDBY",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Allows debug in Standby mode\nAll clocks are disabled and the core powered down automatically in Standby mode.\nAll active clocks and oscillators continue to run during Standby mode, and the core supply is maintained, allowing full debug capability. On exit from Standby mode, a system reset is performed."
            },
            {
                "name": "TRACE_IOEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "trace pin enable"
            },
            {
                "name": "TRACE_EN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "trace port and clock enable.\nThis bit enables the trace port clock, TRACECK."
            },
            {
                "name": "TRACE_MODE",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "trace pin assignment"
            },
            {
                "name": "DCRT",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Debug credentials reset type\nThis bit selects which type of reset is used to revoke the debug authentication credentials"
            }
        ]
    },
    "1140998152": {
        "name": "DBGMCU_APB1LFZR",
        "address": 1140998152,
        "size": 32,
        "access": "",
        "desc": "DBGMCU APB1L peripheral freeze register",
        "fields": [
            {
                "name": "DBG_TIM2_STOP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 stop in debug"
            },
            {
                "name": "DBG_TIM3_STOP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 stop in debug"
            },
            {
                "name": "DBG_TIM6_STOP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 stop in debug"
            },
            {
                "name": "DBG_TIM7_STOP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 stop in debug"
            },
            {
                "name": "DBG_WWDG_STOP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "WWDG stop in debug"
            },
            {
                "name": "DBG_IWDG_STOP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "IWDG stop in debug"
            },
            {
                "name": "DBG_I2C1_STOP",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 SMBUS timeout stop in debug"
            },
            {
                "name": "DBG_I2C2_STOP",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C2 SMBUS timeout stop in debug"
            },
            {
                "name": "DBG_I3C1_STOP",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "I3C1 SCL stall counter stop in debug"
            }
        ]
    },
    "1140998156": {
        "name": "DBGMCU_APB1HFZR",
        "address": 1140998156,
        "size": 32,
        "access": "",
        "desc": "DBGMCU APB1H peripheral freeze register",
        "fields": [
            {
                "name": "DBG_LPTIM2_STOP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LPTIM2 stop in debug"
            }
        ]
    },
    "1140998160": {
        "name": "DBGMCU_APB2FZR",
        "address": 1140998160,
        "size": 32,
        "access": "",
        "desc": "DBGMCU APB2 peripheral freeze register",
        "fields": [
            {
                "name": "DBG_TIM1_STOP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 stop in debug"
            }
        ]
    },
    "1140998164": {
        "name": "DBGMCU_APB3FZR",
        "address": 1140998164,
        "size": 32,
        "access": "",
        "desc": "DBGMCU APB3 peripheral freeze register",
        "fields": [
            {
                "name": "DBG_I3C2_STOP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "I3C2 SCL stall counter stop in debug"
            },
            {
                "name": "DBG_LPTIM1_STOP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "LPTIM1 stop in debug"
            },
            {
                "name": "DBG_RTC_STOP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "RTC stop in debug"
            }
        ]
    },
    "1140998176": {
        "name": "DBGMCU_AHB1FZR",
        "address": 1140998176,
        "size": 32,
        "access": "",
        "desc": "DBGMCU AHB1 peripheral freeze register",
        "fields": [
            {
                "name": "DBG_GPDMA1_0_STOP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPDMA1 channel 0 stop in debug"
            },
            {
                "name": "DBG_GPDMA1_1_STOP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "GPDMA1 channel 1 stop in debug"
            },
            {
                "name": "DBG_GPDMA1_2_STOP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "GPDMA1 channel 2 stop in debug"
            },
            {
                "name": "DBG_GPDMA1_3_STOP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "GPDMA1 channel 3 stop in debug"
            },
            {
                "name": "DBG_GPDMA1_4_STOP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "GPDMA1 channel 4 stop in debug"
            },
            {
                "name": "DBG_GPDMA1_5_STOP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "GPDMA1 channel 5 stop in debug"
            },
            {
                "name": "DBG_GPDMA1_6_STOP",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "GPDMA1 channel 6 stop in debug"
            },
            {
                "name": "DBG_GPDMA1_7_STOP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "GPDMA1 channel 7 stop in debug"
            },
            {
                "name": "DBG_GPDMA2_0_STOP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "GPDMA2 channel 0 stop in debug"
            },
            {
                "name": "DBG_GPDMA2_1_STOP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "GPDMA2 channel 1 stop in debug"
            },
            {
                "name": "DBG_GPDMA2_2_STOP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "GPDMA2 channel 2 stop in debug"
            },
            {
                "name": "DBG_GPDMA2_3_STOP",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "GPDMA2 channel 3 stop in debug"
            },
            {
                "name": "DBG_GPDMA2_4_STOP",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "GPDMA2 channel 4 stop in debug"
            },
            {
                "name": "DBG_GPDMA2_5_STOP",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "GPDMA2 channel 5 stop in debug"
            },
            {
                "name": "DBG_GPDMA2_6_STOP",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "GPDMA2 channel 6 stop in debug"
            },
            {
                "name": "DBG_GPDMA2_7_STOP",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "GPDMA2 channel 7 stop in debug"
            }
        ]
    },
    "1140998396": {
        "name": "DBGMCU_SR",
        "address": 1140998396,
        "size": 32,
        "access": "",
        "desc": "DBGMCU status register",
        "fields": [
            {
                "name": "AP_PRESENT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Bit n identifies whether access port AP n is present in device\nBit n = 0: APn absent\nBit n = 1: APn present"
            },
            {
                "name": "AP_ENABLED",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Bit n identifies whether access port AP n is open (can be accessed via the debug port) or locked (debug access to the AP is blocked)\nBit n = 0: APn locked\nBit n = 1: APn enabled"
            }
        ]
    },
    "1140998400": {
        "name": "DBGMCU_DBG_AUTH_HOST",
        "address": 1140998400,
        "size": 32,
        "access": "",
        "desc": "DBGMCU debug authentication mailbox host register",
        "fields": [
            {
                "name": "MESSAGE",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Debug host to device mailbox message.\nDuring debug authentication the debug host communicates with the device via this register."
            }
        ]
    },
    "1140998404": {
        "name": "DBGMCU_DBG_AUTH_DEVICE",
        "address": 1140998404,
        "size": 32,
        "access": "",
        "desc": "DBGMCU debug authentication mailbox device register",
        "fields": [
            {
                "name": "MESSAGE",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Device to debug host mailbox message.\nDuring debug authentication the device communicates with the debug host via this register."
            }
        ]
    },
    "1140998408": {
        "name": "DBGMCU_DBG_AUTH_ACK",
        "address": 1140998408,
        "size": 32,
        "access": "",
        "desc": "DBGMCU debug authentication mailbox acknowledge register",
        "fields": [
            {
                "name": "HOST_ACK",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Host to device acknowledge.\nThe device sets this bit to indicate that it has placed a message in the DBGMCU_DBG_AUTH_DEVICE register. It should be reset by the host after reading the message"
            },
            {
                "name": "DEV_ACK",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Device to device acknowledge.\nThe host sets this bit to indicate that it has placed a message in the DBGMCU_DBG_AUTH_HOST register. It is reset by the device after reading the message"
            }
        ]
    },
    "1141002192": {
        "name": "DBGMCU_PIDR4",
        "address": 1141002192,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight peripheral identity register 4",
        "fields": [
            {
                "name": "JEP106CON",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "JEP106 continuation code"
            },
            {
                "name": "SIZE",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "register file size"
            }
        ]
    },
    "1141002208": {
        "name": "DBGMCU_PIDR0",
        "address": 1141002208,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight peripheral identity register 0",
        "fields": [
            {
                "name": "PARTNUM",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "part number bits [7:0]"
            }
        ]
    },
    "1141002212": {
        "name": "DBGMCU_PIDR1",
        "address": 1141002212,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight peripheral identity register 1",
        "fields": [
            {
                "name": "PARTNUM",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "part number bits [11:8]"
            },
            {
                "name": "JEP106ID",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "JEP106 identity code bits [3:0]"
            }
        ]
    },
    "1141002216": {
        "name": "DBGMCU_PIDR2",
        "address": 1141002216,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight peripheral identity register 2",
        "fields": [
            {
                "name": "JEP106ID",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "JEP106 identity code bits [6:4]"
            },
            {
                "name": "JEDEC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "JEDEC assigned value"
            },
            {
                "name": "REVISION",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "component revision number"
            }
        ]
    },
    "1141002220": {
        "name": "DBGMCU_PIDR3",
        "address": 1141002220,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight peripheral identity register 3",
        "fields": [
            {
                "name": "CMOD",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "customer modified"
            },
            {
                "name": "REVAND",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "metal fix version"
            }
        ]
    },
    "1141002224": {
        "name": "DBGMCU_CIDR0",
        "address": 1141002224,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight component identity register 0",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "component identification bits [7:0]"
            }
        ]
    },
    "1141002228": {
        "name": "DBGMCU_CIDR1",
        "address": 1141002228,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight component identity register 1",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "component identification bits [11:8]"
            },
            {
                "name": "CLASS",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "component identification bits [15:12] - component class"
            }
        ]
    },
    "1141002232": {
        "name": "DBGMCU_CIDR2",
        "address": 1141002232,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight component identity register 2",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "component identification bits [23:16]"
            }
        ]
    },
    "1141002236": {
        "name": "DBGMCU_CIDR3",
        "address": 1141002236,
        "size": 32,
        "access": "",
        "desc": "DBGMCU CoreSight component identity register 3",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "component identification bits [31:24]"
            }
        ]
    },
    "1073777664": {
        "name": "DTS_CFGR1",
        "address": 1073777664,
        "size": 32,
        "access": "",
        "desc": "Temperature sensor configuration register 1",
        "fields": [
            {
                "name": "TS1_EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Temperature sensor 1 enable bit\nThis bit is set and cleared by software.\nNote: Once enabled, the temperature sensor is active after a specific delay time. The TS1_RDY flag will be set when the sensor is ready."
            },
            {
                "name": "TS1_START",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Start frequency measurement on temperature sensor 1\nThis bit is set and cleared by software."
            },
            {
                "name": "TS1_INTRIG_SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Input trigger selection bit for temperature sensor 1\nThese bits are set and cleared by software. They select which input triggers a temperature measurement. Refer to Section 19.3.10: Trigger input."
            },
            {
                "name": "TS1_SMP_TIME",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Sampling time for temperature sensor 1\nThese bits allow increasing the sampling time to improve measurement precision.\nWhen the PCLK clock is selected as reference clock (REFCLK_SEL = 0), the measurement will be performed at TS1_SMP_TIME period of CLK_PTAT.\nWhen the LSE is selected as reference clock (REFCLK_SEL =1), the measurement will be performed at TS1_SMP_TIME period of LSE."
            },
            {
                "name": "REFCLK_SEL",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Reference clock selection bit\nThis bit is set and cleared by software. It indicates whether the reference clock is the high speed clock (PCLK) or the low speed clock (LSE)."
            },
            {
                "name": "Q_MEAS_OPT",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Quick measurement option bit\nThis bit is set and cleared by software. It is used to increase the measurement speed by suppressing the calibration step. It is effective only when the LSE clock is used as reference clock (REFCLK_SEL=1)."
            },
            {
                "name": "HSREF_CLK_DIV",
                "bitOffset": 24,
                "bitWidth": 7,
                "desc": "High speed clock division ratio\nThese bits are set and cleared by software. They can be used to define the division ratio for the main clock in order to obtain the internal frequency lower than 1 MHz required for the calibration. They are applicable only for calibration when PCLK is selected as reference clock (REFCLK_SEL=0).\n..."
            }
        ]
    },
    "1073777672": {
        "name": "DTS_T0VALR1",
        "address": 1073777672,
        "size": 32,
        "access": "",
        "desc": "Temperature sensor T0 value register 1",
        "fields": [
            {
                "name": "TS1_FMT0",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Engineering value of the frequency measured at T0 for\n\t temperature sensor 1\nThis value is expressed in 0.1 kHz."
            },
            {
                "name": "TS1_T0",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Engineering value of the T0 temperature for temperature sensor 1.\nOthers: Reserved, must not be used."
            }
        ]
    },
    "1073777680": {
        "name": "DTS_RAMPVALR",
        "address": 1073777680,
        "size": 32,
        "access": "",
        "desc": "Temperature sensor ramp value register",
        "fields": [
            {
                "name": "TS1_RAMP_COEFF",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Engineering value of the ramp coefficient for the temperature sensor 1.\nThis value is expressed in Hz/ C."
            }
        ]
    },
    "1073777684": {
        "name": "DTS_ITR1",
        "address": 1073777684,
        "size": 32,
        "access": "",
        "desc": "Temperature sensor interrupt threshold register 1",
        "fields": [
            {
                "name": "TS1_LITTHD",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Low interrupt threshold for temperature sensor 1\nThese bits are set and cleared by software. They indicate the lowest value than can be reached before raising an interrupt signal."
            },
            {
                "name": "TS1_HITTHD",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "High interrupt threshold for temperature sensor 1\nThese bits are set and cleared by software. They indicate the highest value than can be reached before raising an interrupt signal."
            }
        ]
    },
    "1073777692": {
        "name": "DTS_DR",
        "address": 1073777692,
        "size": 32,
        "access": "",
        "desc": "Temperature sensor data register",
        "fields": [
            {
                "name": "TS1_MFREQ",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Value of the counter output value for temperature sensor 1"
            }
        ]
    },
    "1073777696": {
        "name": "DTS_SR",
        "address": 1073777696,
        "size": 32,
        "access": "",
        "desc": "Temperature sensor status register",
        "fields": [
            {
                "name": "TS1_ITEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Interrupt flag for end of measurement on temperature sensor 1, synchronized on PCLK.\nThis bit is set by hardware when a temperature measure is done.\nIt is cleared by software by writing 1 to the TS2_CITEF bit in the DTS_ICIFR register.\nNote: This bit is active only when the TS1_ITEFEN bit is set"
            },
            {
                "name": "TS1_ITLF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Interrupt flag for low threshold on temperature sensor 1, synchronized on PCLK.\nThis bit is set by hardware when the low threshold is set and reached.\nIt is cleared by software by writing 1 to the TS1_CITLF bit in the DTS_ICIFR register.\nNote: This bit is active only when the TS1_ITLFEN bit is set"
            },
            {
                "name": "TS1_ITHF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Interrupt flag for high threshold on temperature sensor 1, synchronized on PCLK\nThis bit is set by hardware when the high threshold is set and reached.\nIt is cleared by software by writing 1 to the TS1_CITHF bit in the DTS_ICIFR register.\nNote: This bit is active only when the TS1_ITHFEN bit is set"
            },
            {
                "name": "TS1_AITEF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Asynchronous interrupt flag for end of measure on temperature sensor 1\nThis bit is set by hardware when a temperature measure is done.\nIt is cleared by software by writing 1 to the TS1_CAITEF bit in the DTS_ICIFR register.\nNote: This bit is active only when the TS1_AITEFEN bit is set"
            },
            {
                "name": "TS1_AITLF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Asynchronous interrupt flag for low threshold on temperature sensor 1\nThis bit is set by hardware when the low threshold is reached.\nIt is cleared by software by writing 1 to the TS1_CAITLF bit in the DTS_ICIFR register.\nNote: This bit is active only when the TS1_AITLFEN bit is set"
            },
            {
                "name": "TS1_AITHF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Asynchronous interrupt flag for high threshold on temperature sensor 1\nThis bit is set by hardware when the high threshold is reached.\nIt is cleared by software by writing 1 to the TS1_CAITHF bit in the DTS_ICIFR register.\nNote: This bit is active only when the TS1_AITHFEN bit is set"
            },
            {
                "name": "TS1_RDY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Temperature sensor 1 ready flag\nThis bit is set and reset by hardware.\nIt indicates that a measurement is ongoing."
            }
        ]
    },
    "1073777700": {
        "name": "DTS_ITENR",
        "address": 1073777700,
        "size": 32,
        "access": "",
        "desc": "Temperature sensor interrupt enable register",
        "fields": [
            {
                "name": "TS1_ITEEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Interrupt enable flag for end of measurement on temperature sensor 1, synchronized on PCLK.\nThis bit are set and cleared by software.\nIt enables the synchronous interrupt for end of measurement."
            },
            {
                "name": "TS1_ITLEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Interrupt enable flag for low threshold on temperature sensor 1, synchronized on PCLK.\nThis bit are set and cleared by software.\nIt enables the synchronous interrupt when the measure reaches or is below the low threshold."
            },
            {
                "name": "TS1_ITHEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Interrupt enable flag for high threshold on temperature sensor 1, synchronized on PCLK.\nThis bit are set and cleared by software.\nIt enables the interrupt when the measure reaches or is above the high threshold."
            },
            {
                "name": "TS1_AITEEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Asynchronous interrupt enable flag for end of measurement on temperature sensor 1\nThis bit are set and cleared by software.\nIt enables the asynchronous interrupt for end of measurement (only when REFCLK_SEL = 1)."
            },
            {
                "name": "TS1_AITLEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Asynchronous interrupt enable flag for low threshold on temperature sensor 1.\nThis bit are set and cleared by software.\nIt enables the asynchronous interrupt when the temperature is below the low threshold (only when REFCLK_SEL= 1)"
            },
            {
                "name": "TS1_AITHEN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Asynchronous interrupt enable flag on high threshold for temperature sensor 1.\nThis bit are set and cleared by software.\nIt enables the asynchronous interrupt when the temperature is above the high threshold (only when REFCLK_SEL= 1'')"
            }
        ]
    },
    "1073777704": {
        "name": "DTS_ICIFR",
        "address": 1073777704,
        "size": 32,
        "access": "",
        "desc": "Temperature sensor clear interrupt flag register",
        "fields": [
            {
                "name": "TS1_CITEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Interrupt clear flag for end of measurement on temperature sensor 1\nWriting 1 to this bit clears the TS1_ITEF flag in the DTS_SR register."
            },
            {
                "name": "TS1_CITLF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Interrupt clear flag for low threshold on temperature sensor 1\nWriting 1 to this bit clears the TS1_ITLF flag in the DTS_SR register."
            },
            {
                "name": "TS1_CITHF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Interrupt clear flag for high threshold on temperature sensor 1\nWriting this bit to 1 clears the TS1_ITHF flag in the DTS_SR register."
            },
            {
                "name": "TS1_CAITEF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Write once bit. Clear the asynchronous IT flag for End Of Measure for thermal sensor 1.\nWriting 1 clears the TS1_AITEF flag of the DTS_SR register."
            },
            {
                "name": "TS1_CAITLF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Asynchronous interrupt clear flag for low threshold on temperature sensor 1\nWriting 1 to this bit clears the TS1_AITLF flag in the DTS_SR register."
            },
            {
                "name": "TS1_CAITHF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Asynchronous interrupt clear flag for high threshold on temperature sensor 1\nWriting 1 to this bit clears the TS1_AITHF flag in the DTS_SR register."
            }
        ]
    },
    "1073777708": {
        "name": "DTS_OR",
        "address": 1073777708,
        "size": 32,
        "access": "",
        "desc": "Temperature sensor option register",
        "fields": [
            {
                "name": "TS_OP0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            },
            {
                "name": "TS_OP31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "general purpose option bits"
            }
        ]
    },
    "1140989952": {
        "name": "EXTI_RTSR1",
        "address": 1140989952,
        "size": 32,
        "access": "",
        "desc": "EXTI rising trigger selection register ",
        "fields": [
            {
                "name": "RT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            }
        ]
    },
    "1140989956": {
        "name": "EXTI_FTSR1",
        "address": 1140989956,
        "size": 32,
        "access": "",
        "desc": "EXTI falling trigger selection register ",
        "fields": [
            {
                "name": "FT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x  (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            }
        ]
    },
    "1140989960": {
        "name": "EXTI_SWIER1",
        "address": 1140989960,
        "size": 32,
        "access": "",
        "desc": "EXTI software interrupt event register ",
        "fields": [
            {
                "name": "SWI0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Software interrupt on event x (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            }
        ]
    },
    "1140989964": {
        "name": "EXTI_RPR1",
        "address": 1140989964,
        "size": 32,
        "access": "",
        "desc": "EXTI rising edge pending register ",
        "fields": [
            {
                "name": "RPIF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            }
        ]
    },
    "1140989968": {
        "name": "EXTI_FPR1",
        "address": 1140989968,
        "size": 32,
        "access": "",
        "desc": "EXTI falling edge pending register ",
        "fields": [
            {
                "name": "FPIF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit (x = 16 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            }
        ]
    },
    "1140989976": {
        "name": "EXTI_PRIVCFGR1",
        "address": 1140989976,
        "size": 32,
        "access": "",
        "desc": "EXTI privilege configuration register ",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 17 to 0)"
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privilege enable on event input 19"
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 22 to 21)"
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 22 to 21)"
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 29 to 24)"
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 29 to 24)"
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 29 to 24)"
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 29 to 24)"
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 29 to 24)"
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 29 to 24)"
            }
        ]
    },
    "1140989984": {
        "name": "EXTI_RTSR2",
        "address": 1140989984,
        "size": 32,
        "access": "",
        "desc": "EXTI rising trigger selection register 2 ",
        "fields": [
            {
                "name": "RT50",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT53",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            }
        ]
    },
    "1140989988": {
        "name": "EXTI_FTSR2",
        "address": 1140989988,
        "size": 32,
        "access": "",
        "desc": "EXTI falling trigger selection register 2 ",
        "fields": [
            {
                "name": "FT50",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT53",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            }
        ]
    },
    "1140989992": {
        "name": "EXTI_SWIER2",
        "address": 1140989992,
        "size": 32,
        "access": "",
        "desc": "EXTI software interrupt event register 2 ",
        "fields": [
            {
                "name": "SWI50",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI53",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independent from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            }
        ]
    },
    "1140989996": {
        "name": "EXTI_RPR2",
        "address": 1140989996,
        "size": 32,
        "access": "",
        "desc": "EXTI rising edge pending register 2 ",
        "fields": [
            {
                "name": "RPIF50",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF53",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            }
        ]
    },
    "1140990000": {
        "name": "EXTI_FPR2",
        "address": 1140990000,
        "size": 32,
        "access": "",
        "desc": "EXTI falling edge pending register 2 ",
        "fields": [
            {
                "name": "FPIF50",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF53",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            }
        ]
    },
    "1140990008": {
        "name": "EXTI_PRIVCFGR2",
        "address": 1140990008,
        "size": 32,
        "access": "",
        "desc": "EXTI privilege configuration register 2 ",
        "fields": [
            {
                "name": "PRIV37",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 42 to 37)"
            },
            {
                "name": "PRIV38",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 42 to 37)"
            },
            {
                "name": "PRIV39",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 42 to 37)"
            },
            {
                "name": "PRIV40",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 42 to 37)"
            },
            {
                "name": "PRIV41",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 42 to 37)"
            },
            {
                "name": "PRIV42",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 42 to 37)"
            },
            {
                "name": "PRIV47",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x"
            },
            {
                "name": "PRIV49",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 50 to 49)"
            },
            {
                "name": "PRIV50",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x (x = 50 to 49)"
            },
            {
                "name": "PRIV53",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privilege enable on event input x"
            }
        ]
    },
    "1140990048": {
        "name": "EXTI_EXTICR1",
        "address": 1140990048,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register ",
        "fields": [
            {
                "name": "EXTI0",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI0 GPIO port selection\nThese bits are written by software to select the source input for EXTI0 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV0 is disabled, EXTI0 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV0 is enabled, EXTI0 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI1",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI1 GPIO port selection\nThese bits are written by software to select the source input for EXTI1 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV1 is disabled, EXTI1 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV1 is enabled, EXTI1 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI2",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI2 GPIO port selection\nThese bits are written by software to select the source input for EXTI2 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV2 is disabled, EXTI2 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV2 is enabled, EXTI2 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI3",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI3 GPIO port selectio\nThese bits are written by software to select the source input for EXTI3 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV3 is disabled, EXTI3 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV3 is enabled, EXTI3 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            }
        ]
    },
    "1140990052": {
        "name": "EXTI_EXTICR2",
        "address": 1140990052,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register ",
        "fields": [
            {
                "name": "EXTI4",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI4 GPIO port selection\nThese bits are written by software to select the source input for EXTI4 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV4 is disabled, EXTI4 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV4 is enabled, EXTI4 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI5",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI5 GPIO port selection\nThese bits are written by software to select the source input for EXTI5 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV5 is disabled, EXTI5 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV5 is enabled, EXTI5 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI6",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI6 GPIO port selection\nThese bits are written by software to select the source input for EXTI6 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV6 is disabled, EXTI6 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV6 is enabled, EXTI6 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI7",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI7 GPIO port selection\nThese bits are written by software to select the source input for EXTI7 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV7 is disabled, EXTI7 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV7 is enabled, EXTI7 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            }
        ]
    },
    "1140990056": {
        "name": "EXTI_EXTICR3",
        "address": 1140990056,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register ",
        "fields": [
            {
                "name": "EXTI8",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI8 GPIO port selection\nThese bits are written by software to select the source input for EXTIm external interrupt.\nWhen EXTI_PRIVCFGR.PRIV8 is disabled, EXTI8 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV8 is enabled, EXTI8 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI9",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI9 GPIO port selection\nThese bits are written by software to select the source input for EXTI9 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV9 is disabled, EXTI9 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV9 is enabled, EXTI9 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI10",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI10 GPIO port selection\nThese bits are written by software to select the source input for EXTI10 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV10 is disabled, EXTI10 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV10 is enabled, EXTI10 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI11",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI11 GPIO port selection\nThese bits are written by software to select the source input for EXTI11 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV11 is disabled, EXTI11 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV11 is enabled, EXTI11 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            }
        ]
    },
    "1140990060": {
        "name": "EXTI_EXTICR4",
        "address": 1140990060,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register ",
        "fields": [
            {
                "name": "EXTI12",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI12 GPIO port selection\nThese bits are written by software to select the source input for EXTI12 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV12 is disabled, EXTI12 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV12 is enabled, EXTI12 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI13",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI13 GPIO port selection\nThese bits are written by software to select the source input for EXTI13 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV13 is disabled, EXTI13 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV13 is enabled, EXTI13 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI14",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI14 GPIO port selection\nThese bits are written by software to select the source input for EXTI14 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV14 is disabled, EXTI14 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV14 is enabled, EXTI14 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI15",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI15 GPIO port selection\nThese bits are written by software to select the source input for EXTI15 external interrupt.\nWhen EXTI_PRIVCFGR.PRIV15 is disabled, EXTI15 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV15 is enabled, EXTI15 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            }
        ]
    },
    "1140990080": {
        "name": "EXTI_IMR1",
        "address": 1140990080,
        "size": 32,
        "access": "",
        "desc": "EXTI CPU wakeup with interrupt mask register ",
        "fields": [
            {
                "name": "IM0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 22 to 21)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 22 to 21)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            }
        ]
    },
    "1140990084": {
        "name": "EXTI_EMR1",
        "address": 1140990084,
        "size": 32,
        "access": "",
        "desc": "EXTI CPU wakeup with event mask register ",
        "fields": [
            {
                "name": "EM0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 17 to 0)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 22 to 21)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 22 to 21)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 29 to 24)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            }
        ]
    },
    "1140990096": {
        "name": "EXTI_IMR2",
        "address": 1140990096,
        "size": 32,
        "access": "",
        "desc": "EXTI CPU wakeup with interrupt mask register 2 ",
        "fields": [
            {
                "name": "IM37",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM38",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM39",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM40",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM41",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM42",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM47",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM49",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 50 to 49)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM50",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x  (x = 50 to 49)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM53",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            }
        ]
    },
    "1140990100": {
        "name": "EXTI_EMR2",
        "address": 1140990100,
        "size": 32,
        "access": "",
        "desc": "EXTI CPU wakeup with event mask register 2 ",
        "fields": [
            {
                "name": "EM37",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM38",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM39",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM40",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM41",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM42",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 42 to 37)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM47",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM49",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 50 to 49)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM50",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x (x = 50 to 49)\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM53",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            }
        ]
    },
    "1073783808": {
        "name": "FDCAN_CREL",
        "address": 1073783808,
        "size": 32,
        "access": "",
        "desc": "FDCAN core release register ",
        "fields": [
            {
                "name": "DAY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "18"
            },
            {
                "name": "MON",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "12"
            },
            {
                "name": "YEAR",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "4"
            },
            {
                "name": "SUBSTEP",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "1"
            },
            {
                "name": "STEP",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "2"
            },
            {
                "name": "REL",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "3"
            }
        ]
    },
    "1073783812": {
        "name": "FDCAN_ENDN",
        "address": 1073783812,
        "size": 32,
        "access": "",
        "desc": "FDCAN endian register ",
        "fields": [
            {
                "name": "ETV",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Endianness test value\nThe endianness test value is 0x8765 4321."
            }
        ]
    },
    "1073783820": {
        "name": "FDCAN_DBTP",
        "address": 1073783820,
        "size": 32,
        "access": "",
        "desc": "FDCAN data bit timing and prescaler register ",
        "fields": [
            {
                "name": "DSJW",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Synchronization jump width\nMust always be smaller than DTSEG2, valid values are 0 to 15. The value used by the hardware is the one programmed, incremented by 1: tSJW = (DSJW + 1) x tq."
            },
            {
                "name": "DTSEG2",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Data time segment after sample point\nValid values are 0 to 15. The value used by the hardware is the one programmed, incremented by 1, i.e. tBS2 = (DTSEG2 + 1) x tq."
            },
            {
                "name": "DTSEG1",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "Data time segment before sample point\nValid values are 0 to 31. The value used by the hardware is the one programmed, incremented by 1, i.e. tBS1 = (DTSEG1 + 1) x tq."
            },
            {
                "name": "DBRP",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Data bit rate prescaler\nThe value by which the oscillator frequency is divided to generate the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Baud Rate Prescaler are 0 to 31. The hardware interpreters this value as the value programmed plus 1."
            },
            {
                "name": "TDC",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transceiver delay compensation"
            }
        ]
    },
    "1073783824": {
        "name": "FDCAN_TEST",
        "address": 1073783824,
        "size": 32,
        "access": "",
        "desc": "FDCAN test register ",
        "fields": [
            {
                "name": "LBCK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Loop back mode"
            },
            {
                "name": "TX",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Control of transmit pin"
            },
            {
                "name": "RX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Receive pin\nMonitors the actual value of pin FDCANx_RX"
            }
        ]
    },
    "1073783828": {
        "name": "FDCAN_RWD",
        "address": 1073783828,
        "size": 32,
        "access": "",
        "desc": "FDCAN RAM watchdog register ",
        "fields": [
            {
                "name": "WDC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Watchdog configuration\nStart value of the message RAM watchdog counter. With the reset value of 00, the counter is disabled.\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of FDCAN_CCCR register are set to 1."
            },
            {
                "name": "WDV",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "Watchdog value\nActual message RAM watchdog counter value."
            }
        ]
    },
    "1073783832": {
        "name": "FDCAN_CCCR",
        "address": 1073783832,
        "size": 32,
        "access": "",
        "desc": "FDCAN CC control register ",
        "fields": [
            {
                "name": "INIT",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Initialization"
            },
            {
                "name": "CCE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Configuration change enable"
            },
            {
                "name": "ASM",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "ASM restricted operation mode\nThe restricted operation mode is intended for applications that adapt themselves to different CAN bit rates. The application tests different bit rates and leaves the Restricted operation Mode after it has received a valid frame. In the optional Restricted operation Mode the node is able to transmit and receive data and remote frames and it gives acknowledge to valid frames, but it does not send active error frames or overload frames. In case of an error condition or overload condition, it does not send dominant bits, instead it waits for the occurrence of bus idle condition to resynchronize itself to the CAN communication. The error counters are not incremented. Bit ASM can only be set by software when both CCE and INIT are set to 1. The bit can be reset by the software at any time."
            },
            {
                "name": "CSA",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clock stop acknowledge"
            },
            {
                "name": "CSR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clock stop request"
            },
            {
                "name": "MON",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Bus monitoring mode\nBit MON can only be set by software when both CCE and INIT are set to 1. The bit can be reset by the Host at any time."
            },
            {
                "name": "DAR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Disable automatic retransmission"
            },
            {
                "name": "TEST",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Test mode enable"
            },
            {
                "name": "FDOE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "FD operation enable"
            },
            {
                "name": "BRSE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "FDCAN bit rate switching"
            },
            {
                "name": "PXHD",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Protocol exception handling disable"
            },
            {
                "name": "EFBI",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Edge filtering during bus integration"
            },
            {
                "name": "TXP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "If this bit is set, the FDCAN pauses for two CAN bit times before starting the next transmission after successfully transmitting a frame."
            },
            {
                "name": "NISO",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Non ISO operation\nIf this bit is set, the FDCAN uses the CAN FD frame format as specified by the Bosch CAN FD Specification V1.0."
            }
        ]
    },
    "1073783836": {
        "name": "FDCAN_NBTP",
        "address": 1073783836,
        "size": 32,
        "access": "",
        "desc": "FDCAN nominal bit timing and prescaler register ",
        "fields": [
            {
                "name": "NTSEG2",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Nominal time segment after sample point\nValid values are 0 to 127. The actual interpretation by the hardware of this value is such that one more than the programmed value is used."
            },
            {
                "name": "NTSEG1",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "Nominal time segment before sample point\nValid values are 0 to 255. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "NBRP",
                "bitOffset": 16,
                "bitWidth": 9,
                "desc": "Bit rate prescaler\nValue by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values are 0 to 511. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "NSJW",
                "bitOffset": 25,
                "bitWidth": 7,
                "desc": "Nominal (re)synchronization jump width\nValid values are 0 to 127. The actual interpretation by the hardware of this value is such that the used value is the one programmed incremented by one.\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073783840": {
        "name": "FDCAN_TSCC",
        "address": 1073783840,
        "size": 32,
        "access": "",
        "desc": "FDCAN timestamp counter configuration register ",
        "fields": [
            {
                "name": "TSS",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Timestamp select\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "TCP",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Timestamp counter prescaler\nConfigures the timestamp and timeout counters time unit in multiples of CAN bit times\n."
            }
        ]
    },
    "1073783844": {
        "name": "FDCAN_TSCV",
        "address": 1073783844,
        "size": 32,
        "access": "",
        "desc": "FDCAN timestamp counter value register ",
        "fields": [
            {
                "name": "TSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Timestamp counter\nThe internal/external timestamp counter value is captured on start of frame (both Rx and Tx)."
            }
        ]
    },
    "1073783848": {
        "name": "FDCAN_TOCC",
        "address": 1073783848,
        "size": 32,
        "access": "",
        "desc": "FDCAN timeout counter configuration register ",
        "fields": [
            {
                "name": "ETOC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Timeout counter enable\nThis is a protected write (P) bit, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "TOS",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Timeout select\nWhen operating in Continuous mode, a write to TOCV presets the counter to the value configured by TOCC[TOP] and continues down-counting. When the timeout counter is controlled by one of the FIFOs, an empty FIFO presets the counter to the value configured by TOCC[TOP]. Down-counting is started when the first FIFO element is stored.\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "TOP",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Timeout period\nStart value of the timeout counter (down-counter). Configures the timeout period."
            }
        ]
    },
    "1073783852": {
        "name": "FDCAN_TOCV",
        "address": 1073783852,
        "size": 32,
        "access": "",
        "desc": "FDCAN timeout counter value register ",
        "fields": [
            {
                "name": "TOC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Timeout counter\nThe timeout counter is decremented in multiples of CAN bit times depending on the configuration of TSCC.TCP. When decremented to 0, interrupt flag IR.TOO is set and the timeout counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS."
            }
        ]
    },
    "1073783872": {
        "name": "FDCAN_ECR",
        "address": 1073783872,
        "size": 32,
        "access": "",
        "desc": "FDCAN error counter register ",
        "fields": [
            {
                "name": "TEC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Transmit error counter\nActual state of the transmit error counter, values between 0 and 255.\nWhen CCCR.ASM is set, the CAN protocol controller does not increment TEC and REC when a CAN protocol error is detected, but CEL is still incremented."
            },
            {
                "name": "REC",
                "bitOffset": 8,
                "bitWidth": 7,
                "desc": "Receive error counter\nActual state of the receive error counter, values between 0 and 127."
            },
            {
                "name": "RP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Receive error passive"
            },
            {
                "name": "CEL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "CAN error logging\nThe counter is incremented each time when a CAN protocol error causes the transmit error counter or the receive error counter to be incremented. It is reset by read access to CEL. The counter stops at 0xFF; the next increment of TEC or REC sets interrupt flag IR[ELO].\nAccess type is RX: reset on read."
            }
        ]
    },
    "1073783876": {
        "name": "FDCAN_PSR",
        "address": 1073783876,
        "size": 32,
        "access": "",
        "desc": "FDCAN protocol status register ",
        "fields": [
            {
                "name": "LEC",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Last error code\nThe LEC indicates the type of the last error to occur on the CAN bus. This field is cleared to 0 when a message has been transferred (reception or transmission) without error.\nAccess type is RS: set on read."
            },
            {
                "name": "ACT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Activity\nMonitors the module's CAN communication state."
            },
            {
                "name": "EP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Error passive"
            },
            {
                "name": "EW",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Warning Sstatus"
            },
            {
                "name": "BO",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Bus_Off status"
            },
            {
                "name": "DLEC",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "Data last error code\nType of last error that occurred in the data phase of a FDCAN format frame with its BRS flag set. Coding is the same as for LEC. This field is cleared to 0 when a FDCAN format frame with its BRS flag set has been transferred (reception or transmission) without error.\nAccess type is RS: set on read."
            },
            {
                "name": "RESI",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "ESI flag of last received FDCAN message\nThis bit is set together with REDL, independent of acceptance filtering.\nAccess type is RX: reset on read."
            },
            {
                "name": "RBRS",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "BRS flag of last received FDCAN message\nThis bit is set together with REDL, independent of acceptance filtering.\nAccess type is RX: reset on read."
            },
            {
                "name": "REDL",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Received FDCAN message\nThis bit is set independent of acceptance filtering.\nAccess type is RX: reset on read."
            },
            {
                "name": "PXE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Protocol exception event"
            },
            {
                "name": "TDCV",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Transmitter delay compensation value\nPosition of the secondary sample point, defined by the sum of the measured delay from FDCAN_TX to FDCAN_RX and TDCR.TDCO. The SSP position is, in the data phase, the number of minimum time quanta (mtq) between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq."
            }
        ]
    },
    "1073783880": {
        "name": "FDCAN_TDCR",
        "address": 1073783880,
        "size": 32,
        "access": "",
        "desc": "FDCAN transmitter delay compensation register ",
        "fields": [
            {
                "name": "TDCF",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Transmitter delay compensation filter window length\nDefines the minimum value for the SSP position, dominant edges on FDCAN_RX that would result in an earlier SSP position are ignored for transmitter delay measurements.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "TDCO",
                "bitOffset": 8,
                "bitWidth": 7,
                "desc": "Transmitter delay compensation offset\nOffset value defining the distance between the measured delay from FDCAN_TX to FDCAN_RX and the secondary sample point. Valid values are 0 to 127 mtq.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073783888": {
        "name": "FDCAN_IR",
        "address": 1073783888,
        "size": 32,
        "access": "",
        "desc": "FDCAN interrupt register ",
        "fields": [
            {
                "name": "RF0N",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 new message"
            },
            {
                "name": "RF0F",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 full"
            },
            {
                "name": "RF0L",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 message lost"
            },
            {
                "name": "RF1N",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 new message"
            },
            {
                "name": "RF1F",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 full"
            },
            {
                "name": "RF1L",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 message lost"
            },
            {
                "name": "HPM",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "High-priority message"
            },
            {
                "name": "TC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transmission completed"
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Transmission cancellation finished"
            },
            {
                "name": "TFE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Tx FIFO empty"
            },
            {
                "name": "TEFN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Tx event FIFO New Entry"
            },
            {
                "name": "TEFF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Tx event FIFO full"
            },
            {
                "name": "TEFL",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Tx event FIFO element lost"
            },
            {
                "name": "TSW",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Timestamp wraparound"
            },
            {
                "name": "MRAF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Message RAM access failure\nThe flag is set when the Rx handler:\nhas not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message storage is aborted and the Rx handler starts processing of the following message.\nwas unable to write a message to the message RAM. In this case message storage is aborted.\nIn both cases the FIFO put index is not updated. The partly stored message is overwritten when the next message is stored to this location.\nThe flag is also set when the Tx Handler was not able to read a message from the Message RAM in time. In this case message transmission is aborted. In case of a Tx Handler access failure the FDCAN is switched into Restricted operation Mode (see mode). To leave Restricted operation Mode, the Host CPU has to reset CCCR.ASM."
            },
            {
                "name": "TOO",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Timeout occurred"
            },
            {
                "name": "ELO",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Error logging overflow"
            },
            {
                "name": "EP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Error passive"
            },
            {
                "name": "EW",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Warning status"
            },
            {
                "name": "BO",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Bus_Off status"
            },
            {
                "name": "WDI",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Watchdog interrupt"
            },
            {
                "name": "PEA",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Protocol error in arbitration phase (nominal bit time is used)"
            },
            {
                "name": "PED",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Protocol error in data phase (data bit time is used)"
            },
            {
                "name": "ARA",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Access to reserved address"
            }
        ]
    },
    "1073783892": {
        "name": "FDCAN_IE",
        "address": 1073783892,
        "size": 32,
        "access": "",
        "desc": "FDCAN interrupt enable register ",
        "fields": [
            {
                "name": "RF0NE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 new message interrupt enable"
            },
            {
                "name": "RF0FE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 full interrupt enable"
            },
            {
                "name": "RF0LE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 message lost interrupt enable"
            },
            {
                "name": "RF1NE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 new message interrupt enable"
            },
            {
                "name": "RF1FE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 full interrupt enable"
            },
            {
                "name": "RF1LE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 message lost interrupt enable"
            },
            {
                "name": "HPME",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "High-priority message interrupt enable"
            },
            {
                "name": "TCE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transmission completed interrupt enable"
            },
            {
                "name": "TCFE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Transmission cancellation finished interrupt enable"
            },
            {
                "name": "TFEE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Tx FIFO empty interrupt enable"
            },
            {
                "name": "TEFNE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Tx event FIFO new entry interrupt enable"
            },
            {
                "name": "TEFFE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Tx event FIFO full interrupt enable"
            },
            {
                "name": "TEFLE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Tx event FIFO element lost interrupt enable"
            },
            {
                "name": "TSWE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Timestamp wraparound interrupt enable"
            },
            {
                "name": "MRAFE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Message RAM access failure interrupt enable"
            },
            {
                "name": "TOOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Timeout occurred interrupt enable"
            },
            {
                "name": "ELOE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Error logging overflow interrupt enable"
            },
            {
                "name": "EPE",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Error passive interrupt enable"
            },
            {
                "name": "EWE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Warning status interrupt enable"
            },
            {
                "name": "BOE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Bus_Off status"
            },
            {
                "name": "WDIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Watchdog interrupt enable"
            },
            {
                "name": "PEAE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Protocol error in arbitration phase enable"
            },
            {
                "name": "PEDE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Protocol error in data phase enable"
            },
            {
                "name": "ARAE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Access to reserved address enable"
            }
        ]
    },
    "1073783896": {
        "name": "FDCAN_ILS",
        "address": 1073783896,
        "size": 32,
        "access": "",
        "desc": "FDCAN interrupt line select register ",
        "fields": [
            {
                "name": "RxFIFO0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RX FIFO bit grouping the following interruption\nRF0LL: Rx FIFO 0 message lost interrupt line\nRF0FL: Rx FIFO 0 full interrupt line\nRF0NL: Rx FIFO 0 new message interrupt line"
            },
            {
                "name": "RxFIFO1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "RX FIFO bit grouping the following interruption\nRF1LL: Rx FIFO 1 message lost interrupt line\nRF1FL: Rx FIFO 1 full Interrupt line\nRF1NL: Rx FIFO 1 new message interrupt line"
            },
            {
                "name": "SMSG",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Status message bit grouping the following interruption\nTCFL: Transmission cancellation finished interrupt line\nTCL: Transmission completed interrupt line\nHPML: High-priority message interrupt line"
            },
            {
                "name": "TFERR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Tx FIFO ERROR grouping the following interruption\nTEFLL: Tx event FIFO element lost interrupt line\nTEFFL: Tx event FIFO full interrupt line\nTEFNL: Tx event FIFO new entry interrupt line\nTFEL: Tx FIFO empty interrupt line"
            },
            {
                "name": "MISC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Interrupt regrouping the following interruption\nTOOL: Timeout occurred interrupt line\nMRAFL: Message RAM access failure interrupt line\nTSWL: Timestamp wraparound interrupt line"
            },
            {
                "name": "BERR",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Bit and line error grouping the following interruption\nEPL Error passive interrupt line\nELOL: Error logging overflow interrupt line"
            },
            {
                "name": "PERR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Protocol error grouping the following interruption\nARAL: Access to reserved address line\nPEDL: Protocol error in data phase line\nPEAL: Protocol error in arbitration phase line\nWDIL: Watchdog interrupt line\nBOL: Bus_Off status\nEWL: Warning status interrupt line"
            }
        ]
    },
    "1073783900": {
        "name": "FDCAN_ILE",
        "address": 1073783900,
        "size": 32,
        "access": "",
        "desc": "FDCAN interrupt line enable register ",
        "fields": [
            {
                "name": "EINT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Enable interrupt line 0"
            },
            {
                "name": "EINT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Enable interrupt line 1"
            }
        ]
    },
    "1073783936": {
        "name": "FDCAN_RXGFC",
        "address": 1073783936,
        "size": 32,
        "access": "",
        "desc": "FDCAN global filter configuration register ",
        "fields": [
            {
                "name": "RRFE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Reject remote frames extended\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "RRFS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Reject remote frames standard\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "ANFE",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Accept non-matching frames extended\nDefines how received messages with 29-bit IDs that do not match any element of the filter list are treated.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "ANFS",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Accept Non-matching frames standard\nDefines how received messages with 11-bit IDs that do not match any element of the filter list are treated.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "F1OM",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "FIFO 1 operation mode (overwrite or blocking)\nThis is a protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "F0OM",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "FIFO 0 operation mode (overwrite or blocking)\nThis is protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "LSS",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "List size standard\n28: Values greater than 28 are interpreted as 28.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "LSE",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "List size extended\n8: Values greater than 8 are interpreted as 8.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073783940": {
        "name": "FDCAN_XIDAM",
        "address": 1073783940,
        "size": 32,
        "access": "",
        "desc": "FDCAN extended ID and mask register ",
        "fields": [
            {
                "name": "EIDM",
                "bitOffset": 0,
                "bitWidth": 29,
                "desc": "Extended ID mask\nFor acceptance filtering of extended frames the Extended ID AND Mask is AND-ed with the Message ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all bits set to 1 the mask is not active.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073783944": {
        "name": "FDCAN_HPMS",
        "address": 1073783944,
        "size": 32,
        "access": "",
        "desc": "FDCAN high-priority message status register ",
        "fields": [
            {
                "name": "BIDX",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Buffer index\nIndex of Rx FIFO element to which the message was stored. Only valid when MSI[1] = 1."
            },
            {
                "name": "MSI",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Message storage indicator"
            },
            {
                "name": "FIDX",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "Filter index\nIndex of matching filter element. Range is 0 to RXGFC[LSS] - 1 or RXGFC[LSE] - 1."
            },
            {
                "name": "FLST",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Filter list\nIndicates the filter list of the matching filter element."
            }
        ]
    },
    "1073783952": {
        "name": "FDCAN_RXF0S",
        "address": 1073783952,
        "size": 32,
        "access": "",
        "desc": "FDCAN Rx FIFO 0 status register ",
        "fields": [
            {
                "name": "F0FL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Rx FIFO 0 fill level\nNumber of elements stored in Rx FIFO 0, range 0 to 3."
            },
            {
                "name": "F0GI",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Rx FIFO 0 get index\nRx FIFO 0 read index pointer, range 0 to 2."
            },
            {
                "name": "F0PI",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Rx FIFO 0 put index\nRx FIFO 0 write index pointer, range 0 to 2."
            },
            {
                "name": "F0F",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 full"
            },
            {
                "name": "RF0L",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 message lost\nThis bit is a copy of interrupt flag IR[RF0L]. When IR[RF0L] is reset, this bit is also reset."
            }
        ]
    },
    "1073783956": {
        "name": "FDCAN_RXF0A",
        "address": 1073783956,
        "size": 32,
        "access": "",
        "desc": "CAN Rx FIFO 0 acknowledge register ",
        "fields": [
            {
                "name": "F0AI",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Rx FIFO 0 acknowledge index\nAfter the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the buffer index of the last element read from Rx FIFO 0 to F0AI. This sets the Rx FIFO 0 get index RXF0S[F0GI] to F0AI + 1 and update the FIFO 0 fill level RXF0S[F0FL]."
            }
        ]
    },
    "1073783960": {
        "name": "FDCAN_RXF1S",
        "address": 1073783960,
        "size": 32,
        "access": "",
        "desc": "FDCAN Rx FIFO 1 status register ",
        "fields": [
            {
                "name": "F1FL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Rx FIFO 1 fill level\nNumber of elements stored in Rx FIFO 1, range 0 to 3."
            },
            {
                "name": "F1GI",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Rx FIFO 1 get index\nRx FIFO 1 read index pointer, range 0 to 2."
            },
            {
                "name": "F1PI",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Rx FIFO 1 put index\nRx FIFO 1 write index pointer, range 0 to 2."
            },
            {
                "name": "F1F",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 full"
            },
            {
                "name": "RF1L",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 message lost\nThis bit is a copy of interrupt flag IR[RF1L]. When IR[RF1L] is reset, this bit is also reset."
            }
        ]
    },
    "1073783964": {
        "name": "FDCAN_RXF1A",
        "address": 1073783964,
        "size": 32,
        "access": "",
        "desc": "FDCAN Rx FIFO 1 acknowledge register ",
        "fields": [
            {
                "name": "F1AI",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Rx FIFO 1 acknowledge index\nAfter the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the buffer index of the last element read from Rx FIFO 1 to F1AI. This sets the Rx FIFO 1 get index RXF1S[F1GI] to F1AI + 1 and update the FIFO 1 Fill Level RXF1S[F1FL]."
            }
        ]
    },
    "1073784000": {
        "name": "FDCAN_TXBC",
        "address": 1073784000,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer configuration register ",
        "fields": [
            {
                "name": "TFQM",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Tx FIFO/queue mode\nThis is a protected write (P) bit, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073784004": {
        "name": "FDCAN_TXFQS",
        "address": 1073784004,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx FIFO/queue status register ",
        "fields": [
            {
                "name": "TFFL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Tx FIFO free level\nNumber of consecutive free Tx FIFO elements starting from TFGI, range 0 to 3. Read as 0 when Tx queue operation is configured (TXBC[TFQM] = 1)."
            },
            {
                "name": "TFGI",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Tx FIFO get index\nTx FIFO read index pointer, range 0 to 3. Read as 0 when Tx queue operation is configured (TXBC.TFQM = 1)"
            },
            {
                "name": "TFQPI",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Tx FIFO/queue put index\nTx FIFO/queue write index pointer, range 0 to 3"
            },
            {
                "name": "TFQF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Tx FIFO/queue full"
            }
        ]
    },
    "1073784008": {
        "name": "FDCAN_TXBRP",
        "address": 1073784008,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer request pending register ",
        "fields": [
            {
                "name": "TRP",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Transmission request pending\nEach Tx buffer has its own transmission request pending bit. The bits are set via register TXBAR. The bits are reset after a requested transmission has completed or has been canceled via register TXBCR.\nAfter a TXBRP bit has been set, a Tx scan is started to check for the pending Tx request with the highest priority (Tx buffer with lowest Message ID).\nA cancellation request resets the corresponding transmission request pending bit of register TXBRP. In case a transmission has already been started when a cancellation is requested, this is done at the end of the transmission, regardless whether the transmission was successful or not. The cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.\nAfter a cancellation has been requested, a finished cancellation is signaled via TXBCF\nafter successful transmission together with the corresponding TXBTO bit\nwhen the transmission has not yet been started at the point of cancellation\nwhen the transmission has been aborted due to lost arbitration\nwhen an error occurred during frame transmission\nIn DAR mode all transmissions are automatically canceled if they are not successful. The corresponding TXBCF bit is set for all unsuccessful transmissions."
            }
        ]
    },
    "1073784012": {
        "name": "FDCAN_TXBAR",
        "address": 1073784012,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer add request register ",
        "fields": [
            {
                "name": "AR",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Add request\nEach Tx buffer has its own add request bit. Writing a 1 sets the corresponding add request bit; writing a 0 has no impact. This enables the Host to set transmission requests for multiple Tx buffers with one write to TXBAR. When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan process has completed."
            }
        ]
    },
    "1073784016": {
        "name": "FDCAN_TXBCR",
        "address": 1073784016,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer cancellation request register ",
        "fields": [
            {
                "name": "CR",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Cancellation request\nEach Tx buffer has its own cancellation request bit. Writing a 1 sets the corresponding CR bit; writing a 0 has no impact.\nThis enables the Host to set cancellation requests for multiple Tx buffers with one write to TXBCR. The bits remain set until the corresponding TXBRP bit is reset."
            }
        ]
    },
    "1073784020": {
        "name": "FDCAN_TXBTO",
        "address": 1073784020,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer transmission occurred register ",
        "fields": [
            {
                "name": "TO",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Transmission occurred.\nEach Tx buffer has its own TO bit. The bits are set when the corresponding TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission is requested by writing a 1 to the corresponding bit of register TXBAR."
            }
        ]
    },
    "1073784024": {
        "name": "FDCAN_TXBCF",
        "address": 1073784024,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer cancellation finished register ",
        "fields": [
            {
                "name": "CF",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Cancellation finished\nEach Tx buffer has its own CF bit. The bits are set when the corresponding TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a new transmission is requested by writing a 1 to the corresponding bit of register TXBAR."
            }
        ]
    },
    "1073784028": {
        "name": "FDCAN_TXBTIE",
        "address": 1073784028,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer transmission interrupt enable register\t",
        "fields": [
            {
                "name": "TIE",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Transmission interrupt enable\nEach Tx buffer has its own TIE bit."
            }
        ]
    },
    "1073784032": {
        "name": "FDCAN_TXBCIE",
        "address": 1073784032,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer cancellation finished interrupt enable register\t",
        "fields": [
            {
                "name": "CFIE",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Cancellation finished interrupt enable.\nEach Tx buffer has its own CFIE bit."
            }
        ]
    },
    "1073784036": {
        "name": "FDCAN_TXEFS",
        "address": 1073784036,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx event FIFO status register ",
        "fields": [
            {
                "name": "EFFL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Event FIFO fill level\nNumber of elements stored in Tx event FIFO, range 0 to 3."
            },
            {
                "name": "EFGI",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Event FIFO get index\nTx event FIFO read index pointer, range 0 to 3."
            },
            {
                "name": "EFPI",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Event FIFO put index\nTx event FIFO write index pointer, range 0 to 3."
            },
            {
                "name": "EFF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Event FIFO full"
            },
            {
                "name": "TEFL",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Tx event FIFO element lost\nThis bit is a copy of interrupt flag IR[TEFL]. When IR[TEFL] is reset, this bit is also reset.\n0 No Tx event FIFO element lost\n1 Tx event FIFO element lost, also set after write attempt to Tx event FIFO of size 0."
            }
        ]
    },
    "1073784040": {
        "name": "FDCAN_TXEFA",
        "address": 1073784040,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx event FIFO acknowledge register ",
        "fields": [
            {
                "name": "EFAI",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Event FIFO acknowledge index\nAfter the Host has read an element or a sequence of elements from the Tx event FIFO, it has to write the index of the last element read from Tx event FIFO to EFAI. This sets the Tx event FIFO get index TXEFS[EFGI] to EFAI + 1 and updates the FIFO 0 fill level TXEFS[EFFL]."
            }
        ]
    },
    "1073784064": {
        "name": "FDCAN_CKDIV",
        "address": 1073784064,
        "size": 32,
        "access": "",
        "desc": "FDCAN CFG clock divider register ",
        "fields": [
            {
                "name": "PDIV",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "input clock divider\nThe APB clock could be divided prior to be used by the CAN sub system. The rate must be computed using the divider output clock.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073881088": {
        "name": "FLASH_ACR",
        "address": 1073881088,
        "size": 32,
        "access": "",
        "desc": "FLASH access control register ",
        "fields": [
            {
                "name": "LATENCY",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Read latency\nThese bits are used to control the number of wait states used during read operations on both non-volatile memory banks. The application software has to program them to the correct value depending on the embedded Flash memory interface frequency and voltage conditions.\n...\nNote: No check is performed by hardware to verify that the configuration is correct."
            },
            {
                "name": "WRHIGHFREQ",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Flash signal delay\nThese bits are used to control the delay between non-volatile memory signals during programming operations. Application software has to program them to the correct value depending on the embedded Flash memory interface frequency. Please refer to  for details.\nNote: No check is performed to verify that the configuration is correct.\nTwo WRHIGHFREQ values can be selected for some frequencies."
            },
            {
                "name": "PRFTEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Prefetch enable. When bit value is modified, user must read back ACR register to be sure PRFTEN has been taken into account.\nBits used to control the prefetch."
            },
            {
                "name": "S_PRFTEN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Smart prefetch enable. When bit value is modified, user must read back ACR register to be sure S_PRFTEN has been taken into account.\nBits used to control the prefetch functionality."
            }
        ]
    },
    "1073881092": {
        "name": "FLASH_NSKEYR",
        "address": 1073881092,
        "size": 32,
        "access": "",
        "desc": "FLASH key register ",
        "fields": [
            {
                "name": "NSKEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Non-volatile memory configuration access unlock key"
            }
        ]
    },
    "1073881100": {
        "name": "FLASH_OPTKEYR",
        "address": 1073881100,
        "size": 32,
        "access": "",
        "desc": "FLASH option key register ",
        "fields": [
            {
                "name": "OPTKEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "FLASH option bytes control access unlock key"
            }
        ]
    },
    "1073881112": {
        "name": "FLASH_OPSR",
        "address": 1073881112,
        "size": 32,
        "access": "",
        "desc": "FLASH operation status register ",
        "fields": [
            {
                "name": "ADDR_OP",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Interrupted operation address."
            },
            {
                "name": "BK_OP",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Interrupted operation bank\nIt indicates which bank was concerned by operation."
            },
            {
                "name": "SYSF_OP",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Operation in system Flash memory interrupted\nIndicates that reset interrupted an ongoing operation in System Flash."
            },
            {
                "name": "OTP_OP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "OTP operation interrupted\nIndicates that reset interrupted an ongoing operation in OTP area."
            },
            {
                "name": "CODE_OP",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "Flash memory operation code"
            }
        ]
    },
    "1073881116": {
        "name": "FLASH_OPTCR",
        "address": 1073881116,
        "size": 32,
        "access": "",
        "desc": "FLASH option control register ",
        "fields": [
            {
                "name": "OPTLOCK",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "FLASH_OPTCR lock option configuration bit\nThe OPTLOCK bit locks the FLASH_OPTCR register as well as all _PRG registers. The correct write sequence to FLASH_OPTKEYR register unlocks this bit. If a wrong sequence is executed, or the unlock sequence to FLASH_OPTKEYR is performed twice, this bit remains locked until next system reset.\nIt is possible to set OPTLOCK by programming it to 1. When set to 1, a new unlock sequence is mandatory to unlock it. When OPTLOCK changes from 0 to 1, the others bits of FLASH_OPTCR register do not change."
            },
            {
                "name": "OPTSTRT",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Option byte start change option configuration bit\nOPTSTRT triggers an option byte change operation. The user can set OPTSTRT only when the OPTLOCK bit is cleared to 0. It's set only by Software and cleared when the option byte change is completed or an error occurs (PGSERR or OPTCHANGEERR). It's reseted at the same time as BSY bit.\nThe user application cannot modify any FLASH_XXX_PRG embedded Flash memory register until the option change operation has been completed.\nBefore setting this bit, the user has to write the required values in the FLASH_XXX_PRG registers. The FLASH_XXX_PRG registers are locked until the option byte change operation has been executed in non-volatile memory."
            },
            {
                "name": "SWAP_BANK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Bank swapping option configuration bit\nSWAP_BANK controls whether Bank1 and Bank2 are swapped or not. This bit is loaded with the SWAP_BANK bit of FLASH_OPTSR_CUR register only after reset or POR."
            }
        ]
    },
    "1073881120": {
        "name": "FLASH_NSSR",
        "address": 1073881120,
        "size": 32,
        "access": "",
        "desc": "FLASH non-secure status register ",
        "fields": [
            {
                "name": "BSY",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "busy flag\nBSY flag indicates that a Flash memory is busy by an operation (write, erase, option byte change). It is set at the beginning of a Flash memory operation and cleared when the operation finishes or an error occurs."
            },
            {
                "name": "WBNE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "write buffer not empty flag\nWBNE flag is set when the embedded Flash memory is waiting for new data to complete the write buffer. In this state, the write buffer is not empty. WBNE is reset by hardware each time the write buffer is complete or the write buffer is emptied following one of the event below:\nthe application software forces the write operation using FW bit in FLASH_NSCR\nthe embedded Flash memory detects an error that involves data loss\nThis bit cannot be reset by software writing 0 directly. To reset it, clear the write buffer by performing any of the above listed actions, or send the missing data."
            },
            {
                "name": "DBNE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "data buffer not empty flag\nDBNE flag is set when the embedded Flash memory interface is processing 6-bits ECC data in dedicated buffer. This bit cannot be set to 0 by software. The hardware resets it once the buffer is free."
            },
            {
                "name": "EOP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "end of operation flag\nEOP flag is set when a operation (program/erase) completes. An interrupt is generated if the EOPIE is set to 1. It is not necessary to reset EOP before starting a new operation. EOP bit is cleared by writing 1 to CLR_EOP bit in FLASH_NSCCR register."
            },
            {
                "name": "WRPERR",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "write protection error flag\nWRPERR flag is raised when a protection error occurs during a program operation. An interrupt is also generated if the WRPERRIE is set to 1. Writing 1 to CLR_WRPERR bit in FLASH_NSCCR register clears WRPERR."
            },
            {
                "name": "PGSERR",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "programming sequence error flag\nPGSERR flag is raised when a sequence error occurs. An interrupt is generated if the PGSERRIE bit is set to 1. Writing 1 to CLR_PGSERR bit in FLASH_NSCCR register clears PGSERR."
            },
            {
                "name": "STRBERR",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "strobe error flag\nSTRBERR flag is raised when a strobe error occurs (when the master attempts to write several times the same byte in the write buffer). An interrupt is generated if the STRBERRIE bit is set to 1. Writing 1 to CLR_STRBERR bit in FLASH_NSCCR register clears STRBERR."
            },
            {
                "name": "INCERR",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "inconsistency error flag\nINCERR flag is raised when a inconsistency error occurs. An interrupt is generated if INCERRIE is set to 1. Writing 1 to CLR_INCERR bit in the FLASH_NSCCR register clears INCERR."
            },
            {
                "name": "OPTCHANGEERR",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Option byte change error flag\nOPTCHANGEERR flag indicates that an error occurred during an option byte change operation. When OPTCHANGEERR is set to 1, the option byte change operation did not successfully complete. An interrupt is generated when this flag is raised if the OPTCHANGEERRIE bit of FLASH_NSCR register is set to 1.\nWriting 1 to CLR_OPTCHANGEERR of register FLASH_CCR clears OPTCHANGEERR.\nNote: The OPTSTRT bit in FLASH_OPTCR cannot be set while OPTCHANGEERR is set."
            }
        ]
    },
    "1073881124": {
        "name": "FLASH_SECSR",
        "address": 1073881124,
        "size": 32,
        "access": "",
        "desc": "FLASH secure status register ",
        "fields": [
            {
                "name": "SECBSY",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "busy flag\nBSY flag indicates that a FLASH memory is busy by an operation (write, erase, option byte change, OBK operations, PUF operation). It is set at the beginning of a Flash memory operation and cleared when the operation finishes or an error occurs."
            },
            {
                "name": "SECWBNE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "write buffer not empty flag\nWBNE flag is set when the embedded Flash memory is waiting for new data to complete the write buffer. In this state, the write buffer is not empty. WBNE is reset by hardware each time the write buffer is complete or the write buffer is emptied following one of the event below:\nthe application software forces the write operation using FW bit in FLASH_SECCR\nthe embedded Flash memory detects an error that involves data loss\nThis bit cannot be reset by writing 0 directly by software. To reset it, clear the write buffer by performing any of the above listed actions, or send the missing data."
            },
            {
                "name": "SECDBNE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "data buffer not empty flag\nDBNE flag is set when the embedded Flash memory interface is processing 6-bits ECC data in dedicated buffer. This bit cannot be set to 0 by software. The hardware resets it once the buffer is free."
            },
            {
                "name": "SECEOP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "end of operation flag\nEOP flag is set when a operation (program/erase) completes. An interrupt is generated if the EOPIE is set to. It is not necessary to reset EOP before starting a new operation. EOP bit is cleared by writing 1 to CLR_EOP bit in FLASH_SECCCR register."
            },
            {
                "name": "SECWRPERR",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "write protection error flag\nWRPERR flag is raised when a protection error occurs during a program operation. An interrupt is also generated if the WRPERRIE is set to 1. Writing 1 to CLR_WRPERR bit in FLASH_SECCCR register clears WRPERR."
            },
            {
                "name": "SECPGSERR",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "programming sequence error flag\nPGSERR flag is raised when a sequence error occurs. An interrupt is generated if the PGSERRIE bit is set to 1. Writing 1 to CLR_PGSERR bit in FLASH_SECCCR register clears PGSERR."
            },
            {
                "name": "SECSTRBERR",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "strobe error flag\nSTRBERR flag is raised when a strobe error occurs (when the master attempts to write several times the same byte in the write buffer). An interrupt is generated if the STRBERRIE bit is set to 1. Writing 1 to CLR_STRBERR bit in FLASH_SECCCR register clears STRBERR."
            },
            {
                "name": "SECINCERR",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "inconsistency error flag\nINCERR flag is raised when a inconsistency error occurs. An interrupt is generated if INCERRIE is set to 1. Writing 1 to CLR_INCERR bit in the FLASH_SECCCR register clears INCERR."
            }
        ]
    },
    "1073881128": {
        "name": "FLASH_NSCR",
        "address": 1073881128,
        "size": 32,
        "access": "",
        "desc": "FLASH Non Secure control register ",
        "fields": [
            {
                "name": "LOCK",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "configuration lock bit\nThis bit locks the FLASH_NSCR register. The correct write sequence to FLASH_NSKEYR register unlocks this bit. If a wrong sequence is executed, or if the unlock sequence to FLASH_NSKEYR is performed twice, this bit remains locked until the next system reset.\nLOCK can be set by programming it to 1. When set to 1, a new unlock sequence is mandatory to unlock it. When LOCK changes from 0 to 1, the other bits of FLASH_NSCR register do not change."
            },
            {
                "name": "PG",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "programming control bit\nPG can be programmed only when LOCK is cleared to 0.\nPG allows programming in Bank1 and Bank2."
            },
            {
                "name": "SER",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "sector erase request\nSetting SER bit to 1 requests a sector erase. SER can be programmed only when LOCK is cleared to 0.\nIf MER and SER are also set, a PGSERR is raised."
            },
            {
                "name": "BER",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "erase request\nSetting BER bit to 1 requests a bank erase operation (user Flash memory only). BER can be programmed only when LOCK is cleared to 0.\nIf MER and SER are also set, a PGSERR is raised.\nNote: Write protection error is triggered when a bank erase is required and some sectors are protected."
            },
            {
                "name": "FW",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "write forcing control bit\nFW forces a write operation even if the write buffer is not full. In this case all bits not written are set to 1 by hardware. FW can be programmed only when LOCK is cleared to 0.\nThe embedded Flash memory resets FW when the corresponding operation has been acknowledged.\nNote: Using a force-write operation prevents the application from updating later the missing bits with something else than 1, because it is likely that it leads to permanent ECC error.\nWrite forcing is effective only if the write buffer is not empty (in particular, FW does not start several write operations when the force-write operations are performed consecutively).\nSince there is just one write buffer, FW can force a write in bank1 or bank2."
            },
            {
                "name": "STRT",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "erase start control bit\nSTRT bit is used to start a sector erase or a bank erase operation. STRT can be programmed only when LOCK is cleared to 0.\nSTRT is reset at the end of the operation or when an error occurs. It cannot be reseted by software."
            },
            {
                "name": "SNB",
                "bitOffset": 6,
                "bitWidth": 3,
                "desc": "sector erase selection number\nThese bits are used to select the target sector for an erase operation (they are unused otherwise). SNB can be programmed only when LOCK is cleared to 0.\n..."
            },
            {
                "name": "MER",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Mass erase request\nSetting MER bit to 1 requests a mass erase operation (user Flash memory only). MER can be programmed only when LOCK is cleared to 0.\nIf BER or SER are both set, a PGSERR is raised.\nError is triggered when a mass erase is required and some sectors are protected."
            },
            {
                "name": "EOPIE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "end of operation interrupt control bit\nSetting EOPIE bit to 1 enables the generation of an interrupt at the end of a program or erase operation. EOPIE can be programmed only when LOCK is cleared to 0."
            },
            {
                "name": "WRPERRIE",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "write protection error interrupt enable bit\nWhen WRPERRIE bit is set to 1, an interrupt is generated when a protection error occurs during a program operation. WRPERRIE can be programmed only when LOCK is cleared to 0."
            },
            {
                "name": "PGSERRIE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "programming sequence error interrupt enable bit\nWhen PGSERRIE bit is set to 1, an interrupt is generated when a sequence error occurs during a program operation. PGSERRIE can be programmed only when LOCK is cleared to 0."
            },
            {
                "name": "STRBERRIE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "strobe error interrupt enable bit\nWhen STRBERRIE bit is set to 1, an interrupt is generated when a strobe error occurs (the master programs several times the same byte in the write buffer) during a write operation. STRBERRIE can be programmed only when LOCK is cleared to 0."
            },
            {
                "name": "INCERRIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "inconsistency error interrupt enable bit\nWhen INCERRIE bit is set to 1, an interrupt is generated when an inconsistency error occurs during a write operation. INCERRIE can be programmed only when LOCK is cleared to 0."
            },
            {
                "name": "OPTCHANGEERRIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Option byte change error interrupt enable bit\nOPTCHANGEERRIE bit controls if an interrupt has to be generated when an error occurs during an option byte change. This bit can be programmed only when LOCK bit is cleared to 0."
            },
            {
                "name": "BKSEL",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Bank selector bit\nBKSEL can only be programmed when LOCK is cleared to 0. The bit selects physical bank, SWAP_BANK setting is ignored."
            }
        ]
    },
    "1073881136": {
        "name": "FLASH_NSCCR",
        "address": 1073881136,
        "size": 32,
        "access": "",
        "desc": "FLASH non-secure clear control register ",
        "fields": [
            {
                "name": "CLR_EOP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "EOP flag clear bit\nSetting this bit to 1 resets to 0 EOP flag in FLASH_NSSR register."
            },
            {
                "name": "CLR_WRPERR",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "WRPERR flag clear bit\nSetting this bit to 1 resets to 0 WRPERR flag in FLASH_NSSR register."
            },
            {
                "name": "CLR_PGSERR",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "PGSERR flag clear bit\nSetting this bit to 1 resets to 0 PGSERR flag in FLASH_NSSR register."
            },
            {
                "name": "CLR_STRBERR",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "STRBERR flag clear bit\nSetting this bit to 1 resets to 0 STRBERR flag in FLASH_NSSR register."
            },
            {
                "name": "CLR_INCERR",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "INCERR flag clear bit\nSetting this bit to 1 resets to 0 INCERR flag in FLASH_NSSR register."
            },
            {
                "name": "CLR_OPTCHANGEERR",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Clear the flag corresponding flag in FLASH_NSSR by writing this bit."
            }
        ]
    },
    "1073881148": {
        "name": "FLASH_PRIVCFGR",
        "address": 1073881148,
        "size": 32,
        "access": "",
        "desc": "FLASH privilege configuration register ",
        "fields": [
            {
                "name": "NSPRIV",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "privilege attribute for non secure registers"
            }
        ]
    },
    "1073881160": {
        "name": "FLASH_HDPEXTR",
        "address": 1073881160,
        "size": 32,
        "access": "",
        "desc": "FLASH HDP extension register ",
        "fields": [
            {
                "name": "HDP1_EXT",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "HDP area extension in 8 Kbytes sectors in Bank1. Extension is added after the HDP1_END sector."
            },
            {
                "name": "HDP2_EXT",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "HDP area extension in 8 Kbytes sectors in Bank2. Extension is added after the HDP2_END sector."
            }
        ]
    },
    "1073881168": {
        "name": "FLASH_OPTSR_CUR",
        "address": 1073881168,
        "size": 32,
        "access": "",
        "desc": "FLASH option status register ",
        "fields": [
            {
                "name": "BOR_LEV",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Brownout level option status bit\nThese bits reflects the power level that generates a system reset."
            },
            {
                "name": "BORH_EN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Brownout high enable status bit"
            },
            {
                "name": "IWDG_SW",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "IWDG control mode option status bit"
            },
            {
                "name": "WWDG_SW",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "WWDG control mode option status bit"
            },
            {
                "name": "NRST_SHDW",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Core domain Shutdown entry reset option status bit"
            },
            {
                "name": "NRST_STOP",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Core domain Stop entry reset option status bit"
            },
            {
                "name": "NRST_STDBY",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Core domain Standby entry reset option status bit"
            },
            {
                "name": "PRODUCT_STATE",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "Life state code (based on Hamming 8,4). More information in ."
            },
            {
                "name": "IO_VDD_HSLV",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "High-speed IO at low VDD voltage status bit. This bit can be set only with VDD below 2.5 V."
            },
            {
                "name": "IO_VDDIO2_HSLV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "High-speed IO at low VDDIO2 voltage status bit. This bit can be set only with VDDIO2 below 2.5 V."
            },
            {
                "name": "IWDG_STOP",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "IWDG Stop mode freeze option status bit\nWhen set the independent watchdog IWDG is in system Stop mode."
            },
            {
                "name": "IWDG_STDBY",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "IWDG Standby mode freeze option status bit\nWhen set the independent watchdog IWDG is frozen in system Standby mode."
            },
            {
                "name": "SWAP_BANK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Bank swapping option status bit\nSWAP_BANK reflects whether Bank1 and Bank2 are swapped or not.\nSWAP_BANK is loaded to SWAP_BANK of FLASH_OPTCR after a reset."
            }
        ]
    },
    "1073881172": {
        "name": "FLASH_OPTSR_PRG",
        "address": 1073881172,
        "size": 32,
        "access": "",
        "desc": "FLASH option status register ",
        "fields": [
            {
                "name": "BOR_LEV",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Brownout level option configuration bit\nThese bits reflects the power level that generates a system reset."
            },
            {
                "name": "BORH_EN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Brownout high enable configuration bit"
            },
            {
                "name": "IWDG_SW",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "IWDG control mode option configuration bit"
            },
            {
                "name": "WWDG_SW",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "WWDG control mode option configuration bit"
            },
            {
                "name": "NRST_SHDW",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Core domain Shutdown entry reset option configuration bit"
            },
            {
                "name": "NRST_STOP",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Core domain Stop entry reset option configuration bit"
            },
            {
                "name": "NRST_STDBY",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Core domain Standby entry reset option configuration bit"
            },
            {
                "name": "PRODUCT_STATE",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "Life state code (based on Hamming 8,4). More information in ."
            },
            {
                "name": "IO_VDD_HSLV",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "High-speed IO at low VDD voltage configuration bit. This bit can be set only with VDD below 2.5 V."
            },
            {
                "name": "IO_VDDIO2_HSLV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "High-speed IO at low VDDIO2 voltage configuration bit. This bit can be set only with VDDIO2 below 2.5 V."
            },
            {
                "name": "IWDG_STOP",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "IWDG Stop mode freeze option configuration bit\nWhen set the independent watchdog IWDG is in system Stop mode."
            },
            {
                "name": "IWDG_STDBY",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "IWDG Standby mode freeze option configuration bit\nWhen set the independent watchdog IWDG is frozen in system Standby mode."
            },
            {
                "name": "SWAP_BANK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Bank swapping option configuration bit\nSWAP_BANK option bit is used to configure whether the Bank1 and Bank2 are swapped or not. This bit is loaded with the SWAP_BANK bit of FLASH_OPTSR_CUR register after a reset."
            }
        ]
    },
    "1073881200": {
        "name": "FLASH_OPTSR2_CUR",
        "address": 1073881200,
        "size": 32,
        "access": "",
        "desc": "FLASH option status register 2 ",
        "fields": [
            {
                "name": "SRAM2_RST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "SRAM2 erase when system reset"
            },
            {
                "name": "BKPRAM_ECC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Backup RAM ECC detection and correction disable"
            },
            {
                "name": "SRAM2_ECC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SRAM2 ECC detection and correction disable"
            },
            {
                "name": "SRAM1_RST",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "SRAM1 erase upon system reset"
            },
            {
                "name": "SRAM1_ECC",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "SRAM1 ECC detection and correction disable"
            }
        ]
    },
    "1073881204": {
        "name": "FLASH_OPTSR2_PRG",
        "address": 1073881204,
        "size": 32,
        "access": "",
        "desc": "FLASH option status register 2 ",
        "fields": [
            {
                "name": "SRAM2_RST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "SRAM2 erase when system reset"
            },
            {
                "name": "BKPRAM_ECC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Backup RAM ECC detection and correction disable"
            },
            {
                "name": "SRAM2_ECC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SRAM2 ECC detection and correction disable"
            },
            {
                "name": "SRAM1_RST",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "SRAM1 erase upon system reset"
            },
            {
                "name": "SRAM1_ECC",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "SRAM1 ECC detection and correction disable"
            }
        ]
    },
    "1073881216": {
        "name": "FLASH_NSBOOTR_CUR",
        "address": 1073881216,
        "size": 32,
        "access": "",
        "desc": "FLASH non-secure unique boot entry register ",
        "fields": [
            {
                "name": "NSBOOT_LOCK",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "A field locking the values of SWAP_BANK, and NSBOOTADD settings."
            },
            {
                "name": "NSBOOTADD",
                "bitOffset": 8,
                "bitWidth": 24,
                "desc": "unique boot entry address\nThese bits reflect the UBE address"
            }
        ]
    },
    "1073881220": {
        "name": "FLASH_NSBOOTR_PRG",
        "address": 1073881220,
        "size": 32,
        "access": "",
        "desc": "FLASH non-secure unique boot entry address ",
        "fields": [
            {
                "name": "NSBOOT_LOCK",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "A field locking the values of SWAP_BANK, and NSBOOTADD settings."
            },
            {
                "name": "NSBOOTADD",
                "bitOffset": 8,
                "bitWidth": 24,
                "desc": "Unique boot entry address\nThese bits allow configuring the BOOT address"
            }
        ]
    },
    "1073881232": {
        "name": "FLASH_OTPBLR_CUR",
        "address": 1073881232,
        "size": 32,
        "access": "",
        "desc": "FLASH non-secure OTP block lock ",
        "fields": [
            {
                "name": "LOCKBL",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "OTP block lock\nBlock n corresponds to OTP 16-bit word 32 x n to 32 x n + 31.\nLOCKBL[n] = 1 indicates that all OTP 16-bit words in OTP Block n are locked and attempt to program them results in WRPERR.\nLOCKBL[n] = 0 indicates that all OTP 16-bit words in OTP Block n are not locked.\nWhen one block is locked, it's not possible to remove the write protection.\nAlso if not locked, it is not possible to erase OTP words."
            }
        ]
    },
    "1073881236": {
        "name": "FLASH_OTPBLR_PRG",
        "address": 1073881236,
        "size": 32,
        "access": "",
        "desc": "FLASH non-secure OTP block lock ",
        "fields": [
            {
                "name": "LOCKBL",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "OTP block lock\nBlock n corresponds to OTP 16-bit word 32 x n to 32 x n + 31.\nLOCKBL[n] = 1 indicates that all OTP 16-bit words in OTP Block n are locked and attempt to program them results in WRPERR.\nLOCKBL[n] = 0 indicates that all OTP 16-bit words in OTP Block n are not locked.\nWhen one block is locked, it is not possible to remove the write protection.\nLOCKBL bits can be set if the corresponding bit in FLASH_OTPBLR_CUR is cleared."
            }
        ]
    },
    "1073881280": {
        "name": "FLASH_PRIVBB1R",
        "address": 1073881280,
        "size": 32,
        "access": "",
        "desc": "FLASH privilege register for bank 1 ",
        "fields": [
            {
                "name": "PRIVBB1",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Privileged / unprivileged 8 Kbytes Flash Bank1 sector attribute (y = 0 to 7)"
            }
        ]
    },
    "1073881320": {
        "name": "FLASH_WRPSGN1R_CUR",
        "address": 1073881320,
        "size": 32,
        "access": "",
        "desc": "FLASH write sector protection for Bank1\t",
        "fields": [
            {
                "name": "WRPSG1",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Bank1 sector protection option status byte\nSetting WRPSG1 bits to 0 write protects the corresponding sectors in bank 1 (0: write protected; 1: not write protected)"
            }
        ]
    },
    "1073881324": {
        "name": "FLASH_WRPSGN1R_PRG",
        "address": 1073881324,
        "size": 32,
        "access": "",
        "desc": "FLASH write sector protection for Bank1\t",
        "fields": [
            {
                "name": "WRPSG1",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Bank1 sector protection option status byte\nSetting WRPSG1 bits to 0 write protects the corresponding sectors in bank 1 (0: write protected; 1: not write protected)"
            }
        ]
    },
    "1073881336": {
        "name": "FLASH_HDP1R_CUR",
        "address": 1073881336,
        "size": 32,
        "access": "",
        "desc": "FLASH HDP Bank1 register ",
        "fields": [
            {
                "name": "HDP1_STRT",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "HDPL barrier start set in number of 8 Kbytes sectors"
            },
            {
                "name": "HDP1_END",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "HDPL barrier end set in number of 8 Kbytes sectors"
            }
        ]
    },
    "1073881340": {
        "name": "FLASH_HDP1R_PRG",
        "address": 1073881340,
        "size": 32,
        "access": "",
        "desc": "FLASH HDP Bank1 register ",
        "fields": [
            {
                "name": "HDP1_STRT",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Bank 1 HDPL barrier start set in number of 8 Kbytes sectors"
            },
            {
                "name": "HDP1_END",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "Bank 1 HDPL barrier end set in number of 8 Kbytes sectors"
            }
        ]
    },
    "1073881344": {
        "name": "FLASH_ECCCORR",
        "address": 1073881344,
        "size": 32,
        "access": "",
        "desc": "FLASH Flash ECC correction register ",
        "fields": [
            {
                "name": "ADDR_ECC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "ECC error address\nWhen an ECC error occurs (for single correction) during a read operation, the ADDR_ECC contains the address that generated the error.\nADDR_ECC is reset when the flag error is reset.\nThe embedded Flash memory programs the address in this register only when no ECC error flags are set. This means that only the first address that generated an ECC error is saved.\nThe address in ADDR_ECC is relative to the Flash memory area where the error occurred (user Flash memory, system Flash memory, data area, read-only/OTP area)."
            },
            {
                "name": "BK_ECC",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "ECC bank flag for corrected ECC error\nIt indicates which bank is concerned by ECC error"
            },
            {
                "name": "SYSF_ECC",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "ECC flag for corrected ECC error in system FLASH\nIt indicates if system Flash memory is concerned by ECC error."
            },
            {
                "name": "OTP_ECC",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "OTP ECC error bit\nThis bit is set to 1 when one single ECC correction occurred during the last successful read operation from the read-only/ OTP area. The address of the ECC error is available in ADDR_ECC bitfield."
            },
            {
                "name": "ECCCIE",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "ECC single correction error interrupt enable bit When ECCCIE bit is set to 1, an interrupt is generated when an ECC single correction error occurs during a read operation."
            },
            {
                "name": "ECCC",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "ECC correction set by hardware when single ECC error has been detected and corrected.\nCleared by writing 1."
            }
        ]
    },
    "1073881348": {
        "name": "FLASH_ECCDETR",
        "address": 1073881348,
        "size": 32,
        "access": "",
        "desc": "FLASH ECC detection register ",
        "fields": [
            {
                "name": "ADDR_ECC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "ECC error address\nWhen an ECC error occurs (double detection) during a read operation, the ADDR_ECC contains the address that generated the error.\nADDR_ECC is reset when the flag error is reset.\nThe embedded Flash memory programs the address in this register only when no ECC error flags are set. This means that only the first address that generated an double ECC error is saved.\nThe address in ADDR_ECC is relative to the Flash memory area where the error occurred (user Flash memory, system Flash memory, data area, read-only/OTP area)."
            },
            {
                "name": "BK_ECC",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "ECC fail bank for double ECC Error\nIt indicates which bank is concerned by ECC error"
            },
            {
                "name": "SYSF_ECC",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "ECC fail for double ECC error in system Flash memory\nIt indicates if system Flash memory is concerned by ECC error."
            },
            {
                "name": "OTP_ECC",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "OTP ECC error bit\nThis bit is set to 1 when double ECC detection occurred during the last read operation from the read-only/ OTP area. The address of the ECC error is available in ADDR_ECC bit field."
            },
            {
                "name": "ECCD",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "ECC detection set by hardware when two ECC error has been detected.\nWhen this bit is set, a NMI is generated.\nCleared by writing 1. Needs to be cleared in order to detect subsequent double ECC errors."
            }
        ]
    },
    "1073881352": {
        "name": "FLASH_ECCDR",
        "address": 1073881352,
        "size": 32,
        "access": "",
        "desc": "FLASH ECC data ",
        "fields": [
            {
                "name": "DATA_ECC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "ECC error data\nWhen an double detection ECC error occurs on special areas with 6-bit ECC on 16-bit of data (data area, read-only/OTP area), the failing data is read to this register.\nBy checking if it is possible to determine whether the failure was on a real data, or due to access to uninitialized memory."
            }
        ]
    },
    "1073881576": {
        "name": "FLASH_WRPSGN2R_CUR",
        "address": 1073881576,
        "size": 32,
        "access": "",
        "desc": "FLASH write sector protection for Bank2\t",
        "fields": [
            {
                "name": "WRPSG2",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Bank2 sector protection option status byte\nSetting WRPSG2 bits to 0 write protects the corresponding sectors in bank 2 (0: write protected; 1: not write protected)"
            }
        ]
    },
    "1073881580": {
        "name": "FLASH_WRPSGN2R_PRG",
        "address": 1073881580,
        "size": 32,
        "access": "",
        "desc": "FLASH write sector protection for Bank2\t",
        "fields": [
            {
                "name": "WRPSG2",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Bank2 sector protection option status byte\nSetting WRPSG2 bits to 0 write protects the corresponding sectors in bank 2 (0: write protected; 1: not write protected)"
            }
        ]
    },
    "1073881592": {
        "name": "FLASH_HDP2R_CUR",
        "address": 1073881592,
        "size": 32,
        "access": "",
        "desc": "FLASH HDP Bank2 register ",
        "fields": [
            {
                "name": "HDP2_STRT",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Bank 2 HDPL barrier start set in number of 8 Kbytes sectors"
            },
            {
                "name": "HDP2_END",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "Bank 2 HDPL barrier end set in number of 8 Kbytes sectors"
            }
        ]
    },
    "1073881596": {
        "name": "FLASH_HDP2R_PRG",
        "address": 1073881596,
        "size": 32,
        "access": "",
        "desc": "FLASH HDP Bank2 register ",
        "fields": [
            {
                "name": "HDP2_STRT",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Bank 2 HDPL barrier start set in number of 8 Kbytes sectors"
            },
            {
                "name": "HDP2_END",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "Bank 2 HDPL barrier end set in number of 8 Kbytes sectors"
            }
        ]
    },
    "1107427328": {
        "name": "GPIOA_MODER",
        "address": 1107427328,
        "size": 32,
        "access": "",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107427332": {
        "name": "GPIOA_OTYPER",
        "address": 1107427332,
        "size": 32,
        "access": "",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107427336": {
        "name": "GPIOA_OSPEEDR",
        "address": 1107427336,
        "size": 32,
        "access": "",
        "desc": "GPIO port output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107427340": {
        "name": "GPIOA_PUPDR",
        "address": 1107427340,
        "size": 32,
        "access": "",
        "desc": "GPIO port pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107427344": {
        "name": "GPIOA_IDR",
        "address": 1107427344,
        "size": 32,
        "access": "",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107427348": {
        "name": "GPIOA_ODR",
        "address": 1107427348,
        "size": 32,
        "access": "",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107427352": {
        "name": "GPIOA_BSRR",
        "address": 1107427352,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107427356": {
        "name": "GPIOA_LCKR",
        "address": 1107427356,
        "size": 32,
        "access": "",
        "desc": "GPIO port configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\n- LOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\n- LOCK key read\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nAny error in the lock sequence aborts the LOCK.\nAfter the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1107427360": {
        "name": "GPIOA_AFRL",
        "address": 1107427360,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107427364": {
        "name": "GPIOA_AFRH",
        "address": 1107427364,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107427368": {
        "name": "GPIOA_BRR",
        "address": 1107427368,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107427372": {
        "name": "GPIOA_HSLVR",
        "address": 1107427372,
        "size": 32,
        "access": "",
        "desc": "GPIO high-speed low-voltage register",
        "fields": [
            {
                "name": "HSLV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428352": {
        "name": "GPIOB_MODER",
        "address": 1107428352,
        "size": 32,
        "access": "",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428356": {
        "name": "GPIOB_OTYPER",
        "address": 1107428356,
        "size": 32,
        "access": "",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428360": {
        "name": "GPIOB_OSPEEDR",
        "address": 1107428360,
        "size": 32,
        "access": "",
        "desc": "GPIO port output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428364": {
        "name": "GPIOB_PUPDR",
        "address": 1107428364,
        "size": 32,
        "access": "",
        "desc": "GPIO port pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428368": {
        "name": "GPIOB_IDR",
        "address": 1107428368,
        "size": 32,
        "access": "",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428372": {
        "name": "GPIOB_ODR",
        "address": 1107428372,
        "size": 32,
        "access": "",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428376": {
        "name": "GPIOB_BSRR",
        "address": 1107428376,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428380": {
        "name": "GPIOB_LCKR",
        "address": 1107428380,
        "size": 32,
        "access": "",
        "desc": "GPIO port configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\n- LOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\n- LOCK key read\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nAny error in the lock sequence aborts the LOCK.\nAfter the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1107428384": {
        "name": "GPIOB_AFRL",
        "address": 1107428384,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428388": {
        "name": "GPIOB_AFRH",
        "address": 1107428388,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428392": {
        "name": "GPIOB_BRR",
        "address": 1107428392,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107428396": {
        "name": "GPIOB_HSLVR",
        "address": 1107428396,
        "size": 32,
        "access": "",
        "desc": "GPIO high-speed low-voltage register",
        "fields": [
            {
                "name": "HSLV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429376": {
        "name": "GPIO_MODER",
        "address": 1107429376,
        "size": 32,
        "access": "",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429380": {
        "name": "GPIO_OTYPER",
        "address": 1107429380,
        "size": 32,
        "access": "",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429384": {
        "name": "GPIO_OSPEEDR",
        "address": 1107429384,
        "size": 32,
        "access": "",
        "desc": "GPIO port output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429388": {
        "name": "GPIO_PUPDR",
        "address": 1107429388,
        "size": 32,
        "access": "",
        "desc": "GPIO port pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429392": {
        "name": "GPIO_IDR",
        "address": 1107429392,
        "size": 32,
        "access": "",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429396": {
        "name": "GPIO_ODR",
        "address": 1107429396,
        "size": 32,
        "access": "",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429400": {
        "name": "GPIO_BSRR",
        "address": 1107429400,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429404": {
        "name": "GPIO_LCKR",
        "address": 1107429404,
        "size": 32,
        "access": "",
        "desc": "GPIO port configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\n- LOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\n- LOCK key read\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nAny error in the lock sequence aborts the LOCK.\nAfter the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1107429408": {
        "name": "GPIO_AFRL",
        "address": 1107429408,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429412": {
        "name": "GPIO_AFRH",
        "address": 1107429412,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429416": {
        "name": "GPIO_BRR",
        "address": 1107429416,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107429420": {
        "name": "GPIO_HSLVR",
        "address": 1107429420,
        "size": 32,
        "access": "",
        "desc": "GPIO high-speed low-voltage register",
        "fields": [
            {
                "name": "HSLV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434496": {
        "name": "GPIOH_MODER",
        "address": 1107434496,
        "size": 32,
        "access": "",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434500": {
        "name": "GPIOH_OTYPER",
        "address": 1107434500,
        "size": 32,
        "access": "",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434504": {
        "name": "GPIOH_OSPEEDR",
        "address": 1107434504,
        "size": 32,
        "access": "",
        "desc": "GPIO port output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.\nThe bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434508": {
        "name": "GPIOH_PUPDR",
        "address": 1107434508,
        "size": 32,
        "access": "",
        "desc": "GPIO port pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434512": {
        "name": "GPIOH_IDR",
        "address": 1107434512,
        "size": 32,
        "access": "",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434516": {
        "name": "GPIOH_ODR",
        "address": 1107434516,
        "size": 32,
        "access": "",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A to D and H).\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434520": {
        "name": "GPIOH_BSRR",
        "address": 1107434520,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: If both BSy and BRy are set, BSy has priority.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434524": {
        "name": "GPIOH_LCKR",
        "address": 1107434524,
        "size": 32,
        "access": "",
        "desc": "GPIO port configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is 0\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\n- LOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\n- LOCK key read\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nAny error in the lock sequence aborts the LOCK.\nAfter the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1107434528": {
        "name": "GPIOH_AFRL",
        "address": 1107434528,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434532": {
        "name": "GPIOH_AFRH",
        "address": 1107434532,
        "size": 32,
        "access": "",
        "desc": "GPIO alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\nNote: The bitfield is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434536": {
        "name": "GPIOH_BRR",
        "address": 1107434536,
        "size": 32,
        "access": "",
        "desc": "GPIO port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\nNote: The bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1107434540": {
        "name": "GPIOH_HSLVR",
        "address": 1107434540,
        "size": 32,
        "access": "",
        "desc": "GPIO high-speed low-voltage register",
        "fields": [
            {
                "name": "HSLV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            },
            {
                "name": "HSLV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x high-speed low-voltage configuration (y = 15 to 0)\nThese bits are written by software to optimize the I/O speed when the I/O supply is low.\nEach bit is active only if the corresponding IO_VDD_HSLV/IO_VDDIO2_HSLV user option bit is set. It must be used only if the I/O supply voltage is below 2.7 V.\nSetting these bits when the I/O supply (VDD or VDDIO2) is higher than 2.7 V may be destructive.\nNote: Not all I/Os support the HSLV mode. Refer to the I/O structure in the corresponding datasheet for the list of I/Os supporting this feature. Other I/Os HSLV configuration must be kept at reset value.\nThe bit is reserved and must be kept to reset value when the corresponding I/O is not available on the selected package."
            }
        ]
    },
    "1073947680": {
        "name": "GTZC1_TZSC_PRIVCFGR1",
        "address": 1073947680,
        "size": 32,
        "access": "",
        "desc": "GTZC1 TZSC privilege configuration register 1",
        "fields": [
            {
                "name": "TIM2PRIV",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "privileged access mode for TIM2"
            },
            {
                "name": "TIM3PRIV",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "privileged access mode for TIM3"
            },
            {
                "name": "TIM6PRIV",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "privileged access mode for TIM6"
            },
            {
                "name": "TIM7PRIV",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "privileged access mode for TIM7"
            },
            {
                "name": "WWDGPRIV",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "privileged access mode for WWDG"
            },
            {
                "name": "IWDGPRIV",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "privileged access mode for IWDG"
            },
            {
                "name": "SPI2PRIV",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "privileged access mode for SPI2"
            },
            {
                "name": "SPI3PRIV",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "privileged access mode for SPI3"
            },
            {
                "name": "USART2PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "privileged access mode for USART2"
            },
            {
                "name": "USART3PRIV",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "privileged access mode for USART3"
            },
            {
                "name": "I2C1PRIV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "privileged access mode for I2C1"
            },
            {
                "name": "I2C2PRIV",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "privileged access mode for I2C2"
            },
            {
                "name": "I3C1PRIV",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "privileged access mode for I3C1"
            },
            {
                "name": "CRSPRIV",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "privileged access mode for CRS"
            },
            {
                "name": "DAC1PRIV",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "privileged access mode for DAC1"
            },
            {
                "name": "DTSPRIV",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "privileged access mode for DTS"
            },
            {
                "name": "LPTIM2PRIV",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "privileged access mode for LPTIM2"
            }
        ]
    },
    "1073947684": {
        "name": "GTZC1_TZSC_PRIVCFGR2",
        "address": 1073947684,
        "size": 32,
        "access": "",
        "desc": "GTZC1 TZSC privilege configuration register 2",
        "fields": [
            {
                "name": "FDCAN1PRIV",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "privileged access mode for FDCAN1"
            },
            {
                "name": "OPAMPPRIV",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "privileged access mode for OPAMP"
            },
            {
                "name": "COMPPRIV",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "privileged access mode for COMP"
            },
            {
                "name": "TIM1PRIV",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "privileged access mode for TIM1"
            },
            {
                "name": "SPI1PRIV",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "privileged access mode for SPI1"
            },
            {
                "name": "USART1PRIV",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "privileged access mode for USART1"
            },
            {
                "name": "USBFSPRIV",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "privileged access mode for USBSF"
            },
            {
                "name": "LPUART1PRIV",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "privileged access mode for LPUART"
            },
            {
                "name": "LPTIM1PRIV",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "privileged access mode for LPTIM1"
            }
        ]
    },
    "1073947688": {
        "name": "GTZC1_TZSC_PRIVCFGR3",
        "address": 1073947688,
        "size": 32,
        "access": "",
        "desc": "GTZC1 TZSC privilege configuration register 3",
        "fields": [
            {
                "name": "I3C2PRIV",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "privileged access mode for I3C2"
            },
            {
                "name": "CRCPRIV",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "privileged access mode for CRC"
            },
            {
                "name": "ICACHEPRIV",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "privileged access mode for ICACHE"
            },
            {
                "name": "ADC1PRIV",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "privileged access mode for ADC1"
            },
            {
                "name": "HASHPRIV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "privileged access mode for HASH"
            },
            {
                "name": "RNGPRIV",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "privileged access mode for RNG"
            },
            {
                "name": "RAMCFGPRIV",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "privileged access mode for RAMSCFG"
            }
        ]
    },
    "1073947760": {
        "name": "GTZC1_TZSC_MPCWM4ACFGR",
        "address": 1073947760,
        "size": 32,
        "access": "",
        "desc": "GTZC1 TZSC BKPSRAM sub-region A watermark configuration\tregister",
        "fields": [
            {
                "name": "SREN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Sub-region z enable"
            },
            {
                "name": "SRLOCK",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Sub-region z lock\nThis bit, once set, can be cleared only by a system reset."
            },
            {
                "name": "PRIV",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged sub-region z\nThis bit is taken into account only if SREN is set."
            }
        ]
    },
    "1073947764": {
        "name": "GTZC1_TZSC_MPCWM4AR",
        "address": 1073947764,
        "size": 32,
        "access": "",
        "desc": "GTZC1 TZSC BKPSRAM sub-region A watermark register",
        "fields": [
            {
                "name": "SUBA_START",
                "bitOffset": 0,
                "bitWidth": 11,
                "desc": "Start of sub-region A\nThis field defines the address offset of the sub-region A, to be multiplied by the granularity defined in Table 16."
            },
            {
                "name": "SUBA_LENGTH",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Length of sub-region A\nThis field defines the length of the sub-region A, to be multiplied by the granularity defined in Table 16.\nWhen SUBA_START + SUBA_LENGTH is higher than the maximum size allowed for the memory, a saturation of SUBA_LENGTH is applied automatically.\nIf SUBA_LENGTH = 0, the sub-region A is disabled (SREN bit in GTZC1_TZSC_MPCMWACFGR is cleared)."
            }
        ]
    },
    "1073947768": {
        "name": "GTZC1_TZSC_MPCWM4BCFGR",
        "address": 1073947768,
        "size": 32,
        "access": "",
        "desc": "GTZC1 TZSC BKPSRAM sub-region B watermark configuration\tregister",
        "fields": [
            {
                "name": "SREN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Sub-region z enable"
            },
            {
                "name": "SRLOCK",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Sub-region z lock\nThis bit, once set, can be cleared only by a system reset."
            },
            {
                "name": "PRIV",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged sub-region z\nThis bit is taken into account only if SREN is set."
            }
        ]
    },
    "1073947772": {
        "name": "GTZC1_TZSC_MPCWM4BR",
        "address": 1073947772,
        "size": 32,
        "access": "",
        "desc": "GTZC1 TZSC BKPSRAM sub-region B watermark register",
        "fields": [
            {
                "name": "SUBB_START",
                "bitOffset": 0,
                "bitWidth": 11,
                "desc": "Start of sub-region B\nThis field defines the address offset of the sub-region B, to be multiplied by the granularity defined in Table 16."
            },
            {
                "name": "SUBB_LENGTH",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Length of sub-region B\nThis field defines the length of the sub-region B, to be multiplied by the granularity defined in Table 16.\nWhen SUBB_START + SUBB_LENGTH is higher than the maximum size allowed for the\nmemory, a saturation of SUBB_LENGTH is applied automatically.\nIf SUBB_LENGTH = 0, the sub-region B is disabled (SREN bit in GTZC1_TZSC_MPCMWBCFGR is cleared)."
            }
        ]
    },
    "1073948160": {
        "name": "GTZC1_MPCBB1_PRIVCFGR0",
        "address": 1073948160,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 0\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948164": {
        "name": "GTZC1_MPCBB1_PRIVCFGR1",
        "address": 1073948164,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 1\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948168": {
        "name": "GTZC1_MPCBB1_PRIVCFGR2",
        "address": 1073948168,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 2\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948172": {
        "name": "GTZC1_MPCBB1_PRIVCFGR3",
        "address": 1073948172,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 3\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948176": {
        "name": "GTZC1_MPCBB1_PRIVCFGR4",
        "address": 1073948176,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 4\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948180": {
        "name": "GTZC1_MPCBB1_PRIVCFGR5",
        "address": 1073948180,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 5\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948184": {
        "name": "GTZC1_MPCBB1_PRIVCFGR6",
        "address": 1073948184,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 6\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948188": {
        "name": "GTZC1_MPCBB1_PRIVCFGR7",
        "address": 1073948188,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 7\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948192": {
        "name": "GTZC1_MPCBB1_PRIVCFGR8",
        "address": 1073948192,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 8\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948196": {
        "name": "GTZC1_MPCBB1_PRIVCFGR9",
        "address": 1073948196,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 9\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948200": {
        "name": "GTZC1_MPCBB1_PRIVCFGR10",
        "address": 1073948200,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 10\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948204": {
        "name": "GTZC1_MPCBB1_PRIVCFGR11",
        "address": 1073948204,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 11\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948208": {
        "name": "GTZC1_MPCBB1_PRIVCFGR12",
        "address": 1073948208,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 12\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948212": {
        "name": "GTZC1_MPCBB1_PRIVCFGR13",
        "address": 1073948212,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 13\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948216": {
        "name": "GTZC1_MPCBB1_PRIVCFGR14",
        "address": 1073948216,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 14\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948220": {
        "name": "GTZC1_MPCBB1_PRIVCFGR15",
        "address": 1073948220,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 15\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948224": {
        "name": "GTZC1_MPCBB1_PRIVCFGR16",
        "address": 1073948224,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 16\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948228": {
        "name": "GTZC1_MPCBB1_PRIVCFGR17",
        "address": 1073948228,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 17\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948232": {
        "name": "GTZC1_MPCBB1_PRIVCFGR18",
        "address": 1073948232,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 18\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948236": {
        "name": "GTZC1_MPCBB1_PRIVCFGR19",
        "address": 1073948236,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 19\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948240": {
        "name": "GTZC1_MPCBB1_PRIVCFGR20",
        "address": 1073948240,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 20\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948244": {
        "name": "GTZC1_MPCBB1_PRIVCFGR21",
        "address": 1073948244,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 21\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948248": {
        "name": "GTZC1_MPCBB1_PRIVCFGR22",
        "address": 1073948248,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 22\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948252": {
        "name": "GTZC1_MPCBB1_PRIVCFGR23",
        "address": 1073948252,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 23\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948256": {
        "name": "GTZC1_MPCBB1_PRIVCFGR24",
        "address": 1073948256,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 24\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948260": {
        "name": "GTZC1_MPCBB1_PRIVCFGR25",
        "address": 1073948260,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 25\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948264": {
        "name": "GTZC1_MPCBB1_PRIVCFGR26",
        "address": 1073948264,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 26\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948268": {
        "name": "GTZC1_MPCBB1_PRIVCFGR27",
        "address": 1073948268,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 27\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948272": {
        "name": "GTZC1_MPCBB1_PRIVCFGR28",
        "address": 1073948272,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 28\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948276": {
        "name": "GTZC1_MPCBB1_PRIVCFGR29",
        "address": 1073948276,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 29\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948280": {
        "name": "GTZC1_MPCBB1_PRIVCFGR30",
        "address": 1073948280,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 30\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073948284": {
        "name": "GTZC1_MPCBB1_PRIVCFGR31",
        "address": 1073948284,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM1 MPCBB privileged configuration for super-block 31\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949184": {
        "name": "GTZC1_MPCBB2_PRIVCFGR0",
        "address": 1073949184,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 0\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949188": {
        "name": "GTZC1_MPCBB2_PRIVCFGR1",
        "address": 1073949188,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 1\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949192": {
        "name": "GTZC1_MPCBB2_PRIVCFGR2",
        "address": 1073949192,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 2\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949196": {
        "name": "GTZC1_MPCBB2_PRIVCFGR3",
        "address": 1073949196,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 3\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949200": {
        "name": "GTZC1_MPCBB2_PRIVCFGR4",
        "address": 1073949200,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 4\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949204": {
        "name": "GTZC1_MPCBB2_PRIVCFGR5",
        "address": 1073949204,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 5\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949208": {
        "name": "GTZC1_MPCBB2_PRIVCFGR6",
        "address": 1073949208,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 6\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949212": {
        "name": "GTZC1_MPCBB2_PRIVCFGR7",
        "address": 1073949212,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 7\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949216": {
        "name": "GTZC1_MPCBB2_PRIVCFGR8",
        "address": 1073949216,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 8\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949220": {
        "name": "GTZC1_MPCBB2_PRIVCFGR9",
        "address": 1073949220,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 9\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949224": {
        "name": "GTZC1_MPCBB2_PRIVCFGR10",
        "address": 1073949224,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 10\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949228": {
        "name": "GTZC1_MPCBB2_PRIVCFGR11",
        "address": 1073949228,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 11\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949232": {
        "name": "GTZC1_MPCBB2_PRIVCFGR12",
        "address": 1073949232,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 12\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949236": {
        "name": "GTZC1_MPCBB2_PRIVCFGR13",
        "address": 1073949236,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 13\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949240": {
        "name": "GTZC1_MPCBB2_PRIVCFGR14",
        "address": 1073949240,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 14\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949244": {
        "name": "GTZC1_MPCBB2_PRIVCFGR15",
        "address": 1073949244,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 15\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949248": {
        "name": "GTZC1_MPCBB2_PRIVCFGR16",
        "address": 1073949248,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 16\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949252": {
        "name": "GTZC1_MPCBB2_PRIVCFGR17",
        "address": 1073949252,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 17\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949256": {
        "name": "GTZC1_MPCBB2_PRIVCFGR18",
        "address": 1073949256,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 18\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949260": {
        "name": "GTZC1_MPCBB2_PRIVCFGR19",
        "address": 1073949260,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 19\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949264": {
        "name": "GTZC1_MPCBB2_PRIVCFGR20",
        "address": 1073949264,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 20\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949268": {
        "name": "GTZC1_MPCBB2_PRIVCFGR21",
        "address": 1073949268,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 21\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949272": {
        "name": "GTZC1_MPCBB2_PRIVCFGR22",
        "address": 1073949272,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 22\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949276": {
        "name": "GTZC1_MPCBB2_PRIVCFGR23",
        "address": 1073949276,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 23\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949280": {
        "name": "GTZC1_MPCBB2_PRIVCFGR24",
        "address": 1073949280,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 24\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949284": {
        "name": "GTZC1_MPCBB2_PRIVCFGR25",
        "address": 1073949284,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 25\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949288": {
        "name": "GTZC1_MPCBB2_PRIVCFGR26",
        "address": 1073949288,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 26\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949292": {
        "name": "GTZC1_MPCBB2_PRIVCFGR27",
        "address": 1073949292,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 27\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949296": {
        "name": "GTZC1_MPCBB2_PRIVCFGR28",
        "address": 1073949296,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 28\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949300": {
        "name": "GTZC1_MPCBB2_PRIVCFGR29",
        "address": 1073949300,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 29\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949304": {
        "name": "GTZC1_MPCBB2_PRIVCFGR30",
        "address": 1073949304,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 30\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073949308": {
        "name": "GTZC1_MPCBB2_PRIVCFGR31",
        "address": 1073949308,
        "size": 32,
        "access": "",
        "desc": "GTZC1 SRAM2 MPCBB privileged configuration for super-block 31\tregister",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            },
            {
                "name": "PRIV31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Privileged configuration for block y, belonging to super-block x (y = 31 to 0)."
            }
        ]
    },
    "1073872900": {
        "name": "GPDMA_PRIVCFGR",
        "address": 1073872900,
        "size": 32,
        "access": "",
        "desc": "GPDMA privileged configuration register",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            }
        ]
    },
    "1073872908": {
        "name": "GPDMA_MISR",
        "address": 1073872908,
        "size": 32,
        "access": "",
        "desc": "GPDMA masked interrupt status register",
        "fields": [
            {
                "name": "MIS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            }
        ]
    },
    "1073872976": {
        "name": "GPDMA_C0LBAR",
        "address": 1073872976,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073872988": {
        "name": "GPDMA_C0FCR",
        "address": 1073872988,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073872992": {
        "name": "GPDMA_C0SR",
        "address": 1073872992,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half transfer event is either a half block transfer or a half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.\nA half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073872996": {
        "name": "GPDMA_C0CR",
        "address": 1073872996,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0 and GPDMA_CxBR1.BRC[10:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873040": {
        "name": "GPDMA_C0TR1",
        "address": 1073873040,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\n1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination\nNote: If the transfer from the source peripheral is configured with peripheral flow-control mode (SWREQ = 0 and PFREQ = 1 and DREQ = 0), and if the destination data width  the source data width, packing is not supported."
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873044": {
        "name": "GPDMA_C0TR2",
        "address": 1073873044,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 14.3.4.\nThe user must not assign a same input hardware request (same REQSEL[7:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:\nNote: If the channel x is activated (GPDMA_CxCR.EN is asserted) with SWREQ = 0 and PFREQ = 1 (peripheral hardware request with peripheral flow-control mode), any software assertion to this DREQ bit is ignored: in peripheral flow-control mode, only a peripheral-to-memory transfer is supported."
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "PFREQ",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Hardware request in peripheral flow control mode\nImportant: If a given channel x is not implemented with this feature, this bit is reserved and PFREQ is not present (see Section 14.3.2 for the list of the implemented channels with this feature.\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:\nNote: In peripheral flow control mode, there are the following restrictions:\nNote: - no 2D/repeated block support (GPDMA_CxBR1.BRC[10:0] must be set to 0)\nNote: - the peripheral must be set as the source of the transfer (DREQ = 0).\nNote: - data packing to a wider destination width is not supported (if destination width  source data width, GPDMA_CxTR1.PAM[1] must be set to 0).\nNote: - GPDMA_CxBR1.BNDT[15:0] must be programmed as a multiple of the source (peripheral) burst size."
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 14.3.7), with an active trigger event if TRIGPOL[1:0] different  00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI 1 ."
            }
        ]
    },
    "1073873048": {
        "name": "GPDMA_C0BR1",
        "address": 1073873048,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873052": {
        "name": "GPDMA_C0SAR",
        "address": 1073873052,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0].\nonce/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.\nNote: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied."
            }
        ]
    },
    "1073873056": {
        "name": "GPDMA_C0DAR",
        "address": 1073873056,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0].\nonce/if completed destination block transfer, for a channel x with 2D addressing capability (x = 12 to 15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873100": {
        "name": "GPDMA_C0LLR",
        "address": 1073873100,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873104": {
        "name": "GPDMA_C1LBAR",
        "address": 1073873104,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873116": {
        "name": "GPDMA_C1FCR",
        "address": 1073873116,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873120": {
        "name": "GPDMA_C1SR",
        "address": 1073873120,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half transfer event is either a half block transfer or a half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.\nA half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873124": {
        "name": "GPDMA_C1CR",
        "address": 1073873124,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0 and GPDMA_CxBR1.BRC[10:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873168": {
        "name": "GPDMA_C1TR1",
        "address": 1073873168,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\n1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination\nNote: If the transfer from the source peripheral is configured with peripheral flow-control mode (SWREQ = 0 and PFREQ = 1 and DREQ = 0), and if the destination data width  the source data width, packing is not supported."
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873172": {
        "name": "GPDMA_C1TR2",
        "address": 1073873172,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 14.3.4.\nThe user must not assign a same input hardware request (same REQSEL[7:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:\nNote: If the channel x is activated (GPDMA_CxCR.EN is asserted) with SWREQ = 0 and PFREQ = 1 (peripheral hardware request with peripheral flow-control mode), any software assertion to this DREQ bit is ignored: in peripheral flow-control mode, only a peripheral-to-memory transfer is supported."
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "PFREQ",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Hardware request in peripheral flow control mode\nImportant: If a given channel x is not implemented with this feature, this bit is reserved and PFREQ is not present (see Section 14.3.2 for the list of the implemented channels with this feature.\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:\nNote: In peripheral flow control mode, there are the following restrictions:\nNote: - no 2D/repeated block support (GPDMA_CxBR1.BRC[10:0] must be set to 0)\nNote: - the peripheral must be set as the source of the transfer (DREQ = 0).\nNote: - data packing to a wider destination width is not supported (if destination width  source data width, GPDMA_CxTR1.PAM[1] must be set to 0).\nNote: - GPDMA_CxBR1.BNDT[15:0] must be programmed as a multiple of the source (peripheral) burst size."
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 14.3.7), with an active trigger event if TRIGPOL[1:0] different  00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI 1 ."
            }
        ]
    },
    "1073873176": {
        "name": "GPDMA_C1BR1",
        "address": 1073873176,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873180": {
        "name": "GPDMA_C1SAR",
        "address": 1073873180,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0].\nonce/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.\nNote: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied."
            }
        ]
    },
    "1073873184": {
        "name": "GPDMA_C1DAR",
        "address": 1073873184,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0].\nonce/if completed destination block transfer, for a channel x with 2D addressing capability (x = 12 to 15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873228": {
        "name": "GPDMA_C1LLR",
        "address": 1073873228,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873232": {
        "name": "GPDMA_C2LBAR",
        "address": 1073873232,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873244": {
        "name": "GPDMA_C2FCR",
        "address": 1073873244,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873248": {
        "name": "GPDMA_C2SR",
        "address": 1073873248,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half transfer event is either a half block transfer or a half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.\nA half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873252": {
        "name": "GPDMA_C2CR",
        "address": 1073873252,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0 and GPDMA_CxBR1.BRC[10:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873296": {
        "name": "GPDMA_C2TR1",
        "address": 1073873296,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\n1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination\nNote: If the transfer from the source peripheral is configured with peripheral flow-control mode (SWREQ = 0 and PFREQ = 1 and DREQ = 0), and if the destination data width  the source data width, packing is not supported."
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873300": {
        "name": "GPDMA_C2TR2",
        "address": 1073873300,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 14.3.4.\nThe user must not assign a same input hardware request (same REQSEL[7:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:\nNote: If the channel x is activated (GPDMA_CxCR.EN is asserted) with SWREQ = 0 and PFREQ = 1 (peripheral hardware request with peripheral flow-control mode), any software assertion to this DREQ bit is ignored: in peripheral flow-control mode, only a peripheral-to-memory transfer is supported."
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "PFREQ",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Hardware request in peripheral flow control mode\nImportant: If a given channel x is not implemented with this feature, this bit is reserved and PFREQ is not present (see Section 14.3.2 for the list of the implemented channels with this feature.\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:\nNote: In peripheral flow control mode, there are the following restrictions:\nNote: - no 2D/repeated block support (GPDMA_CxBR1.BRC[10:0] must be set to 0)\nNote: - the peripheral must be set as the source of the transfer (DREQ = 0).\nNote: - data packing to a wider destination width is not supported (if destination width  source data width, GPDMA_CxTR1.PAM[1] must be set to 0).\nNote: - GPDMA_CxBR1.BNDT[15:0] must be programmed as a multiple of the source (peripheral) burst size."
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 14.3.7), with an active trigger event if TRIGPOL[1:0] different  00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI 1 ."
            }
        ]
    },
    "1073873304": {
        "name": "GPDMA_C2BR1",
        "address": 1073873304,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873308": {
        "name": "GPDMA_C2SAR",
        "address": 1073873308,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0].\nonce/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.\nNote: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied."
            }
        ]
    },
    "1073873312": {
        "name": "GPDMA_C2DAR",
        "address": 1073873312,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0].\nonce/if completed destination block transfer, for a channel x with 2D addressing capability (x = 12 to 15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873356": {
        "name": "GPDMA_C2LLR",
        "address": 1073873356,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873360": {
        "name": "GPDMA_C3LBAR",
        "address": 1073873360,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873372": {
        "name": "GPDMA_C3FCR",
        "address": 1073873372,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873376": {
        "name": "GPDMA_C3SR",
        "address": 1073873376,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half transfer event is either a half block transfer or a half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.\nA half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873380": {
        "name": "GPDMA_C3CR",
        "address": 1073873380,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0 and GPDMA_CxBR1.BRC[10:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873424": {
        "name": "GPDMA_C3TR1",
        "address": 1073873424,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\n1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination\nNote: If the transfer from the source peripheral is configured with peripheral flow-control mode (SWREQ = 0 and PFREQ = 1 and DREQ = 0), and if the destination data width  the source data width, packing is not supported."
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873428": {
        "name": "GPDMA_C3TR2",
        "address": 1073873428,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 14.3.4.\nThe user must not assign a same input hardware request (same REQSEL[7:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:\nNote: If the channel x is activated (GPDMA_CxCR.EN is asserted) with SWREQ = 0 and PFREQ = 1 (peripheral hardware request with peripheral flow-control mode), any software assertion to this DREQ bit is ignored: in peripheral flow-control mode, only a peripheral-to-memory transfer is supported."
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "PFREQ",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Hardware request in peripheral flow control mode\nImportant: If a given channel x is not implemented with this feature, this bit is reserved and PFREQ is not present (see Section 14.3.2 for the list of the implemented channels with this feature.\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:\nNote: In peripheral flow control mode, there are the following restrictions:\nNote: - no 2D/repeated block support (GPDMA_CxBR1.BRC[10:0] must be set to 0)\nNote: - the peripheral must be set as the source of the transfer (DREQ = 0).\nNote: - data packing to a wider destination width is not supported (if destination width  source data width, GPDMA_CxTR1.PAM[1] must be set to 0).\nNote: - GPDMA_CxBR1.BNDT[15:0] must be programmed as a multiple of the source (peripheral) burst size."
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 14.3.7), with an active trigger event if TRIGPOL[1:0] different  00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI 1 ."
            }
        ]
    },
    "1073873432": {
        "name": "GPDMA_C3BR1",
        "address": 1073873432,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873436": {
        "name": "GPDMA_C3SAR",
        "address": 1073873436,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0].\nonce/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.\nNote: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied."
            }
        ]
    },
    "1073873440": {
        "name": "GPDMA_C3DAR",
        "address": 1073873440,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0].\nonce/if completed destination block transfer, for a channel x with 2D addressing capability (x = 12 to 15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873484": {
        "name": "GPDMA_C3LLR",
        "address": 1073873484,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873488": {
        "name": "GPDMA_C4LBAR",
        "address": 1073873488,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873500": {
        "name": "GPDMA_C4FCR",
        "address": 1073873500,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873504": {
        "name": "GPDMA_C4SR",
        "address": 1073873504,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half transfer event is either a half block transfer or a half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.\nA half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873508": {
        "name": "GPDMA_C4CR",
        "address": 1073873508,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0 and GPDMA_CxBR1.BRC[10:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873552": {
        "name": "GPDMA_C4TR1",
        "address": 1073873552,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\n1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination\nNote: If the transfer from the source peripheral is configured with peripheral flow-control mode (SWREQ = 0 and PFREQ = 1 and DREQ = 0), and if the destination data width  the source data width, packing is not supported."
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873556": {
        "name": "GPDMA_C4TR2",
        "address": 1073873556,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 14.3.4.\nThe user must not assign a same input hardware request (same REQSEL[7:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:\nNote: If the channel x is activated (GPDMA_CxCR.EN is asserted) with SWREQ = 0 and PFREQ = 1 (peripheral hardware request with peripheral flow-control mode), any software assertion to this DREQ bit is ignored: in peripheral flow-control mode, only a peripheral-to-memory transfer is supported."
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "PFREQ",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Hardware request in peripheral flow control mode\nImportant: If a given channel x is not implemented with this feature, this bit is reserved and PFREQ is not present (see Section 14.3.2 for the list of the implemented channels with this feature.\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:\nNote: In peripheral flow control mode, there are the following restrictions:\nNote: - no 2D/repeated block support (GPDMA_CxBR1.BRC[10:0] must be set to 0)\nNote: - the peripheral must be set as the source of the transfer (DREQ = 0).\nNote: - data packing to a wider destination width is not supported (if destination width  source data width, GPDMA_CxTR1.PAM[1] must be set to 0).\nNote: - GPDMA_CxBR1.BNDT[15:0] must be programmed as a multiple of the source (peripheral) burst size."
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 14.3.7), with an active trigger event if TRIGPOL[1:0] different  00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI 1 ."
            }
        ]
    },
    "1073873560": {
        "name": "GPDMA_C4BR1",
        "address": 1073873560,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873564": {
        "name": "GPDMA_C4SAR",
        "address": 1073873564,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0].\nonce/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.\nNote: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied."
            }
        ]
    },
    "1073873568": {
        "name": "GPDMA_C4DAR",
        "address": 1073873568,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0].\nonce/if completed destination block transfer, for a channel x with 2D addressing capability (x = 12 to 15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873612": {
        "name": "GPDMA_C4LLR",
        "address": 1073873612,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873616": {
        "name": "GPDMA_C5LBAR",
        "address": 1073873616,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873628": {
        "name": "GPDMA_C5FCR",
        "address": 1073873628,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873632": {
        "name": "GPDMA_C5SR",
        "address": 1073873632,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half transfer event is either a half block transfer or a half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.\nA half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873636": {
        "name": "GPDMA_C5CR",
        "address": 1073873636,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0 and GPDMA_CxBR1.BRC[10:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873680": {
        "name": "GPDMA_C5TR1",
        "address": 1073873680,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\n1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination\nNote: If the transfer from the source peripheral is configured with peripheral flow-control mode (SWREQ = 0 and PFREQ = 1 and DREQ = 0), and if the destination data width  the source data width, packing is not supported."
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873684": {
        "name": "GPDMA_C5TR2",
        "address": 1073873684,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 14.3.4.\nThe user must not assign a same input hardware request (same REQSEL[7:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:\nNote: If the channel x is activated (GPDMA_CxCR.EN is asserted) with SWREQ = 0 and PFREQ = 1 (peripheral hardware request with peripheral flow-control mode), any software assertion to this DREQ bit is ignored: in peripheral flow-control mode, only a peripheral-to-memory transfer is supported."
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "PFREQ",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Hardware request in peripheral flow control mode\nImportant: If a given channel x is not implemented with this feature, this bit is reserved and PFREQ is not present (see Section 14.3.2 for the list of the implemented channels with this feature.\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:\nNote: In peripheral flow control mode, there are the following restrictions:\nNote: no 2D/repeated block support (GPDMA_CxBR1.BRC[10:0] must be set to 0)\nNote: the peripheral must be set as the source of the transfer (DREQ = 0).\nNote: data packing to a wider destination width is not supported (if destination width  source data width, GPDMA_CxTR1.PAM[1] must be set to 0).\nNote: GPDMA_CxBR1.BNDT[15:0] must be programmed as a multiple of the source (peripheral) burst size."
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 14.3.7), with an active trigger event if TRIGPOL[1:0] different  00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI 1 ."
            }
        ]
    },
    "1073873688": {
        "name": "GPDMA_C5BR1",
        "address": 1073873688,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873692": {
        "name": "GPDMA_C5SAR",
        "address": 1073873692,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0].\nonce/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.\nNote: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied."
            }
        ]
    },
    "1073873696": {
        "name": "GPDMA_C5DAR",
        "address": 1073873696,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0].\nonce/if completed destination block transfer, for a channel x with 2D addressing capability (x = 12 to 15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873740": {
        "name": "GPDMA_C5LLR",
        "address": 1073873740,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873744": {
        "name": "GPDMA_C6LBAR",
        "address": 1073873744,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873756": {
        "name": "GPDMA_C6FCR",
        "address": 1073873756,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873760": {
        "name": "GPDMA_C6SR",
        "address": 1073873760,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half transfer event is either a half block transfer or a half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.\nA half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873764": {
        "name": "GPDMA_C6CR",
        "address": 1073873764,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0 and GPDMA_CxBR1.BRC[10:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873808": {
        "name": "GPDMA_C6TR1",
        "address": 1073873808,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\n1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination\nNote: If the transfer from the source peripheral is configured with peripheral flow-control mode (SWREQ = 0 and PFREQ = 1 and DREQ = 0), and if the destination data width  the source data width, packing is not supported."
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873812": {
        "name": "GPDMA_C6TR2",
        "address": 1073873812,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 14.3.4.\nThe user must not assign a same input hardware request (same REQSEL[7:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:\nNote: If the channel x is activated (GPDMA_CxCR.EN is asserted) with SWREQ = 0 and PFREQ = 1 (peripheral hardware request with peripheral flow-control mode), any software assertion to this DREQ bit is ignored: in peripheral flow-control mode, only a peripheral-to-memory transfer is supported."
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "PFREQ",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Hardware request in peripheral flow control mode\nImportant: If a given channel x is not implemented with this feature, this bit is reserved and PFREQ is not present (see Section 14.3.2 for the list of the implemented channels with this feature.\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:\nNote: In peripheral flow control mode, there are the following restrictions:\nNote: no 2D/repeated block support (GPDMA_CxBR1.BRC[10:0] must be set to 0)\nNote: the peripheral must be set as the source of the transfer (DREQ = 0).\nNote: data packing to a wider destination width is not supported (if destination width  source data width, GPDMA_CxTR1.PAM[1] must be set to 0).\nNote: GPDMA_CxBR1.BNDT[15:0] must be programmed as a multiple of the source (peripheral) burst size."
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 14.3.7), with an active trigger event if TRIGPOL[1:0] different  00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI 1 ."
            }
        ]
    },
    "1073873816": {
        "name": "GPDMA_C6BR1",
        "address": 1073873816,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 alternate block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] different  0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            },
            {
                "name": "BRC",
                "bitOffset": 16,
                "bitWidth": 11,
                "desc": "Block repeat counter\nThis field contains the number of repetitions of the current block (0 to 2047).\nWhen the channel is enabled, this field becomes read-only. After decrements, this field indicates the remaining number of blocks, excluding the current one. This counter is hardware decremented for each completed block transfer.\nOnce the last block transfer is completed (BRC[10:0] = BNDT[15:0] = 0):\nIf GPDMA_CxLLR.UB1 = 1, all GPDMA_CxBR1 fields are updated by the next LLI in the memory.\nIf GPDMA_CxLLR.UB1 = 0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value.\nif all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] different  0, this field is internally restored to the programmed value (infinite/continuous last LLI).\nif GPDMA_CxLLR = 0, this field is kept as zero following the last LLI and data transfer."
            },
            {
                "name": "SDEC",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "source address decrement"
            },
            {
                "name": "DDEC",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "destination address decrement"
            },
            {
                "name": "BRSDEC",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Block repeat source address decrement\nNote: On top of this increment/decrement (depending on BRSDEC), GPDMA_CxSAR is in the same time also updated by the increment/decrement (depending on SDEC) of the GPDMA_CxTR3.SAO value, as it is done after any programmed burst transfer."
            },
            {
                "name": "BRDDEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Block repeat destination address decrement\nNote: On top of this increment/decrement (depending on BRDDEC), GPDMA_CxDAR is in the same time also updated by the increment/decrement (depending on DDEC) of the GPDMA_CxTR3.DAO value, as it is usually done at the end of each programmed burst transfer."
            }
        ]
    },
    "1073873820": {
        "name": "GPDMA_C6SAR",
        "address": 1073873820,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0].\nonce/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.\nNote: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied."
            }
        ]
    },
    "1073873824": {
        "name": "GPDMA_C6DAR",
        "address": 1073873824,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0].\nonce/if completed destination block transfer, for a channel x with 2D addressing capability (x = 12 to 15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873828": {
        "name": "GPDMA_C6TR3",
        "address": 1073873828,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 transfer register 3",
        "fields": [
            {
                "name": "SAO",
                "bitOffset": 0,
                "bitWidth": 13,
                "desc": "source address offset increment\nThe source address, pointed by GPDMA_CxSAR, is incremented or decremented (depending on GPDMA_CxBR1.SDEC) by this offset SAO[12:0] for each programmed source burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.SINC = 1).\nNote: A source address offset must be aligned with the programmed data width of a source burst (SAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.\nNote: When the source block size is not a multiple of the destination burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied."
            },
            {
                "name": "DAO",
                "bitOffset": 16,
                "bitWidth": 13,
                "desc": "destination address offset increment\nThe destination address, pointed by GPDMA_CxDAR, is incremented or decremented (depending on GPDMA_CxBR1.DDEC) by this offset DAO[12:0] for each programmed destination burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.DINC = 1).\nNote: A destination address offset must be aligned with the programmed data width of a destination burst (DAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873832": {
        "name": "GPDMA_C6BR2",
        "address": 1073873832,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 block register 2",
        "fields": [
            {
                "name": "BRSAO",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Block repeated source address offset\nFor a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRSDEC) the current source address (GPDMA_CxSAR) at the end of a block transfer.\nA block repeated source address offset must be aligned with the programmed data width of a source burst (BRSAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: BRSAO[15:0] must be set to 0 in peripheral flow-control mode (if GPDMA_CxTR2.PFREQ = 1)."
            },
            {
                "name": "BRDAO",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Block repeated destination address offset\nFor a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRDDEC) the current destination address (GPDMA_CxDAR) at the end of a block transfer.\nA block repeated destination address offset must be aligned with the programmed data width of a destination burst (BRDAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: BRDAO[15:0] must be set to 0 in peripheral flow-control mode (if GPDMA_CxTR2.PFREQ = 1)."
            }
        ]
    },
    "1073873868": {
        "name": "GPDMA_C6LLR",
        "address": 1073873868,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 alternate linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UB2",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR2 from memory\nThis bit controls the update of GPDMA_CxBR2 from the memory during the link transfer."
            },
            {
                "name": "UT3",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR3 from memory\nThis bit controls the update of GPDMA_CxTR3 from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873872": {
        "name": "GPDMA_C7LBAR",
        "address": 1073873872,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873884": {
        "name": "GPDMA_C7FCR",
        "address": 1073873884,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873888": {
        "name": "GPDMA_C7SR",
        "address": 1073873888,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, a 2D/repeated block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half transfer event is either a half block transfer or a half 2D/repeated block transfer, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0]).\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination.\nA half 2D/repeated block transfer occurs when half of the repeated blocks (rounded up integer of (GPDMA_CxBR1.BRC[10:0]+1)/2)) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] and GPDMA_CxBR1.BRC[10:0], to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873892": {
        "name": "GPDMA_C7CR",
        "address": 1073873892,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0 and GPDMA_CxBR1.BRC[10:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873936": {
        "name": "GPDMA_C7TR1",
        "address": 1073873936,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\n1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination\nNote: If the transfer from the source peripheral is configured with peripheral flow-control mode (SWREQ = 0 and PFREQ = 1 and DREQ = 0), and if the destination data width  the source data width, packing is not supported."
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] and address offset GPDMA_CxTR3.DAO[2:0], versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873940": {
        "name": "GPDMA_C7TR2",
        "address": 1073873940,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 14.3.4.\nThe user must not assign a same input hardware request (same REQSEL[7:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:\nNote: If the channel x is activated (GPDMA_CxCR.EN is asserted) with SWREQ = 0 and PFREQ = 1 (peripheral hardware request with peripheral flow-control mode), any software assertion to this DREQ bit is ignored: in peripheral flow-control mode, only a peripheral-to-memory transfer is supported."
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "PFREQ",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Hardware request in peripheral flow control mode\nImportant: If a given channel x is not implemented with this feature, this bit is reserved and PFREQ is not present (see Section 14.3.2 for the list of the implemented channels with this feature.\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:\nNote: In peripheral flow control mode, there are the following restrictions:\nNote: no 2D/repeated block support (GPDMA_CxBR1.BRC[10:0] must be set to 0)\nNote: the peripheral must be set as the source of the transfer (DREQ = 0).\nNote: data packing to a wider destination width is not supported (if destination width  source data width, GPDMA_CxTR1.PAM[1] must be set to 0).\nNote: GPDMA_CxBR1.BNDT[15:0] must be programmed as a multiple of the source (peripheral) burst size."
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 14.3.7), with an active trigger event if TRIGPOL[1:0] different  00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[5:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLI 0  data transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLI 1 ."
            }
        ]
    },
    "1073873944": {
        "name": "GPDMA_C7BR1",
        "address": 1073873944,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 alternate block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] different  0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1]=1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            },
            {
                "name": "BRC",
                "bitOffset": 16,
                "bitWidth": 11,
                "desc": "Block repeat counter\nThis field contains the number of repetitions of the current block (0 to 2047).\nWhen the channel is enabled, this field becomes read-only. After decrements, this field indicates the remaining number of blocks, excluding the current one. This counter is hardware decremented for each completed block transfer.\nOnce the last block transfer is completed (BRC[10:0] = BNDT[15:0] = 0):\nIf GPDMA_CxLLR.UB1 = 1, all GPDMA_CxBR1 fields are updated by the next LLI in the memory.\nIf GPDMA_CxLLR.UB1 = 0 and if there is at least one not null Uxx update bit, this field is internally restored to the programmed value.\nif all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] different  0, this field is internally restored to the programmed value (infinite/continuous last LLI).\nif GPDMA_CxLLR = 0, this field is kept as zero following the last LLI and data transfer."
            },
            {
                "name": "SDEC",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "source address decrement"
            },
            {
                "name": "DDEC",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "destination address decrement"
            },
            {
                "name": "BRSDEC",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Block repeat source address decrement\nNote: On top of this increment/decrement (depending on BRSDEC), GPDMA_CxSAR is in the same time also updated by the increment/decrement (depending on SDEC) of the GPDMA_CxTR3.SAO value, as it is done after any programmed burst transfer."
            },
            {
                "name": "BRDDEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Block repeat destination address decrement\nNote: On top of this increment/decrement (depending on BRDDEC), GPDMA_CxDAR is in the same time also updated by the increment/decrement (depending on DDEC) of the GPDMA_CxTR3.DAO value, as it is usually done at the end of each programmed burst transfer."
            }
        ]
    },
    "1073873948": {
        "name": "GPDMA_C7SAR",
        "address": 1073873948,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC and GPDMA_CxTR3.SAO[12:0].\nonce/if completed source block transfer, for a channel x with 2D addressing capability (x = 12 to 15). additional block repeat source incremented/decremented offset value as programmed by GPDMA_CxBR1.BRSDEC and GPDMA_CxBR2.BRSAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued.\nNote: When the source block size is not a multiple of the source burst size and is a multiple of the source data width, the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied."
            }
        ]
    },
    "1073873952": {
        "name": "GPDMA_C7DAR",
        "address": 1073873952,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC and GPDMA_CxTR3.DAO[12:0].\nonce/if completed destination block transfer, for a channel x with 2D addressing capability (x = 12 to 15), the additional block repeat destination incremented/decremented offset value as programmed by GPDMA_CxBR1.BRDDEC and GPDMA_CxBR2.BRDAO[15:0]\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873956": {
        "name": "GPDMA_C7TR3",
        "address": 1073873956,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 transfer register 3",
        "fields": [
            {
                "name": "SAO",
                "bitOffset": 0,
                "bitWidth": 13,
                "desc": "source address offset increment\nThe source address, pointed by GPDMA_CxSAR, is incremented or decremented (depending on GPDMA_CxBR1.SDEC) by this offset SAO[12:0] for each programmed source burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.SINC = 1).\nNote: A source address offset must be aligned with the programmed data width of a source burst (SAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and none transfer is issued.\nNote: When the source block size is not a multiple of the destination burst size and is a multiple of the source data width, then the last programmed source burst is not completed and is internally shorten to match the block size. In this case, the additional GPDMA_CxTR3.SAO[12:0] is not applied."
            },
            {
                "name": "DAO",
                "bitOffset": 16,
                "bitWidth": 13,
                "desc": "destination address offset increment\nThe destination address, pointed by GPDMA_CxDAR, is incremented or decremented (depending on GPDMA_CxBR1.DDEC) by this offset DAO[12:0] for each programmed destination burst. This offset is not including and is added to the programmed burst size when the completed burst is addressed in incremented mode (GPDMA_CxTR1.DINC = 1).\nNote: A destination address offset must be aligned with the programmed data width of a destination burst (DAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873960": {
        "name": "GPDMA_C7BR2",
        "address": 1073873960,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 block register 2",
        "fields": [
            {
                "name": "BRSAO",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Block repeated source address offset\nFor a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRSDEC) the current source address (GPDMA_CxSAR) at the end of a block transfer.\nA block repeated source address offset must be aligned with the programmed data width of a source burst (BRSAO[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: BRSAO[15:0] must be set to 0 in peripheral flow-control mode (if GPDMA_CxTR2.PFREQ = 1)."
            },
            {
                "name": "BRDAO",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Block repeated destination address offset\nFor a channel with 2D addressing capability, this field is used to update (by addition or subtraction depending on GPDMA_CxBR1.BRDDEC) the current destination address (GPDMA_CxDAR) at the end of a block transfer.\nA block repeated destination address offset must be aligned with the programmed data width of a destination burst (BRDAO[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: BRDAO[15:0] must be set to 0 in peripheral flow-control mode (if GPDMA_CxTR2.PFREQ = 1)."
            }
        ]
    },
    "1073873996": {
        "name": "GPDMA_C7LLR",
        "address": 1073873996,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 alternate linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UB2",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR2 from memory\nThis bit controls the update of GPDMA_CxBR2 from the memory during the link transfer."
            },
            {
                "name": "UT3",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR3 from memory\nThis bit controls the update of GPDMA_CxTR3 from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different  0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1108083712": {
        "name": "HASH_CR",
        "address": 1108083712,
        "size": 32,
        "access": "",
        "desc": "HASH control register",
        "fields": [
            {
                "name": "INIT",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Initialize message digest calculation\nWriting this bit to 1 resets the hash processor core, so that the HASH is ready to compute the message digest of a new message.\nWriting this bit to 0 has no effect. Reading this bit always returns 0."
            },
            {
                "name": "DMAE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "DMA enable\nAfter this bit is set, it is cleared by hardware while the last data of the message is written into the hash processor.\nSetting this bit to 0 while a DMA transfer is ongoing does not abort the current transfer. Instead, the DMA interface of the HASH remains internally enabled until the transfer is completed or INIT is written to 1.\nSetting INIT bit to 1 does not clear DMAE bit."
            },
            {
                "name": "DATATYPE",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Data type selection\nThis bitfield defines the format of the data entered into the HASH_DIN register:"
            },
            {
                "name": "MODE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Mode selection\nThis bit selects the normal or the keyed HMAC mode for the selected algorithm:\nThis selection is only taken into account when the INIT bit is set. Changing this bit during a computation has no effect."
            },
            {
                "name": "NBW",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Number of words already pushed\nRefer to NBWP[3:0] bitfield of HASH_SR for a description of NBW[3:0] bitfield.\nThis bit is read-only."
            },
            {
                "name": "DINNE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "DIN not empty\nRefer to DINNE bit of HASH_SR for a description of DINNE bit.\nThis bit is read-only."
            },
            {
                "name": "MDMAT",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Multiple DMA transfers\nThis bit is set when hashing large files when multiple DMA transfers are needed."
            },
            {
                "name": "LKEY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Long key selection\nThe application must set this bit if the HMAC key is greater than the block size (64 bytes)\nThis selection is only taken into account when the INIT and MODE bits are set (HMAC mode selected). Changing this bit during a computation has no effect."
            },
            {
                "name": "ALGO",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Algorithm selection\nThese bits select the hash algorithm:\nThis selection is only taken into account when the INIT bit is set. Changing this bitfield during a computation has no effect.\nWhen the ALGO bitfield is updated and INIT bit is set, NBWE in HASH_SR is automatically updated to 0x11."
            }
        ]
    },
    "1108083716": {
        "name": "HASH_DIN",
        "address": 1108083716,
        "size": 32,
        "access": "",
        "desc": "HASH data input register",
        "fields": [
            {
                "name": "DATAIN",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Data input\nWriting this register pushes the current register content into the FIFO, and the register takes the new value presented on the AHB bus.\nReading this register returns zeros."
            }
        ]
    },
    "1108083720": {
        "name": "HASH_STR",
        "address": 1108083720,
        "size": 32,
        "access": "",
        "desc": "HASH start register",
        "fields": [
            {
                "name": "NBLW",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Number of valid bits in the last word\nWhen the last word of the message bit string is written to HASH_DIN register, the hash processor takes only the valid bits, specified as below, after internal data swapping:\n...\nThe above mechanism is valid only if DCAL = 0. If NBLW bits are written while DCAL is set to 1, the NBLW bitfield remains unchanged. In other words it is not possible to configure NBLW and set DCAL at the same time.\nReading NBLW bits returns the last value written to NBLW."
            },
            {
                "name": "DCAL",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Digest calculation\nWriting this bit to 1 starts the message padding using the previously written value of NBLW, and starts the calculation of the final message digest with all the data words written to the input FIFO since the INIT bit was last written to 1.\nReading this bit returns 0."
            }
        ]
    },
    "1108083724": {
        "name": "HASH_HRA0",
        "address": 1108083724,
        "size": 32,
        "access": "",
        "desc": "HASH aliased digest register 0",
        "fields": [
            {
                "name": "H0",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108083728": {
        "name": "HASH_HRA1",
        "address": 1108083728,
        "size": 32,
        "access": "",
        "desc": "HASH aliased digest register 1",
        "fields": [
            {
                "name": "H1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108083732": {
        "name": "HASH_HRA2",
        "address": 1108083732,
        "size": 32,
        "access": "",
        "desc": "HASH aliased digest register 2",
        "fields": [
            {
                "name": "H2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108083736": {
        "name": "HASH_HRA3",
        "address": 1108083736,
        "size": 32,
        "access": "",
        "desc": "HASH aliased digest register 3",
        "fields": [
            {
                "name": "H3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108083740": {
        "name": "HASH_HRA4",
        "address": 1108083740,
        "size": 32,
        "access": "",
        "desc": "HASH aliased digest register 4",
        "fields": [
            {
                "name": "H4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108083744": {
        "name": "HASH_IMR",
        "address": 1108083744,
        "size": 32,
        "access": "",
        "desc": "HASH interrupt enable register",
        "fields": [
            {
                "name": "DINIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Data input interrupt enable"
            },
            {
                "name": "DCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Digest calculation completion interrupt enable"
            }
        ]
    },
    "1108083748": {
        "name": "HASH_SR",
        "address": 1108083748,
        "size": 32,
        "access": "",
        "desc": "HASH status register",
        "fields": [
            {
                "name": "DINIS",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Data input interrupt status\nThis bit is set by hardware when the FIFO is ready to get a new block (16 locations are free). It is cleared by writing it to 0 or by writing the HASH_DIN register.\nWhen DINIS = 0, HASH_CSRx registers reads as zero."
            },
            {
                "name": "DCIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Digest calculation completion interrupt status\nThis bit is set by hardware when a digest becomes ready (the whole message has been processed). It is cleared by writing it to 0 or by writing the INIT bit to 1 in the HASH_CR register."
            },
            {
                "name": "DMAS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "DMA Status\nThis bit provides information on the DMA interface activity. It is set with DMAE and cleared when DMAE = 0 and no DMA transfer is ongoing. No interrupt is associated with this bit."
            },
            {
                "name": "BUSY",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Busy bit"
            },
            {
                "name": "NBWP",
                "bitOffset": 9,
                "bitWidth": 5,
                "desc": "Number of words already pushed\nThis bitfield is the exact number of words in the message that have already been pushed into the FIFO. NBWP is incremented by 1 when a write access is performed to the HASH_DIN register.\nWhen a digest calculation starts, NBWP is updated to NBWP- block size (in words), and NBWP goes to zero when the INIT bit is written to 1."
            },
            {
                "name": "DINNE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DIN not empty\nThis bit is set when the HASH_DIN register holds valid data (that is after being written at least once). It is cleared when either the INIT bit (initialization) or the DCAL bit (completion of the previous message processing) is written to 1."
            },
            {
                "name": "NBWE",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Number of words expected\nThis bitfield reflects the number of words in the message that must be pushed into the FIFO to trigger a partial computation. NBWE is decremented by 1 when a write access is performed to the HASH_DIN register.\nNBWE is set to the expected block size +1 in words (0x11) when INIT bit is set in HASH_CR. It is set to the expected block size (0x10) when the partial digest calculation ends."
            }
        ]
    },
    "1108083960": {
        "name": "HASH_CSR0",
        "address": 1108083960,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 0",
        "fields": [
            {
                "name": "CS0",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083964": {
        "name": "HASH_CSR1",
        "address": 1108083964,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 1",
        "fields": [
            {
                "name": "CS1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083968": {
        "name": "HASH_CSR2",
        "address": 1108083968,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 2",
        "fields": [
            {
                "name": "CS2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083972": {
        "name": "HASH_CSR3",
        "address": 1108083972,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 3",
        "fields": [
            {
                "name": "CS3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083976": {
        "name": "HASH_CSR4",
        "address": 1108083976,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 4",
        "fields": [
            {
                "name": "CS4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083980": {
        "name": "HASH_CSR5",
        "address": 1108083980,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 5",
        "fields": [
            {
                "name": "CS5",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083984": {
        "name": "HASH_CSR6",
        "address": 1108083984,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 6",
        "fields": [
            {
                "name": "CS6",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083988": {
        "name": "HASH_CSR7",
        "address": 1108083988,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 7",
        "fields": [
            {
                "name": "CS7",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083992": {
        "name": "HASH_CSR8",
        "address": 1108083992,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 8",
        "fields": [
            {
                "name": "CS8",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083996": {
        "name": "HASH_CSR9",
        "address": 1108083996,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 9",
        "fields": [
            {
                "name": "CS9",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084000": {
        "name": "HASH_CSR10",
        "address": 1108084000,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 10",
        "fields": [
            {
                "name": "CS10",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084004": {
        "name": "HASH_CSR11",
        "address": 1108084004,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 11",
        "fields": [
            {
                "name": "CS11",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084008": {
        "name": "HASH_CSR12",
        "address": 1108084008,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 12",
        "fields": [
            {
                "name": "CS12",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084012": {
        "name": "HASH_CSR13",
        "address": 1108084012,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 13",
        "fields": [
            {
                "name": "CS13",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084016": {
        "name": "HASH_CSR14",
        "address": 1108084016,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 14",
        "fields": [
            {
                "name": "CS14",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084020": {
        "name": "HASH_CSR15",
        "address": 1108084020,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 15",
        "fields": [
            {
                "name": "CS15",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084024": {
        "name": "HASH_CSR16",
        "address": 1108084024,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 16",
        "fields": [
            {
                "name": "CS16",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084028": {
        "name": "HASH_CSR17",
        "address": 1108084028,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 17",
        "fields": [
            {
                "name": "CS17",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084032": {
        "name": "HASH_CSR18",
        "address": 1108084032,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 18",
        "fields": [
            {
                "name": "CS18",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084036": {
        "name": "HASH_CSR19",
        "address": 1108084036,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 19",
        "fields": [
            {
                "name": "CS19",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084040": {
        "name": "HASH_CSR20",
        "address": 1108084040,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 20",
        "fields": [
            {
                "name": "CS20",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084044": {
        "name": "HASH_CSR21",
        "address": 1108084044,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 21",
        "fields": [
            {
                "name": "CS21",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084048": {
        "name": "HASH_CSR22",
        "address": 1108084048,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 22",
        "fields": [
            {
                "name": "CS22",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084052": {
        "name": "HASH_CSR23",
        "address": 1108084052,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 23",
        "fields": [
            {
                "name": "CS23",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084056": {
        "name": "HASH_CSR24",
        "address": 1108084056,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 24",
        "fields": [
            {
                "name": "CS24",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084060": {
        "name": "HASH_CSR25",
        "address": 1108084060,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 25",
        "fields": [
            {
                "name": "CS25",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084064": {
        "name": "HASH_CSR26",
        "address": 1108084064,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 26",
        "fields": [
            {
                "name": "CS26",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084068": {
        "name": "HASH_CSR27",
        "address": 1108084068,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 27",
        "fields": [
            {
                "name": "CS27",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084072": {
        "name": "HASH_CSR28",
        "address": 1108084072,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 28",
        "fields": [
            {
                "name": "CS28",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084076": {
        "name": "HASH_CSR29",
        "address": 1108084076,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 29",
        "fields": [
            {
                "name": "CS29",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084080": {
        "name": "HASH_CSR30",
        "address": 1108084080,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 30",
        "fields": [
            {
                "name": "CS30",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084084": {
        "name": "HASH_CSR31",
        "address": 1108084084,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 31",
        "fields": [
            {
                "name": "CS31",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084088": {
        "name": "HASH_CSR32",
        "address": 1108084088,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 32",
        "fields": [
            {
                "name": "CS32",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084092": {
        "name": "HASH_CSR33",
        "address": 1108084092,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 33",
        "fields": [
            {
                "name": "CS33",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084096": {
        "name": "HASH_CSR34",
        "address": 1108084096,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 34",
        "fields": [
            {
                "name": "CS34",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084100": {
        "name": "HASH_CSR35",
        "address": 1108084100,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 35",
        "fields": [
            {
                "name": "CS35",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084104": {
        "name": "HASH_CSR36",
        "address": 1108084104,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 36",
        "fields": [
            {
                "name": "CS36",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084108": {
        "name": "HASH_CSR37",
        "address": 1108084108,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 37",
        "fields": [
            {
                "name": "CS37",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084112": {
        "name": "HASH_CSR38",
        "address": 1108084112,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 38",
        "fields": [
            {
                "name": "CS38",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084116": {
        "name": "HASH_CSR39",
        "address": 1108084116,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 39",
        "fields": [
            {
                "name": "CS39",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084120": {
        "name": "HASH_CSR40",
        "address": 1108084120,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 40",
        "fields": [
            {
                "name": "CS40",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084124": {
        "name": "HASH_CSR41",
        "address": 1108084124,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 41",
        "fields": [
            {
                "name": "CS41",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084128": {
        "name": "HASH_CSR42",
        "address": 1108084128,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 42",
        "fields": [
            {
                "name": "CS42",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084132": {
        "name": "HASH_CSR43",
        "address": 1108084132,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 43",
        "fields": [
            {
                "name": "CS43",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084136": {
        "name": "HASH_CSR44",
        "address": 1108084136,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 44",
        "fields": [
            {
                "name": "CS44",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084140": {
        "name": "HASH_CSR45",
        "address": 1108084140,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 45",
        "fields": [
            {
                "name": "CS45",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084144": {
        "name": "HASH_CSR46",
        "address": 1108084144,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 46",
        "fields": [
            {
                "name": "CS46",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084148": {
        "name": "HASH_CSR47",
        "address": 1108084148,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 47",
        "fields": [
            {
                "name": "CS47",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084152": {
        "name": "HASH_CSR48",
        "address": 1108084152,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 48",
        "fields": [
            {
                "name": "CS48",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084156": {
        "name": "HASH_CSR49",
        "address": 1108084156,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 49",
        "fields": [
            {
                "name": "CS49",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084160": {
        "name": "HASH_CSR50",
        "address": 1108084160,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 50",
        "fields": [
            {
                "name": "CS50",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084164": {
        "name": "HASH_CSR51",
        "address": 1108084164,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 51",
        "fields": [
            {
                "name": "CS51",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084168": {
        "name": "HASH_CSR52",
        "address": 1108084168,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 52",
        "fields": [
            {
                "name": "CS52",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084172": {
        "name": "HASH_CSR53",
        "address": 1108084172,
        "size": 32,
        "access": "",
        "desc": "HASH context swap register 53",
        "fields": [
            {
                "name": "CS53",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\nRefer to Section 24.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084496": {
        "name": "HASH_HR0",
        "address": 1108084496,
        "size": 32,
        "access": "",
        "desc": "HASH digest register 0",
        "fields": [
            {
                "name": "H0",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084500": {
        "name": "HASH_HR1",
        "address": 1108084500,
        "size": 32,
        "access": "",
        "desc": "HASH digest register 1",
        "fields": [
            {
                "name": "H1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084504": {
        "name": "HASH_HR2",
        "address": 1108084504,
        "size": 32,
        "access": "",
        "desc": "HASH digest register 2",
        "fields": [
            {
                "name": "H2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084508": {
        "name": "HASH_HR3",
        "address": 1108084508,
        "size": 32,
        "access": "",
        "desc": "HASH digest register 3",
        "fields": [
            {
                "name": "H3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084512": {
        "name": "HASH_HR4",
        "address": 1108084512,
        "size": 32,
        "access": "",
        "desc": "HASH digest register 4",
        "fields": [
            {
                "name": "H4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084516": {
        "name": "HASH_HR5",
        "address": 1108084516,
        "size": 32,
        "access": "",
        "desc": "HASH supplementary digest register 5",
        "fields": [
            {
                "name": "H5",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084520": {
        "name": "HASH_HR6",
        "address": 1108084520,
        "size": 32,
        "access": "",
        "desc": "HASH supplementary digest register 6",
        "fields": [
            {
                "name": "H6",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084524": {
        "name": "HASH_HR7",
        "address": 1108084524,
        "size": 32,
        "access": "",
        "desc": "HASH supplementary digest register 7",
        "fields": [
            {
                "name": "H7",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\nRefer to Section 24.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1073939456": {
        "name": "ICACHE_CR",
        "address": 1073939456,
        "size": 32,
        "access": "",
        "desc": "ICACHE control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable"
            },
            {
                "name": "CACHEINV",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "cache invalidation\nSet by software and cleared by hardware when the BUSYF flag is set (during cache maintenance operation). Writing 0 has no effect."
            },
            {
                "name": "WAYSEL",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "cache associativity mode selection\nThis bit allows user to choose ICACHE set-associativity. It can be written by software only when cache is disabled (EN = 0)."
            },
            {
                "name": "HITMEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "hit monitor enable"
            },
            {
                "name": "MISSMEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "miss monitor enable"
            },
            {
                "name": "HITMRST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "hit monitor reset"
            },
            {
                "name": "MISSMRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "miss monitor reset"
            }
        ]
    },
    "1073939460": {
        "name": "ICACHE_SR",
        "address": 1073939460,
        "size": 32,
        "access": "",
        "desc": "ICACHE status register",
        "fields": [
            {
                "name": "BUSYF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "busy flag"
            },
            {
                "name": "BSYENDF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "busy end flag"
            },
            {
                "name": "ERRF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "cache error flag"
            }
        ]
    },
    "1073939464": {
        "name": "ICACHE_IER",
        "address": 1073939464,
        "size": 32,
        "access": "",
        "desc": "ICACHE interrupt enable register",
        "fields": [
            {
                "name": "BSYENDIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "interrupt enable on busy end\nSet by software to enable an interrupt generation at the end of a cache invalidate operation."
            },
            {
                "name": "ERRIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "interrupt enable on cache error\nSet by software to enable an interrupt generation in case of cache functional error (cacheable write access)"
            }
        ]
    },
    "1073939468": {
        "name": "ICACHE_FCR",
        "address": 1073939468,
        "size": 32,
        "access": "",
        "desc": "ICACHE flag clear register",
        "fields": [
            {
                "name": "CBSYENDF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "clear busy end flag\nSet by software."
            },
            {
                "name": "CERRF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "clear cache error flag\nSet by software."
            }
        ]
    },
    "1073939472": {
        "name": "ICACHE_HMONR",
        "address": 1073939472,
        "size": 32,
        "access": "",
        "desc": "ICACHE hit monitor register",
        "fields": [
            {
                "name": "HITMON",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "cache hit monitor counter"
            }
        ]
    },
    "1073939476": {
        "name": "ICACHE_MMONR",
        "address": 1073939476,
        "size": 32,
        "access": "",
        "desc": "ICACHE miss monitor register",
        "fields": [
            {
                "name": "MISSMON",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "cache miss monitor counter"
            }
        ]
    },
    "1073754112": {
        "name": "IWDG_KR",
        "address": 1073754112,
        "size": 32,
        "access": "",
        "desc": "IWDG key register ",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Key value (write only, read 0x0000)\nThese bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0.\nWriting the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see )\nWriting the key value 0xCCCC starts the watchdog (except if the hardware watchdog option is selected)"
            }
        ]
    },
    "1073754116": {
        "name": "IWDG_PR",
        "address": 1073754116,
        "size": 32,
        "access": "",
        "desc": "IWDG prescaler register ",
        "fields": [
            {
                "name": "PR",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Prescaler divider\nThese bits are write access protected see . They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the  must be reset in order to be able to change the prescaler divider.\nOthers: divider / 1024\nNote: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the status register (IWDG_SR) is reset."
            }
        ]
    },
    "1073754120": {
        "name": "IWDG_RLR",
        "address": 1073754120,
        "size": 32,
        "access": "",
        "desc": "IWDG reload register ",
        "fields": [
            {
                "name": "RL",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter reload value\nThese bits are write access protected see . They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the . The watchdog counter counts down from this value. The timeout period is a function of this value and the prescaler.clock. It is not recommended to set RL[11:0] to a value lower than 2.\nThe RVU bit in the  must be reset to be able to change the reload value.\nNote: Reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on it. For this reason the value read from this register is valid only when the RVU bit in the status register (IWDG_SR) is reset."
            }
        ]
    },
    "1073754124": {
        "name": "IWDG_SR",
        "address": 1073754124,
        "size": 32,
        "access": "",
        "desc": "IWDG status register ",
        "fields": [
            {
                "name": "PVU",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Watchdog prescaler value update\nThis bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).\nThe prescaler value can be updated only when PVU bit is reset."
            },
            {
                "name": "RVU",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Watchdog counter reload value update\nThis bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).\nThe reload value can be updated only when RVU bit is reset."
            },
            {
                "name": "WVU",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Watchdog counter window value update\nThis bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).\nThe window value can be updated only when WVU bit is reset.\nThis bit is generated only if generic 'window' = 1"
            },
            {
                "name": "EWU",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Watchdog interrupt comparator value update\nThis bit is set by hardware to indicate that an update of the interrupt comparator value (EWIT[11:0]) or an update of the EWIE is ongoing. It is reset by hardware when the update operation is completed in the VDD voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).\nThe EWIT[11:0] and EWIE fields can be updated only when EWU bit is reset."
            },
            {
                "name": "EWIF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Watchdog early interrupt flag\nThis bit is set to '1' by hardware in order to indicate that an early interrupt is pending. This bit must be cleared by the software by writing the bit EWIC of IWDG_EWCR register to '1'."
            }
        ]
    },
    "1073754128": {
        "name": "IWDG_WINR",
        "address": 1073754128,
        "size": 32,
        "access": "",
        "desc": "IWDG window register ",
        "fields": [
            {
                "name": "WIN",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter window value\nThese bits are write access protected, see , they contain the high limit of the window value to be compared with the downcounter.\nTo prevent a reset, the IWDCNT downcounter must be reloaded when its value is lower than WIN[11:0]+1 and greater than 1.\nThe WVU bit in the  must be reset to be able to change the reload value.\nNote: Reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the (IWDG_SR) is reset."
            }
        ]
    },
    "1073754132": {
        "name": "IWDG_EWCR",
        "address": 1073754132,
        "size": 32,
        "access": "",
        "desc": "IWDG early wakeup interrupt register ",
        "fields": [
            {
                "name": "EWIT",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter window value\nThese bits are write access protected (see ). They are written by software to define at which position of the IWDCNT down-counter the early wakeup interrupt must be generated. The early interrupt is generated when the IWDCNT is lower or equal to EWIT[11:0] - 1.\nEWIT[11:0] must be bigger than 1.\nAn interrupt is generated only if EWIE = 1.\nThe EWU bit in the  must be reset to be able to change the reload value.\nNote: Reading this register returns the Early wakeup comparator value and the Interrupt enable bit from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the EWU bit in the  is reset."
            },
            {
                "name": "EWIC",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Watchdog early interrupt acknowledge\nThe software must write a 1 into this bit in order to acknowledge the early wakeup interrupt and to clear the EWIF flag. Writing 0 has not effect, reading this flag returns a 0."
            },
            {
                "name": "EWIE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Watchdog early interrupt enable\nSet and reset by software.\nThe EWU bit in the  must be reset to be able to change the value of this bit."
            }
        ]
    },
    "1073763328": {
        "name": "I2C_CR1",
        "address": 1073763328,
        "size": 32,
        "access": "",
        "desc": "I2C control register 1 ",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Peripheral enable\nNote: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles."
            },
            {
                "name": "TXIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TX Interrupt enable"
            },
            {
                "name": "RXIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "RX Interrupt enable"
            },
            {
                "name": "ADDRIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address match Interrupt enable (slave only)"
            },
            {
                "name": "NACKIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not acknowledge received Interrupt enable"
            },
            {
                "name": "STOPIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Stop detection Interrupt enable"
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transfer Complete interrupt enable\nNote: Any of these events generate an interrupt:\nTransfer Complete (TC)\nTransfer Complete Reload (TCR)"
            },
            {
                "name": "ERRIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Error interrupts enable\nNote: Any of these errors generate an interrupt:\nArbitration Loss (ARLO)\nBus Error detection (BERR)\nOverrun/Underrun (OVR)\nTimeout detection (TIMEOUT)\nPEC error detection (PECERR)\nAlert pin event detection (ALERT)"
            },
            {
                "name": "DNF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Digital noise filter\nThese bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK\n...\nNote: If the analog filter is also enabled, the digital filter is added to the analog filter.\nThis filter can only be programmed when the I2C is disabled (PE = 0)."
            },
            {
                "name": "ANFOFF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Analog noise filter OFF\nNote: This bit can only be programmed when the I2C is disabled (PE = 0)."
            },
            {
                "name": "TXDMAEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "DMA transmission requests enable"
            },
            {
                "name": "RXDMAEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DMA reception requests enable"
            },
            {
                "name": "SBC",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Slave byte control\nThis bit is used to enable hardware byte control in slave mode."
            },
            {
                "name": "NOSTRETCH",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Clock stretching disable\nThis bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.\nNote: This bit can only be programmed when the I2C is disabled (PE = 0)."
            },
            {
                "name": "WUPEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Wakeup from Stop mode enable\nNote: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to .\nNote: WUPEN can be set only when DNF = '0000'"
            },
            {
                "name": "GCEN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "General call enable"
            },
            {
                "name": "SMBHEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "SMBus host address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "SMBDEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "SMBus device default address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "ALERTEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "SMBus alert enable\nNote: When ALERTEN=0, the SMBA pin can be used as a standard GPIO.\nIf the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "PECEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "PEC enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "FMP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Fast-mode Plus 20 mA drive enable"
            },
            {
                "name": "ADDRACLR",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Address match flag (ADDR) automatic clear"
            },
            {
                "name": "STOPFACLR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "STOP detection flag (STOPF) automatic clear"
            }
        ]
    },
    "1073763332": {
        "name": "I2C_CR2",
        "address": 1073763332,
        "size": 32,
        "access": "",
        "desc": "I2C control register 2 ",
        "fields": [
            {
                "name": "SADD",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Slave address (master mode)\nIn 7-bit addressing mode (ADD10 = 0):\nSADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care.\nIn 10-bit addressing mode (ADD10 = 1):\nSADD[9:0] should be written with the 10-bit slave address to be sent.\nNote: Changing these bits when the START bit is set is not allowed."
            },
            {
                "name": "RD_WRN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Transfer direction (master mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "ADD10",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "10-bit addressing mode (master mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "HEAD10R",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "10-bit address header only read direction (master receiver mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "START",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Start generation\nThis bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0.\nIf the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer.\nOtherwise setting this bit generates a START condition once the bus is free.\nNote: Writing '0' to this bit has no effect.\nThe START bit can be set even if the bus is BUSY or I2C is in slave mode.\nThis bit has no effect when RELOAD is set."
            },
            {
                "name": "STOP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Stop generation (master mode)\nThe bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.\nIn Master Mode:\nNote: Writing '0' to this bit has no effect."
            },
            {
                "name": "NACK",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "NACK generation (slave mode)\nThe bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0.\nNote: Writing '0' to this bit has no effect.\nThis bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value.\nWhen an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value.\nWhen hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value."
            },
            {
                "name": "NBYTES",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Number of bytes\nThe number of bytes to be transmitted/received is programmed there. This field is don't care in slave mode with SBC=0.\nNote: Changing these bits when the START bit is set is not allowed."
            },
            {
                "name": "RELOAD",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "NBYTES reload mode\nThis bit is set and cleared by software."
            },
            {
                "name": "AUTOEND",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Automatic end mode (master mode)\nThis bit is set and cleared by software.\nNote: This bit has no effect in slave mode or when the RELOAD bit is set."
            },
            {
                "name": "PECBYTE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Packet error checking byte\nThis bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0.\nNote: Writing '0' to this bit has no effect.\nThis bit has no effect when RELOAD is set.\nThis bit has no effect is slave mode when SBC=0.\nIf the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            }
        ]
    },
    "1073763336": {
        "name": "I2C_OAR1",
        "address": 1073763336,
        "size": 32,
        "access": "",
        "desc": "I2C own address 1 register ",
        "fields": [
            {
                "name": "OA1",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Interface own slave address\n7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care.\n10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.\nNote: These bits can be written only when OA1EN=0."
            },
            {
                "name": "OA1MODE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Own Address 1 10-bit mode\nNote: This bit can be written only when OA1EN=0."
            },
            {
                "name": "OA1EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Own Address 1 enable"
            }
        ]
    },
    "1073763340": {
        "name": "I2C_OAR2",
        "address": 1073763340,
        "size": 32,
        "access": "",
        "desc": "I2C own address 2 register ",
        "fields": [
            {
                "name": "OA2",
                "bitOffset": 1,
                "bitWidth": 7,
                "desc": "Interface address\n7-bit addressing mode: 7-bit address\nNote: These bits can be written only when OA2EN=0."
            },
            {
                "name": "OA2MSK",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "Own Address 2 masks\nNote: These bits can be written only when OA2EN=0.\nAs soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches."
            },
            {
                "name": "OA2EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Own Address 2 enable"
            }
        ]
    },
    "1073763344": {
        "name": "I2C_TIMINGR",
        "address": 1073763344,
        "size": 32,
        "access": "",
        "desc": "I2C timing register ",
        "fields": [
            {
                "name": "SCLL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "SCL low period (master mode)\nThis field is used to generate the SCL low period in master mode.\ntSCLL = (SCLL+1) x tPRESC\nNote: SCLL is also used to generate tBUF and tSU:STA timings."
            },
            {
                "name": "SCLH",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "SCL high period (master mode)\nThis field is used to generate the SCL high period in master mode.\ntSCLH = (SCLH+1) x tPRESC\nNote: SCLH is also used to generate tSU:STO and tHD:STA timing."
            },
            {
                "name": "SDADEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Data hold time\nThis field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL.\ntSDADEL= SDADEL x tPRESC\nNote: SDADEL is used to generate tHD:DAT timing."
            },
            {
                "name": "SCLDEL",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Data setup time\nThis field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL.\ntSCLDEL = (SCLDEL+1) x tPRESC\nNote: tSCLDEL is used to generate tSU:DAT timing."
            },
            {
                "name": "PRESC",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Timing prescaler\nThis field is used to prescale i2c_ker_ck in order to generate the clock period tPRESC used for data setup and hold counters (refer to ) and for SCL high and low level counters (refer to ).\ntPRESC = (PRESC+1) x tI2CCLK"
            }
        ]
    },
    "1073763348": {
        "name": "I2C_TIMEOUTR",
        "address": 1073763348,
        "size": 32,
        "access": "",
        "desc": "I2C timeout register ",
        "fields": [
            {
                "name": "TIMEOUTA",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Bus Timeout A\nThis field is used to configure:\nThe SCL low timeout condition tTIMEOUT when TIDLE=0\ntTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK\nThe bus idle condition (both SCL and SDA high) when TIDLE=1\ntIDLE= (TIMEOUTA+1) x 4 x tI2CCLK\nNote: These bits can be written only when TIMOUTEN=0."
            },
            {
                "name": "TIDLE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Idle clock timeout detection\nNote: This bit can be written only when TIMOUTEN=0."
            },
            {
                "name": "TIMOUTEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Clock timeout enable"
            },
            {
                "name": "TIMEOUTB",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Bus timeout B\nThis field is used to configure the cumulative clock extension timeout:\nIn master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected\nIn slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected\ntLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK\nNote: These bits can be written only when TEXTEN=0."
            },
            {
                "name": "TEXTEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Extended clock timeout enable"
            }
        ]
    },
    "1073763352": {
        "name": "I2C_ISR",
        "address": 1073763352,
        "size": 32,
        "access": "",
        "desc": "I2C interrupt and status register ",
        "fields": [
            {
                "name": "TXE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Transmit data register empty (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register.\nThis bit can be written to '1' by software in order to flush the transmit data register I2C_TXDR.\nNote: This bit is set by hardware when PE=0."
            },
            {
                "name": "TXIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transmit interrupt status (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register.\nThis bit can be written to '1' by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1).\nNote: This bit is cleared by hardware when PE=0."
            },
            {
                "name": "RXNE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receive data register not empty (receivers)\nThis bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read.\nNote: This bit is cleared by hardware when PE=0."
            },
            {
                "name": "ADDR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address matched (slave mode)\nThis bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit.\nNote: This bit is cleared by hardware when PE=0."
            },
            {
                "name": "NACKF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not Acknowledge received flag\nThis flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit.\nNote: This bit is cleared by hardware when PE=0."
            },
            {
                "name": "STOPF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Stop detection flag\nThis flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer:\neither as a master, provided that the STOP condition is generated by the peripheral.\nor as a slave, provided that the peripheral has been addressed previously during this transfer.\nIt is cleared by software by setting the STOPCF bit.\nNote: This bit is cleared by hardware when PE=0."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transfer Complete (master mode)\nThis flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set.\nNote: This bit is cleared by hardware when PE=0."
            },
            {
                "name": "TCR",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transfer Complete Reload\nThis flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value.\nNote: This bit is cleared by hardware when PE=0.\nThis flag is only for master mode, or for slave mode when the SBC bit is set."
            },
            {
                "name": "BERR",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Bus error\nThis flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit.\nNote: This bit is cleared by hardware when PE=0."
            },
            {
                "name": "ARLO",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Arbitration lost\nThis flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit.\nNote: This bit is cleared by hardware when PE=0."
            },
            {
                "name": "OVR",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Overrun/Underrun (slave mode)\nThis flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.\nNote: This bit is cleared by hardware when PE=0."
            },
            {
                "name": "PECERR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "PEC Error in reception\nThis flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit.\nNote: This bit is cleared by hardware when PE=0.\nIf the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "TIMEOUT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Timeout or tLOW detection flag\nThis flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit.\nNote: This bit is cleared by hardware when PE=0.\nIf the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "ALERT",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SMBus alert\nThis flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit.\nNote: This bit is cleared by hardware when PE=0.\nIf the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "BUSY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Bus busy\nThis flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a STOP condition is detected, or when PE=0."
            },
            {
                "name": "DIR",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Transfer direction (Slave mode)\nThis flag is updated when an address match event occurs (ADDR=1)."
            },
            {
                "name": "ADDCODE",
                "bitOffset": 17,
                "bitWidth": 7,
                "desc": "Address match code (Slave mode)\nThese bits are updated with the received address when an address match event occurs (ADDR = 1).\nIn the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address."
            }
        ]
    },
    "1073763356": {
        "name": "I2C_ICR",
        "address": 1073763356,
        "size": 32,
        "access": "",
        "desc": "I2C interrupt clear register ",
        "fields": [
            {
                "name": "ADDRCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address matched flag clear\nWriting 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register."
            },
            {
                "name": "NACKCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not Acknowledge flag clear\nWriting 1 to this bit clears the NACKF flag in I2C_ISR register."
            },
            {
                "name": "STOPCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "STOP detection flag clear\nWriting 1 to this bit clears the STOPF flag in the I2C_ISR register."
            },
            {
                "name": "BERRCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Bus error flag clear\nWriting 1 to this bit clears the BERRF flag in the I2C_ISR register."
            },
            {
                "name": "ARLOCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Arbitration lost flag clear\nWriting 1 to this bit clears the ARLO flag in the I2C_ISR register."
            },
            {
                "name": "OVRCF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Overrun/Underrun flag clear\nWriting 1 to this bit clears the OVR flag in the I2C_ISR register."
            },
            {
                "name": "PECCF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "PEC Error flag clear\nWriting 1 to this bit clears the PECERR flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "TIMOUTCF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Timeout detection flag clear\nWriting 1 to this bit clears the TIMEOUT flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "ALERTCF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Alert flag clear\nWriting 1 to this bit clears the ALERT flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            }
        ]
    },
    "1073763360": {
        "name": "I2C_PECR",
        "address": 1073763360,
        "size": 32,
        "access": "",
        "desc": "I2C PEC register ",
        "fields": [
            {
                "name": "PEC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Packet error checking register\nThis field contains the internal PEC when PECEN=1.\nThe PEC is cleared by hardware when PE=0."
            }
        ]
    },
    "1073763364": {
        "name": "I2C_RXDR",
        "address": 1073763364,
        "size": 32,
        "access": "",
        "desc": "I2C receive data register ",
        "fields": [
            {
                "name": "RXDATA",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit receive data\nData byte received from the I2C bus"
            }
        ]
    },
    "1073763368": {
        "name": "I2C_TXDR",
        "address": 1073763368,
        "size": 32,
        "access": "",
        "desc": "I2C transmit data register ",
        "fields": [
            {
                "name": "TXDATA",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit transmit data\nData byte to be transmitted to the I2C bus\nNote: These bits can be written only when TXE=1."
            }
        ]
    },
    "1073765376": {
        "name": "I3C_CR",
        "address": 1073765376,
        "size": 32,
        "access": "",
        "desc": "I3C message control register ",
        "fields": [
            {
                "name": "DCNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "count of data to transfer during a read or write message, in bytes (whatever I3C is acting as controller/target)\nLinear encoding up to 64 Kbytes -1\n..."
            },
            {
                "name": "RNW",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "read / non-write message (when I3C is acting as controller)\nWhen I3C is acting as controller, this field is used if MTYPE[3:0]=0010 (private message) or MTYPE[3:0]=0011 (direct message) or MTYPE[3:0]=0100 (legacy I2C message), in order to emit the RnW bit on the I3C bus."
            },
            {
                "name": "ADD",
                "bitOffset": 17,
                "bitWidth": 7,
                "desc": "7-bit I3C dynamic / I2C static target address (when I3C is acting as controller)\nWhen I3C is acting as controller, this field is used if MTYPE[3:0]=0010 (private message) or MTYPE[3:0]=0011 (direct message) or MTYPE[3:0]=0100 (legacy I2C message)"
            },
            {
                "name": "MTYPE",
                "bitOffset": 27,
                "bitWidth": 4,
                "desc": "message type (whatever I3C is acting as controller/target)\nBits[26:0] are ignored.\nAfter M2 error detection on an I3C SDR message, this is needed for SCL 'stuck at' recovery.\nBits[26:0] are ignored.\nIf I3C_CFGR.EXITPTRN=1, an HDR exit pattern is emitted on the bus to generate an escalation fault.\nBits[23:17] (ADD[6:0]) is the emitted 7-bit dynamic address.\nBit[16] (RNW) is the emitted RnW bit.\nThe transferred private message is:\n{S / S+7'h7E+RnW=0+Sr / Sr+*} + 7-bit DynAddr + RnW + (8-bit Data + T)* + Sr/P.\nAfter a S (START), depending on I3C_CFGR.NOARBH, the arbitrable header (7'h7E+RnW=0) is inserted or not.\nSr+*: after a Sr (Repeated Start), the hardware automatically inserts (7'h7E+RnW=0) if needed, i.e. if it follows an I3C direct message without ending by a P (Stop).\nBits[23:17] (ADD[6:0]) is the emitted 7-bit dynamic address.\nBit[16] (RNW) is the emitted RnW bit.\nThe transferred direct message is:\nSr + 7-bit DynAddr + RnW + (8-bit Data + T)* + Sr/P\nBits[23:17] (ADD[6:0]) is the emitted 7-bit static address.\nBit[16] (RNW) is the emitted RnW bit.\nThe transferred legacy I2C message is:\n{S / S+ 7'h7E+RnW=0 + Sr / Sr+*} + 7-bit StaAddr + RnW + (8-bit Data + T)* + Sr/P.\nAfter a S (START), depending on I3C_CFGR.NOARBH, the arbitrable header (7'h7E+RnW=0) is inserted or not.\nSr+*: after a Sr (Repeated Start), the hardware automatically inserts (7'h7E+RnW=0) if needed, i.e. if it follows an I3C direct message without ending by a P (Stop).\n1xxx: reserved (when I3C is acting as I3C controller, used when target)\n0xxx: reserved\n{S +} 7'h02 addr + RnW=0\n{S +} 7-bit I3C_DEVR0.DA[6:0] + RnW=0\nafter a bus available condition (the target first emits a START request), or once the controller drives a START.\n{S +} 7-bit I3C_DEVR0.DA[6:0] + RnW=1 (+Ack/Nack from controller)\nWhen acknowledged from controller, the next (optional, depending on I3C_BCR.BCR2) transmitted IBI payload data is defined by I3C_CR.DCNT[15:0] and must be consistently programmed vs the maximum IBI payload data size which is defined by I3C_IBIDR.IBIP[2:0].\nOthers: reserved"
            },
            {
                "name": "MEND",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "message end type (when the I3C is acting as controller)"
            }
        ]
    },
    "1073765380": {
        "name": "I3C_CFGR",
        "address": 1073765380,
        "size": 32,
        "access": "",
        "desc": "I3C configuration register ",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I3C enable (whatever I3C is acting as controller/target)\n- Except registers, the peripheral is under reset (a.k.a. partial reset).\n- Before clearing EN, when I3C is acting as a controller, all the possible target requests must be disabled using DISEC CCC.\n- When I3C is acting as a target, software should not disable the I3C, unless a partial reset is needed.\nIn this state, some register fields can not be modified (like CRINIT, HKSDAEN for the I3C_CFGR)"
            },
            {
                "name": "CRINIT",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "initial controller/target role\nThis bit can be modified only when I3C_CFGR.EN = 0.\nOnce enabled by setting I3C_CFGR.EN = 1, I3C peripheral initially acts as an I3C target. I3C does not drive SCL line and does not enable SDA pull-up, until it eventually acquires the controller role.\nOnce enabled by setting I3C_CFGR.EN = 1, I3C peripheral initially acts as a controller. It has the I3C controller role, so drives SCL line and enables SDA pull-up, until it eventually offers the controller role to an I3C secondary controller."
            },
            {
                "name": "NOARBH",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "no arbitrable header after a START (when I3C is acting as a controller)\nThis bit can be modified only when there is no on-going frame.\n- The target address is emitted directly after a START in case of a legacy I2C message or an I3C SDR private read/write message.\n- This is a more performing option (when is useless the emission of the 0x7E arbitrable header), but this is to be used only when the controller is sure that the addressed target device can not emit concurrently an IBI or a controller-role request (to insure no misinterpretation and no potential conflict between the address emitted by the controller in open-drain mode and the same address a target device can emit after a START, for IBI or MR)."
            },
            {
                "name": "RSTPTRN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HDR reset pattern enable (when I3C is acting as a controller)\nThis bit can be modified only when there is no on-going frame."
            },
            {
                "name": "EXITPTRN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HDR Exit Pattern enable (when I3C is acting as a controller)\nThis bit can be modified only when there is no on-going frame.\nThis is used to send only the header to test ownership of the bus when there is a suspicion of problem after controller-role hand-off (new controller didn't assert its controller-role by accessing the previous one in less than Activity State time).\nThe HDR Exit Pattern is sent even if the message header {S/Sr + 0x7E addr + W } is ACKed."
            },
            {
                "name": "HKSDAEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "High-keeper enable on SDA line (when I3C is acting as a controller)\nThis bit can be modified only when I3C_CFGR.EN=0."
            },
            {
                "name": "HJACK",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Hot Join request acknowledge (when I3C is acting as a controller)\nAfter the NACK, the message continues as initially programmed (the hot-joining target is aware of the NACK and surely emits another hot-join request later on).\nAfter the ACK, the message continues as initially programmed. The software is aware by the HJ interrupt (flag I3C_EVR.HJF is set) and initiates the ENTDAA sequence later on, potentially preventing others Hot Join requests with a Disable target events command (DISEC, with DISHJ=1).\nIndependently of the HJACK configuration, further Hot Join request(s) are NACKed until the Hot Join flag, HJF, is cleared. However, a NACKed target can be assigned a dynamic address by the ENTDAA sequence initiated later on by the first HJ request, preventing this target to emit an HJ request again."
            },
            {
                "name": "RXDMAEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "RX-FIFO DMA request enable (whatever I3C is acting as controller/target)\n- Software reads and pops a data byte/word from RX-FIFO i.e. reads I3C_RDR or I3C_RDWR register.\n- A next data byte/word is to be read by the software either via polling on the flag I3C_EVR.RXFNEF=1 or via interrupt notification (enabled by I3C_IER.RXFNEIE=1).\n- DMA reads and pops data byte(s)/word(s) from RX-FIFO i.e. reads I3C_RDR or I3C_RDWR register.\n- A next data byte/word is automatically read by the programmed hardware (i.e. via the asserted RX-FIFO DMA request from the I3C and the programmed DMA channel)."
            },
            {
                "name": "RXFLUSH",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "RX-FIFO flush (whatever I3C is acting as controller/target)\nThis bit can only be written."
            },
            {
                "name": "RXTHRES",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "RX-FIFO threshold (whatever I3C is acting as controller/target)\nThis threshold defines, compared to the RX-FIFO level, when the I3C_EVR.RXFNEF flag is set (and consequently if RXDMAEN=1 when is asserted a DMA RX request).\nRXFNEF is set when 1 byte is to be read in RX-FIFO (i.e. in I3C_RDR).\nRXFNEF is set when 4 bytes are to be read in RX-FIFO (i.e. in I3C_RDWR)."
            },
            {
                "name": "TXDMAEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "TX-FIFO DMA request enable (whatever I3C is acting as controller/target)\n- Software writes and pushes a data byte/word into TX-FIFO i.e. writes I3C_TDR or I3C_TDWR register, to be transmitted over the I3C bus.\n- A next data byte/word is to be written by the software either via polling on the flag I3C_EVR.TXFNFF=1 or via interrupt notification (enabled by I3C_IER.TXFNFIE=1).\n- DMA writes and pushes data byte(s)/word(s) into TX-FIFO i.e. writes I3C_TDR or I3C_TDWR register.\n- A next data byte/word transfer is automatically pushed by the programmed hardware (i.e. via the asserted TX-FIFO DMA request from the I3C and the programmed DMA channel)."
            },
            {
                "name": "TXFLUSH",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "TX-FIFO flush (whatever I3C is acting as controller/target)\nThis bit can only be written.\nWhen the I3C is acting as target, this bit can be used to flush the TX-FIFO on a private read if the controller has early ended the read data (i.e. driven low the T bit) and there is/are remaining data in the TX-FIFO (i.e. I3C_SR.ABT=1 and I3C_SR.XDCNT[15:0]  I3C_TGTTDR.TGTTDCNT[15:0])."
            },
            {
                "name": "TXTHRES",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "TX-FIFO threshold (whatever I3C is acting as controller/target)\nThis threshold defines, compared to the TX-FIFO level, when the I3C_EVR.TXFNFF flag is set (and consequently if TXDMAEN=1 when is asserted a DMA TX request).\nTXFNFF is set when 1 byte is to be written in TX-FIFO (i.e. in I3C_TDR).\nTXFNFF is set when 4 bytes are to be written in TX-FIFO (i.e. in I3C_TDWR)."
            },
            {
                "name": "SDMAEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "S-FIFO DMA request enable (when I3C is acting as controller)\nCondition: When RMODE=1 (FIFO is enabled for the status):\n- Software reads and pops a status word from S-FIFO i.e. reads I3C_SR register after a completed frame (I3C_EVR.FCF=1) or an error (I3C_EVR.ERRF=1).\n- A status word can be read by the software either via polling on these register flags or via interrupt notification (enabled by I3C_IER.FCIE=1 and I3C_IER.ERRIE=1).\n- DMA reads and pops status word(s) from S-FIFO i.e. reads I3C_SR register.\n- Status word(s) are automatically read by the programmed hardware (i.e. via the asserted S-FIFO DMA request from the I3C and the programmed DMA channel)."
            },
            {
                "name": "SFLUSH",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "S-FIFO flush (when I3C is acting as controller)\nWhen I3C is acting as I3C controller, this bit can only be written (and is only used when I3C is acting as controller)."
            },
            {
                "name": "RMODE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "S-FIFO enable / status receive mode (when I3C is acting as controller)\nWhen I3C is acting as I3C controller, this bit is used for the enabling the FIFO for the status (S-FIFO) vs the received status from the target on the I3C bus.\nWhen I3C is acting as target, this bit must be cleared.\n- Status register (i.e. I3C_SR) is used without FIFO mechanism.\n- There is no SCL stretch if a new status register content is not read.\n- Status register must be read before being lost/overwritten.\nAll message status must be read.\nThere is SCL stretch when there is no more space in the S-FIFO."
            },
            {
                "name": "TMODE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "transmit mode (when I3C is acting as controller)\nWhen I3C is acting as I3C controller, this bit is used for the C-FIFO and TX-FIFO management vs the emitted frame on the I3C bus.\nA frame transfer starts as soon as first control word is present in C-FIFO."
            },
            {
                "name": "CDMAEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "C-FIFO DMA request enable (when I3C is acting as controller)\nWhen I3C is acting as controller:\n- Software writes and pushes control word(s) into C-FIFO i.e. writes I3C_CR register, as needed for a given frame.\n- A next control word transfer can be written by software either via polling on the flag I3C_EVR.CFNFF=1 or via interrupt notification (enabled by I3C_IER.CFNFIE=1).\n- DMA writes and pushes control word(s) into C-FIFO i.e. writes I3C_CR register, as needed for a given frame.\n- A next control word transfer is automatically written by the programmed hardware (i.e. via the asserted C-FIFO DMA request from the I3C and the programmed DMA channel)."
            },
            {
                "name": "CFLUSH",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "C-FIFO flush (when I3C is acting as controller)\nThis bit can only be written."
            },
            {
                "name": "TSFSET",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "frame transfer set (a.k.a. software trigger) (when I3C is acting as controller)\nThis bit can only be written.\nWhen I3C is acting as I3C controller:\nNote: If this bit is not set, the other alternative for the software to initiate a frame transfer is to directly write the first control word register (i.e. I3C_CR) while C-FIFO is empty (i.e. I3C_EVR.CFEF=1). Then, if the first written control word is not tagged as a message end (i.e I3C_CR.MEND=0), it causes the hardware to assert the flag I3C_EVR.CFNFF (C-FIFO not full and a next control word is needed)."
            }
        ]
    },
    "1073765392": {
        "name": "I3C_RDR",
        "address": 1073765392,
        "size": 32,
        "access": "",
        "desc": "I3C receive data byte register ",
        "fields": [
            {
                "name": "RDB0",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit received data on I3C bus."
            }
        ]
    },
    "1073765396": {
        "name": "I3C_RDWR",
        "address": 1073765396,
        "size": 32,
        "access": "",
        "desc": "I3C receive data word register ",
        "fields": [
            {
                "name": "RDB0",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit received data (earliest byte on I3C bus)."
            },
            {
                "name": "RDB1",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "8-bit received data (next byte after RDB0 on I3C bus)."
            },
            {
                "name": "RDB2",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "8-bit received data (next byte after RDB1 on I3C bus)."
            },
            {
                "name": "RDB3",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "8-bit received data (latest byte on I3C bus)."
            }
        ]
    },
    "1073765400": {
        "name": "I3C_TDR",
        "address": 1073765400,
        "size": 32,
        "access": "",
        "desc": "I3C transmit data byte register ",
        "fields": [
            {
                "name": "TDB0",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit data to transmit on I3C bus."
            }
        ]
    },
    "1073765404": {
        "name": "I3C_TDWR",
        "address": 1073765404,
        "size": 32,
        "access": "",
        "desc": "I3C transmit data word register ",
        "fields": [
            {
                "name": "TDB0",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit transmit data (earliest byte on I3C bus)"
            },
            {
                "name": "TDB1",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "8-bit transmit data (next byte after TDB0[7:0] on I3C bus)."
            },
            {
                "name": "TDB2",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "8-bit transmit data (next byte after TDB1[7:0] on I3C bus)."
            },
            {
                "name": "TDB3",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "8-bit transmit data (latest byte on I3C bus)."
            }
        ]
    },
    "1073765408": {
        "name": "I3C_IBIDR",
        "address": 1073765408,
        "size": 32,
        "access": "",
        "desc": "I3C IBI payload data register ",
        "fields": [
            {
                "name": "IBIDB0",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit IBI payload data (earliest byte on I3C bus, i.e. MDB[7:0] mandatory data byte)."
            },
            {
                "name": "IBIDB1",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "8-bit IBI payload data (next byte on I3C bus after IBIDB0[7:0])."
            },
            {
                "name": "IBIDB2",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "8-bit IBI payload data (next byte on I3C bus after IBIDB1[7:0])."
            },
            {
                "name": "IBIDB3",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "8-bit IBI payload data (latest byte on I3C bus)."
            }
        ]
    },
    "1073765412": {
        "name": "I3C_TGTTDR",
        "address": 1073765412,
        "size": 32,
        "access": "",
        "desc": "I3C target transmit configuration register ",
        "fields": [
            {
                "name": "TGTTDCNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "transmit data counter, in bytes (when I3C is configured as target)\nThis field must be written by software in the same access when is asserted PRELOAD, in order to define the number of bytes to preload and to transmit.\nThis field is updated by hardware and reports, when read, the remaining number of bytes to be loaded into the TX-FIFO."
            },
            {
                "name": "PRELOAD",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "preload of the TX-FIFO (when I3C is configured as target)\nThis bit must be written and asserted by software in the same access when is written and defined the number of bytes to preload into the TX-FIFO and to transmit.\nThis bit is cleared by hardware when all the data bytes to transmit are loaded into the TX-FIFO."
            }
        ]
    },
    "1073765424": {
        "name": "I3C_SR",
        "address": 1073765424,
        "size": 32,
        "access": "",
        "desc": "I3C status register ",
        "fields": [
            {
                "name": "XDCNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "data counter\n- When the I3C is acting as controller: number of targets detected on the bus\n- When the I3C is acting as target: number of transmitted bytes\n- Whatever the I3C is acting as controller or target: number of data bytes read from or transmitted on the I3C bus during the MID[7:0] message"
            },
            {
                "name": "ABT",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "a private read message is completed/aborted prematurely by the target (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit indicates if the private read data which is transmitted by the target early terminates (i.e. the target drives T bit low earlier vs what does expect the controller in terms of programmed number of read data bytes i.e. I3C_CR.DCNT[15:0])."
            },
            {
                "name": "DIR",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "message direction\nWhatever the I3C is acting as controller or target, this bit indicates the direction of the related message on the I3C bus\nNote: ENTDAA CCC is considered as a write command."
            },
            {
                "name": "MID",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "message identifier/counter of a given frame (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this field identifies the control word message (i.e. I3C_CR) to which the I3C_SR status register refers.\nFirst message of a frame is identified with MID[7:0]=0.\nThis field is incremented (by hardware) on the completion of a new message control word (i.e. I3C_CR) over I3C bus. This field is reset for every new frame start."
            }
        ]
    },
    "1073765428": {
        "name": "I3C_SER",
        "address": 1073765428,
        "size": 32,
        "access": "",
        "desc": "I3C status error register ",
        "fields": [
            {
                "name": "CODERR",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "protocol error code/type\ncontroller detected an illegally formatted CCC\ncontroller detected that transmitted data on the bus is different from expected\ncontroller detected a not acknowledged broadcast address (7'hE)\ncontroller detected the new controller did not drive bus after controller-role hand-off\ntarget detected an invalid broadcast address 7'hE+W\ntarget detected a parity error on a CCC code via a parity check (vs T bit)\ntarget detected a parity error on a write data via a parity check (vs T bit)\ntarget detected a parity error on the assigned address during dynamic address arbitration via a parity check (vs PAR bit)\ntarget detected a 7'hE+R missing after Sr during dynamic address arbitration\ntarget detected an illegally formatted CCC\ntarget detected that transmitted data on the bus is different from expected\nothers: reserved"
            },
            {
                "name": "PERR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "protocol error"
            },
            {
                "name": "STALL",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "SCL stall error (when the I3C is acting as target)"
            },
            {
                "name": "DOVR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "RX-FIFO overrun or TX-FIFO underrun\ni) a TX-FIFO underrun: TX-FIFO is empty and a write data byte has to be transmitted\nii) a RX-FIFO overrun: RX-FIFO is full and a new data byte is received"
            },
            {
                "name": "COVR",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "C-FIFO underrun or S-FIFO overrun (when the I3C is acting as controller)\ni) a C-FIFO underrun: control FIFO is empty and a restart has to be emitted\nii) a S-FIFO overrun: S-FIFO is full and a new message ends"
            },
            {
                "name": "ANACK",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "address not acknowledged (when the I3C is configured as controller)\ni) a legacy I2C read/write transfer\nii) a direct CCC write transfer\niii) the second trial of a direct CCC read transfer\niv) a private read/write transfer"
            },
            {
                "name": "DNACK",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "data not acknowledged (when the I3C is acting as controller)\ni) a legacy I2C write transfer\nii) the second trial when sending dynamic address during ENTDAA procedure"
            },
            {
                "name": "DERR",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data error (when the I3C is acting as controller)"
            }
        ]
    },
    "1073765440": {
        "name": "I3C_RMR",
        "address": 1073765440,
        "size": 32,
        "access": "",
        "desc": "I3C received message register ",
        "fields": [
            {
                "name": "IBIRDCNT",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "IBI received payload data count (when the I3C is configured as controller)\nWhen the I3C is configured as controller, this field logs the number of data bytes effectively received in the I3C_IBIDR register."
            },
            {
                "name": "RCODE",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "received CCC code (when the I3C is configured as target)\nWhen the I3C is configured as target, this field logs the received CCC code."
            },
            {
                "name": "RADD",
                "bitOffset": 17,
                "bitWidth": 7,
                "desc": "received target address (when the I3C is configured as controller)\nWhen the I3C is configured as controller, this field logs the received dynamic address from the target during acknowledged IBI or controller-role request."
            }
        ]
    },
    "1073765456": {
        "name": "I3C_EVR",
        "address": 1073765456,
        "size": 32,
        "access": "",
        "desc": "I3C event register ",
        "fields": [
            {
                "name": "CFEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "C-FIFO empty flag (whatever the I3C is acting as controller/target)\nThis flag is asserted by hardware to indicate that the C-FIFO is empty when controller, and that the I3C_CR register contains no control word (i.e. none IBI/CR/HJ request) when target.\nThis flag is de-asserted by hardware to indicate that the C-FIFO is not empty when controller, and that the I3C_CR register contains one control word (i.e. a pending IBI/CR/HJ request) when target.\nNote: When the I3C is acting as controller, if the C-FIFO and TX-FIFO preload is configured (i.e. I3C_CFGR.TMODE=1), the software must wait for TXFEF=1 and CFEF=1 before starting a new frame transfer."
            },
            {
                "name": "TXFEF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TX-FIFO empty flag (whatever the I3C is acting as controller/target)\nThis flag is asserted by hardware to indicate that the TX-FIFO is empty.\nThis flag is de-asserted by hardware to indicate that the TX-FIFO is not empty.\nNote: When the I3C is acting as controller, if the C-FIFO and TX-FIFO preload is configured (i.e. I3C_CFGR.TMODE=1), the software must wait for TXFEF=1 and CFEF=1 before starting a new frame transfer."
            },
            {
                "name": "CFNFF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "C-FIFO not full flag (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this flag is asserted by hardware to indicate that a control word is to be written to the C-FIFO.\nThis flag is de-asserted by hardware to indicate that a control word is not to be written to the C-FIFO.\nNote: The software must wait for CFNFF=1 (by polling or via the enabled interrupt) before writing to C-FIFO (i.e. writing to I3C_CR)."
            },
            {
                "name": "SFNEF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "S-FIFO not empty flag (when the I3C is acting as controller)\nWhen the I3C is acting as controller, if the S-FIFO is enabled (i.e. I3C_CFGR.RMODE=1), this flag is asserted by hardware to indicate that a status word is to be read from the S-FIFO.\nThis flag is de-asserted by hardware to indicate that a status word is not to be read from the S-FIFO."
            },
            {
                "name": "TXFNFF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TX-FIFO not full flag (whatever the I3C is acting as controller/target)\nThis flag is asserted by hardware to indicate that a data byte/word is to be written to the TX-FIFO.\nThis flag is de-asserted by hardware to indicate that a data byte/word is not to be written to the TX-FIFO.\nNote: The software must wait for TXFNFF=1 (by polling or via the enabled interrupt) before writing to TX-FIFO (i.e. writing to I3C_TDR or I3C_TDWR depending on I3C_CFGR.TXTHRES).\nNote: When the I3C is acting as target, if the software intends to use the TXFNFF flag for writing into I3C_TDR/I3C_TDWR, it must have configured and set the TX-FIFO preload (i.e. write I3C_TGTTDR.PRELOAD)."
            },
            {
                "name": "RXFNEF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RX-FIFO not empty flag (whatever the I3C is acting as controller/target)\nThis flag is asserted by hardware to indicate that a data byte is to be read from the RX-FIFO.\nThis flag is de-asserted by hardware to indicate that a data byte is not to be read from the RX-FIFO.\nNote: The software must wait for RXFNEF=1 (by polling or via the enabled interrupt) before reading from RX-FIFO (i.e. writing to I3C_RDR or I3C_RDWR depending on I3C_CFGR.RXTHRES)."
            },
            {
                "name": "TXLASTF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "last written data byte/word flag (whatever the I3C is acting as controller/target)\nThis flag is asserted by hardware to indicate that the last data byte/word (depending on I3C_CFGR.TXTHRES) of a message is to be written to the TX-FIFO.\nThis flag is de-asserted by hardware when the last data byte/word of a message is written."
            },
            {
                "name": "RXLASTF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "last read data byte/word flag (whatever the I3C is acting as controller/target)\nThis flag is asserted by hardware to indicate that the last data byte/word (depending on I3C_CFGR.RXTHRES) of a message is to be read from the RX-FIFO.\nThis flag is de-asserted by hardware when the last data byte/word of a message is read."
            },
            {
                "name": "FCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "frame complete flag (whatever the I3C is acting as controller/target)\nWhen the I3C is acting as controller, this flag is asserted by hardware to indicate that a frame has been (normally) completed on the I3C bus, i.e when a stop is issued.\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that a message addressed to/by this target has been (normally) completed on the I3C bus, i.e when a next stop or repeated start is then issued by the controller.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CFCF bit."
            },
            {
                "name": "RXTGTENDF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "target-initiated read end flag (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this flag is asserted by hardware to indicate that the target has prematurely ended a read transfer.\nThen, software should read I3C_SR to get more information on the prematurely read transfer.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CRXTGTENDF bit."
            },
            {
                "name": "ERRF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "flag (whatever the I3C is acting as controller/target)\nThis flag is asserted by hardware to indicate that an error occurred.Then, software should read I3C_SER to get the error type.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CERRF bit."
            },
            {
                "name": "IBIF",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "IBI flag (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this flag is asserted by hardware to indicate that an IBI request has been received.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CIBIF bit."
            },
            {
                "name": "IBIENDF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "IBI end flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that a IBI transfer has been received and completed (IBI acknowledged and IBI data bytes read by controller if any).\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CIBIENDF bit."
            },
            {
                "name": "CRF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "controller-role request flag (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this flag is asserted by hardware to indicate that a controller-role request has been acknowledged and completed (by hardware). The software should then issue a GETACCCR CCC (get accept controller role) for the controller-role hand-off procedure.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CCRF bit."
            },
            {
                "name": "CRUPDF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "controller-role update flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that it has now gained the controller role after the completed controller-role hand-off procedure.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CCRUPDF bit."
            },
            {
                "name": "HJF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "hot-join flag (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this flag is asserted by hardware to indicate that an hot join request has been received.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CHJF bit."
            },
            {
                "name": "WKPF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "wakeup/missed start flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that a start has been detected (i.e. a SDA falling edge followed by a SCL falling edge) but on the next SCL falling edge, the I3C kernel clock is (still) gated. Thus an I3C bus transaction may have been lost by the target.\nThe corresponding interrupt may be used to wakeup the device from a low power mode (Sleep or Stop mode).\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CWKPF bit."
            },
            {
                "name": "GETF",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "get flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that any direct CCC of get type (GET*** CCC) has been received.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CGETF bit."
            },
            {
                "name": "STAF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "get status flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that a direct GETSTATUS CCC (get status) has been received.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CSTAF bit."
            },
            {
                "name": "DAUPDF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "dynamic address update flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that a dynamic address update has been received via any of the broadcast ENTDAA, RSTDAA and direct SETNEWDA CCC.\nThen, software should read I3C_DEVR0.DA[6:0] to get the maximum write length value.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CDAUPDF bit."
            },
            {
                "name": "MWLUPDF",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "maximum write length update flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that a direct SETMWL CCC (set max write length) has been received.\nThen, software should read I3C_MAXWLR.MWL[15:0] to get the maximum write length value.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CMWLUPDF bit."
            },
            {
                "name": "MRLUPDF",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "maximum read length update flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that a direct SETMRL CCC (set max read length) has been received.\nThen, software should read I3C_MAXRLR.MRL[15:0] to get the maximum read length value.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CMRLUPDF bit."
            },
            {
                "name": "RSTF",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "reset pattern flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that a reset pattern has been detected (i.e. 14 SDA transitions while SCL is low, followed by repeated start, then stop).\nThen, software should read I3C_DEVR0.RSTACT[1:0] and I3C_DEVR0.RSTVAL, to know what reset level is required.\nIf RSTVAL=1: when the RSTF is asserted (and/or the corresponding interrupt if enabled), I3C_DEVR0.RSTACT[1:0] dictates the reset action to be performed by the software if any.\nIf RSTVAL=0: when the RSTF is asserted (and/or the corresponding interrupt if enabled), the software should issue an I3C reset after a first detected reset pattern, and a system reset on the second one.\nThe corresponding interrupt may be used to wakeup the device from a low power mode (Sleep or Stop mode).\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CRSTF bit."
            },
            {
                "name": "ASUPDF",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "activity state update flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that the direct or broadcast ENTASx CCC (with x=0...3) has been received.\nThen, software should read I3C_DEVR0.AS[1:0].\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CASUPDF bit."
            },
            {
                "name": "INTUPDF",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "interrupt/controller-role/hot-join update flag (when the I3C is acting as target)\nWhen the I3C is acting as target, this flag is asserted by hardware to indicate that the direct or broadcast ENEC/DISEC CCC (enable/disable target events) has been received, where a target event is either an interrupt/IBI request, a controller-role request, or an hot-join request.\nThen, software should read respectively I3C_DEVR0.IBIEN, I3C_DEVR0.CREN or I3C_DEVR0.HJEN.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CINTUPDF bit."
            },
            {
                "name": "DEFF",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "DEFTGTS flag (when the I3C is acting as target)\nWhen the I3C is acting as target (and is typically controller capable), this flag is asserted by hardware to indicate that the broadcast DEFTGTS CCC (define list of targets) has been received.\nThen, software may store the received data for when getting the controller role.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CDEFF bit."
            },
            {
                "name": "GRPF",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "group addressing flag (when the I3C is acting as target)\nWhen the I3C is acting as target (and is typically controller capable), this flag is asserted by hardware to indicate that the broadcast DEFGRPA CCC (define list of group addresses) has been received.\nThen, software may store the received data for when getting the controller role.\nThis flag is cleared when software writes 1 into corresponding I3C_CEVR.CGRPF bit."
            }
        ]
    },
    "1073765460": {
        "name": "I3C_IER",
        "address": 1073765460,
        "size": 32,
        "access": "",
        "desc": "I3C interrupt enable register ",
        "fields": [
            {
                "name": "CFNFIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "C-FIFO not full interrupt enable (whatever the I3C is acting as controller/target)"
            },
            {
                "name": "SFNEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "S-FIFO not empty interrupt enable (whatever the I3C is acting as controller/target)"
            },
            {
                "name": "TXFNFIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TX-FIFO not full interrupt enable (whatever the I3C is acting as controller/target)"
            },
            {
                "name": "RXFNEIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RX-FIFO not empty interrupt enable (whatever the I3C is acting as controller/target)"
            },
            {
                "name": "FCIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "frame complete interrupt enable (whatever the I3C is acting as controller/target)"
            },
            {
                "name": "RXTGTENDIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "target-initiated read end interrupt enable (when the I3C is acting as controller)"
            },
            {
                "name": "ERRIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "error interrupt enable (whatever the I3C is acting as controller/target)"
            },
            {
                "name": "IBIIE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "IBI request interrupt enable (when the I3C is acting as controller)"
            },
            {
                "name": "IBIENDIE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "IBI end interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "CRIE",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "controller-role request interrupt enable (when the I3C is acting as controller)"
            },
            {
                "name": "CRUPDIE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "controller-role update interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "HJIE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "hot-join interrupt enable (when the I3C is acting as controller)"
            },
            {
                "name": "WKPIE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "wakeup interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "GETIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "GETxxx CCC interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "STAIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "GETSTATUS CCC interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "DAUPDIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "ENTDAA/RSTDAA/SETNEWDA CCC interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "MWLUPDIE",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "SETMWL CCC interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "MRLUPDIE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "SETMRL CCC interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "RSTIE",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "reset pattern interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "ASUPDIE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "ENTASx CCC interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "INTUPDIE",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "ENEC/DISEC CCC interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "DEFIE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "DEFTGTS CCC interrupt enable (when the I3C is acting as target)"
            },
            {
                "name": "GRPIE",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "DEFGRPA CCC interrupt enable (when the I3C is acting as target)"
            }
        ]
    },
    "1073765464": {
        "name": "I3C_CEVR",
        "address": 1073765464,
        "size": 32,
        "access": "",
        "desc": "I3C clear event register ",
        "fields": [
            {
                "name": "CFCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "clear frame complete flag (whatever the I3C is acting as controller/target)"
            },
            {
                "name": "CRXTGTENDF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "clear target-initiated read end flag (when the I3C is acting as controller)"
            },
            {
                "name": "CERRF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "clear error flag (whatever the I3C is acting as controller/target)"
            },
            {
                "name": "CIBIF",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "clear IBI request flag (when the I3C is acting as controller)"
            },
            {
                "name": "CIBIENDF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "clear IBI end flag (when the I3C is acting as target)"
            },
            {
                "name": "CCRF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "clear controller-role request flag (when the I3C is acting as controller)"
            },
            {
                "name": "CCRUPDF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "clear controller-role update flag (when the I3C is acting as target)"
            },
            {
                "name": "CHJF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "clear hot-join flag (when the I3C is acting as controller)"
            },
            {
                "name": "CWKPF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "clear wakeup flag (when the I3C is acting as target)"
            },
            {
                "name": "CGETF",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "clear GETxxx CCC flag (when the I3C is acting as target)"
            },
            {
                "name": "CSTAF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "clear GETSTATUS CCC flag (when the I3C is acting as target)"
            },
            {
                "name": "CDAUPDF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "clear ENTDAA/RSTDAA/SETNEWDA CCC flag (when the I3C is acting as target)"
            },
            {
                "name": "CMWLUPDF",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "clear SETMWL CCC flag (when the I3C is acting as target)"
            },
            {
                "name": "CMRLUPDF",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "clear SETMRL CCC flag (when the I3C is acting as target)"
            },
            {
                "name": "CRSTF",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "clear reset pattern flag (when the I3C is acting as target)"
            },
            {
                "name": "CASUPDF",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "clear ENTASx CCC flag (when the I3C is acting as target)"
            },
            {
                "name": "CINTUPDF",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "clear ENEC/DISEC CCC flag (when the I3C is acting as target)"
            },
            {
                "name": "CDEFF",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "clear DEFTGTS CCC flag (when the I3C is acting as target)"
            },
            {
                "name": "CGRPF",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "clear DEFGRPA CCC flag (when the I3C is acting as target)"
            }
        ]
    },
    "1073765472": {
        "name": "I3C_DEVR0",
        "address": 1073765472,
        "size": 32,
        "access": "",
        "desc": "I3C own device characteristics register ",
        "fields": [
            {
                "name": "DAVAL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "dynamic address is valid (when the I3C is acting as target)\nWhen the I3C is acting as controller, this field can be written by software, for validating its own dynamic address, for example before a controller-role hand-off.\nWhen the I3C is acting as target, this field is asserted by hardware on the acknowledge of the broadcast ENTDAA CCC or the direct SETNEWDA CCC, and this field is cleared by hardware on the acknowledge of the broadcast RSTDAA CCC."
            },
            {
                "name": "DA",
                "bitOffset": 1,
                "bitWidth": 7,
                "desc": "7-bit dynamic address\nWhen the I3C is acting as controller, this field can be written by software, for defining its own dynamic address.\nWhen the I3C is acting as target, this field is updated by hardware on the reception of either the broadcast ENTDAA CCC or the direct SETNEWDA CCC."
            },
            {
                "name": "IBIEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "IBI request enable (when the I3C is acting as target)\nThis field is initially written by software when I3C_CFGR.EN=0, and is updated by hardware on the reception of DISEC CCC with DISINT=1 (i.e. cleared) and the reception of ENEC CCC with ENINT=1 (i.e. set)."
            },
            {
                "name": "CREN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "controller-role request enable (when the I3C is acting as target)\nThis field is initially written by software when I3C_CFGR.EN=0, and is updated by hardware on the reception of DISEC CCC with DISCR=1 (i.e. cleared) and the reception of ENEC CCC with ENCR=1 (i.e. set)."
            },
            {
                "name": "HJEN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "hot-join request enable (when the I3C is acting as target)\nThis field is initially written by software when I3C_CFGR.EN=0, and is updated by hardware on the reception of DISEC CCC with DISHJ=1 (i.e. cleared) and the reception of ENEC CCC with ENHJ=1 (i.e. set)."
            },
            {
                "name": "AS",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "activity state (when the I3C is acting as target)\nThis read field is updated by hardware on the reception of a ENTASx CCC (enter activity state, with x=0-3):"
            },
            {
                "name": "RSTACT",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "reset action/level on received reset pattern (when the I3C is acting as target)\nThis read field is used by hardware on the reception of a direct read RSTACT CCC in order to return the corresponding data byte on the I3C bus.\nThis read field is updated by hardware on the reception of a broadcast or direct write RSTACT CCC (target reset action)."
            },
            {
                "name": "RSTVAL",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "reset action is valid (when the I3C is acting as target)\nThis read bit is asserted by hardware to indicate that the RTSACT[1:0] field has been updated on the reception of a broadcast or direct write RSTACT CCC (target reset action) and is valid.\nThis field is cleared by hardware when the target receives a frame start.\nIf RSTVAL=1: when the RSTF is asserted (and/or the corresponding interrupt if enabled), I3C_DEVR0.RSTACT[1:0] dictates the reset action to be performed by the software if any.\nIf RSTVAL=0: when the RSTF is asserted (and/or the corresponding interrupt if enabled), the software should issue an I3C reset after a first detected reset pattern, and a system reset on the second one."
            }
        ]
    },
    "1073765476": {
        "name": "I3C_DEVR1",
        "address": 1073765476,
        "size": 32,
        "access": "",
        "desc": "I3C device 1 characteristics register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 1,
                "bitWidth": 7,
                "desc": "assigned I3C dynamic address to target x (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this field should be written by software to store the 7-bit dynamic address that the controller sends via a broadcast ENTDAA or a direct SETNEWDA CCC which has been acknowledged by the target x.\nWriting to this field has no impact when the read field I3C_DEVRx.DIS=1."
            },
            {
                "name": "IBIACK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "IBI request acknowledge (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a IBI request from target x:\n- After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another IBI request later on)\n- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.\n- After the ACK, the controller logs the IBI payload data, if any, depending on I3C_DEVRx.IBIDEN.\n- The software is notified by the IBI flag (i.e. I3C_EVR.IBIF=1) and/or the corresponding interrupt if enabled;\n- Independently from IBIACK configuration for this or other devices, further IBI request(s) are NACKed until IBI request flag (i.e. I3C_EVR.IBIF) and controller-role request flag (i.e. I3C_EVR.CRF) are both cleared."
            },
            {
                "name": "CRACK",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "controller-role request acknowledge (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a controller-role request from target x:\nAfter the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another controller-role request later on)\n- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.\n- After the ACK, the message continues as initially programmed. The software is notified by the controller-role request flag (i.e. I3C_EVR.CRF=1) and/or the corresponding interrupt if enabled; For effectively granting the controller-role to the requesting secondary controller, software should issue a GETACCCR (formerly known as GETACCMST), followed by a STOP.\n- Independently of CRACK configuration for this or other devices, further controller-role request(s) are NACKed until controller-role request flag (i.e. I3C_EVR.CRF) and IBI flag (i.e. I3C_EVR.IBIF) are both cleared."
            },
            {
                "name": "IBIDEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "IBI data enable (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit should be written by software to store the BCR[2] bit as received from the target x during broadcast ENTDAA or direct GETBCR CCC via the received I3C_RDR.\nWriting to this field has no impact when the read field I3C_DEVRx.DIS=1."
            },
            {
                "name": "SUSP",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "suspend/stop I3C transfer on received IBI (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is used to receive an IBI from target x with pending read notification feature (i.e. with received MDB[7:5]=3'b101).\nIf this bit is set, when an IBI is received (i.e. I3C_EVR.IBIF=1), a Stop is emitted on the I3C bus and the C-FIFO is automatically flushed by hardware; to avoid a next private read communication issue if a previous private read message to the target x was stored in the C-FIFO."
            },
            {
                "name": "DIS",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "DA[6:0] write disabled (when the I3C is acting as controller)\nWhen the I3C is acting as controller, once that software set IBIACK=1 or CRACK=1, this read bit is set by hardware (i.e. DIS=1) to lock the configured DA[6:0] and IBIDEN values.\nThen, to be able to next modify DA[6:0] or IBIDEN, the software must wait for this field DIS to be de-asserted by hardware (i.e. polling on DIS=0) before modifying these two assigned values to the target x. Indeed, the target may be requesting an IBI or a controller-role meanwhile the controller intends to modify DA[6:0] or IBIDEN."
            }
        ]
    },
    "1073765480": {
        "name": "I3C_DEVR2",
        "address": 1073765480,
        "size": 32,
        "access": "",
        "desc": "I3C device 2 characteristics register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 1,
                "bitWidth": 7,
                "desc": "assigned I3C dynamic address to target x (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this field should be written by software to store the 7-bit dynamic address that the controller sends via a broadcast ENTDAA or a direct SETNEWDA CCC which has been acknowledged by the target x.\nWriting to this field has no impact when the read field I3C_DEVRx.DIS=1."
            },
            {
                "name": "IBIACK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "IBI request acknowledge (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a IBI request from target x:\n- After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another IBI request later on)\n- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.\n- After the ACK, the controller logs the IBI payload data, if any, depending on I3C_DEVRx.IBIDEN.\n- The software is notified by the IBI flag (i.e. I3C_EVR.IBIF=1) and/or the corresponding interrupt if enabled;\n- Independently from IBIACK configuration for this or other devices, further IBI request(s) are NACKed until IBI request flag (i.e. I3C_EVR.IBIF) and controller-role request flag (i.e. I3C_EVR.CRF) are both cleared."
            },
            {
                "name": "CRACK",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "controller-role request acknowledge (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a controller-role request from target x:\nAfter the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another controller-role request later on)\n- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.\n- After the ACK, the message continues as initially programmed. The software is notified by the controller-role request flag (i.e. I3C_EVR.CRF=1) and/or the corresponding interrupt if enabled; For effectively granting the controller-role to the requesting secondary controller, software should issue a GETACCCR (formerly known as GETACCMST), followed by a STOP.\n- Independently of CRACK configuration for this or other devices, further controller-role request(s) are NACKed until controller-role request flag (i.e. I3C_EVR.CRF) and IBI flag (i.e. I3C_EVR.IBIF) are both cleared."
            },
            {
                "name": "IBIDEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "IBI data enable (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit should be written by software to store the BCR[2] bit as received from the target x during broadcast ENTDAA or direct GETBCR CCC via the received I3C_RDR.\nWriting to this field has no impact when the read field I3C_DEVRx.DIS=1."
            },
            {
                "name": "SUSP",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "suspend/stop I3C transfer on received IBI (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is used to receive an IBI from target x with pending read notification feature (i.e. with received MDB[7:5]=3'b101).\nIf this bit is set, when an IBI is received (i.e. I3C_EVR.IBIF=1), a Stop is emitted on the I3C bus and the C-FIFO is automatically flushed by hardware; to avoid a next private read communication issue if a previous private read message to the target x was stored in the C-FIFO."
            },
            {
                "name": "DIS",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "DA[6:0] write disabled (when the I3C is acting as controller)\nWhen the I3C is acting as controller, once that software set IBIACK=1 or CRACK=1, this read bit is set by hardware (i.e. DIS=1) to lock the configured DA[6:0] and IBIDEN values.\nThen, to be able to next modify DA[6:0] or IBIDEN, the software must wait for this field DIS to be de-asserted by hardware (i.e. polling on DIS=0) before modifying these two assigned values to the target x. Indeed, the target may be requesting an IBI or a controller-role meanwhile the controller intends to modify DA[6:0] or IBIDEN."
            }
        ]
    },
    "1073765484": {
        "name": "I3C_DEVR3",
        "address": 1073765484,
        "size": 32,
        "access": "",
        "desc": "I3C device 3 characteristics register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 1,
                "bitWidth": 7,
                "desc": "assigned I3C dynamic address to target x (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this field should be written by software to store the 7-bit dynamic address that the controller sends via a broadcast ENTDAA or a direct SETNEWDA CCC which has been acknowledged by the target x.\nWriting to this field has no impact when the read field I3C_DEVRx.DIS=1."
            },
            {
                "name": "IBIACK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "IBI request acknowledge (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a IBI request from target x:\n- After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another IBI request later on)\n- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.\n- After the ACK, the controller logs the IBI payload data, if any, depending on I3C_DEVRx.IBIDEN.\n- The software is notified by the IBI flag (i.e. I3C_EVR.IBIF=1) and/or the corresponding interrupt if enabled;\n- Independently from IBIACK configuration for this or other devices, further IBI request(s) are NACKed until IBI request flag (i.e. I3C_EVR.IBIF) and controller-role request flag (i.e. I3C_EVR.CRF) are both cleared."
            },
            {
                "name": "CRACK",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "controller-role request acknowledge (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a controller-role request from target x:\nAfter the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another controller-role request later on)\n- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.\n- After the ACK, the message continues as initially programmed. The software is notified by the controller-role request flag (i.e. I3C_EVR.CRF=1) and/or the corresponding interrupt if enabled; For effectively granting the controller-role to the requesting secondary controller, software should issue a GETACCCR (formerly known as GETACCMST), followed by a STOP.\n- Independently of CRACK configuration for this or other devices, further controller-role request(s) are NACKed until controller-role request flag (i.e. I3C_EVR.CRF) and IBI flag (i.e. I3C_EVR.IBIF) are both cleared."
            },
            {
                "name": "IBIDEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "IBI data enable (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit should be written by software to store the BCR[2] bit as received from the target x during broadcast ENTDAA or direct GETBCR CCC via the received I3C_RDR.\nWriting to this field has no impact when the read field I3C_DEVRx.DIS=1."
            },
            {
                "name": "SUSP",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "suspend/stop I3C transfer on received IBI (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is used to receive an IBI from target x with pending read notification feature (i.e. with received MDB[7:5]=3'b101).\nIf this bit is set, when an IBI is received (i.e. I3C_EVR.IBIF=1), a Stop is emitted on the I3C bus and the C-FIFO is automatically flushed by hardware; to avoid a next private read communication issue if a previous private read message to the target x was stored in the C-FIFO."
            },
            {
                "name": "DIS",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "DA[6:0] write disabled (when the I3C is acting as controller)\nWhen the I3C is acting as controller, once that software set IBIACK=1 or CRACK=1, this read bit is set by hardware (i.e. DIS=1) to lock the configured DA[6:0] and IBIDEN values.\nThen, to be able to next modify DA[6:0] or IBIDEN, the software must wait for this field DIS to be de-asserted by hardware (i.e. polling on DIS=0) before modifying these two assigned values to the target x. Indeed, the target may be requesting an IBI or a controller-role meanwhile the controller intends to modify DA[6:0] or IBIDEN."
            }
        ]
    },
    "1073765488": {
        "name": "I3C_DEVR4",
        "address": 1073765488,
        "size": 32,
        "access": "",
        "desc": "I3C device 4 characteristics register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 1,
                "bitWidth": 7,
                "desc": "assigned I3C dynamic address to target x (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this field should be written by software to store the 7-bit dynamic address that the controller sends via a broadcast ENTDAA or a direct SETNEWDA CCC which has been acknowledged by the target x.\nWriting to this field has no impact when the read field I3C_DEVRx.DIS=1."
            },
            {
                "name": "IBIACK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "IBI request acknowledge (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a IBI request from target x:\n- After the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another IBI request later on)\n- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.\n- After the ACK, the controller logs the IBI payload data, if any, depending on I3C_DEVRx.IBIDEN.\n- The software is notified by the IBI flag (i.e. I3C_EVR.IBIF=1) and/or the corresponding interrupt if enabled;\n- Independently from IBIACK configuration for this or other devices, further IBI request(s) are NACKed until IBI request flag (i.e. I3C_EVR.IBIF) and controller-role request flag (i.e. I3C_EVR.CRF) are both cleared."
            },
            {
                "name": "CRACK",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "controller-role request acknowledge (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is written by software to define the acknowledge policy to be applied on the I3C bus on the reception of a controller-role request from target x:\nAfter the NACK, the message continues as initially programmed (the target is aware of the NACK and can emit another controller-role request later on)\n- The field DIS is asserted by hardware to protect DA[6:0] from being modified by software meanwhile the hardware can store internally the current DA[6:0] into the kernel clock domain.\n- After the ACK, the message continues as initially programmed. The software is notified by the controller-role request flag (i.e. I3C_EVR.CRF=1) and/or the corresponding interrupt if enabled; For effectively granting the controller-role to the requesting secondary controller, software should issue a GETACCCR (formerly known as GETACCMST), followed by a STOP.\n- Independently of CRACK configuration for this or other devices, further controller-role request(s) are NACKed until controller-role request flag (i.e. I3C_EVR.CRF) and IBI flag (i.e. I3C_EVR.IBIF) are both cleared."
            },
            {
                "name": "IBIDEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "IBI data enable (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit should be written by software to store the BCR[2] bit as received from the target x during broadcast ENTDAA or direct GETBCR CCC via the received I3C_RDR.\nWriting to this field has no impact when the read field I3C_DEVRx.DIS=1."
            },
            {
                "name": "SUSP",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "suspend/stop I3C transfer on received IBI (when the I3C is acting as controller)\nWhen the I3C is acting as controller, this bit is used to receive an IBI from target x with pending read notification feature (i.e. with received MDB[7:5]=3'b101).\nIf this bit is set, when an IBI is received (i.e. I3C_EVR.IBIF=1), a Stop is emitted on the I3C bus and the C-FIFO is automatically flushed by hardware; to avoid a next private read communication issue if a previous private read message to the target x was stored in the C-FIFO."
            },
            {
                "name": "DIS",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "DA[6:0] write disabled (when the I3C is acting as controller)\nWhen the I3C is acting as controller, once that software set IBIACK=1 or CRACK=1, this read bit is set by hardware (i.e. DIS=1) to lock the configured DA[6:0] and IBIDEN values.\nThen, to be able to next modify DA[6:0] or IBIDEN, the software must wait for this field DIS to be de-asserted by hardware (i.e. polling on DIS=0) before modifying these two assigned values to the target x. Indeed, the target may be requesting an IBI or a controller-role meanwhile the controller intends to modify DA[6:0] or IBIDEN."
            }
        ]
    },
    "1073765520": {
        "name": "I3C_MAXRLR",
        "address": 1073765520,
        "size": 32,
        "access": "",
        "desc": "I3C maximum read length register ",
        "fields": [
            {
                "name": "MRL",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "maximum data read length (when I3C is acting as target)\nThis field is initially written by software when I3C_CFGR.EN=0 and updated by hardware on the reception of SETMRL command (with potentially also updated IBIP[2:0]).\nSoftware is notified of a MRL update by the I3C_EVR.MRLUPF and the corresponding interrupt if enabled.\nThis field is used by hardware to return the value on the I3C bus when the target receives a GETMRL CCC."
            },
            {
                "name": "IBIP",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "IBI payload data size, in bytes (when I3C is acting as target)\nThis field is initially written by software when I3C_CFGR.EN=0 to set the number of data bytes to be sent to the controller after an IBI request has been acknowledged.This field may be updated by hardware on the reception of SETMRL command (which potentially also updated IBIP[2:0]).\nSoftware is notified of a MRL update by the I3C_EVR.MRLUPF and the corresponding interrupt if enabled.\nothers: same as 100"
            }
        ]
    },
    "1073765524": {
        "name": "I3C_MAXWLR",
        "address": 1073765524,
        "size": 32,
        "access": "",
        "desc": "I3C maximum write length register ",
        "fields": [
            {
                "name": "MWL",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "maximum data write length (when I3C is acting as target)\nThis field is initially written by software when I3C_CFGR.EN=0 and updated by hardware on the reception of SETMWL command.\nSoftware is notified of a MWL update by the I3C_EVR.MWLUPF and the corresponding interrupt if enabled.\nThis field is used by hardware to return the value on the I3C bus when the target receives a GETMWL CCC."
            }
        ]
    },
    "1073765536": {
        "name": "I3C_TIMINGR0",
        "address": 1073765536,
        "size": 32,
        "access": "",
        "desc": "I3C timing register 0 ",
        "fields": [
            {
                "name": "SCLL_PP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "SCL low duration in I3C push-pull phases, in number of kernel clocks cycles:\ntSCLL_PP = (SCLL_PP + 1) x tI3CCLK\nSCLL_PP is used to generate tLOW (I3C) timing."
            },
            {
                "name": "SCLH_I3C",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "SCL high duration, used for I3C messages (both in push-pull and open-drain phases), in number of kernel clocks cycles:\ntSCLH_I3C = (SCLH_I3C + 1) x tI3CCLK\nSCLH_I3C is used to generate both tHIGH (I3C) and tHIGH_MIXED timings."
            },
            {
                "name": "SCLL_OD",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "SCL low duration in open-drain phases, used for legacy I2C commands and for I3C open-drain phases (address header phase following a START, not a Repeated START), in number of kernel clocks cycles:\ntSCLL_OD = (SCLL_OD + 1) x tI3CCLK\nSCLL_OD is used to generate both tLOW (I2C) and tLOW_OD timings (max. of the two)."
            },
            {
                "name": "SCLH_I2C",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "SCL high duration, used for legacy I2C commands, in number of kernel clocks cycles:\ntSCLH_I2C = (SCLH_I2C + 1) x tI3CCLK\nSCLH_I2C is used to generate tHIGH (I2C) timing."
            }
        ]
    },
    "1073765540": {
        "name": "I3C_TIMINGR1",
        "address": 1073765540,
        "size": 32,
        "access": "",
        "desc": "I3C timing register 1 ",
        "fields": [
            {
                "name": "AVAL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "number of kernel clock cycles, that is used whatever I3C is acting as controller or target, to set the following MIPI I3C timings, like bus available condition time:\nWhen the I3C is acting as target:\nfor bus available condition time: it must wait for (bus available condition) time to be elapsed after a stop and before issuing a start request for an IBI or a controller-role request (i.e. bus free condition is sustained for at least tAVAL). refer to MIPI timing tAVAL = 1  s. This timing is defined by:\ntAVAL = (AVAL[7:0] + 2) x tI3CCLK\nfor bus idle condition time: it must wait for (bus idle condition) time to be elapsed after that both SDA and SCL are continuously high and stable before issuing a hot-join event. Refer to MIPI v1.1 timing tIDLE = 200  s . This timing is defined by:\ntIDLE = (AVAL[7:0] + 2) x 200 x tI3CCLK\nWhen the I3C is acting as controller, it can not stall the clock beyond a maximum stall time (i.e. stall the SCL clock low), as follows:\non first bit of assigned address during dynamic address assignment: it can not stall the clock beyond the MIPI timing tSTALLDAA = 15 ms. This timing is defined by:\ntSTALLDAA = (AVAL[7:0] + 1) x 15000 x tI3CCLK\non ACK/NACK phase of I3C/I2C transfer, on parity bit of write data transfer, on transition bit of I3C read transfer: it can not stall the clock beyond the MIPI timing tSTALL = 100  s. This timing is defined by:\ntSTALL = (AVAL[7:0] + 1) x 100 x tI3CCLK\nWhatever the I3C is acting as controller or as (controller-capable) target, during a controller-role hand-off procedure:\nThe new controller must wait for a time (refer to MIPI timing tNEWCRLock) before pulling SDA low (i.e. issuing a start). And the active controller must wait for the same time while monitoring new controller and before testing the new controller by pulling SDA low. This time to wait is dependent on the defined I3C_TIMINGR1.ANSCR[1:0], as follows:\nIf ASNCR[1:0]=00: tNEWCRLock = (AVAL[7:0] + 1)  x tI3CCLK\nIf ASNCR[1:0]=01: tNEWCRLock = (AVAL[7:0] + 1) x 100 x tI3CCLK\nIf ASNCR[1:0]=10: tNEWCRLock = (AVAL[7:0] + 1) x 2000 x tI3CCLK\nIf ASNCR[1:0]=11: tNEWCRLock = (AVAL[7:0] + 1) x 50000 x tI3CCLK"
            },
            {
                "name": "ASNCR",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "activity state of the new controller (when I3C is acting as active- controller)\nThis field indicates the time to wait before being accessed as new target, refer to the other field AVAL[7:0].\nThis field can be modified only when the I3C is acting as controller."
            },
            {
                "name": "FREE",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "number of kernel clocks cycles that is used to set some MIPI timings like bus free condition time (when the I3C is acting as controller)"
            },
            {
                "name": "SDA_HD",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "SDA hold time (when the I3C is acting as controller), in number of kernel clocks cycles (refer to MIPI timing SDA hold time in push-pull tHD_PP):"
            }
        ]
    },
    "1073765544": {
        "name": "I3C_TIMINGR2",
        "address": 1073765544,
        "size": 32,
        "access": "",
        "desc": "I3C timing register 2 ",
        "fields": [
            {
                "name": "STALLT",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Controller clock stall on T-bit phase of Data enable\nThe SCL is stalled during STALL x tSCLL_PP in the T-bit phase (before 9th bit). This allows the target to prepare data to be sent."
            },
            {
                "name": "STALLD",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "controller clock stall on PAR phase of Data enable\nThe SCL is stalled during STALL x tSCLL_PP in the T-bit phase (before 9th bit). This allows the target to read received data."
            },
            {
                "name": "STALLC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "controller clock stall on PAR phase of CCC enable\nThe SCL is stalled during STALL x tSCLL_PP in the T-bit phase of common command code (before 9th bit). This allows the target to decode the command."
            },
            {
                "name": "STALLA",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "controller clock stall enable on ACK phase\nThe SCL is stalled (during tSCLL_STALLas defined by STALL)  in the address ACK/NACK phase (before 9th bit). This allows the target to prepare data or the controller to respond to target interrupt."
            },
            {
                "name": "STALL",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "controller clock stall time, in number of kernel clock cycles\ntSCLL_STALL = STALL x tI3CCLK"
            }
        ]
    },
    "1073765568": {
        "name": "I3C_BCR",
        "address": 1073765568,
        "size": 32,
        "access": "",
        "desc": "I3C bus characteristics register ",
        "fields": [
            {
                "name": "BCR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "max data speed limitation"
            },
            {
                "name": "BCR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "in-band interrupt (IBI) payload"
            },
            {
                "name": "BCR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "controller capable"
            }
        ]
    },
    "1073765572": {
        "name": "I3C_DCR",
        "address": 1073765572,
        "size": 32,
        "access": "",
        "desc": "I3C device characteristics register ",
        "fields": [
            {
                "name": "DCR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "device characteristics ID\nothers: ID to describe the type of the I3C sensor/device\nNote: The latest MIPI DCR ID assignments are available at: https://www.mipi.org/MIPI_I3C_device_characteristics_register"
            }
        ]
    },
    "1073765576": {
        "name": "I3C_GETCAPR",
        "address": 1073765576,
        "size": 32,
        "access": "",
        "desc": "I3C get capability register ",
        "fields": [
            {
                "name": "CAPPEND",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "IBI MDB support for pending read notification\nThis bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and indicates the support (or not) of the pending read notification via the IBI MDB[7:0] value.\nThis bit is used to return the GETCAP3 byte in response to the GETCAPS CCC format 1."
            }
        ]
    },
    "1073765580": {
        "name": "I3C_CRCAPR",
        "address": 1073765580,
        "size": 32,
        "access": "",
        "desc": "I3C controller-role capability register ",
        "fields": [
            {
                "name": "CAPDHOFF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "delayed controller-role hand-off\nThis bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and indicates if this target I3C may need additional time to process a controller-role hand-off requested by the current controller.\nThis bit is used to return the CRCAP2 byte in response to the GETCAPS CCC format 2."
            },
            {
                "name": "CAPGRP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "group management support (when acting as controller)\nThis bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and indicates if the I3C is able to support group management when it acts as a controller (after controller-role hand-off) via emitted DEFGRPA, RSTGRPA, and SETGRPA CCC.\nThis bit is used to return the CRCAP1 byte in response to the GETCAPS CCC format 2."
            }
        ]
    },
    "1073765584": {
        "name": "I3C_GETMXDSR",
        "address": 1073765584,
        "size": 32,
        "access": "",
        "desc": "I3C get capability register ",
        "fields": [
            {
                "name": "HOFFAS",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "controller hand-off activity state\nThis bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and indicates in which initial activity state the (other) current controller should expect the I3C bus after a controller-role hand-off to this controller-capable I3C, when returning the defining byte CRHDLY (0x91) to a GETMXDS CCC.\nThis 2-bit field is used to return the CRHDLY1 byte in response to the GETCAPS CCC format 3, in order to state which is the activity state of this I3C when becoming controller after a controller-role hand-off, and consequently the time the former controller should wait before testing this I3C to be confirmed its ownership."
            },
            {
                "name": "FMT",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "GETMXDS CCC format\nThis field is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and indicates how is returned the GETMXDS format 1 (without MaxRdTurn) and format 2 (with MaxRdTurn).\nThis bit is used to return the 2-byte format 1 (MaxWr, MaxRd) or 5-byte format 2 (MaxWr, MaxRd, 3-byte MaxRdTurn) byte in response to the GETCAPS CCC.\n- 3-byte MaxRdTurn is returned with MSB=0, middle byte=0 and LSB=RDTURN[7:0].\n- Max read turnaround time is less than 256  s.\n- 3-byte MaxRdTurn is returned with MSB=0, middle byte=RDTURN[7:0] and LSB=0.\n- Max read turnaround time is between 256  s and 65535  s\n- 3-byte MaxRdTurn is returned with MSB=RDTURN[7:0], middle byte=0 and LSB=0.\n- Max read turnaround time is between 65535  s and 16 s."
            },
            {
                "name": "RDTURN",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "programmed byte of the 3-byte MaxRdTurn (maximum read turnaround byte)\nThis bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and writes the value of the selected byte (via the FMT[1:0] field) of the 3-byte MaxRdTurn which is returned in response to the GETMXDS CCC format 2 to encode the maximum read turnaround time."
            },
            {
                "name": "TSCO",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "clock-to-data turnaround time (tSCO)\nThis bit is written by software during bus initialization (i.e. I3C_CFGR.EN=0) and is used to specify the clock-to-data turnaround time tSCO (vs the value of 12 ns). This bit is used by the hardware in response to the GETMXDS CCC to return the encoded clock-to-data turnaround time via the returned MaxRd[5:3] bits."
            }
        ]
    },
    "1073765588": {
        "name": "I3C_EPIDR",
        "address": 1073765588,
        "size": 32,
        "access": "",
        "desc": "I3C extended provisioned ID register ",
        "fields": [
            {
                "name": "MIPIID",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "4-bit MIPI Instance ID\nThis field is written by software to set and identify individually each instance of this I3C IP with a specific number on a single I3C bus.\nThis field represents the bits[15:12] of the 48-bit provisioned ID.\nNote: The bits[11:0] of the provisioned ID may be 0."
            },
            {
                "name": "IDTSEL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "provisioned ID type selector\nThis field is set as 0 i.e. vendor fixed value.\nThis field represents the bit[32] of the 48-bit provisioned ID.\nNote: The bits[31:16] of the provisioned ID may be 0."
            },
            {
                "name": "MIPIMID",
                "bitOffset": 17,
                "bitWidth": 15,
                "desc": "15-bit MIPI manufacturer ID\nThis read field is the 15-bit STMicroelectronics MIPI ID i.e. 0x0104.\nThis field represents the bits[47:33] of the 48-bit provisioned ID."
            }
        ]
    },
    "1140868096": {
        "name": "LPTIM_ISR_output",
        "address": 1140868096,
        "size": 32,
        "access": "",
        "desc": "LPTIM1 interrupt and status register [alternate]",
        "fields": [
            {
                "name": "CC1IF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Compare 1 interrupt flag\nIf channel CC1 is configured as output:\nThe CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register."
            },
            {
                "name": "ARRM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match\nARRM is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register."
            },
            {
                "name": "EXTTRIG",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger edge event\nEXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CMP1OK",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK\nCMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "ARROK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK\nARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "UP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Counter direction change down to up\nIn Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            },
            {
                "name": "DOWN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Counter direction change up to down\nIn Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            },
            {
                "name": "UE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPTIM update event occurred\nUE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA."
            },
            {
                "name": "REPOK",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK\nREPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CC2IF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Compare 2 interrupt flag\nIf channel CC2 is configured as output:\nThe CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the\ncompare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to ."
            },
            {
                "name": "CMP2OK",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK\nCMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to ."
            },
            {
                "name": "DIEROK",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Interrupt enable register update OK\nDIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register."
            }
        ]
    },
    "1140868100": {
        "name": "LPTIM_ICR_output",
        "address": 1140868100,
        "size": 32,
        "access": "",
        "desc": "LPTIM1 interrupt clear register [alternate]",
        "fields": [
            {
                "name": "CC1CF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 clear flag\nWriting 1 to this bit clears the CC1IF flag in the LPTIM_ISR register."
            },
            {
                "name": "ARRMCF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match clear flag\nWriting 1 to this bit clears the ARRM flag in the LPTIM_ISR register"
            },
            {
                "name": "EXTTRIGCF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge clear flag\nWriting 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register"
            },
            {
                "name": "CMP1OKCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK clear flag\nWriting 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register."
            },
            {
                "name": "ARROKCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK clear flag\nWriting 1 to this bit clears the ARROK flag in the LPTIM_ISR register"
            },
            {
                "name": "UPCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP clear flag\nWriting 1 to this bit clear the UP flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            },
            {
                "name": "DOWNCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down clear flag\nWriting 1 to this bit clear the DOWN flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            },
            {
                "name": "UECF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Update event clear flag\nWriting 1 to this bit clear the UE flag in the LPTIM_ISR register."
            },
            {
                "name": "REPOKCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK clear flag\nWriting 1 to this bit clears the REPOK flag in the LPTIM_ISR register."
            },
            {
                "name": "CC2CF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 2 clear flag\nWriting 1 to this bit clears the CC2IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to ."
            },
            {
                "name": "CMP2OKCF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK clear flag\nWriting 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to ."
            },
            {
                "name": "DIEROKCF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Interrupt enable register update OK clear flag\nWriting 1 to this bit clears the DIEROK flag in the LPTIM_ISR register."
            }
        ]
    },
    "1140868104": {
        "name": "LPTIM_DIER_output",
        "address": 1140868104,
        "size": 32,
        "access": "",
        "desc": "LPTIM1 interrupt enable register [alternate]",
        "fields": [
            {
                "name": "CC1IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt enable"
            },
            {
                "name": "ARRMIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match Interrupt Enable"
            },
            {
                "name": "EXTTRIGIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge Interrupt Enable"
            },
            {
                "name": "CMP1OKIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK interrupt enable"
            },
            {
                "name": "ARROKIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK Interrupt Enable"
            },
            {
                "name": "UPIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            },
            {
                "name": "DOWNIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            },
            {
                "name": "UEIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Update event interrupt enable"
            },
            {
                "name": "REPOKIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK interrupt Enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 2 interrupt enable\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to ."
            },
            {
                "name": "CMP2OKIE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK interrupt enable\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Please refer to ."
            },
            {
                "name": "UEDE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Update event DMA request enable\nNote: If LPTIM does not implement at least 1 channel this bit is reserved. Please refer to ."
            }
        ]
    },
    "1140868108": {
        "name": "LPTIM_CFGR",
        "address": 1140868108,
        "size": 32,
        "access": "",
        "desc": "LPTIM configuration register ",
        "fields": [
            {
                "name": "CKSEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clock selector\nThe CKSEL bit selects which clock source the LPTIM uses:"
            },
            {
                "name": "CKPOL",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Clock Polarity\nWhen the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active.\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active.\nRefer to  for more details about Encoder mode sub-modes."
            },
            {
                "name": "CKFLT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Configurable digital filter for external clock\nThe CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature"
            },
            {
                "name": "TRGFLT",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Configurable digital filter for trigger\nThe TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature"
            },
            {
                "name": "PRESC",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "Clock prescaler\nThe PRESC bits configure the prescaler division factor. It can be one among the following division factors:"
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Trigger selector\nThe TRIGSEL bits select the trigger source that serves as a trigger event for the LPTIM among the below 8 available sources:\nSee  for details."
            },
            {
                "name": "TRIGEN",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Trigger enable and polarity\nThe TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:"
            },
            {
                "name": "TIMOUT",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Timeout enable\nThe TIMOUT bit controls the Timeout feature"
            },
            {
                "name": "WAVE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Waveform shape\nThe WAVE bit controls the output shape"
            },
            {
                "name": "WAVPOL",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Waveform shape polarity\nThe WAVPOL bit controls the output polarity\nNote: If the LPTIM implements at least one capture/compare channel, this bit is reserved. Please refer to ."
            },
            {
                "name": "PRELOAD",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Registers update mode\nThe PRELOAD bit controls the LPTIM_ARR, LPTIM_RCR and the LPTIM_CCRx registers update modality"
            },
            {
                "name": "COUNTMODE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "counter mode enabled\nThe COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:"
            },
            {
                "name": "ENC",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Encoder mode enable\nThe ENC bit controls the Encoder mode\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            }
        ]
    },
    "1140868112": {
        "name": "LPTIM_CR",
        "address": 1140868112,
        "size": 32,
        "access": "",
        "desc": "LPTIM control register ",
        "fields": [
            {
                "name": "ENABLE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPTIM enable\nThe ENABLE bit is set and cleared by software."
            },
            {
                "name": "SNGSTRT",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPTIM start in Single mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = '00'), setting this bit starts the LPTIM in single pulse mode.\nIf the software start is disabled (TRIGEN[1:0] different than '00'), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.\nIf this bit is set when the LPTIM is in continuous counting mode, then the LPTIM stops at the following match between LPTIM_ARR and LPTIM_CNT registers.\nThis bit can only be set when the LPTIM is enabled. It is automatically reset by hardware."
            },
            {
                "name": "CNTSTRT",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Timer start in Continuous mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = '00'), setting this bit starts the LPTIM in Continuous mode.\nIf the software start is disabled (TRIGEN[1:0] different than '00'), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.\nIf this bit is set when a single pulse mode counting is ongoing, then the timer does not stop at the next match between the LPTIM_ARR and LPTIM_CNT registers and the LPTIM counter keeps counting in Continuous mode.\nThis bit can be set only when the LPTIM is enabled. It is automatically reset by hardware."
            },
            {
                "name": "COUNTRST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Counter reset\nThis bit is set by software and cleared by hardware. When set to '1' this bit triggers a synchronous reset of the LPTIM_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock).\nThis bit can be set only when the LPTIM is enabled. It is automatically reset by hardware.\nCOUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software should consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'."
            },
            {
                "name": "RSTARE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Reset after read enable\nThis bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM_CNT register asynchronously resets LPTIM_CNT register content.\nThis bit can be set only when the LPTIM is enabled."
            }
        ]
    },
    "1140868116": {
        "name": "LPTIM_CCR1",
        "address": 1140868116,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 1 ",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the capture/compare 1 register.\nDepending on the PRELOAD option, the CCR1 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 1 contains the value to be compared to the counter LPTIM_CNT and signaled on OC1 output.\nIf channel CC1 is configured as input:\nCCR1 becomes read-only, it contains the counter value transferred by the last input capture 1 event. The LPTIM_CCR1 register is read-only and cannot be programmed."
            }
        ]
    },
    "1140868120": {
        "name": "LPTIM_ARR",
        "address": 1140868120,
        "size": 32,
        "access": "",
        "desc": "LPTIM autoreload register ",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto reload value\nARR is the autoreload value for the LPTIM.\nThis value must be strictly greater than the CCRx[15:0] value."
            }
        ]
    },
    "1140868124": {
        "name": "LPTIM_CNT",
        "address": 1140868124,
        "size": 32,
        "access": "",
        "desc": "LPTIM counter register ",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value\nWhen the LPTIM is running with an asynchronous clock, reading the LPTIM_CNT register may return unreliable values. So in this case it is necessary to perform two consecutive read accesses and verify that the two returned values are identical."
            }
        ]
    },
    "1140868136": {
        "name": "LPTIM_RCR",
        "address": 1140868136,
        "size": 32,
        "access": "",
        "desc": "LPTIM repetition register ",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Repetition register value\nREP is the repetition value for the LPTIM."
            }
        ]
    },
    "1140868140": {
        "name": "LPTIM_CCMR1",
        "address": 1140868140,
        "size": 32,
        "access": "",
        "desc": "LPTIM capture/compare mode register 1 ",
        "fields": [
            {
                "name": "CC1SEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 selection\nThis bitfield defines the direction of the channel input (capture) or output mode."
            },
            {
                "name": "CC1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 output enable.\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 1 (LPTIM_CCR1) or not."
            },
            {
                "name": "CC1P",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Capture/compare 1 output polarity.\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nThis field is used to select the IC1 polarity for capture operations."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC1 input (IC1)."
            },
            {
                "name": "IC1F",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Input capture 1 filter\nThis bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            },
            {
                "name": "CC2SEL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/compare 2 selection\nThis bitfield defines the direction of the channel, input (capture) or output mode."
            },
            {
                "name": "CC2E",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/compare 2 output enable.\nThis bit determines if a capture of the counter value can actually be done into the input capture/compare register 2 (LPTIM_CCR2) or not."
            },
            {
                "name": "CC2P",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Capture/compare 2 output polarity.\nOnly bit2 is used to set polarity when output mode is enabled, bit3 is don't care.\nThis field is used to select the IC2 polarity for capture operations."
            },
            {
                "name": "IC2PSC",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler\nThis bitfield defines the ratio of the prescaler acting on the CC2 input (IC2)."
            },
            {
                "name": "IC2F",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Input capture 2 filter\nThis bitfield defines the number of consecutive equal samples that should be detected when a level change occurs on an external input capture signal before it is considered as a valid level transition. An internal clock source must be present to use this feature."
            }
        ]
    },
    "1140868148": {
        "name": "LPTIM_CCR2",
        "address": 1140868148,
        "size": 32,
        "access": "",
        "desc": "LPTIM compare register 2 ",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/compare 2 value\nIf channel CC2 is configured as output:\nCCR2 is the value to be loaded in the capture/compare 2 register.\nDepending on the PRELOAD option, the CCR2 register is immediately updated if the PRELOAD bit is reset and updated at next LPTIM update event if PREOAD bit is reset.\nThe capture/compare register 2 contains the value to be compared to the counter LPTIM_CNT and signaled on OC2 output.\nIf channel CC2 is configured as input:\nCCR2 becomes read-only, it contains the counter value transferred by the last input capture 2 event. The LPTIM_CCR2 register is read-only and cannot be programmed."
            }
        ]
    },
    "1140859904": {
        "name": "LPUART_CR1_enabled",
        "address": 1140859904,
        "size": 32,
        "access": "",
        "desc": "LPUART control register 1 [alternate] ",
        "fields": [
            {
                "name": "UE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPUART enable\nWhen this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software.\nNote: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit.\nThe DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit."
            },
            {
                "name": "UESM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPUART enable in low-power mode\nWhen this bit is cleared, the LPUART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the LPUART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\nNote: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode."
            },
            {
                "name": "RE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software."
            },
            {
                "name": "TE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit ('0' followed by '1') sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1'. To ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register.\nIn Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts."
            },
            {
                "name": "IDLEIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "IDLE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFNEIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFNFIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PEIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "PE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "PCE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "WAKE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver wakeup method\nThis bit determines the LPUART wakeup method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "M0",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description).\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "MME",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Mute mode enable\nThis bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software."
            },
            {
                "name": "CMIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Character match interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "DEDT",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Driver Enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer control and RS485 Driver Enable.\nIf the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DEAT",
                "bitOffset": 21,
                "bitWidth": 5,
                "desc": "Driver Enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer .\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "M1",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] = '00': 1 Start bit, 8 Data bits, n Stop bit\nM[1:0] = '01': 1 Start bit, 9 Data bits, n Stop bit\nM[1:0] = '10': 1 Start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the LPUART is disabled (UE=0).\nNote: In 7-bit data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported."
            },
            {
                "name": "FIFOEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "FIFO mode enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFEIE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TXFIFO empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFFIE",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RXFIFO Full interrupt enable\nThis bit is set and cleared by software."
            }
        ]
    },
    "1140859908": {
        "name": "LPUART_CR2",
        "address": 1140859908,
        "size": 32,
        "access": "",
        "desc": "LPUART control register 2 ",
        "fields": [
            {
                "name": "ADDM7",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "7-bit Address Detection/4-bit Address Detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\nThis bit can only be written when the LPUART is disabled (UE=0)\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively."
            },
            {
                "name": "STOP",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "STOP bits\nThese bits are used for programming the stop bits.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "SWAP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Swap TX/RX pins\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "RXINV",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "RX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "TXINV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DATAINV",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Binary data inversion\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "MSBFIRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Most significant bit first\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "ADD",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Address of the LPUART node\nThese bits give the address of the LPUART node in Mute mode or a character code to be recognized in low-power or Run mode:\nIn Mute mode: they are used in multiprocessor communication to wakeup from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.\nIn low-power mode: they are used for wake up from low-power mode on character match.\nWhen WUS[1:0] is programmed to 0b00 (WUF active on address match), the wakeup from low-power mode is performed when the received character corresponds to the character programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1.\nIn Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.\nThese bits can only be written when the reception is disabled (RE = 0) or when the USART is disabled (UE = 0)."
            }
        ]
    },
    "1140859912": {
        "name": "LPUART_CR3",
        "address": 1140859912,
        "size": 32,
        "access": "",
        "desc": "LPUART control register 3 ",
        "fields": [
            {
                "name": "EIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FE=1 or ORE=1 or NE=1 in the LPUART_ISR register)."
            },
            {
                "name": "HDSEL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Half-duplex selection\nSelection of Single-wire Half-duplex mode\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DMAR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA enable receiver\nThis bit is set/reset by software"
            },
            {
                "name": "DMAT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA enable transmitter\nThis bit is set/reset by software"
            },
            {
                "name": "RTSE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "RTS enable\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "CTSE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS enable\nThis bit can only be written when the LPUART is disabled (UE=0)"
            },
            {
                "name": "CTSIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS interrupt enable"
            },
            {
                "name": "OVRDIS",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun Disable\nThis bit is used to disable the receive overrun detection.\nthe ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register.\nThis bit can only be written when the LPUART is disabled (UE=0).\nNote: This control bit enables checking the communication flow w/o reading the data."
            },
            {
                "name": "DDRE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DMA Disable on Reception Error\nThis bit can only be written when the LPUART is disabled (UE=0).\nNote: The reception errors are: parity error, framing error or noise error."
            },
            {
                "name": "DEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DEP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Driver enable polarity selection\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "WUS0",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).\nThis bitfield can only be written when the LPUART is disabled (UE=0).\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2386."
            },
            {
                "name": "WUS1",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).\nThis bitfield can only be written when the LPUART is disabled (UE=0).\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2386."
            },
            {
                "name": "WUFIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode interrupt enable\nThis bit is set and cleared by software.\nNote: WUFIE must be set before entering in low-power mode.\nIf the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2386."
            },
            {
                "name": "TXFTIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFTCFG",
                "bitOffset": 25,
                "bitWidth": 3,
                "desc": "Receive FIFO threshold configuration\nRemaining combinations: Reserved."
            },
            {
                "name": "RXFTIE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "RXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFTCFG",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "TXFIFO threshold configuration\nRemaining combinations: Reserved."
            }
        ]
    },
    "1140859916": {
        "name": "LPUART_BRR",
        "address": 1140859916,
        "size": 32,
        "access": "",
        "desc": "LPUART baud rate register ",
        "fields": [
            {
                "name": "BRR",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "LPUART baud rate division (LPUARTDIV)"
            }
        ]
    },
    "1140859928": {
        "name": "LPUART_RQR",
        "address": 1140859928,
        "size": 32,
        "access": "",
        "desc": "LPUART request register ",
        "fields": [
            {
                "name": "SBKRQ",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\nNote: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit."
            },
            {
                "name": "MMRQ",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Mute mode request\nWriting 1 to this bit puts the LPUART in Mute mode and resets the RWU flag."
            },
            {
                "name": "RXFRQ",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Receive data flush request\nWriting 1 to this bit clears the RXNE flag.\nThis enables discarding the received data without reading it, and avoid an overrun condition."
            },
            {
                "name": "TXFRQ",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Transmit data flush request\nThis bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register).\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register."
            }
        ]
    },
    "1140859932": {
        "name": "LPUART_ISR_enabled",
        "address": 1140859932,
        "size": 32,
        "access": "",
        "desc": "LPUART interrupt and status register [alternate] ",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error\nThis bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register.\nAn interrupt is generated if PEIE = 1 in the LPUART_CR1 register.\nNote: This error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "FE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE = 1 in the LPUART_CR1 register.\nNote: This error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Start bit noise detection flag\nThis bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NFCF bit in the LPUART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.\nThis error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "ORE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the LPUART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register.\nAn interrupt is generated if RXFNEIE=1 or EIE = 1 in the LPUART_CR1 register.\nNote: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.\nThis bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register."
            },
            {
                "name": "IDLE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected\nThis bit is set by hardware when an Idle line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register.\nNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).\nIf Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set."
            },
            {
                "name": "RXFNE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty\nRXFNE bit is set by hardware when the RXFIFO is not empty, and so data can be read from the LPUART_RDR register. Every read of the LPUART_RDR frees a location in the RXFIFO. It is cleared when the RXFIFO is empty.\nThe RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register.\nAn interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete\nThis bit indicates that the last data written in the LPUART_TDR has been transmitted out of the shift register. The TC flag behaves as follows:\nWhen TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXFE is set.\nWhen TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached.\nWhen TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred.\nWhen TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty.\nAn interrupt is generated if TCIE=1 in the LPUART_CR1 register.\nTC bit is cleared by software by writing 1 to the TCCF in the LPUART_ICR register or by writing to the LPUART_TDR register."
            },
            {
                "name": "TXFNF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full\nTXFNF is set by hardware when TXFIFO is not full, and so data can be written in the LPUART_TDR. Every write in the LPUART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the LPUART_TDR.\nThe TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time).\nAn interrupt is generated if the TXFNFIE bit =1 in the LPUART_CR1 register.\nNote: This bit is used during single buffer transmission."
            },
            {
                "name": "CTSIF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS interrupt flag\nThis bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register.\nAn interrupt is generated if CTSIE=1 in the LPUART_CR3 register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "CTS",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "BUSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not)."
            },
            {
                "name": "CMF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register.\nAn interrupt is generated if CMIE=1in the LPUART_CR1 register."
            },
            {
                "name": "SBKF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission."
            },
            {
                "name": "RWU",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Receiver wakeup from Mute mode\nThis bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register.\nWhen wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register.\nNote: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "WUF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode flag\nThis bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the LPUART_ICR register.\nAn interrupt is generated if WUFIE=1 in the LPUART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nIf the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "TEACK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART.\nIt can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period."
            },
            {
                "name": "REACK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART.\nIt can be used to verify that the LPUART is ready for reception before entering low-power mode.\nNote: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "TXFE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO Empty\nThis bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the LPUART_RQR register.\nAn interrupt is generated if the TXFEIE bit =1 (bit 30) in the LPUART_CR1 register."
            },
            {
                "name": "RXFF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "RXFIFO Full\nThis bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the LPUART_RDR register.\nAn interrupt is generated if the RXFFIE bit =1 in the LPUART_CR1 register."
            },
            {
                "name": "RXFT",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "RXFIFO threshold flag\nThis bit is set by hardware when the RXFIFO reaches the threshold programmed in RXFTCFG in LPUART_CR3 register i.e. the Receive FIFO contains RXFTCFG data. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the LPUART_CR3 register."
            },
            {
                "name": "TXFT",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "TXFIFO threshold flag\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG in LPUART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the LPUART_CR3 register."
            }
        ]
    },
    "1140859936": {
        "name": "LPUART_ICR",
        "address": 1140859936,
        "size": 32,
        "access": "",
        "desc": "LPUART interrupt flag clear register ",
        "fields": [
            {
                "name": "PECF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error clear flag\nWriting 1 to this bit clears the PE flag in the LPUART_ISR register."
            },
            {
                "name": "FECF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error clear flag\nWriting 1 to this bit clears the FE flag in the LPUART_ISR register."
            },
            {
                "name": "NECF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the LPUART_ISR register."
            },
            {
                "name": "ORECF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the LPUART_ISR register."
            },
            {
                "name": "IDLECF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the LPUART_ISR register."
            },
            {
                "name": "TCCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the LPUART_ISR register."
            },
            {
                "name": "CTSCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the LPUART_ISR register."
            },
            {
                "name": "CMCF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match clear flag\nWriting 1 to this bit clears the CMF flag in the LPUART_ISR register."
            },
            {
                "name": "WUCF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the USART_ISR register.\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2386."
            }
        ]
    },
    "1140859940": {
        "name": "LPUART_RDR",
        "address": 1140859940,
        "size": 32,
        "access": "",
        "desc": "LPUART receive data register ",
        "fields": [
            {
                "name": "RDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Receive data value\nContains the received data character.\nThe RDR register provides the parallel interface between the input shift register and the internal bus (see ).\nWhen receiving with the parity enabled, the value read in the MSB bit is the received parity bit."
            }
        ]
    },
    "1140859944": {
        "name": "LPUART_TDR",
        "address": 1140859944,
        "size": 32,
        "access": "",
        "desc": "LPUART transmit data register ",
        "fields": [
            {
                "name": "TDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Transmit data value\nContains the data character to be transmitted.\nThe TDR register provides the parallel interface between the internal bus and the output shift register (see ).\nWhen transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.\nNote: This register must be written only when TXE/TXFNF=1."
            }
        ]
    },
    "1140859948": {
        "name": "LPUART_PRESC",
        "address": 1140859948,
        "size": 32,
        "access": "",
        "desc": "LPUART prescaler register ",
        "fields": [
            {
                "name": "PRESCALER",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Clock prescaler\nThe LPUART input clock can be divided by a prescaler:\nRemaining combinations: Reserved.\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256."
            }
        ]
    },
    "1073755136": {
        "name": "OPAMP1_CSR",
        "address": 1073755136,
        "size": 32,
        "access": "",
        "desc": "OPAMP1 control/status register ",
        "fields": [
            {
                "name": "OPAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Operational amplifier Enable\nNote: If OPAMP1 is unconnected in a specific package, it must remain disabled (keep OPAMP1_CSR register default value)."
            },
            {
                "name": "FORCE_VP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Force internal reference on VP (reserved for test)"
            },
            {
                "name": "VP_SEL",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Non inverted input selection"
            },
            {
                "name": "VM_SEL",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Inverting input selection"
            },
            {
                "name": "OPAHSM",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Operational amplifier high-speed mode\nThe operational amplifier must be disable to change this configuration."
            },
            {
                "name": "CALON",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Calibration mode enabled"
            },
            {
                "name": "CALSEL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Calibration selection\nIt is used to select the offset calibration bus used to generate the internal reference voltage when CALON = 1 or FORCE_VP= 1."
            },
            {
                "name": "PGA_GAIN",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "Operational amplifier Programmable amplifier gain value"
            },
            {
                "name": "USERTRIM",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "User trimming enable\nThis bit allows to switch from 'factory' AOP offset trimmed values to 'user' AOP offset trimmed values\nThis bit is active for both mode normal and high-power."
            },
            {
                "name": "TSTREF",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "OPAMP calibration reference voltage output control (reserved for test)"
            },
            {
                "name": "CALOUT",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Operational amplifier calibration output\nOPAMP output status flag. During the calibration mode, OPAMP is used as comparator."
            }
        ]
    },
    "1073755140": {
        "name": "OPAMP1_OTR",
        "address": 1073755140,
        "size": 32,
        "access": "",
        "desc": "OPAMP1 trimming register in normal mode ",
        "fields": [
            {
                "name": "TRIMOFFSETN",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Trim for NMOS differential pairs"
            },
            {
                "name": "TRIMOFFSETP",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "Trim for PMOS differential pairs"
            }
        ]
    },
    "1073755144": {
        "name": "OPAMP1_HSOTR",
        "address": 1073755144,
        "size": 32,
        "access": "",
        "desc": "OPAMP1 trimming register in high-speed mode \t",
        "fields": [
            {
                "name": "TRIMHSOFFSETN",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "High-speed mode trim for NMOS differential pairs"
            },
            {
                "name": "TRIMHSOFFSETP",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "High-speed mode trim for PMOS differential pairs"
            }
        ]
    },
    "1073755148": {
        "name": "OPAMP_OR",
        "address": 1073755148,
        "size": 32,
        "access": "",
        "desc": "OPAMP option register ",
        "fields": []
    },
    "1140983808": {
        "name": "PWR_PMCR",
        "address": 1140983808,
        "size": 32,
        "access": "",
        "desc": "PWR power mode control register",
        "fields": [
            {
                "name": "LPMS",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "low-power mode selection\nThis bit defines the Deepsleep mode."
            },
            {
                "name": "SVOS",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "system Stop mode voltage scaling selection\nThese bits control the V CORE  voltage level in system Stop mode, to obtain the best trade-off between power consumption and performance."
            },
            {
                "name": "CSSF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "clear Standby and Stop flags (always read as 0)\nThis bit is cleared to 0 by hardware."
            },
            {
                "name": "FLPS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Flash memory low-power mode in Stop mode\nThis bit is used to obtain the best trade-off between low-power consumption and restart time when exiting from Stop mode.\nWhen it is set, the Flash memory enters low-power mode when the CPU domain is in Stop mode.\nNote: When system enters stop mode with SVOS5 enabled, Flash memory is automatically forced in low-power mode."
            },
            {
                "name": "BOOSTE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "analog switch V BOOST  control\nThis bit enables the booster to guarantee the analog switch AC performance when the V DD  supply voltage is below 2.7 V (reduction of the total harmonic distortion to have the same switch performance over the full supply voltage range) The V DD  supply voltage can be monitored through the PVD and the PLS bits."
            },
            {
                "name": "AVD_READY",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "analog voltage ready\nThis bit is only used when the analog switch boost needs to be enabled (see BOOSTE bit).\nIt must be set by software when the expected V DDA  analog supply level is available.\nThe correct analog supply level is indicated by the AVDO bit (PWR_VMSR register) after setting the AVDEN bit (PWR_VMCR register) and selecting the supply level to be monitored \t(ALS bits)."
            },
            {
                "name": "SRAM2SO",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "AHB SRAM2 shut-off in Stop mode."
            },
            {
                "name": "SRAM1SO",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "AHB SRAM1 shut-off in Stop mode"
            }
        ]
    },
    "1140983812": {
        "name": "PWR_PMSR",
        "address": 1140983812,
        "size": 32,
        "access": "",
        "desc": "PWR status register",
        "fields": [
            {
                "name": "STOPF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Stop flag\nThis bit is set by hardware and cleared only by any reset or by setting the CSSF bit."
            },
            {
                "name": "SBF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "System standby flag\nThis bit is set by hardware and cleared only by a POR or by setting the CSSF bit."
            }
        ]
    },
    "1140983824": {
        "name": "PWR_VOSCR",
        "address": 1140983824,
        "size": 32,
        "access": "",
        "desc": "PWR voltage scaling control register",
        "fields": [
            {
                "name": "VOS",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "voltage scaling selection according to performance\nThese bits control the V CORE  voltage level and allow to obtain the best trade-off between power consumption and performance:\n- In bypass mode, these bits must also be set according to the external provided core voltage level and related performance.\n- When increasing the performance, the voltage scaling must be changed before increasing the system frequency.\n- When decreasing performance, the system frequency must first be decreased before changing the voltage scaling."
            }
        ]
    },
    "1140983828": {
        "name": "PWR_VOSSR",
        "address": 1140983828,
        "size": 32,
        "access": "",
        "desc": "PWR voltage scaling status register",
        "fields": [
            {
                "name": "VOSRDY",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Ready bit for V CORE  voltage scaling output selection."
            },
            {
                "name": "ACTVOSRDY",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Voltage level ready for currently used VOS"
            },
            {
                "name": "ACTVOS",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "voltage output scaling currently applied to V CORE\nThis field provides the last VOS value."
            }
        ]
    },
    "1140983840": {
        "name": "PWR_BDCR",
        "address": 1140983840,
        "size": 32,
        "access": "",
        "desc": "PWR Backup domain control register",
        "fields": [
            {
                "name": "BREN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Backup RAM retention in Standby and V BAT  modes\nWhen this bit set, the backup regulator (used to maintain the backup RAM content in Standby and V BAT  modes) is enabled.\nIf BREN is cleared, the backup regulator is switched off. The backup RAM can still be used in \tRun and Stop modes. However its content is lost in Standby and V BAT  modes.\nIf BREN is set, the application must wait till the backup regulator ready flag (BRRDY) is set to indicate that the data written into the SRAM is maintained in Standby and V BAT  modes."
            },
            {
                "name": "MONEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Backup domain voltage and temperature monitoring enable"
            },
            {
                "name": "VBE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "V BAT  charging enable\nNote: Reset only by POR,."
            },
            {
                "name": "VBRS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "V BAT  charging resistor selection"
            }
        ]
    },
    "1140983844": {
        "name": "PWR_DBPCR",
        "address": 1140983844,
        "size": 32,
        "access": "",
        "desc": "PWR disable backup protection control register",
        "fields": [
            {
                "name": "DBP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Disable Backup domain write protection\nIn reset state, all registers and SRAM in Backup domain are protected against parasitic write \taccess. This bit must be set to enable write access to these registers."
            }
        ]
    },
    "1140983848": {
        "name": "PWR_BDSR",
        "address": 1140983848,
        "size": 32,
        "access": "",
        "desc": "PWR Backup domain status register",
        "fields": [
            {
                "name": "BRRDY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "backup regulator ready\nThis bit is set by hardware to indicate that the backup regulator is ready."
            },
            {
                "name": "VBATL",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "V BAT  level monitoring versus low threshold"
            },
            {
                "name": "VBATH",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "V BAT  level monitoring versus high threshold"
            },
            {
                "name": "TEMPL",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "temperature level monitoring versus low threshold"
            },
            {
                "name": "TEMPH",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "temperature level monitoring versus high threshold"
            }
        ]
    },
    "1140983856": {
        "name": "PWR_SCCR",
        "address": 1140983856,
        "size": 32,
        "access": "",
        "desc": "PWR supply configuration control register",
        "fields": [
            {
                "name": "BYPASS",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "power management unit bypass"
            },
            {
                "name": "LDOEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "LDO enable\nThe value is set by hardware when the package uses the LDO regulator."
            }
        ]
    },
    "1140983860": {
        "name": "PWR_VMCR",
        "address": 1140983860,
        "size": 32,
        "access": "",
        "desc": "PWR voltage monitor control register",
        "fields": [
            {
                "name": "PVDE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "PVD enable"
            },
            {
                "name": "PLS",
                "bitOffset": 1,
                "bitWidth": 3,
                "desc": "programmable voltage detector (PVD) level selection\nThese bits select the voltage threshold detected by the PVD."
            },
            {
                "name": "AVDEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "peripheral voltage monitor on V DDA  enable"
            },
            {
                "name": "ALS",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "analog voltage detector (AVD) level selection\nThese bits select the voltage threshold detected by the AVD."
            }
        ]
    },
    "1140983868": {
        "name": "PWR_VMSR",
        "address": 1140983868,
        "size": 32,
        "access": "",
        "desc": "PWR voltage monitor status register",
        "fields": [
            {
                "name": "AVDO",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "analog voltage detector output on V DDA\nThis bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit.\nNote: Since the AVD is disabled in Standby mode, this bit is equal to 0 after standby or reset until the AVDEN bit is set."
            },
            {
                "name": "VDDIO2RDY",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "voltage detector output on V DDIO2\nThis bit is set and cleared by hardware."
            },
            {
                "name": "PVDO",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "programmable voltage detect output\nThis bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit.\nNote: Since the PVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the PVDE bit is set."
            }
        ]
    },
    "1140983872": {
        "name": "PWR_WUSCR",
        "address": 1140983872,
        "size": 32,
        "access": "",
        "desc": "PWR wakeup status clear register",
        "fields": [
            {
                "name": "CWUF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "clear wakeup pin flag for WUFx\nThese bits are always read as 0."
            },
            {
                "name": "CWUF2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "clear wakeup pin flag for WUFx\nThese bits are always read as 0."
            },
            {
                "name": "CWUF3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "clear wakeup pin flag for WUFx\nThese bits are always read as 0."
            },
            {
                "name": "CWUF4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "clear wakeup pin flag for WUFx\nThese bits are always read as 0."
            },
            {
                "name": "CWUF5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "clear wakeup pin flag for WUFx\nThese bits are always read as 0."
            }
        ]
    },
    "1140983876": {
        "name": "PWR_WUSR",
        "address": 1140983876,
        "size": 32,
        "access": "",
        "desc": "PWR wakeup status register",
        "fields": [
            {
                "name": "WUF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "wakeup pin WUFx flag\nThis bit is set by hardware and cleared only by a RESET pin or by setting the CWUFx bit in PWR_WUSCR register."
            },
            {
                "name": "WUF2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "wakeup pin WUFx flag\nThis bit is set by hardware and cleared only by a RESET pin or by setting the CWUFx bit in PWR_WUSCR register."
            },
            {
                "name": "WUF3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "wakeup pin WUFx flag\nThis bit is set by hardware and cleared only by a RESET pin or by setting the CWUFx bit in PWR_WUSCR register."
            },
            {
                "name": "WUF4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "wakeup pin WUFx flag\nThis bit is set by hardware and cleared only by a RESET pin or by setting the CWUFx bit in PWR_WUSCR register."
            },
            {
                "name": "WUF5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "wakeup pin WUFx flag\nThis bit is set by hardware and cleared only by a RESET pin or by setting the CWUFx bit in PWR_WUSCR register."
            }
        ]
    },
    "1140983880": {
        "name": "PWR_WUCR",
        "address": 1140983880,
        "size": 32,
        "access": "",
        "desc": "PWR wakeup configuration register",
        "fields": [
            {
                "name": "WUPEN1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable wakeup pin WUPx\nThese bits are set and cleared by software.\nNote: an additional wakeup event is detected if WUPx pin is enabled (by setting the WUPENx bit) when WUPx pin level is already high when WUPPx selects rising edge, or low when WUPPx selects falling edge."
            },
            {
                "name": "WUPEN2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "enable wakeup pin WUPx\nThese bits are set and cleared by software.\nNote: an additional wakeup event is detected if WUPx pin is enabled (by setting the WUPENx bit) when WUPx pin level is already high when WUPPx selects rising edge, or low when WUPPx selects falling edge."
            },
            {
                "name": "WUPEN3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "enable wakeup pin WUPx\nThese bits are set and cleared by software.\nNote: an additional wakeup event is detected if WUPx pin is enabled (by setting the WUPENx bit) when WUPx pin level is already high when WUPPx selects rising edge, or low when WUPPx selects falling edge."
            },
            {
                "name": "WUPEN4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "enable wakeup pin WUPx\nThese bits are set and cleared by software.\nNote: an additional wakeup event is detected if WUPx pin is enabled (by setting the WUPENx bit) when WUPx pin level is already high when WUPPx selects rising edge, or low when WUPPx selects falling edge."
            },
            {
                "name": "WUPEN5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "enable wakeup pin WUPx\nThese bits are set and cleared by software.\nNote: an additional wakeup event is detected if WUPx pin is enabled (by setting the WUPENx bit) when WUPx pin level is already high when WUPPx selects rising edge, or low when WUPPx selects falling edge."
            },
            {
                "name": "WUPP1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "wakeup pin polarity bit for WUPx\nThese bits define the polarity used for event detection on WUPx external wakeup pin."
            },
            {
                "name": "WUPP2",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "wakeup pin polarity bit for WUPx\nThese bits define the polarity used for event detection on WUPx external wakeup pin."
            },
            {
                "name": "WUPP3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "wakeup pin polarity bit for WUPx\nThese bits define the polarity used for event detection on WUPx external wakeup pin."
            },
            {
                "name": "WUPP4",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "wakeup pin polarity bit for WUPx\nThese bits define the polarity used for event detection on WUPx external wakeup pin."
            },
            {
                "name": "WUPP5",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "wakeup pin polarity bit for WUPx\nThese bits define the polarity used for event detection on WUPx external wakeup pin."
            },
            {
                "name": "WUPPUPD1",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "wakeup pin pull configuration for WKUPx\nThese bits define the I/O pad pull configuration used when WUPENx = 1. The associated GPIO port pull configuration must be set to the same value or to 00. The wakeup pin pull configuration is kept in Standby mode."
            },
            {
                "name": "WUPPUPD2",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "wakeup pin pull configuration for WKUPx\nThese bits define the I/O pad pull configuration used when WUPENx = 1. The associated GPIO port pull configuration must be set to the same value or to 00. The wakeup pin pull configuration is kept in Standby mode."
            },
            {
                "name": "WUPPUPD3",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "wakeup pin pull configuration for WKUPx\nThese bits define the I/O pad pull configuration used when WUPENx = 1. The associated GPIO port pull configuration must be set to the same value or to 00. The wakeup pin pull configuration is kept in Standby mode."
            },
            {
                "name": "WUPPUPD4",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "wakeup pin pull configuration for WKUPx\nThese bits define the I/O pad pull configuration used when WUPENx = 1. The associated GPIO port pull configuration must be set to the same value or to 00. The wakeup pin pull configuration is kept in Standby mode."
            },
            {
                "name": "WUPPUPD5",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "wakeup pin pull configuration for WKUPx\nThese bits define the I/O pad pull configuration used when WUPENx = 1. The associated GPIO port pull configuration must be set to the same value or to 00. The wakeup pin pull configuration is kept in Standby mode."
            }
        ]
    },
    "1140983888": {
        "name": "PWR_IORETR",
        "address": 1140983888,
        "size": 32,
        "access": "",
        "desc": "PWR I/O retention register",
        "fields": [
            {
                "name": "IORETEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "IO retention enable:\nWhen entering into standby mode, the output is sampled, and applied to the output IO during the standby power mode.\nNote: the IO state is not retained if the DBG_STANDBY bit is set in DBGMCU_CR register."
            },
            {
                "name": "JTAGIORETEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "IO retention enable for JTAG IOs\nwhen entering into standby mode, the output is sampled, and applied to the output IO during the standby power mode"
            }
        ]
    },
    "1140984068": {
        "name": "PWR_PRIVCFGR",
        "address": 1140984068,
        "size": 32,
        "access": "",
        "desc": "PWR privilege configuration register",
        "fields": [
            {
                "name": "NSPRIV",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "PWR functions privilege configuration\nSet and reset by software. This bit can be written only by privileged access."
            }
        ]
    },
    "1073897472": {
        "name": "RAMCFG_M1CR",
        "address": 1073897472,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 1 control register",
        "fields": [
            {
                "name": "ECCE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ECC enable.\nThis bit reset value is defined by the user option bit configuration. When set, it can be cleared by software only after writing the unlock sequence in the RAMCFG_MxECCKEYR register.\nNote: This bit is reserved and must be kept at reset value in SRAM1 control register."
            },
            {
                "name": "ALE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Address latch enable\nNote: This bit is reserved and must be kept at reset value in SRAM1 control register."
            },
            {
                "name": "SRAMER",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM erase\nThis bit can be set by software only after writing the unlock sequence in the ERASEKEY field of the RAMCFG_MxERKEYR register. Setting this bit starts the SRAM erase. This bit is automatically cleared by hardware at the end of the erase operation."
            }
        ]
    },
    "1073897480": {
        "name": "RAMCFG_M1ISR",
        "address": 1073897480,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory interrupt status register",
        "fields": [
            {
                "name": "SEDC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ECC single error detected and corrected\nNote: This bit is reserved and must be kept at reset value in SRAM1 interrupt status register."
            },
            {
                "name": "DED",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ECC double error detected\nNote: This bit is reserved and must be kept at reset value in SRAM1 interrupt status register."
            },
            {
                "name": "SRAMBUSY",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM busy with erase operation\nNote: Depending on the SRAM, the erase operation can be performed due to software request, system reset if the option bit is enabled, tamper detection or product state regression. Refer to Table 9: Internal SRAMs features."
            }
        ]
    },
    "1073897512": {
        "name": "RAMCFG_M1ERKEYR",
        "address": 1073897512,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 1 erase key register",
        "fields": [
            {
                "name": "ERASEKEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Erase write protection key\nThe following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register.\n1) Write 0xCA into ERASEKEY[7:0].\n2) Write 0x53 into ERASEKEY[7:0].\nNote: Writing a wrong key reactivates the write protection."
            }
        ]
    },
    "1073897536": {
        "name": "RAMCFG_M2CR",
        "address": 1073897536,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 2 control register",
        "fields": [
            {
                "name": "ECCE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ECC enable.\nThis bit reset value is defined by the user option bit configuration. When set, it can be cleared by software only after writing the unlock sequence in the RAMCFG_MxECCKEYR register.\nNote: This bit is reserved and must be kept at reset value in SRAM1 control register."
            },
            {
                "name": "ALE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Address latch enable\nNote: This bit is reserved and must be kept at reset value in SRAM1 control register."
            },
            {
                "name": "SRAMER",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM erase\nThis bit can be set by software only after writing the unlock sequence in the ERASEKEY field of the RAMCFG_MxERKEYR register. Setting this bit starts the SRAM erase. This bit is automatically cleared by hardware at the end of the erase operation."
            }
        ]
    },
    "1073897540": {
        "name": "RAMCFG_M2IER",
        "address": 1073897540,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 2 interrupt enable register",
        "fields": [
            {
                "name": "SEIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ECC single error interrupt enable"
            },
            {
                "name": "DEIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ECC double error interrupt enable"
            },
            {
                "name": "ECCNMI",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Double error NMI\nThis bit is set by software and cleared only by a global RAMCFG reset.\nNote: if ECCNMI is set, the RAMCFG maskable interrupt is not generated whatever DEIE bit value."
            }
        ]
    },
    "1073897544": {
        "name": "RAMCFG_M2ISR",
        "address": 1073897544,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory interrupt status register",
        "fields": [
            {
                "name": "SEDC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ECC single error detected and corrected\nNote: This bit is reserved and must be kept at reset value in SRAM1 interrupt status register."
            },
            {
                "name": "DED",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ECC double error detected\nNote: This bit is reserved and must be kept at reset value in SRAM1 interrupt status register."
            },
            {
                "name": "SRAMBUSY",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM busy with erase operation\nNote: Depending on the SRAM, the erase operation can be performed due to software request, system reset if the option bit is enabled, tamper detection or product state regression. Refer to Table 9: Internal SRAMs features."
            }
        ]
    },
    "1073897548": {
        "name": "RAMCFG_M2SEAR",
        "address": 1073897548,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 2 ECC single error address register",
        "fields": [
            {
                "name": "ESEA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "ECC single error address\nWhen the ALE bit is set in the RAMCFG_MxCR register, this field is updated with the address corresponding to the ECC single error."
            }
        ]
    },
    "1073897552": {
        "name": "RAMCFG_M2DEAR",
        "address": 1073897552,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 2 ECC double error address register",
        "fields": [
            {
                "name": "EDEA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "ECC double error address\nWhen the ALE bit is set in the RAMCFG_MxCR register, this field is updated with the address corresponding to the ECC double error."
            }
        ]
    },
    "1073897556": {
        "name": "RAMCFG_M2ICR",
        "address": 1073897556,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 2 interrupt clear register 2",
        "fields": [
            {
                "name": "CSEDC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear ECC single error detected and corrected\nWriting 1 to this flag clears the SEDC bit in the RAMCFG_MxISR register. Reading this flag returns the SEDC value."
            },
            {
                "name": "CDED",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear ECC double error detected\nWriting 1 to this flag clears the DED bit in the RAMCFG_MxISR register. Reading this flag returns the DED value."
            }
        ]
    },
    "1073897560": {
        "name": "RAMCFG_M2WPR1",
        "address": 1073897560,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 2 write protection register 1",
        "fields": [
            {
                "name": "P0WP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P1WP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P2WP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P3WP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P4WP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P5WP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P6WP",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P7WP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P8WP",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P9WP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P10WP",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P11WP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P12WP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P13WP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P14WP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            },
            {
                "name": "P15WP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte page y write protection\nThese bits are set by software and cleared only by a global RAMCFG reset."
            }
        ]
    },
    "1073897572": {
        "name": "RAMCFG_M2ECCKEYR",
        "address": 1073897572,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 2 ECC key register",
        "fields": [
            {
                "name": "ECCKEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "ECC write protection key\nThe following steps are required to unlock the write protection of the ECCE bit in the RAMCFG_MxCR register.\n1) Write 0xAE into ECCKEY[7:0].\n2) Write 0x75 into ECCKEY[7:0].\nNote: Writing a wrong key reactivates the write protection."
            }
        ]
    },
    "1073897576": {
        "name": "RAMCFG_M2ERKEYR",
        "address": 1073897576,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 2 erase key register",
        "fields": [
            {
                "name": "ERASEKEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Erase write protection key\nThe following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register.\n1) Write 0xCA into ERASEKEY[7:0].\n2) Write 0x53 into ERASEKEY[7:0].\nNote: Writing a wrong key reactivates the write protection."
            }
        ]
    },
    "1073897604": {
        "name": "RAMCFG_M3IER",
        "address": 1073897604,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 3 interrupt enable register",
        "fields": [
            {
                "name": "SEIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ECC single error interrupt enable"
            },
            {
                "name": "DEIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ECC double error interrupt enable"
            },
            {
                "name": "ECCNMI",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Double error NMI\nThis bit is set by software and cleared only by a global RAMCFG reset.\nNote: if ECCNMI is set, the RAMCFG maskable interrupt is not generated whatever DEIE bit value."
            }
        ]
    },
    "1073897608": {
        "name": "RAMCFG_M3ISR",
        "address": 1073897608,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory interrupt status register",
        "fields": [
            {
                "name": "SEDC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ECC single error detected and corrected\nNote: This bit is reserved and must be kept at reset value in SRAM1 interrupt status register."
            },
            {
                "name": "DED",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ECC double error detected\nNote: This bit is reserved and must be kept at reset value in SRAM1 interrupt status register."
            },
            {
                "name": "SRAMBUSY",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM busy with erase operation\nNote: Depending on the SRAM, the erase operation can be performed due to software request, system reset if the option bit is enabled, tamper detection or product state regression. Refer to Table 9: Internal SRAMs features."
            }
        ]
    },
    "1073897612": {
        "name": "RAMCFG_M3SEAR",
        "address": 1073897612,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 3 ECC single error address register",
        "fields": [
            {
                "name": "ESEA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "ECC single error address\nWhen the ALE bit is set in the RAMCFG_MxCR register, this field is updated with the address corresponding to the ECC single error."
            }
        ]
    },
    "1073897616": {
        "name": "RAMCFG_M3DEAR",
        "address": 1073897616,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 3 ECC double error address register",
        "fields": [
            {
                "name": "EDEA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "ECC double error address\nWhen the ALE bit is set in the RAMCFG_MxCR register, this field is updated with the address corresponding to the ECC double error."
            }
        ]
    },
    "1073897620": {
        "name": "RAMCFG_M3ICR",
        "address": 1073897620,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 3 interrupt clear register 3",
        "fields": [
            {
                "name": "CSEDC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear ECC single error detected and corrected\nWriting 1 to this flag clears the SEDC bit in the RAMCFG_MxISR register. Reading this flag returns the SEDC value."
            },
            {
                "name": "CDED",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear ECC double error detected\nWriting 1 to this flag clears the DED bit in the RAMCFG_MxISR register. Reading this flag returns the DED value."
            }
        ]
    },
    "1073897636": {
        "name": "RAMCFG_M3ECCKEYR",
        "address": 1073897636,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 3 ECC key register",
        "fields": [
            {
                "name": "ECCKEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "ECC write protection key\nThe following steps are required to unlock the write protection of the ECCE bit in the RAMCFG_MxCR register.\n1) Write 0xAE into ECCKEY[7:0].\n2) Write 0x75 into ECCKEY[7:0].\nNote: Writing a wrong key reactivates the write protection."
            }
        ]
    },
    "1073897640": {
        "name": "RAMCFG_M3ERKEYR",
        "address": 1073897640,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 3 erase key register",
        "fields": [
            {
                "name": "ERASEKEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Erase write protection key\nThe following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register.\n1) Write 0xCA into ERASEKEY[7:0].\n2) Write 0x53 into ERASEKEY[7:0].\nNote: Writing a wrong key reactivates the write protection."
            }
        ]
    },
    "1073897704": {
        "name": "RAMCFG_M4ERKEYR",
        "address": 1073897704,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 4 erase key register",
        "fields": [
            {
                "name": "ERASEKEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Erase write protection key\nThe following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register.\n1) Write 0xCA into ERASEKEY[7:0].\n2) Write 0x53 into ERASEKEY[7:0].\nNote: Writing a wrong key reactivates the write protection."
            }
        ]
    },
    "1073897728": {
        "name": "RAMCFG_M5CR",
        "address": 1073897728,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 5 control register",
        "fields": [
            {
                "name": "ECCE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ECC enable.\nThis bit reset value is defined by the user option bit configuration. When set, it can be cleared by software only after writing the unlock sequence in the RAMCFG_MxECCKEYR register.\nNote: This bit is reserved and must be kept at reset value in SRAM1 control register."
            },
            {
                "name": "ALE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Address latch enable\nNote: This bit is reserved and must be kept at reset value in SRAM1 control register."
            },
            {
                "name": "SRAMER",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM erase\nThis bit can be set by software only after writing the unlock sequence in the ERASEKEY field of the RAMCFG_MxERKEYR register. Setting this bit starts the SRAM erase. This bit is automatically cleared by hardware at the end of the erase operation."
            }
        ]
    },
    "1073897732": {
        "name": "RAMCFG_M5IER",
        "address": 1073897732,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 5 interrupt enable register",
        "fields": [
            {
                "name": "SEIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ECC single error interrupt enable"
            },
            {
                "name": "DEIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ECC double error interrupt enable"
            },
            {
                "name": "ECCNMI",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Double error NMI\nThis bit is set by software and cleared only by a global RAMCFG reset.\nNote: if ECCNMI is set, the RAMCFG maskable interrupt is not generated whatever DEIE bit value."
            }
        ]
    },
    "1073897736": {
        "name": "RAMCFG_M5ISR",
        "address": 1073897736,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory interrupt status register",
        "fields": [
            {
                "name": "SEDC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ECC single error detected and corrected\nNote: This bit is reserved and must be kept at reset value in SRAM1 interrupt status register."
            },
            {
                "name": "DED",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ECC double error detected\nNote: This bit is reserved and must be kept at reset value in SRAM1 interrupt status register."
            },
            {
                "name": "SRAMBUSY",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM busy with erase operation\nNote: Depending on the SRAM, the erase operation can be performed due to software request, system reset if the option bit is enabled, tamper detection or product state regression. Refer to Table 9: Internal SRAMs features."
            }
        ]
    },
    "1073897740": {
        "name": "RAMCFG_M5SEAR",
        "address": 1073897740,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 5 ECC single error address register",
        "fields": [
            {
                "name": "ESEA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "ECC single error address\nWhen the ALE bit is set in the RAMCFG_MxCR register, this field is updated with the address corresponding to the ECC single error."
            }
        ]
    },
    "1073897744": {
        "name": "RAMCFG_M5DEAR",
        "address": 1073897744,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 5 ECC double error address register",
        "fields": [
            {
                "name": "EDEA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "ECC double error address\nWhen the ALE bit is set in the RAMCFG_MxCR register, this field is updated with the address corresponding to the ECC double error."
            }
        ]
    },
    "1073897748": {
        "name": "RAMCFG_M5ICR",
        "address": 1073897748,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 5 interrupt clear register 5",
        "fields": [
            {
                "name": "CSEDC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear ECC single error detected and corrected\nWriting 1 to this flag clears the SEDC bit in the RAMCFG_MxISR register. Reading this flag returns the SEDC value."
            },
            {
                "name": "CDED",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear ECC double error detected\nWriting 1 to this flag clears the DED bit in the RAMCFG_MxISR register. Reading this flag returns the DED value."
            }
        ]
    },
    "1073897764": {
        "name": "RAMCFG_M5ECCKEYR",
        "address": 1073897764,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 5 ECC key register",
        "fields": [
            {
                "name": "ECCKEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "ECC write protection key\nThe following steps are required to unlock the write protection of the ECCE bit in the RAMCFG_MxCR register.\n1) Write 0xAE into ECCKEY[7:0].\n2) Write 0x75 into ECCKEY[7:0].\nNote: Writing a wrong key reactivates the write protection."
            }
        ]
    },
    "1073897768": {
        "name": "RAMCFG_M5ERKEYR",
        "address": 1073897768,
        "size": 32,
        "access": "",
        "desc": "RAMCFG memory 5 erase key register",
        "fields": [
            {
                "name": "ERASEKEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Erase write protection key\nThe following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register.\n1) Write 0xCA into ERASEKEY[7:0].\n2) Write 0x53 into ERASEKEY[7:0].\nNote: Writing a wrong key reactivates the write protection."
            }
        ]
    },
    "1140984832": {
        "name": "RCC_CR",
        "address": 1140984832,
        "size": 32,
        "access": "",
        "desc": "RCC clock control register ",
        "fields": [
            {
                "name": "HSION",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "HSI clock enable\nSet and cleared by software.\nSet by hardware to force the HSI to ON when the product leaves Stop mode, if STOPWUCK = 1 or STOPKERWUCK = 1.\nSet by hardware to force the HSI to ON when the product leaves Standby mode or in case of a failure of the HSE which is used as the system clock source.\nThis bit cannot be cleared if the HSI is used directly (via SW mux) as system clock, or if the HSI is selected as reference clock for PLL1 with PLL1 enabled (PLL1ON bit set to 1)."
            },
            {
                "name": "HSIRDY",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "HSI clock ready flag\nSet by hardware to indicate that the HSI oscillator is stable."
            },
            {
                "name": "HSIKERON",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "HSI clock enable in Stop mode\nSet and reset by software to force the HSI to ON, even in Stop mode, in order to be quickly available as kernel clock for peripherals. This bit has no effect on the value of HSION."
            },
            {
                "name": "HSIDIV",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "HSI clock divider\nSet and reset by software.\nThese bits allow selecting a division ratio in order to configure the wanted HSI clock frequency. The\nHSIDIV cannot be changed if the HSI is selected as reference clock for at least one enabled PLL (PLLxON bit set to 1). In that case, the new HSIDIV value is ignored."
            },
            {
                "name": "HSIDIVF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "HSI divider flag\nSet and reset by hardware.\nAs a write operation to HSIDIV has not an immediate effect on the frequency, this flag indicates the\ncurrent status of the HSI divider. HSIDIVF goes immediately to 0 when HSIDIV value is changed, and is set back to 1 when the output frequency matches the value programmed into HSIDIV."
            },
            {
                "name": "CSION",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CSI clock enable\nSet and reset by software to enable/disable CSI clock for system and/or peripheral.\nSet by hardware to force the CSI to ON when the system leaves Stop mode, if STOPWUCK = 1 or STOPKERWUCK = 1.\nThis bit cannot be cleared if the CSI is used directly (via SW mux) as system clock, or if the CSI is selected as reference clock for PLL1 with PLL1 enabled (PLL1ON bit set to 1)."
            },
            {
                "name": "CSIRDY",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CSI clock ready flag\nSet by hardware to indicate that the CSI oscillator is stable. This bit is activated only if the RC is enabled by CSION (it is not activated if the CSI is enabled by CSIKERON or by a peripheral request)."
            },
            {
                "name": "CSIKERON",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CSI clock enable in Stop mode\nSet and reset by software to force the CSI to ON, even in Stop mode, in order to be quickly available as kernel clock for some peripherals. This bit has no effect on the value of CSION."
            },
            {
                "name": "HSI48ON",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "HSI48 clock enable\nSet by software and cleared by software or by the hardware when the system enters to Stop\nor Standby mode."
            },
            {
                "name": "HSI48RDY",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "HSI48 clock ready flag\nSet by hardware to indicate that the HSI48 oscillator is stable."
            },
            {
                "name": "HSEON",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "HSE clock enable\nSet and cleared by software.\nCleared by hardware to stop the HSE when entering Stop or Standby mode.\nThis bit cannot be cleared if the HSE is used directly (via SW mux) as system clock, or if the\nHSE is selected as reference clock for PLL1 with PLL1 enabled (PLL1ON bit set to 1)."
            },
            {
                "name": "HSERDY",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "HSE clock ready flag\nSet by hardware to indicate that the HSE oscillator is stable."
            },
            {
                "name": "HSEBYP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "HSE clock bypass\nSet and cleared by software to bypass the oscillator with an external clock. The external clock must be enabled with the HSEON bit to be used by the device.\nThe HSEBYP bit can be written only if the HSE oscillator is disabled."
            },
            {
                "name": "HSECSSON",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "HSE clock security system enable\nSet by software to enable clock security system on HSE.\nThis bit is 'set only' (disabled by a system reset or when the system enters in Standby mode). When HSECSSON is set, the clock detector is enabled by hardware when the HSE is ready and disabled by hardware if an oscillator failure is detected."
            },
            {
                "name": "HSEEXT",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "external high speed clock type in Bypass mode\nSet and reset by software to select the external clock type (analog or digital).\nThe external clock must be enabled with the HSEON bit to be used by the device. The HSEEXT bit can be written only if the HSE oscillator is disabled."
            },
            {
                "name": "PLL1ON",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "PLL1 enable\nSet and cleared by software to enable PLL1.\nCleared by hardware when entering Stop or Standby mode. Note that the hardware prevents\nwriting this bit to 0, if the PLL1 output is used as the system clock."
            },
            {
                "name": "PLL1RDY",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "PLL1 clock ready flag\nSet by hardware to indicate that the PLL1 is locked."
            },
            {
                "name": "PLL2ON",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "PLL2 enable\nSet and cleared by software to enable PLL2.\nCleared by hardware when entering Stop or Standby mode."
            },
            {
                "name": "PLL2RDY",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "PLL2 clock ready flag\nSet by hardware to indicate that the PLL is locked."
            }
        ]
    },
    "1140984848": {
        "name": "RCC_HSICFGR",
        "address": 1140984848,
        "size": 32,
        "access": "",
        "desc": "RCC HSI calibration register ",
        "fields": [
            {
                "name": "HSICAL",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "HSI clock calibration\nSet by hardware by option byte loading during system reset nreset. Adjusted by software through trimming bits HSITRIM.\nThis field represents the sum of engineering option byte calibration value and HSITRIM bits value."
            },
            {
                "name": "HSITRIM",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "HSI clock trimming\nSet by software to adjust calibration.\nHSITRIM field is added to the engineering option bytes loaded during reset phase (FLASH_HSI_OPT) in order to form the calibration trimming value.\nHSICAL = HSITRIM + FLASH_HSI_OPT.\nAfter a change of HSITRIM it takes one system clock cycle before the new HSITRIM value is updated\nNote: The reset value of the field is 0x40."
            }
        ]
    },
    "1140984852": {
        "name": "RCC_CRRCR",
        "address": 1140984852,
        "size": 32,
        "access": "",
        "desc": "RCC clock recovery RC register ",
        "fields": [
            {
                "name": "HSI48CAL",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Internal RC 48 MHz clock calibration\nSet by hardware by option-byte loading during system reset NRESET. Read-only."
            }
        ]
    },
    "1140984856": {
        "name": "RCC_CSICFGR",
        "address": 1140984856,
        "size": 32,
        "access": "",
        "desc": "RCC CSI calibration register ",
        "fields": [
            {
                "name": "CSICAL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "CSI clock calibration\nSet by hardware by option byte loading during system reset NRESET. Adjusted by software through trimming bits CSITRIM.\nThis field represents the sum of engineering option byte calibration value and CSITRIM bits value."
            },
            {
                "name": "CSITRIM",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "CSI clock trimming\nSet by software to adjust calibration.\nCSITRIM field is added to the engineering option bytes loaded during reset phase (FLASH_CSI_OPT) in order to form the calibration trimming value.\nCSICAL = CSITRIM + FLASH_CSI_OPT.\nNote: The reset value of the field is 0x20."
            }
        ]
    },
    "1140984860": {
        "name": "RCC_CFGR1",
        "address": 1140984860,
        "size": 32,
        "access": "",
        "desc": "RCC clock configuration register ",
        "fields": [
            {
                "name": "SW",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "system clock and trace clock switch\nSet and reset by software to select system clock and trace clock sources (sys_ck).\nSet by hardware in order to:\n-\tforce the selection of the HSI or CSI (depending on STOPWUCK selection) when leaving a system Stop mode\n-\tforce the selection of the HSI in case of failure of the HSE when used directly or indirectly as system clock\nothers: reserved"
            },
            {
                "name": "SWS",
                "bitOffset": 3,
                "bitWidth": 3,
                "desc": "system clock switch status\nSet and reset by hardware to indicate which clock source is used as system clock. 000: HSI used as system clock (hsi_ck) (default after reset).\nothers: reserved"
            },
            {
                "name": "STOPWUCK",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "system clock selection after a wakeup from system Stop\nSet and reset by software to select the system wakeup clock from system Stop.\nThe selected clock is also used as emergency clock for the clock security system (CSS) on HSE. 0: HSI selected as wakeup clock from system Stop (default after reset)\nSTOPWUCK must not be modified when CSS is enabled (by HSECSSON bit) and the system clock is HSE (SWS = 10) or a switch on HSE is requested (SW =10)."
            },
            {
                "name": "STOPKERWUCK",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "kernel clock selection after a wakeup from system Stop\nSet and reset by software to select the kernel wakeup clock from system Stop."
            },
            {
                "name": "RTCPRE",
                "bitOffset": 8,
                "bitWidth": 6,
                "desc": "HSE division factor for RTC clock\nSet and cleared by software to divide the HSE to generate a clock for RTC.\nCaution: The software must set these bits correctly to ensure that the clock supplied to the RTC is lower than 1 MHz. These bits must be configured if needed before selecting the RTC clock source.\n..."
            },
            {
                "name": "TIMPRE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "timers clocks prescaler selection\nThis bit is set and reset by software to control the clock frequency of all the timers connected to APB1 and APB2 domains."
            },
            {
                "name": "MCO1PRE",
                "bitOffset": 18,
                "bitWidth": 4,
                "desc": "MCO1 prescaler\nSet and cleared by software to configure the prescaler of the MCO1. Modification of this prescaler may generate glitches on MCO1. It is highly recommended to change this prescaler only after reset, before enabling the external oscillators and the PLLs.\n..."
            },
            {
                "name": "MCO1SEL",
                "bitOffset": 22,
                "bitWidth": 3,
                "desc": "Microcontroller clock output 1\nSet and cleared by software. Clock source selection may generate glitches on MCO1.\nIt is highly recommended to configure these bits only after reset, before enabling the external oscillators and the PLLs.\nothers: reserved"
            },
            {
                "name": "MCO2PRE",
                "bitOffset": 25,
                "bitWidth": 4,
                "desc": "MCO2 prescaler\nSet and cleared by software to configure the prescaler of the MCO2. Modification of this prescaler may generate glitches on MCO2. It is highly recommended to change this prescaler only after reset, before enabling the external oscillators and the PLLs.\n..."
            },
            {
                "name": "MCO2SEL",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "microcontroller clock output 2\nSet and cleared by software. Clock source selection may generate glitches on MCO2.\nIt is highly recommended to configure these bits only after reset, before enabling the external oscillators and the PLLs.\nothers: reserved"
            }
        ]
    },
    "1140984864": {
        "name": "RCC_CFGR2",
        "address": 1140984864,
        "size": 32,
        "access": "",
        "desc": "RCC CPU domain clock configuration register 2 ",
        "fields": [
            {
                "name": "HPRE",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "AHB prescaler\nSet and reset by software to control the division factor of rcc_hclk. Changing\nthis division ratio has an impact on the frequency of all bus matrix clocks\n0xxx: rcc_hclk = sys_ck (default after reset)"
            },
            {
                "name": "PPRE1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "APB low-speed prescaler (APB1)\nSet and reset by software to control the division factor of rcc_pclk1.\nThe clock is divided by the new prescaler factor from 1 to 16 cycles of rcc_hclk after PPRE write.\n0xx: rcc_pclk1 = rcc_hclk1 (default after reset)"
            },
            {
                "name": "PPRE2",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "APB high-speed prescaler (APB2)\nSet and reset by software to control APB high-speed clocks division factor.\nThe clocks are divided with the new prescaler factor from 1 to 16 APB cycles after PPRE2 write.\n0xx: rcc_pclk2 = rcc_hclk1"
            },
            {
                "name": "PPRE3",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "APB low-speed prescaler (APB3)\nSet and reset by software to control APB low-speed clocks division factor.\nThe clocks are divided with the new prescaler factor from 1 to 16 APB cycles after PPRE3 write.\n0xx: rcc_pclk3 = rcc_hclk1"
            },
            {
                "name": "AHB1DIS",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "AHB1 clock disable\nThis bit can be set in order to further reduce power consumption, when none of the AHB1\nperipherals from RCC_AHB1ENR are used and when their clocks are disabled in\nRCC_AHB1ENR. When this bit is set, all the AHB1 peripherals clocks from\nRCC_AHB1ENR are off.\nenable control bits"
            },
            {
                "name": "AHB2DIS",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "AHB2 clock disable\nThis bit can be set in order to further reduce power consumption, when none of the AHB2\nperipherals from RCC_AHB2ENR are used and when their clocks are disabled in\nRCC_AHB2ENR. When this bit is set, all the AHB2 peripherals clocks from\nRCC_AHB2ENR are off.\nenable control bits"
            },
            {
                "name": "AHB4DIS",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "AHB4 clock disable\nThis bit can be set in order to further reduce power consumption, when none of the AHB4\nperipherals from RCC_AHB4ENR are used and when their clocks are disabled in\nRCC_AHB4ENR. When this bit is set, all the AHB4 peripherals clocks from\nRCC_AHB4ENR are off.\nenable control bits"
            },
            {
                "name": "APB1DIS",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "APB1 clock disable value\nThis bit can be set in order to further reduce power consumption, when none of the APB1\nperipherals (except IWDG) are used and when their clocks are disabled in RCC_APB1ENR.\nWhen this bit is set, all the APB1 peripherals clocks are off, except for IWDG.\ncontrol bits"
            },
            {
                "name": "APB2DIS",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "APB2 clock disable value\nThis bit can be set in order to further reduce power consumption, when none of the APB2\nperipherals are used and when their clocks are disabled in RCC_APB2ENR. When this bit is\nset, all the APB2 peripherals clocks are off.\ncontrol bits"
            },
            {
                "name": "APB3DIS",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "APB3 clock disable value.Set and cleared by software\nThis bit can be set in order to further reduce power consumption, when none of the APB3\nperipherals are used and when their clocks are disabled in RCC_APB3ENR. When this bit is\nset, all the APB3 peripherals clocks are off.\ncontrol bits"
            }
        ]
    },
    "1140984872": {
        "name": "RCC_PLL1CFGR",
        "address": 1140984872,
        "size": 32,
        "access": "",
        "desc": "RCC PLL clock source selection register ",
        "fields": [
            {
                "name": "PLL1SRC",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "DIVMx and PLLs clock source selection\nSet and reset by software to select the PLL clock source. These bits can be written only when all PLLs are disabled.\nIn order to save power, when no PLL is used, the value of PLL1SRC must be set to '00'. 00: no clock send to DIVMx divider and PLLs (default after reset)."
            },
            {
                "name": "PLL1RGE",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "PLL1 input frequency range\nSet and reset by software to select the proper reference frequency range used for PLL1. This bit must be written before enabling the PLL1."
            },
            {
                "name": "PLL1FRACEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "PLL1 fractional latch enable\nSet and reset by software to latch the content of FRACN1 into the sigma-delta modulator.\nIn order to latch the FRACN1 value into the sigma-delta modulator, PLL1FRACEN must be set to 0, then set to 1. The transition 0 to 1 transfers the content of FRACN1 into the modulator."
            },
            {
                "name": "PLL1VCOSEL",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "PLL1 VCO selection\nSet and reset by software to select the proper VCO frequency range used for PLL1. This bit must be written before enabling the PLL1."
            },
            {
                "name": "PLL1M",
                "bitOffset": 8,
                "bitWidth": 6,
                "desc": "prescaler for PLL1\nSet and cleared by software to configure the prescaler of the PLL1.\nThe hardware does not allow any modification of this prescaler when PLL1 is enabled (PLL1ON = 1 or PLL1RDY = 1).\nIn order to save power when PLL1 is not used, the value of DIVM1 must be set to 0.\n...\n..."
            },
            {
                "name": "PLL1PEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "PLL1 DIVP divider output enable\nSet and reset by software to enable the pll1_p_ck output of the PLL1.\nThis bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).\nIn order to save power, when the pll1_p_ck output of the PLL1 is not used, the pll1_p_ck must be disabled."
            },
            {
                "name": "PLL1QEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "PLL1 DIVQ divider output enable\nSet and reset by software to enable the pll1_q_ck output of the PLL1.\nIn order to save power, when the pll1_q_ck output of the PLL1 is not used, the pll1_q_ck must be disabled.\nThis bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0)."
            },
            {
                "name": "PLL1REN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "PLL1 DIVR divider output enable\nSet and reset by software to enable the pll1_r_ck output of the PLL1.\nTo save power, DIVR1EN and DIVR1 bits must be set to 0 when the pll1_r_ck is not used. This bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0)."
            }
        ]
    },
    "1140984876": {
        "name": "RCC_PLL2CFGR",
        "address": 1140984876,
        "size": 32,
        "access": "",
        "desc": "RCC PLL clock source selection register ",
        "fields": [
            {
                "name": "PLL2SRC",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "DIVMx and PLLs clock source selection\nSet and reset by software to select the PLL clock source.\nThese bits can be written only when all PLLs are disabled.\nIn order to save power, when no PLL is used, the value of PLL2SRC must be set to '00'."
            },
            {
                "name": "PLL2RGE",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "PLL2 input frequency range\nSet and reset by software to select the proper reference frequency range used for PLL2. These bits must be written before enabling the PLL2."
            },
            {
                "name": "PLL2FRACEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "PLL2 fractional latch enable\nSet and reset by software to enable the pll2_p_ck output of the PLL2.\nTo save power, when the pll2_p_ck output of the PLL2 is not used, the pll2_p_ck must be disabled."
            },
            {
                "name": "PLL2VCOSEL",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "PLL2 VCO selection\nSet and reset by software to select the proper VCO frequency range used for PLL2.\nThis bit must be written before enabling the PLL2."
            },
            {
                "name": "PLL2M",
                "bitOffset": 8,
                "bitWidth": 6,
                "desc": "prescaler for PLL2\nSet and cleared by software to configure the prescaler of the PLL2.\nThe hardware does not allow any modification of this prescaler when PLL2 is enabled (PLL2ON = 1 or PLL2RDY = 1).\nIn order to save power when PLL2 is not used, the value of DIVM2 must be set to 0.\n...\n..."
            },
            {
                "name": "PLL2PEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "PLL2 DIVP divider output enable\nSet and reset by software to enable the pll2_p_ck output of the PLL2.\nTo save power, when the pll2_p_ck output of the PLL2 is not used, the pll2_p_ck must be disabled."
            },
            {
                "name": "PLL2QEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "PLL2 DIVQ divider output enable\nSet and reset by software to enable the pll2_q_ck output of the PLL2.\nTo save power, when the pll2_q_ck output of the PLL2 is not used, the pll2_q_ck must be disabled."
            },
            {
                "name": "PLL2REN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "PLL2 DIVR divider output enable\nSet and reset by software to enable the pll2_r_ck output of the PLL2.\nTo save power, DIVR2EN and DIVR2 bits must be set to 0 when the pll2_r_ck is not used."
            }
        ]
    },
    "1140984884": {
        "name": "RCC_PLL1DIVR",
        "address": 1140984884,
        "size": 32,
        "access": "",
        "desc": "RCC PLL1 dividers register ",
        "fields": [
            {
                "name": "PLL1N",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Multiplication factor for PLL1VCO\nSet and reset by software to control the multiplication factor of the VCO.\nThese bits can be written only when the PLL is disabled (PLL1ON = 0 and PLL1RDY = 0).\n...\n...\nOthers: reserved"
            },
            {
                "name": "PLL1P",
                "bitOffset": 9,
                "bitWidth": 7,
                "desc": "PLL1 DIVP division factor\nSet and reset by software to control the frequency of the pll1_p_ck clock.\nThese bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).\nNote that odd division factors are not allowed.\n..."
            },
            {
                "name": "PLL1Q",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "PLL1 DIVQ division factor\nSet and reset by software to control the frequency of the pll1_q_ck clock.\nThese bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).\n..."
            },
            {
                "name": "PLL1R",
                "bitOffset": 24,
                "bitWidth": 7,
                "desc": "PLL1 DIVR division factor\nSet and reset by software to control the frequency of the pll1_r_ck clock.\nThese bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).\n..."
            }
        ]
    },
    "1140984888": {
        "name": "RCC_PLL1FRACR",
        "address": 1140984888,
        "size": 32,
        "access": "",
        "desc": "RCC PLL1 fractional divider register ",
        "fields": [
            {
                "name": "PLL1FRACN",
                "bitOffset": 3,
                "bitWidth": 13,
                "desc": "fractional part of the multiplication factor for PLL1 VCO\nSet and reset by software to control the fractional part of the multiplication factor of the VCO. These bits can be written at any time, allowing dynamic fine-tuning of the PLL1 VCO.\nThe software must set correctly these bits to insure that the VCO output frequency is between its valid frequency range, that is:\n* 128 to 560 MHz if PLL1VCOSEL = 0\n* \t150 to 420 MHz if PLL1VCOSEL = 1\nVCO output frequency = Fref1_ck x (PLL1N + (PLL1FRACN / 213)), with\n* \tPLL1N between 8 and 420\n* \tPLL1FRACN can be between 0 and 213- 1\n* \tThe input frequency Fref1_ck must be between 1 and 16 MHz.\nTo change the PLL1FRACN value on-the-fly even if the PLL is enabled, the application must proceed as follows:\n* \tSet the bit PLL1FRACEN to 0\n* \tWrite the new fractional value into PLL1FRACN\n* \tSet the bit PLL1FRACEN to 1"
            }
        ]
    },
    "1140984892": {
        "name": "RCC_PLL2DIVR",
        "address": 1140984892,
        "size": 32,
        "access": "",
        "desc": "RCC PLL1 dividers register ",
        "fields": [
            {
                "name": "PLL2N",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Multiplication factor for PLL2VCO\nSet and reset by software to control the multiplication factor of the VCO.\nThese bits can be written only when the PLL is disabled (PLL2ON = 0 and PLL2RDY = 0).\n...\n...\nOthers: reserved"
            },
            {
                "name": "PLL2P",
                "bitOffset": 9,
                "bitWidth": 7,
                "desc": "PLL2 DIVP division factor\nSet and reset by software to control the frequency of the pll2_p_ck clock.\nThese bits can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0).\n..."
            },
            {
                "name": "PLL2Q",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "PLL2 DIVQ division factor\nSet and reset by software to control the frequency of the pll2_q_ck clock.\nThese bits can be written only when the PLL2 is disabled (PLL2ON = 0 and PLL2RDY = 0).\n..."
            },
            {
                "name": "PLL2R",
                "bitOffset": 24,
                "bitWidth": 7,
                "desc": "PLL2 DIVR division factor\nSet and reset by software to control the frequency of the pll2_r_ck clock.\nThese bits can be written only when the PLL1 is disabled (PLL2ON = 0 and PLL2RDY = 0).\n..."
            }
        ]
    },
    "1140984896": {
        "name": "RCC_PLL2FRACR",
        "address": 1140984896,
        "size": 32,
        "access": "",
        "desc": "RCC PLL2 fractional divider register ",
        "fields": [
            {
                "name": "PLL2FRACN",
                "bitOffset": 3,
                "bitWidth": 13,
                "desc": "fractional part of the multiplication factor for PLL2 VCO\nSet and reset by software to control the fractional part of the multiplication factor of the VCO. These bits can be written at any time, allowing dynamic fine-tuning of the PLL2 VCO.\nThe software must set correctly these bits to insure that the VCO output frequency is between its valid frequency range, that is:\n* 128 to 560 MHz if PLL2VCOSEL = 0\n* \t150 to 420 MHz if PLL2VCOSEL = 1\nVCO output frequency = Fref2_ck x (PLL2N + (PLL2FRACN / 213)), with\n* \tPLL2N between 8 and 420\n* \tPLL2FRACN can be between 0 and 213- 1\n* \tThe input frequency Fref2_ck must be between 1 and 16 MHz.\nTo change the PLL2FRACN value on-the-fly even if the PLL is enabled, the application must proceed as follows:\n* \tSet the bit PLL2FRACEN to 0\n* \tWrite the new fractional value into PLL2FRACN\n* \tSet the bit PLL2FRACEN to 1"
            }
        ]
    },
    "1140984912": {
        "name": "RCC_CIER",
        "address": 1140984912,
        "size": 32,
        "access": "",
        "desc": "RCC clock source interrupt enable register ",
        "fields": [
            {
                "name": "LSIRDYIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI ready interrupt enable\nSet and reset by software to enable/disable interrupt caused by the LSI oscillator stabilization."
            },
            {
                "name": "LSERDYIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt enable\nSet and reset by software to enable/disable interrupt caused by the LSE oscillator stabilization."
            },
            {
                "name": "CSIRDYIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CSI ready interrupt enable\nSet and reset by software to enable/disable interrupt caused by the CSI oscillator stabilization."
            },
            {
                "name": "HSIRDYIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI ready interrupt enable\nSet and reset by software to enable/disable interrupt caused by the HSI oscillator stabilization."
            },
            {
                "name": "HSERDYIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE ready interrupt enable\nSet and reset by software to enable/disable interrupt caused by the HSE oscillator stabilization."
            },
            {
                "name": "HSI48RDYIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "HSI48 ready interrupt enable\nSet and reset by software to enable/disable interrupt caused by the HSI48 oscillator stabilization."
            },
            {
                "name": "PLL1RDYIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "PLL1 ready interrupt enable\nSet and reset by software to enable/disable interrupt caused by PLL1 lock."
            },
            {
                "name": "PLL2RDYIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "PLL2 ready interrupt enable\nSet and reset by software to enable/disable interrupt caused by PLL2 lock."
            }
        ]
    },
    "1140984916": {
        "name": "RCC_CIFR",
        "address": 1140984916,
        "size": 32,
        "access": "",
        "desc": "RCC clock source interrupt flag register ",
        "fields": [
            {
                "name": "LSIRDYF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI ready interrupt flag\nReset by software by writing LSIRDYC bit.\nSet by hardware when the LSI clock becomes stable and LSIRDYIE is set."
            },
            {
                "name": "LSERDYF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt flag\nReset by software by writing LSERDYC bit.\nSet by hardware when the LSE clock becomes stable and LSERDYIE is set."
            },
            {
                "name": "CSIRDYF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CSI ready interrupt flag\nReset by software by writing CSIRDYC bit.\nSet by hardware when the CSI clock becomes stable and CSIRDYIE is set."
            },
            {
                "name": "HSIRDYF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI ready interrupt flag\nReset by software by writing HSIRDYC bit.\nSet by hardware when the HSI clock becomes stable and HSIRDYIE is set."
            },
            {
                "name": "HSERDYF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE ready interrupt flag\nReset by software by writing HSERDYC bit.\nSet by hardware when the HSE clock becomes stable and HSERDYIE is set."
            },
            {
                "name": "HSI48RDYF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "HSI48 ready interrupt flag\nReset by software by writing HSI48RDYC bit.\nSet by hardware when the HSI48 clock becomes stable and HSI48RDYIE is set."
            },
            {
                "name": "PLL1RDYF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "PLL1 ready interrupt flag\nReset by software by writing PLL1RDYC bit.\nSet by hardware when the PLL1 locks and PLL1RDYIE is set."
            },
            {
                "name": "PLL2RDYF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "PLL2 ready interrupt flag\nReset by software by writing PLL2RDYC bit.\nSet by hardware when the PLL2 locks and PLL2RDYIE is set."
            },
            {
                "name": "HSECSSF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "HSE clock security system interrupt flag\nReset by software by writing HSECSSC bit.\nSet by hardware in case of HSE clock failure."
            }
        ]
    },
    "1140984920": {
        "name": "RCC_CICR",
        "address": 1140984920,
        "size": 32,
        "access": "",
        "desc": "RCC clock source interrupt clear register ",
        "fields": [
            {
                "name": "LSIRDYC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI ready interrupt clear\nSet by software to clear LSIRDYF.\nReset by hardware when clear done."
            },
            {
                "name": "LSERDYC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt clear\nSet by software to clear LSERDYF.\nReset by hardware when clear done."
            },
            {
                "name": "CSIRDYC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "HSI ready interrupt clear\nSet by software to clear CSIRDYF.\nReset by hardware when clear done."
            },
            {
                "name": "HSIRDYC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI ready interrupt clear\nSet by software to clear HSIRDYF.\nReset by hardware when clear done."
            },
            {
                "name": "HSERDYC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE ready interrupt clear\nSet by software to clear HSERDYF.\nReset by hardware when clear done."
            },
            {
                "name": "HSI48RDYC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "HSI48 ready interrupt clear\nSet by software to clear HSI48RDYF.\nReset by hardware when clear done."
            },
            {
                "name": "PLL1RDYC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "PLL1 ready interrupt clear\nSet by software to clear PLL1RDYF.\nReset by hardware when clear done."
            },
            {
                "name": "PLL2RDYC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "PLL2 ready interrupt clear\nSet by software to clear PLL2RDYF.\nReset by hardware when clear done."
            },
            {
                "name": "HSECSSC",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "HSE clock security system interrupt clear\nSet by software to clear HSECSSF.\nReset by hardware when clear done."
            }
        ]
    },
    "1140984928": {
        "name": "RCC_AHB1RSTR",
        "address": 1140984928,
        "size": 32,
        "access": "",
        "desc": "RCC AHB1 reset register ",
        "fields": [
            {
                "name": "GPDMA1RST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPDMA1 block reset\nSet and reset by software."
            },
            {
                "name": "GPDMA2RST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "GPDMA2 block reset\nSet and reset by software."
            },
            {
                "name": "CRCRST",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC block reset Set and reset by software."
            },
            {
                "name": "RAMCFGRST",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "RAMCFG block reset\nSet and reset by software."
            }
        ]
    },
    "1140984932": {
        "name": "RCC_AHB2RSTR",
        "address": 1140984932,
        "size": 32,
        "access": "",
        "desc": "RCC AHB2 peripheral reset register ",
        "fields": [
            {
                "name": "GPIOARST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPIOA block reset\nSet and reset by software."
            },
            {
                "name": "GPIOBRST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "GPIOB block reset\nSet and reset by software."
            },
            {
                "name": "GPIOCRST",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "GPIOC block reset\nSet and reset by software."
            },
            {
                "name": "GPIODRST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "GPIOD block reset\nSet and reset by software."
            },
            {
                "name": "GPIOHRST",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "GPIOH block reset\nSet and reset by software."
            },
            {
                "name": "ADC1RST",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "ADC1 block reset\nSet and reset by software."
            },
            {
                "name": "DAC12RST",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "DAC block reset\nSet and reset by software."
            },
            {
                "name": "HASHRST",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "HASH block reset\nSet and reset by software."
            },
            {
                "name": "RNGRST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "RNG block reset\nSet and reset by software."
            }
        ]
    },
    "1140984948": {
        "name": "RCC_APB1LRSTR",
        "address": 1140984948,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 peripheral low reset register ",
        "fields": [
            {
                "name": "TIM2RST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 block reset\nSet and reset by software."
            },
            {
                "name": "TIM3RST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 block reset\nSet and reset by software."
            },
            {
                "name": "TIM6RST",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 block reset\nSet and reset by software."
            },
            {
                "name": "TIM7RST",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 block reset\nSet and reset by software."
            },
            {
                "name": "OPAMPRST",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "OPAMP block reset\nSet and reset by software."
            },
            {
                "name": "SPI2RST",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SPI2 block reset\nSet and reset by software."
            },
            {
                "name": "SPI3RST",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SPI3 block reset\nSet and reset by software."
            },
            {
                "name": "COMPRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "COMP block reset\nSet and reset by software."
            },
            {
                "name": "USART2RST",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 block reset\nSet and reset by software."
            },
            {
                "name": "USART3RST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "USART3 block reset\nSet and reset by software."
            },
            {
                "name": "I2C1RST",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 block reset\nSet and reset by software."
            },
            {
                "name": "I2C2RST",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C2 block reset\nSet and reset by software."
            },
            {
                "name": "I3C1RST",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "I3C1 block reset\nSet and reset by software."
            },
            {
                "name": "CRSRST",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "CRS block reset\nSet and reset by software."
            }
        ]
    },
    "1140984952": {
        "name": "RCC_APB1HRSTR",
        "address": 1140984952,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 peripheral high reset register ",
        "fields": [
            {
                "name": "DTSRST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "DTS block reset\nSet and reset by software."
            },
            {
                "name": "LPTIM2RST",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LPTIM2 block reset\nSet and reset by software."
            },
            {
                "name": "FDCAN1RST",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "FDCAN1 block reset\nSet and reset by software."
            }
        ]
    },
    "1140984956": {
        "name": "RCC_APB2RSTR",
        "address": 1140984956,
        "size": 32,
        "access": "",
        "desc": "RCC APB2 peripheral reset register ",
        "fields": [
            {
                "name": "TIM1RST",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 block reset\nSet and reset by software."
            },
            {
                "name": "SPI1RST",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 block reset\nSet and reset by software."
            },
            {
                "name": "USART1RST",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 block reset\nSet and reset by software."
            },
            {
                "name": "USBFSRST",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "USBFS block reset\nSet and reset by software."
            }
        ]
    },
    "1140984960": {
        "name": "RCC_APB3RSTR",
        "address": 1140984960,
        "size": 32,
        "access": "",
        "desc": "RCC APB3 peripheral reset register ",
        "fields": [
            {
                "name": "SBSRST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SBS block reset\nSet and reset by software."
            },
            {
                "name": "LPUART1RST",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LPUART1 block reset\nSet and reset by software."
            },
            {
                "name": "I3C2RST",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "I3C2RST block reset\nSet and reset by software."
            },
            {
                "name": "LPTIM1RST",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "LPTIM1 block reset\nSet and reset by software."
            },
            {
                "name": "VREFRST",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "VREF block reset\nSet and reset by software."
            }
        ]
    },
    "1140984968": {
        "name": "RCC_AHB1ENR",
        "address": 1140984968,
        "size": 32,
        "access": "",
        "desc": "RCC AHB1 peripherals clock register ",
        "fields": [
            {
                "name": "GPDMA1EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPDMA1 clock enable\nSet and reset by software."
            },
            {
                "name": "GPDMA2EN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "GPDMA2 clock enable\nSet and reset by software."
            },
            {
                "name": "FLITFEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Flash interface clock enable\nSet and reset by software."
            },
            {
                "name": "CRCEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC clock enable\nSet and reset by software."
            },
            {
                "name": "RAMCFGEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "RAMCFG clock enable\nSet and reset by software."
            },
            {
                "name": "BKPRAMEN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "BKPRAM clock enable\nSet and reset by software"
            },
            {
                "name": "SRAM1EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "SRAM1 clock enable\nSet and reset by software."
            }
        ]
    },
    "1140984972": {
        "name": "RCC_AHB2ENR",
        "address": 1140984972,
        "size": 32,
        "access": "",
        "desc": "RCC AHB2 peripheral clock register ",
        "fields": [
            {
                "name": "GPIOAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPIOA clock enable\nSet and reset by software."
            },
            {
                "name": "GPIOBEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "GPIOB clock enable\nSet and reset by software."
            },
            {
                "name": "GPIOCEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "GPIOC clock enable\nSet and reset by software."
            },
            {
                "name": "GPIODEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "GPIOD clock enable\nSet and reset by software."
            },
            {
                "name": "GPIOHEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "GPIOH clock enable\nSet and reset by software."
            },
            {
                "name": "ADC1EN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "ADC1 peripherals clock enabled\nSet and reset by software."
            },
            {
                "name": "DAC12EN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "DAC clock enable\nSet and reset by software."
            },
            {
                "name": "HASHEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "HASH clock enable\nSet and reset by software."
            },
            {
                "name": "RNGEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "RNG clock enable\nSet and reset by software."
            },
            {
                "name": "SRAM2EN",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "SRAM2 clock enable\nSet and reset by software."
            }
        ]
    },
    "1140984988": {
        "name": "RCC_APB1LENR",
        "address": 1140984988,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 peripheral clock register ",
        "fields": [
            {
                "name": "TIM2EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 clock enable\nSet and reset by software."
            },
            {
                "name": "TIM3EN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 clock enable\nSet and reset by software."
            },
            {
                "name": "TIM6EN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 clock enable\nSet and reset by software."
            },
            {
                "name": "TIM7EN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 clock enable\nSet and reset by software."
            },
            {
                "name": "WWDGEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "WWDG clock enable\nSet and reset by software."
            },
            {
                "name": "OPAMPEN",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "OPAMP clock enable\nSet and reset by software."
            },
            {
                "name": "SPI2EN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SPI2 clock enable\nSet and reset by software."
            },
            {
                "name": "SPI3EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SPI3 clock enable\nSet and reset by software."
            },
            {
                "name": "COMPEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "COMP clock enable\nSet and reset by software."
            },
            {
                "name": "USART2EN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 clock enable\nSet and reset by software."
            },
            {
                "name": "USART3EN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "USART3 clock enable\nSet and reset by software."
            },
            {
                "name": "I2C1EN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 clock enable\nSet and reset by software."
            },
            {
                "name": "I2C2EN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C2 clock enable\nSet and reset by software."
            },
            {
                "name": "I3C1EN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "I3C1 clock enable\nSet and reset by software."
            },
            {
                "name": "CRSEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "CRS clock enable\nSet and reset by software."
            }
        ]
    },
    "1140984992": {
        "name": "RCC_APB1HENR",
        "address": 1140984992,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 peripheral clock register ",
        "fields": [
            {
                "name": "DTSEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "DTS clock enable\nSet and reset by software."
            },
            {
                "name": "LPTIM2EN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LPTIM2 clock enable\nSet and reset by software."
            },
            {
                "name": "FDCAN1EN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "FDCAN1 peripheral clock enable\nSet and reset by software."
            }
        ]
    },
    "1140984996": {
        "name": "RCC_APB2ENR",
        "address": 1140984996,
        "size": 32,
        "access": "",
        "desc": "RCC APB2 peripheral clock register ",
        "fields": [
            {
                "name": "TIM1EN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 clock enable\nSet and reset by software."
            },
            {
                "name": "SPI1EN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 clock enable\nSet and reset by software."
            },
            {
                "name": "USART1EN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 clock enable\nSet and reset by software."
            },
            {
                "name": "USBFSEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "USBFS clock enable\nSet and reset by software."
            }
        ]
    },
    "1140985000": {
        "name": "RCC_APB3ENR",
        "address": 1140985000,
        "size": 32,
        "access": "",
        "desc": "RCC APB3 peripheral clock register ",
        "fields": [
            {
                "name": "SBSEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SBS clock enable\nSet and reset by software."
            },
            {
                "name": "LPUART1EN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LPUART1 clock enable\nSet and reset by software."
            },
            {
                "name": "I3C2EN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "I3C2EN clock enable\nSet and reset by software."
            },
            {
                "name": "LPTIM1EN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "LPTIM1 clock enable\nSet and reset by software."
            },
            {
                "name": "VREFEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "VREF clock enable\nSet and reset by software."
            },
            {
                "name": "RTCAPBEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "RTC APB interface clock enable\nSet and reset by software."
            }
        ]
    },
    "1140985008": {
        "name": "RCC_AHB1LPENR",
        "address": 1140985008,
        "size": 32,
        "access": "",
        "desc": "RCC AHB1 sleep clock register ",
        "fields": [
            {
                "name": "GPDMA1LPEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPDMA1 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "GPDMA2LPEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "GPDMA2 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "FLITFLPEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Flash interface (FLITF) clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "CRCLPEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "RAMCFGLPEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "RAMCFG clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "BKPRAMLPEN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "BKPRAM clock enable during sleep mode\nSet and reset by software"
            },
            {
                "name": "ICACHELPEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "ICACHE clock enable during sleep mode\nSet and reset by software"
            },
            {
                "name": "SRAM1LPEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "SRAM1 clock enable during sleep mode\nSet and reset by software"
            }
        ]
    },
    "1140985012": {
        "name": "RCC_AHB2LPENR",
        "address": 1140985012,
        "size": 32,
        "access": "",
        "desc": "RCC AHB2 sleep clock register ",
        "fields": [
            {
                "name": "GPIOALPEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPIOA clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "GPIOBLPEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "GPIOB clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "GPIOCLPEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "GPIOC clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "GPIODLPEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "GPIOD clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "GPIOHLPEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "GPIOH clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "ADC1LPEN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "ADC1 peripherals clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "DAC12LPEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "DAC clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "HASHLPEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "HASH clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "RNGLPEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "RNG clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "SRAM2LPEN",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "SRAM2 clock enable during sleep mode\nSet and reset by software."
            }
        ]
    },
    "1140985028": {
        "name": "RCC_APB1LLPENR",
        "address": 1140985028,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 sleep clock register ",
        "fields": [
            {
                "name": "TIM2LPEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "TIM3LPEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "TIM6LPEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "TIM7LPEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "WWDGLPEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "WWDG clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "OPAMPLPEN",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "OPAMP clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "SPI2LPEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SPI2 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "SPI3LPEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SPI3 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "COMPLPEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "COMP clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "USART2LPEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "USART3LPEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "USART3 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "I2C1LPEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "I2C2LPEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C2 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "I3C1LPEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "I3C1 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "CRSLPEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "CRS clock enable during sleep mode\nSet and reset by software."
            }
        ]
    },
    "1140985032": {
        "name": "RCC_APB1HLPENR",
        "address": 1140985032,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 sleep clock register ",
        "fields": [
            {
                "name": "DTSLPEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "DTS clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "LPTIM2LPEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LPTIM2 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "FDCAN1LPEN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "FDCAN1 peripheral clock enable during sleep mode\nSet and reset by software."
            }
        ]
    },
    "1140985036": {
        "name": "RCC_APB2LPENR",
        "address": 1140985036,
        "size": 32,
        "access": "",
        "desc": "RCC APB2 sleep clock register ",
        "fields": [
            {
                "name": "TIM1LPEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "SPI1LPEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "USART1LPEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "USBFSLPEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "USBFS clock enable during sleep mode\nSet and reset by software."
            }
        ]
    },
    "1140985040": {
        "name": "RCC_APB3LPENR",
        "address": 1140985040,
        "size": 32,
        "access": "",
        "desc": "RCC APB3 sleep clock register ",
        "fields": [
            {
                "name": "SBSLPEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SBS clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "LPUART1LPEN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LPUART1 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "I3C2LPEN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "I3C2 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "LPTIM1LPEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "LPTIM1 clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "VREFLPEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "VREF clock enable during sleep mode\nSet and reset by software."
            },
            {
                "name": "RTCAPBLPEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "RTC APB interface clock enable during sleep mode\nSet and reset by software."
            }
        ]
    },
    "1140985048": {
        "name": "RCC_CCIPR1",
        "address": 1140985048,
        "size": 32,
        "access": "",
        "desc": "RCC kernel clock configuration register ",
        "fields": [
            {
                "name": "USART1SEL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "USART1 kernel clock source selection\nSet and reset by software.\nothers: reserved, the kernel clock is disabled"
            },
            {
                "name": "USART2SEL",
                "bitOffset": 3,
                "bitWidth": 3,
                "desc": "USART2 kernel clock source selection\nSet and reset by software.\nothers: reserved, the kernel clock is disabled"
            },
            {
                "name": "USART3SEL",
                "bitOffset": 6,
                "bitWidth": 3,
                "desc": "USART3 kernel clock source selection\nSet and reset by software.\nothers: reserved, the kernel clock is disabled"
            },
            {
                "name": "TIMICSEL",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "TIM2, TIM3 and LPTIM2 input capture source selection\nSet and reset by software."
            }
        ]
    },
    "1140985052": {
        "name": "RCC_CCIPR2",
        "address": 1140985052,
        "size": 32,
        "access": "",
        "desc": "RCC kernel clock configuration register ",
        "fields": [
            {
                "name": "LPTIM1SEL",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "LPTIM1 kernel clock source selection\nothers: reserved, the kernel clock is disabled"
            },
            {
                "name": "LPTIM2SEL",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "LPTIM2 kernel clock source selection\nothers: reserved, the kernel clock is disabled"
            }
        ]
    },
    "1140985056": {
        "name": "RCC_CCIPR3",
        "address": 1140985056,
        "size": 32,
        "access": "",
        "desc": "RCC kernel clock configuration register ",
        "fields": [
            {
                "name": "SPI1SEL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "SPI1 kernel clock source selection\nSet and reset by software.\nothers: reserved, the kernel clock is disabled"
            },
            {
                "name": "SPI2SEL",
                "bitOffset": 3,
                "bitWidth": 3,
                "desc": "SPI2 kernel clock source selection\nSet and reset by software.\nothers: reserved, the kernel clock is disabled"
            },
            {
                "name": "SPI3SEL",
                "bitOffset": 6,
                "bitWidth": 3,
                "desc": "SPI3 kernel clock source selection\nSet and reset by software.\nothers: reserved, the kernel clock is disabled"
            },
            {
                "name": "LPUART1SEL",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "LPUART1 kernel clock source selection\nothers: reserved, the kernel clock is disabled"
            }
        ]
    },
    "1140985060": {
        "name": "RCC_CCIPR4",
        "address": 1140985060,
        "size": 32,
        "access": "",
        "desc": "RCC kernel clock configuration register ",
        "fields": [
            {
                "name": "SYSTICKSEL",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "SYSTICK clock source selection\nNote: rcc_hclk frequency must be four times higher than\nlsi_ker_ck/lse_ck (period (LSI/LSE) greater than or equal 4 * period (HCLK)."
            },
            {
                "name": "USBFSSEL",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "USBFS kernel clock source selection"
            },
            {
                "name": "I2C1SEL",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "I2C1 kernel clock source selection"
            },
            {
                "name": "I2C2SEL",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "I2C2 kernel clock source selection"
            },
            {
                "name": "I3C1SEL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "I3C1 kernel clock source selection"
            },
            {
                "name": "I3C2SEL",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "I3C2 kernel clock source selection"
            }
        ]
    },
    "1140985064": {
        "name": "RCC_CCIPR5",
        "address": 1140985064,
        "size": 32,
        "access": "",
        "desc": "RCC kernel clock configuration register ",
        "fields": [
            {
                "name": "ADCDACSEL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "ADC and DAC kernel clock source selection\nothers: reserved, the kernel clock is disabled"
            },
            {
                "name": "DAC1SEL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "DAC1 sample and hold clock source selection"
            },
            {
                "name": "RNGSEL",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "RNG kernel clock source selection"
            },
            {
                "name": "FDCAN1SEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "FDCAN1 kernel clock source selection"
            },
            {
                "name": "CKPERSEL",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "per_ck clock source selection"
            }
        ]
    },
    "1140985072": {
        "name": "RCC_BDCR",
        "address": 1140985072,
        "size": 32,
        "access": "",
        "desc": "RCC Backup domain control register ",
        "fields": [
            {
                "name": "LSEON",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSE oscillator enabled\nSet and reset by software."
            },
            {
                "name": "LSERDY",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE oscillator ready\nSet and reset by hardware to indicate when the LSE is stable.\nThis bit needs 6 cycles of lse_ck clock to fall down after LSEON has been set to 0."
            },
            {
                "name": "LSEBYP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "LSE oscillator bypass\nSet and reset by software to bypass oscillator in debug mode. This bit must not be written when the LSE is enabled (by LSEON) or ready (LSERDY = 1)"
            },
            {
                "name": "LSEDRV",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "LSE oscillator driving capability\nSet by software to select the driving capability of the LSE oscillator.\nThese bit can be written only if LSE oscillator is disabled (LSEON = 0 and LSERDY = 0)."
            },
            {
                "name": "LSECSSON",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LSE clock security system enable\nSet by software to enable the clock security system on 32 kHz oscillator.\nLSECSSON must be enabled after LSE is enabled (LSEON enabled) and ready (LSERDY set by hardware) and after RTCSEL is selected.\nOnce enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD = 1). In that case the software must disable LSECSSON."
            },
            {
                "name": "LSECSSD",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LSE clock security system failure detection\nSet by hardware to indicate when a failure has been detected by the clock security system on the external 32 kHz oscillator."
            },
            {
                "name": "LSEEXT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "low-speed external clock type in bypass mode\nSet and reset by software to select the external clock type (analog or digital).\nThe external clock must be enabled with the LSEON bit, to be used by the device.\nThe LSEEXT bit can be written only if the LSE oscillator is disabled."
            },
            {
                "name": "RTCSEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "RTC clock source selection\nSet by software to select the clock source for the RTC.\nThese bits can be written only one time (except in case of failure detection on LSE).\nThese bits must be written before LSECSSON is enabled.\nThe VSWRST bit can be used to reset them, then it can be written one time again.\nIf HSE is selected as RTC clock, this clock is lost when the system is in Stop mode or in case of a pin reset (NRST)."
            },
            {
                "name": "RTCEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "RTC clock enable\nSet and reset by software."
            },
            {
                "name": "VSWRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "VSwitch domain software reset\nSet and reset by software."
            },
            {
                "name": "LSCOEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low-speed clock output (LSCO) enable\nSet and cleared by software."
            },
            {
                "name": "LSCOSEL",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Low-speed clock output selection\nSet and cleared by software."
            },
            {
                "name": "LSION",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "LSI oscillator enable\nSet and cleared by software."
            },
            {
                "name": "LSIRDY",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "LSI oscillator ready\nSet and cleared by hardware to indicate when the LSI oscillator is stable.\nAfter the LSION bit is cleared, LSIRDY goes low after three internal low-speed oscillator clock cycles.\nThis bit is set when the LSI is used by IWDG or RTC, even if LSION = 0."
            }
        ]
    },
    "1140985076": {
        "name": "RCC_RSR",
        "address": 1140985076,
        "size": 32,
        "access": "",
        "desc": "RCC reset status register ",
        "fields": [
            {
                "name": "RMVF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "remove reset flag\nSet and reset by software to reset the value of the reset flags."
            },
            {
                "name": "PINRSTF",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "pin reset flag (NRST)\nReset by software by writing the RMVF bit.\nSet by hardware when a reset from pin occurs."
            },
            {
                "name": "BORRSTF",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "BOR reset flag\nReset by software by writing the RMVF bit.\nSet by hardware when a BOR reset occurs (pwr_bor_rst)."
            },
            {
                "name": "SFTRSTF",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "system reset from CPU reset flag\nReset by software by writing the RMVF bit.\nSet by hardware when the system reset is due to CPU.The CPU can generate a system reset by writing SYSRESETREQ bit of AIRCR register of the core M33."
            },
            {
                "name": "IWDGRSTF",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "independent watchdog reset flag\nReset by software by writing the RMVF bit.\nSet by hardware when an independent watchdog reset occurs."
            },
            {
                "name": "WWDGRSTF",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "window watchdog reset flag\nReset by software by writing the RMVF bit.\nSet by hardware when a window watchdog reset occurs."
            },
            {
                "name": "LPWRRSTF",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Low-power reset flag\nSet by hardware when a reset occurs due to Stop or Standby mode entry, whereas the corresponding nRST_STOP, nRST_STBY option bit is cleared.\nCleared by writing to the RMVF bit."
            }
        ]
    },
    "1108084736": {
        "name": "RNG_CR",
        "address": 1108084736,
        "size": 32,
        "access": "",
        "desc": "RNG control register",
        "fields": [
            {
                "name": "RNGEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "True random number generator enable"
            },
            {
                "name": "IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Interrupt Enable"
            },
            {
                "name": "CED",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clock error detection\nThe clock error detection cannot be enabled nor disabled on-the-fly when the RNG is enabled, i.e. to enable or disable CED the RNG must be disabled.\nWriting this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1."
            },
            {
                "name": "ARDIS",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto reset disable\nWhen auto-reset is enabled application still need to clear SEIS bit after a noise source error.\nWriting this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1."
            },
            {
                "name": "RNG_CONFIG3",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "RNG configuration 3\nReserved to the RNG configuration (bitfield 3). Refer to RNG_CONFIG1 bitfield for details.\nIf NISTC bit is cleared in this register RNG_CONFIG3 bitfield values are ignored by RNG."
            },
            {
                "name": "NISTC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Non NIST compliant\ntwo conditioning loops are performed and 256 bits of noise source are used.\nWriting this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1."
            },
            {
                "name": "RNG_CONFIG2",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "RNG configuration 2\nReserved to the RNG configuration (bitfield 2). Refer to RNG_CONFIG1 bitfield for details."
            },
            {
                "name": "CLKDIV",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Clock divider factor\nThis value used to configure an internal programmable divider (from 1 to 16) acting on the incoming RNG clock. These bits can be written only when the core is disabled (RNGEN = 0).\n...\nWriting these bits is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1."
            },
            {
                "name": "RNG_CONFIG1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "RNG configuration 1\nReserved to the RNG configuration (bitfield 1). Must be initialized using the recommended value documented in Section 23.6: RNG entropy source validation.\nWriting any bit of RNG_CONFIG1 is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1."
            },
            {
                "name": "CONDRST",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Conditioning soft reset\n\tWrite 1 and then write 0 to reset the conditioning logic, clear all the FIFOs and start a new RNG initialization process, with RNG_SR cleared. Registers RNG_CR and RNG_NSCR are not changed by CONDRST.\nThis bit must be set to 1 in the same access that set any configuration bits [29:4]. In other words, when CONDRST bit is set to 1 correct configuration in bits [29:4] must also be written.\nWhen CONDRST is set to 0 by software its value goes to 0 when the reset process is done. It takes about 2 AHB clock cycles + 2 RNG clock cycles."
            },
            {
                "name": "CONFIGLOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RNG Config lock\nThis bitfield is set once: if this bit is set it can only be reset to 0 if RNG is reset."
            }
        ]
    },
    "1108084740": {
        "name": "RNG_SR",
        "address": 1108084740,
        "size": 32,
        "access": "",
        "desc": "RNG status register",
        "fields": [
            {
                "name": "DRDY",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Data Ready\nOnce the output buffer becomes empty (after reading the RNG_DR register), this bit returns to 0 until a new random value is generated.\nNote: The DRDY bit can rise when the peripheral is disabled (RNGEN = 0 in the RNG_CR register).\nIf IE=1 in the RNG_CR register, an interrupt is generated when DRDY = 1."
            },
            {
                "name": "CECS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clock error current status\nNote: CECS bit is valid only if the CED bit in the RNG_CR register is set to 0."
            },
            {
                "name": "SECS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Seed error current status\nRun-time repetition count test failed (noise source has provided more than 24 consecutive bits at a constant value 0 or 1, or more than 32 consecutive occurrence of two bits patterns 01 or 10)\nStart-up or continuous adaptive proportion test on noise source failed.\nStart-up post-processing/conditioning sanity check failed."
            },
            {
                "name": "CEIS",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clock error interrupt status\nThis bit is set at the same time as CECS. It is cleared by writing 0. Writing 1 has no effect.\nAn interrupt is pending if IE = 1 in the RNG_CR register."
            },
            {
                "name": "SEIS",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Seed error interrupt status\nThis bit is set at the same time as SECS. It is cleared by writing 0 (unless CONDRST is used). Writing 1 has no effect.\nAn interrupt is pending if IE = 1 in the RNG_CR register."
            }
        ]
    },
    "1108084744": {
        "name": "RNG_DR",
        "address": 1108084744,
        "size": 32,
        "access": "",
        "desc": "RNG data register",
        "fields": [
            {
                "name": "RNDATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Random data\n32-bit random data which are valid when DRDY = 1. When DRDY = 0 RNDATA value is zero.\nIt is recommended to always verify that RNG_DR is different from zero. Because when it is the case a seed error occurred between RNG_SR polling and RND_DR output reading (rare event)."
            }
        ]
    },
    "1108084752": {
        "name": "RNG_HTCR",
        "address": 1108084752,
        "size": 32,
        "access": "",
        "desc": "RNG health test control register",
        "fields": [
            {
                "name": "HTCFG",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "health test configuration\nThis configuration is used by RNG to configure the health tests. See Section 23.6: RNG entropy source validation for the recommended value.\nNote: The RNG behavior, including the read to this register, is not guaranteed if a different value from the recommended value is written."
            }
        ]
    },
    "1140881408": {
        "name": "RTC_TR",
        "address": 1140881408,
        "size": 32,
        "access": "",
        "desc": "RTC time register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format"
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            }
        ]
    },
    "1140881412": {
        "name": "RTC_DR",
        "address": 1140881412,
        "size": 32,
        "access": "",
        "desc": "RTC date register",
        "fields": [
            {
                "name": "DU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Date units in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "MU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Month units in BCD format"
            },
            {
                "name": "MT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Month tens in BCD format"
            },
            {
                "name": "WDU",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Week day units\n..."
            },
            {
                "name": "YU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Year units in BCD format"
            },
            {
                "name": "YT",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Year tens in BCD format"
            }
        ]
    },
    "1140881416": {
        "name": "RTC_SSR",
        "address": 1140881416,
        "size": 32,
        "access": "",
        "desc": "RTC subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Synchronous binary counter\nSS[31:16]: Synchronous binary counter MSB values\nWhen Binary or Mixed mode is selected (BIN = 01 or 10 or 11):\nSS[31:16] are the 16 MSB of the SS[31:0] free-running down-counter.\nWhen BCD mode is selected (BIN=00):\nSS[31:16] are forced by hardware to 0x0000.\nSS[15:0]: Subsecond value/synchronous binary counter LSB values\nWhen Binary mode is selected (BIN = 01 or 10 or 11):\nSS[15:0] are the 16 LSB of the SS[31:0] free-running down-counter.\nWhen BCD mode is selected (BIN=00):\nSS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below:\nSecond fraction = (PREDIV_S - SS) / (PREDIV_S + 1)\nSS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR."
            }
        ]
    },
    "1140881420": {
        "name": "RTC_ICSR",
        "address": 1140881420,
        "size": 32,
        "access": "",
        "desc": "RTC initialization control and status register",
        "fields": [
            {
                "name": "WUTWF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer write flag\nThis bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode."
            },
            {
                "name": "SHPF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Shift operation pending\nThis flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect."
            },
            {
                "name": "INITS",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Initialization status flag\nThis bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state)."
            },
            {
                "name": "RSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Registers synchronization flag\nThis bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software.\nIt is cleared either by software or by hardware in initialization mode."
            },
            {
                "name": "INITF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Initialization flag\nWhen this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated."
            },
            {
                "name": "INIT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Initialization mode"
            },
            {
                "name": "BIN",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Binary mode"
            },
            {
                "name": "BCDU",
                "bitOffset": 10,
                "bitWidth": 3,
                "desc": "BCD update (BIN = 10 or 11)\nIn mixed mode when both BCD calendar and binary extended counter are used (BIN = 10 or 11), the calendar second is incremented using the SSR Least Significant Bits."
            },
            {
                "name": "RECALPF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Recalibration pending Flag\nThe RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly."
            }
        ]
    },
    "1140881424": {
        "name": "RTC_PRER",
        "address": 1140881424,
        "size": 32,
        "access": "",
        "desc": "RTC prescaler register",
        "fields": [
            {
                "name": "PREDIV_S",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Synchronous prescaler factor\nThis is the synchronous division factor:\nck_spre frequency = ck_apre frequency/(PREDIV_S+1)"
            },
            {
                "name": "PREDIV_A",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Asynchronous prescaler factor\nThis is the asynchronous division factor:\nck_apre frequency = RTCCLK frequency/(PREDIV_A+1)"
            }
        ]
    },
    "1140881428": {
        "name": "RTC_WUTR",
        "address": 1140881428,
        "size": 32,
        "access": "",
        "desc": "RTC wakeup timer register",
        "fields": [
            {
                "name": "WUT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Wakeup auto-reload value bits\nWhen the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register.\nWhen WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer.\nThe first assertion of WUTF occurs between WUT and (WUT + 2) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden."
            },
            {
                "name": "WUTOCLR",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Wakeup auto-reload output clear value\nWhen WUTOCLR[15:0] is different from 0x0000, WUTF is set by hardware when the auto-reload down-counter reaches 0 and is cleared by hardware when the auto-reload downcounter reaches WUTOCLR[15:0].\nWhen WUTOCLR[15:0] = 0x0000, WUTF is set by hardware when the WUT down-counter\nreaches 0 and is cleared by software."
            }
        ]
    },
    "1140881432": {
        "name": "RTC_CR",
        "address": 1140881432,
        "size": 32,
        "access": "",
        "desc": "RTC control register",
        "fields": [
            {
                "name": "WUCKSEL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "ck_wut wakeup clock selection\n10x: ck_spre (usually 1 Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU.\n11x: ck_spre (usually 1 Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU. Furthermore, 2sup16/sup is added to the WUT counter value."
            },
            {
                "name": "TSEDGE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp event active edge\nTSE must be reset when TSEDGE is changed to avoid unwanted TSF setting."
            },
            {
                "name": "REFCKON",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "RTC_REFIN reference clock detection enable (50 or 60 Hz)\nNote: BIN must be 0x00 and PREDIV_S must be 0x00FF."
            },
            {
                "name": "BYPSHAD",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Bypass the shadow registers\nNote: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1."
            },
            {
                "name": "FMT",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Hour format"
            },
            {
                "name": "SSRUIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "SSR underflow interrupt enable"
            },
            {
                "name": "ALRAE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Alarm A enable"
            },
            {
                "name": "ALRBE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Alarm B enable"
            },
            {
                "name": "WUTE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Wakeup timer enable\nNote: When the wakeup timer is disabled, wait for WUTWF = 1 before enabling it again."
            },
            {
                "name": "TSE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "timestamp enable"
            },
            {
                "name": "ALRAIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Alarm A interrupt enable"
            },
            {
                "name": "ALRBIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Alarm B interrupt enable"
            },
            {
                "name": "WUTIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Wakeup timer interrupt enable"
            },
            {
                "name": "TSIE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Timestamp interrupt enable"
            },
            {
                "name": "ADD1H",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Add 1 hour (summer time change)\nWhen this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0."
            },
            {
                "name": "SUB1H",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Subtract 1 hour (winter time change)\nWhen this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0.\nSetting this bit has no effect when current hour is 0."
            },
            {
                "name": "BKP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Backup\nThis bit can be written by the user to memorize whether the daylight saving time change has been performed or not."
            },
            {
                "name": "COSEL",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Calibration output selection\nWhen COE = 1, this bit selects which signal is output on CALIB.\nThese frequencies are valid for RTCCLK at 32.768 kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to Section 31.3.17: Calibration clock output."
            },
            {
                "name": "POL",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Output polarity\nThis bit is used to configure the polarity of TAMPALRM output."
            },
            {
                "name": "OSEL",
                "bitOffset": 21,
                "bitWidth": 2,
                "desc": "Output selection\nThese bits are used to select the flag to be routed to TAMPALRM output."
            },
            {
                "name": "COE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Calibration output enable\nThis bit enables the CALIB output"
            },
            {
                "name": "ITSE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "timestamp on internal event enable"
            },
            {
                "name": "TAMPTS",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Activate timestamp on tamper detection event\nTAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set up to 3 ck_apre cycles after the tamper flags."
            },
            {
                "name": "TAMPOE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Tamper detection output enable on TAMPALRM"
            },
            {
                "name": "ALRAFCLR",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Alarm A flag automatic clear"
            },
            {
                "name": "ALRBFCLR",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Alarm B flag automatic clear"
            },
            {
                "name": "TAMPALRM_PU",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "TAMPALRM pull-up enable"
            },
            {
                "name": "TAMPALRM_TYPE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TAMPALRM output type"
            },
            {
                "name": "OUT2EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RTC_OUT2 output enable\nWith this bit set, the RTC outputs can be remapped on RTC_OUT2 as follows:\nOUT2EN = 0: RTC output 2 disable\nIf OSEL different  00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1\nIf OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT1\nOUT2EN = 1: RTC output 2 enable\nIf (OSEL different  00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2\nIf OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT2\nIf (OSEL different  00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1."
            }
        ]
    },
    "1140881436": {
        "name": "RTC_PRIVCFGR",
        "address": 1140881436,
        "size": 32,
        "access": "",
        "desc": "RTC privilege mode control register",
        "fields": [
            {
                "name": "ALRAPRIV",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A and SSR underflow privilege protection"
            },
            {
                "name": "ALRBPRIV",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B privilege protection"
            },
            {
                "name": "WUTPRIV",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer privilege protection"
            },
            {
                "name": "TSPRIV",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp privilege protection"
            },
            {
                "name": "CALPRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Shift register, Delight saving, calibration and reference clock privilege protection"
            },
            {
                "name": "INITPRIV",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Initialization privilege protection"
            },
            {
                "name": "PRIV",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "RTC privilege protection"
            }
        ]
    },
    "1140881444": {
        "name": "RTC_WPR",
        "address": 1140881444,
        "size": 32,
        "access": "",
        "desc": "RTC write protection register",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Write protection key\nThis byte is written by software.\nReading this byte always returns 0x00.\nRefer to RTC register write protection for a description of how to unlock RTC register write protection."
            }
        ]
    },
    "1140881448": {
        "name": "RTC_CALR",
        "address": 1140881448,
        "size": 32,
        "access": "",
        "desc": "RTC calibration register",
        "fields": [
            {
                "name": "CALM",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Calibration minus\nThe frequency of the calendar is reduced by masking CALM out of 2sup20/sup RTCCLK pulses (32 seconds if the input frequency is 32768 Hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm.\nTo increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section 31.3.15: RTC smooth digital calibration on page 1092."
            },
            {
                "name": "LPCAL",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "RTC low-power mode"
            },
            {
                "name": "CALW16",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Use a 16-second calibration cycle period\nWhen CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1.\nNote: CALM[0] is stuck at 0 when CALW16 = 1. Refer to Section 31.3.15: RTC smooth digital calibration."
            },
            {
                "name": "CALW8",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Use an 8-second calibration cycle period\nWhen CALW8 is set to 1, the 8-second calibration cycle period is selected.\nNote: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to Section 31.3.15: RTC smooth digital calibration."
            },
            {
                "name": "CALP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Increase frequency of RTC by 488.5 ppm\nThis feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution.\nRefer to Section 31.3.15: RTC smooth digital calibration."
            }
        ]
    },
    "1140881452": {
        "name": "RTC_SHIFTR",
        "address": 1140881452,
        "size": 32,
        "access": "",
        "desc": "RTC shift control register",
        "fields": [
            {
                "name": "SUBFS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Subtract a fraction of a second\nThese bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThe value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by:\nDelay (seconds) = SUBFS / (PREDIV_S + 1)\nA fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by:\nAdvance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))).\nIn mixed BCD-binary mode (BIN=10 or 11), the SUBFS[14:BCDU+8] must be written with 0.\nNote: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time."
            },
            {
                "name": "ADD1S",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Add one second\nThis bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThis function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation."
            }
        ]
    },
    "1140881456": {
        "name": "RTC_TSTR",
        "address": 1140881456,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp time register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format."
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format."
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format."
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format."
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format."
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format."
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            }
        ]
    },
    "1140881460": {
        "name": "RTC_TSDR",
        "address": 1140881460,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp date register",
        "fields": [
            {
                "name": "DU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Date units in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "MU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Month units in BCD format"
            },
            {
                "name": "MT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Month tens in BCD format"
            },
            {
                "name": "WDU",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Week day units"
            }
        ]
    },
    "1140881464": {
        "name": "RTC_TSSSR",
        "address": 1140881464,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Subsecond value/synchronous binary counter values\nSS[31:0] is the value of the synchronous prescaler counter when the timestamp event occurred."
            }
        ]
    },
    "1140881472": {
        "name": "RTC_ALRMAR",
        "address": 1140881472,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format."
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format."
            },
            {
                "name": "MSK1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Alarm A seconds mask"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "MSK2",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Alarm A minutes mask"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            },
            {
                "name": "MSK3",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Alarm A hours mask"
            },
            {
                "name": "DU",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Date units or day in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "WDSEL",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Week day selection"
            },
            {
                "name": "MSK4",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Alarm A date mask"
            }
        ]
    },
    "1140881476": {
        "name": "RTC_ALRMASSR",
        "address": 1140881476,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Subseconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.\nThis field is the mirror of SS[14:0] in the RTC_ALRMABINR, and so can also be read or written through RTC_ALRMABINR."
            },
            {
                "name": "MASKSS",
                "bitOffset": 24,
                "bitWidth": 6,
                "desc": "Mask the most-significant bits starting at this bit\n...\nFrom 32 to 63: All 32 SS bits are compared and must match to activate alarm.\nNote: In BCD mode (BIN=00) the overflow bits of the synchronous counter (bits 31:15) are never compared. These bits can be different from 0 only after a shift operation."
            },
            {
                "name": "SSCLR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Clear synchronous counter on alarm (Binary mode only)\nNote: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11)."
            }
        ]
    },
    "1140881480": {
        "name": "RTC_ALRMBR",
        "address": 1140881480,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format"
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format"
            },
            {
                "name": "MSK1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Alarm B seconds mask"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "MSK2",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Alarm B minutes mask"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            },
            {
                "name": "MSK3",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Alarm B hours mask"
            },
            {
                "name": "DU",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Date units or day in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "WDSEL",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Week day selection"
            },
            {
                "name": "MSK4",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Alarm B date mask"
            }
        ]
    },
    "1140881484": {
        "name": "RTC_ALRMBSSR",
        "address": 1140881484,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Subseconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.\nThis field is the mirror of SS[14:0] in the RTC_ALRMBBINR, and so can also be read or written through RTC_ALRMBBINR."
            },
            {
                "name": "MASKSS",
                "bitOffset": 24,
                "bitWidth": 6,
                "desc": "Mask the most-significant bits starting at this bit\n...\nFrom 32 to 63: All 32 SS bits are compared and must match to activate alarm.\nNote: In BCD mode (BIN=00)The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation."
            },
            {
                "name": "SSCLR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Clear synchronous counter on alarm (Binary mode only)\nNote: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11)."
            }
        ]
    },
    "1140881488": {
        "name": "RTC_SR",
        "address": 1140881488,
        "size": 32,
        "access": "",
        "desc": "RTC status register",
        "fields": [
            {
                "name": "ALRAF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR)."
            },
            {
                "name": "ALRBF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR)."
            },
            {
                "name": "WUTF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer flag\nThis flag is set by hardware when the wakeup auto-reload counter reaches 0.\nIf WUTOCLR[15:0] is different from 0x0000, WUTF is cleared by hardware when the wakeup\nauto-reload counter reaches WUTOCLR value.\nIf WUTOCLR[15:0] is 0x0000, WUTF must be cleared by software.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
            },
            {
                "name": "TSF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp flag\nThis flag is set by hardware when a timestamp event occurs.\nIf ITSF flag is set, TSF must be cleared together with ITSF.\nNote: TSF is not set if TAMPTS = 1 and the tamper flag is read during the 3 ck_apre cycles following tamper event. Refer to Timestamp on tamper event for more details."
            },
            {
                "name": "TSOVF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Timestamp overflow flag\nThis flag is set by hardware when a timestamp event occurs while TSF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "ITSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Internal timestamp flag\nThis flag is set by hardware when a timestamp on the internal event occurs."
            },
            {
                "name": "SSRUF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SSR underflow flag\nThis flag is set by hardware when the SSR rolls under 0. SSRUF is not set when SSCLR=1."
            }
        ]
    },
    "1140881492": {
        "name": "RTC_MISR",
        "address": 1140881492,
        "size": 32,
        "access": "",
        "desc": "RTC masked interrupt status register",
        "fields": [
            {
                "name": "ALRAMF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A masked flag\nThis flag is set by hardware when the alarm A interrupt occurs."
            },
            {
                "name": "ALRBMF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B masked flag\nThis flag is set by hardware when the alarm B interrupt occurs."
            },
            {
                "name": "WUTMF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer masked flag\nThis flag is set by hardware when the wakeup timer interrupt occurs.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
            },
            {
                "name": "TSMF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp masked flag\nThis flag is set by hardware when a timestamp interrupt occurs.\nIf ITSF flag is set, TSF must be cleared together with ITSF."
            },
            {
                "name": "TSOVMF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Timestamp overflow masked flag\nThis flag is set by hardware when a timestamp interrupt occurs while TSMF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "ITSMF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Internal timestamp masked flag\nThis flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised."
            },
            {
                "name": "SSRUMF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SSR underflow masked flag\nThis flag is set by hardware when the SSR underflow interrupt occurs."
            }
        ]
    },
    "1140881500": {
        "name": "RTC_SCR",
        "address": 1140881500,
        "size": 32,
        "access": "",
        "desc": "RTC status clear register",
        "fields": [
            {
                "name": "CALRAF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear alarm A flag\nWriting 1 in this bit clears the ALRAF bit in the RTC_SR register."
            },
            {
                "name": "CALRBF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear alarm B flag\nWriting 1 in this bit clears the ALRBF bit in the RTC_SR register."
            },
            {
                "name": "CWUTF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear wakeup timer flag\nWriting 1 in this bit clears the WUTF bit in the RTC_SR register."
            },
            {
                "name": "CTSF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear timestamp flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIf ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF."
            },
            {
                "name": "CTSOVF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear timestamp overflow flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "CITSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clear internal timestamp flag\nWriting 1 in this bit clears the ITSF bit in the RTC_SR register."
            },
            {
                "name": "CSSRUF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Clear SSR underflow flag\nWriting '1' in this bit clears the SSRUF in the RTC_SR register."
            }
        ]
    },
    "1140881520": {
        "name": "RTC_ALRABINR",
        "address": 1140881520,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A binary mode register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Synchronous counter alarm value in Binary mode\nThis value is compared with the contents of the synchronous counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.\nSS[14:0] is the mirror of SS[14:0] in the RTC_ALRMASSRR, and so can also be read or written through RTC_ALRMASSR."
            }
        ]
    },
    "1140881524": {
        "name": "RTC_ALRBBINR",
        "address": 1140881524,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B binary mode register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Synchronous counter alarm value in Binary mode\nThis value is compared with the contents of the synchronous counter to determine if Alarm Bis to be activated. Only bits 0 up MASKSS-1 are compared.\nSS[14:0] is the mirror of SS[14:0] in the RTC_ALRMBSSRR, and so can also be read or written through RTC_ALRMBSSR."
            }
        ]
    },
    "1140851728": {
        "name": "SBS_HDPLCR",
        "address": 1140851728,
        "size": 32,
        "access": "",
        "desc": "SBS temporal isolation control register",
        "fields": [
            {
                "name": "INCR_HDPL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "increment HDPL value\nOther: all other values allow a HDPL level increment."
            }
        ]
    },
    "1140851732": {
        "name": "SBS_HDPLSR",
        "address": 1140851732,
        "size": 32,
        "access": "",
        "desc": "SBS temporal isolation status register",
        "fields": [
            {
                "name": "HDPL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "temporal isolation level\nThis bitfield returns the current temporal isolation level."
            }
        ]
    },
    "1140851744": {
        "name": "SBS_DBGCR",
        "address": 1140851744,
        "size": 32,
        "access": "",
        "desc": "SBS debug control register",
        "fields": [
            {
                "name": "AP_UNLOCK",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "access port unlock\nWrite 0xB4 to this bitfield to open the device access port."
            },
            {
                "name": "DBG_UNLOCK",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "debug unlock when DBG_AUTH_HDPL is reached\nWrite 0xB4 to this bitfield to open the debug when HDPL in SBS_HDPLSR equals to DBG_AUTH_HDPL in this register."
            },
            {
                "name": "DBG_AUTH_HDPL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "authenticated debug temporal isolation level\nWriting to this bitfield defines at which HDPL the authenticated debug opens.\nNote: Writing any other values is ignored. Reading any other value means the debug never opens."
            }
        ]
    },
    "1140851748": {
        "name": "SBS_DBGLOCKR",
        "address": 1140851748,
        "size": 32,
        "access": "",
        "desc": "SBS debug lock register",
        "fields": [
            {
                "name": "DBGCFG_LOCK",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "debug configuration lock\nReading this bitfield returns 0x6A if the bitfield value is different from 0xB4.\n0xC3 is the recommended value to lock the debug configuration using this bitfield.\nOther: Writes to SBS_DBGCR ignored"
            }
        ]
    },
    "1140851968": {
        "name": "SBS_PMCR",
        "address": 1140851968,
        "size": 32,
        "access": "",
        "desc": "SBS product mode and configuration register",
        "fields": [
            {
                "name": "BOOSTEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "booster enable\nSet this bit to reduce the total harmonic distortion of the analog switch when the processor supply is below 2.7 V. The booster can be activated to guaranty AC performance on analog switch when the supply is below 2.7 V. When the booster is activated, the analog switch performances are the same as with the full voltage range."
            },
            {
                "name": "BOOSTVDDSEL",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "booster V DD  selection\nNote: Booster must not be used when V DDA   2.7 V, but V DD   2.7 V (add current consumption).\nNote: When both V DD   2.7 V and V DDA   2.7 V, booster is needed to get full AC performances from I/O analog switches."
            },
            {
                "name": "PB6_FMPLUS",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Fast-mode Plus command on PB(6)"
            },
            {
                "name": "PB7_FMPLUS",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Fast-mode Plus command on PB(7)"
            },
            {
                "name": "PB8_FMPLUS",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Fast-mode Plus command on PB(8)"
            }
        ]
    },
    "1140851972": {
        "name": "SBS_FPUIMR",
        "address": 1140851972,
        "size": 32,
        "access": "",
        "desc": "SBS FPU interrupt mask register",
        "fields": [
            {
                "name": "FPU_IE",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "FPU interrupt enable\nSet and cleared by software to enable the Cortex-M33 FPU interrupts\nFPU_IE[5]: inexact interrupt enable (interrupt disabled at reset)\nFPU_IE[4]: input abnormal interrupt enable\nFPU_IE[3]: overflow interrupt enable\nFPU_IE[2]: underflow interrupt enable\nFPU_IE[1]: divide-by-zero interrupt enable\nFPU_IE[0]: invalid operation interrupt enable"
            }
        ]
    },
    "1140851976": {
        "name": "SBS_MESR",
        "address": 1140851976,
        "size": 32,
        "access": "",
        "desc": "SBS memory erase status register",
        "fields": [
            {
                "name": "MCLR",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "erase after reset status\nThis bit shows the status of the protection for SRAM2, BKPRAM, ICACHE, ICACHE. It is set by hardware and reset by software"
            },
            {
                "name": "IPMEE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "end-of-erase status for ICACHE\nThis bit shows the status of the protection for ICACHE. It is set by hardware and reset by software."
            }
        ]
    },
    "1140851984": {
        "name": "SBS_CCCSR",
        "address": 1140851984,
        "size": 32,
        "access": "",
        "desc": "SBS compensation cell for I/Os control and status register",
        "fields": [
            {
                "name": "EN1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable compensation cell for VDDIO power rail\nThis bit enables the I/O compensation cell."
            },
            {
                "name": "CS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "code selection for VDDIO power rail (reset value set to 1)\nThis bit selects the code to be applied for the I/O compensation cell."
            },
            {
                "name": "EN2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "enable compensation cell for VDDIO2 power rail\nThis bit enables the I/O compensation cell."
            },
            {
                "name": "CS2",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "code selection for VDDIO2 power rail (reset value set to 1)\nThis bit selects the code to be applied for the I/O compensation cell."
            },
            {
                "name": "RDY1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "VDDIO compensation cell ready flag\nThis bit provides the status of the compensation cell."
            },
            {
                "name": "RDY2",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "VDDIO2 compensation cell ready flag\nThis bit provides the status of the VDDIO2 compensation cell."
            }
        ]
    },
    "1140851988": {
        "name": "SBS_CCVALR",
        "address": 1140851988,
        "size": 32,
        "access": "",
        "desc": "SBS compensation cell for I/Os value register",
        "fields": [
            {
                "name": "ANSRC1",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "compensation value for the NMOS transistor\nThis value is provided by the cell and must be interpreted by the processor to compensate the slew rate in the functional range."
            },
            {
                "name": "APSRC1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "compensation value for the PMOS transistor\nThis value is provided by the cell and must be interpreted by the processor to compensate the slew rate in the functional range."
            },
            {
                "name": "ANSRC2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Compensation value for the NMOS transistor\nThis value is provided by the cell and must be interpreted by the processor to compensate the slew rate in the functional range."
            },
            {
                "name": "APSRC2",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "compensation value for the PMOS transistor\nThis value is provided by the cell and must be interpreted by the processor to compensate the slew rate in the functional range."
            }
        ]
    },
    "1140851992": {
        "name": "SBS_CCSWCR",
        "address": 1140851992,
        "size": 32,
        "access": "",
        "desc": "SBS compensation cell for I/Os software code register",
        "fields": [
            {
                "name": "SW_ANSRC1",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "NMOS compensation code for VDD power rails\nThis bitfield is written by software to define an I/O compensation cell code for NMOS transistors of the VDD power rail. This code is applied to the I/O when CS1 is set in SBS_CCSR."
            },
            {
                "name": "SW_APSRC1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "PMOS compensation code for the VDD power rails\nThis bitfield is written by software to define an I/O compensation cell code for PMOS transistors of the VDDIO power rail. This code is applied to the I/O when CS1 is set in SBS_CCSR."
            },
            {
                "name": "SW_ANSRC2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "NMOS compensation code for VDDIO power rails\nThis bitfield is written by software to define an I/O compensation cell code for NMOS transistors of the VDD power rail. This code is applied to the I/O when CS2 is set in SBS_CCSR."
            },
            {
                "name": "SW_APSRC2",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "PMOS compensation code for the V DDIO  power rails\nThis bitfield is written by software to define an I/O compensation cell code for PMOS transistors of the VDDIO power rail. This code is applied to the I/O when CS2 is set in SBS_CCSR."
            }
        ]
    },
    "1140852000": {
        "name": "SBS_CFGR2",
        "address": 1140852000,
        "size": 32,
        "access": "",
        "desc": "SBS Class B register",
        "fields": [
            {
                "name": "CLL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "core lockup lock\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock the lockup (HardFault) output of Cortex-M33 with TIM1 break inputs."
            },
            {
                "name": "SEL",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SRAM ECC error lock\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock the SRAM double ECC error signal with break input of TIM1."
            },
            {
                "name": "PVDL",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "PVD lock\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock the PVD connection with TIM1 break inputs."
            },
            {
                "name": "ECCL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "ECC lock\nThis bit is set and cleared by software. It can be used to enable and lock the Flash memory double ECC error with break input of TIM1."
            }
        ]
    },
    "1140852036": {
        "name": "SBS_CNSLCKR",
        "address": 1140852036,
        "size": 32,
        "access": "",
        "desc": "SBS CPU lock register",
        "fields": [
            {
                "name": "LOCKNSVTOR",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "VTOR_NS register lock\nThis bit is set by software and cleared only by a system reset."
            },
            {
                "name": "LOCKNSMPU",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "MPU register lock\nThis bit is set by software and cleared only by a system reset. When set, this bit disables write access to MPU_CTRL_NS, MPU_RNR_NS and MPU_RBAR_NS registers."
            }
        ]
    },
    "1140852044": {
        "name": "SBS_ECCNMIR",
        "address": 1140852044,
        "size": 32,
        "access": "",
        "desc": "SBS flift ECC NMI mask register",
        "fields": [
            {
                "name": "ECCNMI_MASK_EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "NMI behavior setup when a double ECC error occurs on flitf data part"
            }
        ]
    },
    "1073819648": {
        "name": "SPI_CR1",
        "address": 1073819648,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S control register 1 ",
        "fields": [
            {
                "name": "SPE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "serial peripheral enable\nThis bit is set by and cleared by software.\nWhen SPE=1, SPI data transfer is enabled, SPI_CFG1 and SPI_CFG2 configuration registers, CRCPOLY, UDRDR, IOLOCK bit in the SPI_CR1 register are write protected. They can be changed only when SPE=0.\nWhen SPE=0 any SPI operation is stopped and disabled, all the pending requests of the events with enabled interrupt are blocked except the MODF interrupt request (but their pending still propagates the request of the spi_plck clock), the SS output is deactivated at master, the RDY signal keeps not ready status at slave, the internal state machine is reseted, all the FIFOs content is flushed, CRC calculation initialized, receive data register is read zero.\nSPE is cleared and cannot be set when MODF error flag is active."
            },
            {
                "name": "MASRX",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "master automatic suspension in Receive mode\nThis bit is set and cleared by software to control continuous SPI transfer in master receiver mode and automatic management in order to avoid overrun condition.\nWhen SPI communication is suspended by hardware automatically, it could happen that few bits of next frame are already clocked out due to internal synchronization delay.\nThis is why, the automatic suspension is not quite reliable when size of data drops below 8 bits. In this case, a safe suspension can be achieved by combination with delay inserted between data frames applied when MIDI parameter keeps a non zero value; sum of data size and the interleaved SPI cycles should always produce interval at length of 8 SPI clock periods at minimum. After software clearing of the SUSP bit, the communication resumes and continues by subsequent bits transaction without any next constraint. Prior the SUSP bit is cleared, the user must release the RxFIFO space as much as possible by reading out all the data packets available at RxFIFO based on the RXP flag indication to prevent any subsequent suspension."
            },
            {
                "name": "CSTART",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "master transfer start\nThis bit can be set by software if SPI is enabled only to start an SPI or I2S/PCM communication. In SPI mode, it is cleared by hardware when end of transfer (EOT) flag is set or when a transaction suspend request is accepted. In I2S/PCM mode, it is also cleared by hardware as described in the .\nIn SPI mode, the bit is taken into account at master mode only. If transmission is enabled, communication starts or continues only if any data is available in the transmission FIFO."
            },
            {
                "name": "CSUSP",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "master SUSPend request\nThis bit reads as zero.\nIn Master mode, when this bit is set by software, the CSTART bit is reset at the end of the current frame and communication is suspended. The user has to check SUSP flag to check end of the frame transaction.\nThe Master mode communication must be suspended (using this bit or keeping TXDR empty) before going to Low-power mode. Can be used in SPI or I2S mode.\nAfter software suspension, SUSP flag has to be cleared and SPI disabled and re-enabled before the next transaction starts."
            },
            {
                "name": "HDDIR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Rx/Tx direction at Half-duplex mode\nIn Half-Duplex configuration the HDDIR bit establishes the Rx/Tx direction of the data transfer. This bit is ignored in Full-Duplex or any Simplex configuration."
            },
            {
                "name": "SSI",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "internal SS signal input level\nThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the peripheral SS input internally and the I/O value of the SS pin is ignored."
            },
            {
                "name": "CRC33_17",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "32-bit CRC polynomial configuration"
            },
            {
                "name": "RCRCINI",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "CRC calculation initialization pattern control for receiver"
            },
            {
                "name": "TCRCINI",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CRC calculation initialization pattern control for transmitter"
            },
            {
                "name": "IOLOCK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "locking the AF configuration of associated IOs\nThis bit is set by software and cleared by hardware whenever the SPE bit is changed from 1 to 0.\nWhen this bit is set, SPI_CFG2 register content cannot be modified. This bit can be set when SPI is disabled only else it is write protected. It is cleared and cannot be set when MODF bit is set."
            }
        ]
    },
    "1073819652": {
        "name": "SPI_CR2",
        "address": 1073819652,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S control register 2 ",
        "fields": [
            {
                "name": "TSIZE",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "number of data at current transfer\nWhen these bits are changed by software, the SPI has to be disabled.\nEndless transaction is initialized when CSTART is set while zero value is stored at TSIZE. TSIZE cannot be set to 0xFFFF respective 0x3FFF value when CRC is enabled.\nNote: TSIZE[15:10] bits are reserved at limited feature set instances and must be kept at reset value."
            }
        ]
    },
    "1073819656": {
        "name": "SPI_CFG1",
        "address": 1073819656,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S configuration register 1 ",
        "fields": [
            {
                "name": "DSIZE",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "number of bits in at single SPI data frame\n.....\nNote: Maximum data size can be limited up to 16-bits at some instances. At instances with limited set of features, DSIZE2:0] bits are reserved and must be kept at reset state. DSIZE[4:3] bits then control next settings of data size:\n00xxx: 8-bits\n01xxx: 16-bits\n10xxx: 24-bits\n11xxx: 32-bits."
            },
            {
                "name": "FTHLV",
                "bitOffset": 5,
                "bitWidth": 4,
                "desc": "FIFO threshold level\nDefines number of data frames at single data packet. Size of the packet should not exceed 1/2 of FIFO space."
            },
            {
                "name": "UDRCFG",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "behavior of slave transmitter at underrun condition\nFor more details see underrun condition."
            },
            {
                "name": "RXDMAEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Rx DMA stream enable"
            },
            {
                "name": "TXDMAEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Tx DMA stream enable"
            },
            {
                "name": "CRCSIZE",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "length of CRC frame to be transacted and compared\nMost significant bits are taken into account from polynomial calculation when CRC result is transacted or compared. The length of the polynomial is not affected by this setting.\n.....\nThe value must be set equal or multiply of data size (DSIZE[4:0]). Its maximum size corresponds to DSIZE maximum at the instance.\nNote: The most significant bit at CRCSIZE bit field is reserved at the peripheral instances where data size is limited to 16-bit."
            },
            {
                "name": "CRCEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "hardware CRC computation enable"
            },
            {
                "name": "MBR",
                "bitOffset": 28,
                "bitWidth": 3,
                "desc": "master baud rate prescaler setting\nNote: MBR setting is considered at slave working at TI mode, too (see mode)."
            },
            {
                "name": "BPASS",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "bypass of the prescaler at master baud rate clock generator"
            }
        ]
    },
    "1073819660": {
        "name": "SPI_CFG2",
        "address": 1073819660,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S configuration register 2 ",
        "fields": [
            {
                "name": "MSSI",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Master SS Idleness\nSpecifies an extra delay, expressed in number of SPI clock cycle periods, inserted additionally between active edge of SS opening a session and the beginning of the first data frame of the session in Master mode when SSOE is enabled.\n...\nNote: This feature is not supported in TI mode.\nTo include the delay, the SPI must be disabled and re-enabled between sessions."
            },
            {
                "name": "MIDI",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "master Inter-Data Idleness\nSpecifies minimum time delay (expressed in SPI clock cycles periods) inserted between two consecutive data frames in Master mode.\n...\nNote: This feature is not supported in TI mode."
            },
            {
                "name": "RDIOM",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "RDY signal input/output management\nNote: When DSIZE at the SPI_CFG1 register is configured shorter than 8-bit, the RDIOM bit has to be kept at zero."
            },
            {
                "name": "RDIOP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "RDY signal input/output polarity"
            },
            {
                "name": "IOSWP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "swap functionality of MISO and MOSI pins\nWhen this bit is set, the function of MISO and MOSI pins alternate functions are inverted.\nOriginal MISO pin becomes MOSI and original MOSI pin becomes MISO.\nNote: This bit can be also used in PCM and I2S modes to swap SDO and SDI pins."
            },
            {
                "name": "COMM",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "SPI Communication Mode"
            },
            {
                "name": "SP",
                "bitOffset": 19,
                "bitWidth": 3,
                "desc": "serial protocol\nothers: reserved, must not be used"
            },
            {
                "name": "MASTER",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "SPI Master"
            },
            {
                "name": "LSBFRST",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "data frame format\nNote: This bit can be also used in PCM and I2S modes."
            },
            {
                "name": "CPHA",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "clock phase"
            },
            {
                "name": "CPOL",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "clock polarity"
            },
            {
                "name": "SSM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "software management of SS signal input\nWhen master uses hardware SS output (SSM=0 and SSOE=1) the SS signal input is forced to not active state internally to prevent master mode fault error."
            },
            {
                "name": "SSIOP",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "SS input/output polarity"
            },
            {
                "name": "SSOE",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "SS output enable\nThis bit is taken into account in Master mode only"
            },
            {
                "name": "SSOM",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "SS output management in Master mode\nThis bit is taken into account in Master mode when SSOE is enabled. It allows the SS output to be configured between two consecutive data transfers."
            },
            {
                "name": "AFCNTR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "alternate function GPIOs control\nThis bit is taken into account when SPE=0 only\nWhen SPI has to be disabled temporary for a specific configuration reason (e.g. CRC reset, CPHA or HDDIR change) setting this bit prevents any glitches on the associated outputs configured at alternate function mode by keeping them forced at state corresponding the current SPI configuration.\nNote: This bit can be also used in PCM and I2S modes.\nNote: The bit AFCNTR must not be set to 1, when the block is in slave mode."
            }
        ]
    },
    "1073819664": {
        "name": "SPI_IER",
        "address": 1073819664,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S interrupt enable register ",
        "fields": [
            {
                "name": "RXPIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RXP interrupt enable"
            },
            {
                "name": "TXPIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TXP interrupt enable\nTXPIE is set by software and cleared by TXTF flag set event."
            },
            {
                "name": "DXPIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "DXP interrupt enabled\nDXPIE is set by software and cleared by TXTF flag set event."
            },
            {
                "name": "EOTIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "EOT, SUSP and TXC interrupt enable"
            },
            {
                "name": "TXTFIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TXTFIE interrupt enable"
            },
            {
                "name": "UDRIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "UDR interrupt enable"
            },
            {
                "name": "OVRIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "OVR interrupt enable"
            },
            {
                "name": "CRCEIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CRC error interrupt enable"
            },
            {
                "name": "TIFREIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "TIFRE interrupt enable"
            },
            {
                "name": "MODFIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "mode Fault interrupt enable"
            }
        ]
    },
    "1073819668": {
        "name": "SPI_SR",
        "address": 1073819668,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S status register ",
        "fields": [
            {
                "name": "RXP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rx-Packet available\nIn I2S mode, it must be interpreted as follow: RxFIFO level is lower than FTHLV\nIn I2S mode, it must be interpreted as follow: RxFIFO level is higher or equal to FTHLV\nRXP flag is changed by hardware. It monitors number of overall data currently available at RxFIFO if SPI is enabled. It has to be checked once a data packet is completely read out from RxFIFO."
            },
            {
                "name": "TXP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tx-Packet space available\nIn I2S mode, it must be interpreted as follow: there is less than FTHLV free locations in the TxFIFO\nIn I2S mode, it must be interpreted as follow: there is FTHLV or more than FTHLV free locations in the TxFIFO\nTXP flag is changed by hardware. It monitors overall space currently available at TxFIFO no matter if SPI is enabled or not. It has to be checked once a complete data packet is stored at TxFIFO."
            },
            {
                "name": "DXP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "duplex packet\nDXP flag is set whenever both TXP and RXP flags are set regardless SPI mode."
            },
            {
                "name": "EOT",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "end of transfer\nEOT is set by hardware as soon as a full transfer is complete, that is when SPI is re-enabled or when TSIZE number of data have been transmitted and/or received on the SPI. EOT is cleared when SPI is re-enabled or by writing 1 to EOTC bit of SPI_IFCR optionally.\nEOT flag triggers an interrupt if EOTIE bit is set.\nIf DXP flag is used until TXTF flag is set and DXPIE is cleared, EOT can be used to download the last packets contained into RxFIFO in one-shot.\nIn master, EOT event terminates the data transaction and handles SS output optionally. When CRC is applied, the EOT event is extended over the CRC frame transaction.\nTo restart the internal state machine properly, SPI is strongly suggested to be disabled and re-enabled before next transaction starts despite its setting is not changed."
            },
            {
                "name": "TXTF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "transmission transfer filled\nTXTF is set by hardware as soon as all of the data packets in a transfer have been submitted for transmission by application software or DMA, that is when TSIZE number of data have been pushed into the TxFIFO.\nThis bit is cleared by software write 1 to TXTFC bit of SPI_IFCR exclusively.\nTXTF flag triggers an interrupt if TXTFIE bit is set.\nTXTF setting clears the TXPIE and DXPIE masks so to off-load application software from calculating when to disable TXP and DXP interrupts."
            },
            {
                "name": "UDR",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "underrun\nThis bit is cleared when SPI is re-enabled or by writing 1 to UDRC bit of SPI_IFCR optionally.\nNote: In SPI mode, the UDR flag applies to Slave mode only. In I2S/PCM mode, (when available) this flag applies to Master and Slave mode"
            },
            {
                "name": "OVR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "overrun\nThis bit is cleared when SPI is re-enabled or by writing 1 to OVRC bit of SPI_IFCR optionally."
            },
            {
                "name": "CRCE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CRC error\nThis bit is cleared when SPI is re-enabled or by writing 1 to CRCEC bit of SPI_IFCR optionally."
            },
            {
                "name": "TIFRE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "TI frame format error\nThis bit is cleared by writing 1 to TIFREC bit of SPI_IFCR exclusively."
            },
            {
                "name": "MODF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "mode fault\nThis bit is cleared by writing 1 to MODFC bit of SPI_IFCR exclusively."
            },
            {
                "name": "SUSP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "suspension status\nIn Master mode, SUSP is set by hardware either as soon as the current frame is completed after CSUSP request is done or at master automatic suspend receive mode (MASRX bit is set at SPI_CR1 register) on RxFIFO full condition.\nSUSP generates an interrupt when EOTIE is set.\nThis bit has to be cleared prior SPI is disabled and this is done by writing 1 to SUSPC bit of SPI_IFCR exclusively."
            },
            {
                "name": "TXC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "TxFIFO transmission complete\nThe flag behavior depends on TSIZE setting.\nWhen TSIZE=0 the TXC is changed by hardware exclusively and it raises each time the TxFIFO becomes empty and there is no activity on the bus.\nIf TSIZE 0 there is no specific reason to monitor TXC as it just copies the EOT flag value including its software clearing. The TXC generates an interrupt when EOTIE is set."
            },
            {
                "name": "RXPLVL",
                "bitOffset": 13,
                "bitWidth": 2,
                "desc": "RxFIFO packing level\nWhen RXWNE=0 and data size is set up to 16-bit, the value gives number of remaining data frames persisting at RxFIFO.\nNote: (*): Optional value when data size is set up to 8-bit only.\nWhen data size is greater than 16-bit, these bits are always read as 00. In that consequence, the single data frame received at the FIFO cannot be detected neither by RWNE nor by RXPLVL bits if data size is set from 17 to 24 bits. The user then must apply other methods like TSIZE0 or FTHLV=0."
            },
            {
                "name": "RXWNE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "RxFIFO word not empty\nNote: This bit value does not depend on DSIZE setting and keeps together with RXPLVL[1:0] information about RxFIFO occupancy by residual data."
            },
            {
                "name": "CTSIZE",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "number of data frames remaining in current TSIZE session\nThe value is not quite reliable when traffic is ongoing on bus or during autonomous operation in low-power mode.\nNote: CTSIZE[15:0] bits are not available in instances with limited set of features."
            }
        ]
    },
    "1073819672": {
        "name": "SPI_IFCR",
        "address": 1073819672,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S interrupt/status flags clear register ",
        "fields": [
            {
                "name": "EOTC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "end of transfer flag clear\nWriting a 1 into this bit clears EOT flag in the SPI_SR register"
            },
            {
                "name": "TXTFC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "transmission transfer filled flag clear\nWriting a 1 into this bit clears TXTF flag in the SPI_SR register"
            },
            {
                "name": "UDRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "underrun flag clear\nWriting a 1 into this bit clears UDR flag in the SPI_SR register"
            },
            {
                "name": "OVRC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "overrun flag clear\nWriting a 1 into this bit clears OVR flag in the SPI_SR register"
            },
            {
                "name": "CRCEC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CRC error flag clear\nWriting a 1 into this bit clears CRCE flag in the SPI_SR register"
            },
            {
                "name": "TIFREC",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "TI frame format error flag clear\nWriting a 1 into this bit clears TIFRE flag in the SPI_SR register"
            },
            {
                "name": "MODFC",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "mode fault flag clear\nWriting a 1 into this bit clears MODF flag in the SPI_SR register"
            },
            {
                "name": "SUSPC",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "SUSPend flag clear\nWriting a 1 into this bit clears SUSP flag in the SPI_SR register"
            }
        ]
    },
    "1073819680": {
        "name": "SPI_TXDR",
        "address": 1073819680,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S transmit data register ",
        "fields": [
            {
                "name": "TXDR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "transmit data register\nThe register serves as an interface with TxFIFO. A write to it accesses TxFIFO.\nNote: In SPI mode, data is always right-aligned. Alignment of data at I2S mode depends on DATLEN and DATFMT setting. Unused bits are ignored when writing to the register, and read as zero when the register is read.\nNote: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is written by single access.\nhalfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be written by single access.\nword-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data can be written by single access.\nWrite access of this register less than the configured data size is forbidden."
            }
        ]
    },
    "1073819696": {
        "name": "SPI_RXDR",
        "address": 1073819696,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S receive data register ",
        "fields": [
            {
                "name": "RXDR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "receive data register\nThe register serves as an interface with RxFIFO. When it is read, RxFIFO is accessed.\nNote: In SPI mode, data is always right-aligned. Alignment of data at I2S mode depends on DATLEN and DATFMT setting. Unused bits are read as zero when the register is read. Writing to the register is ignored.\nNote: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is read by single access\nhalfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be read by single access\nword-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data can be read by single access.\nRead access of this register less than the configured data size is forbidden."
            }
        ]
    },
    "1073819712": {
        "name": "SPI_CRCPOLY",
        "address": 1073819712,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S polynomial register ",
        "fields": [
            {
                "name": "CRCPOLY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "CRC polynomial register\nThis register contains the polynomial for the CRC calculation.\nThe default 9-bit polynomial setting 0x107 corresponds to default 8-bit setting of DSIZE. It is compatible with setting 0x07 used at some other ST products with fixed length of the polynomial string where the most significant bit of the string is always kept hidden.\nLength of the polynomial is given by the most significant bit of the value stored at this register. It has to be set greater than DSIZE. CRC33_17 bit has to be set additionally with CRCPOLY register when DSIZE is configured to maximum 32-bit or 16-bit size and CRC is enabled (to keep polynomial length grater than data size).\nNote: CRCPOLY[31:16] bits are reserved at instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored."
            }
        ]
    },
    "1073819716": {
        "name": "SPI_TXCRC",
        "address": 1073819716,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S transmitter CRC register ",
        "fields": [
            {
                "name": "TXCRC",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "CRC register for transmitter\nWhen CRC calculation is enabled, the TXCRC[31:0] bits contain the computed CRC value of the subsequently transmitted bytes. CRC calculation is initialized when the CRCEN bit of SPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPOLY register.\nThe number of bits considered at calculation depends on SPI_CRCPOLY register and CRCSIZE bits settings at SPI_CFG1 register.\nNote: a read to this register when the communication is ongoing could return an incorrect value.\nNote: not used for the I2S mode.\nNote: TXCRC[31-16] bits are reserved at instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.\nNote: The configuration of CRCSIZE bit field is not taken into account when the content of this register is read by software. No masking is applied for unused bits at this case."
            }
        ]
    },
    "1073819720": {
        "name": "SPI_RXCRC",
        "address": 1073819720,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S receiver CRC register ",
        "fields": [
            {
                "name": "RXCRC",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "CRC register for receiver\nWhen CRC calculation is enabled, the RXCRC[31:0] bits contain the computed CRC value of the subsequently received bytes. CRC calculation is initialized when the CRCEN bit of SPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPOLY register.\nThe number of bits considered at calculation depends on SPI_CRCPOLY register and CRCSIZE bits settings at SPI_CFG1 register.\nNote: a read to this register when the communication is ongoing could return an incorrect value.\nNot used for the I2S mode.\nRXCRC[31-16] bits are reserved at the peripheral instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.\nNote: The configuration of CRCSIZE bit field is not taken into account when the content of this register is read by software. No masking is applied for unused bits at this case."
            }
        ]
    },
    "1073819724": {
        "name": "SPI_UDRDR",
        "address": 1073819724,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S underrun data register ",
        "fields": [
            {
                "name": "UDRDR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "data at slave underrun condition\nThe register is taken into account in Slave mode and at underrun condition only. The number of bits considered depends on DSIZE bit settings of the SPI_CFG1 register. Underrun condition handling depends on setting UDRCFG bit at SPI_CFG1 register.\nNote: UDRDR[31-16] bits are reserved at the peripheral instances with data size limited to 16-bit. There is no constraint when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored."
            }
        ]
    },
    "1073819728": {
        "name": "SPI_I2SCFGR",
        "address": 1073819728,
        "size": 32,
        "access": "",
        "desc": "SPI/I2S configuration register ",
        "fields": [
            {
                "name": "I2SMOD",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I2S mode selection"
            },
            {
                "name": "I2SCFG",
                "bitOffset": 1,
                "bitWidth": 3,
                "desc": "I2S configuration mode\nothers, not used"
            },
            {
                "name": "I2SSTD",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "I2S standard selection\nFor more details on I2S standards, refer to"
            },
            {
                "name": "PCMSYNC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "PCM frame synchronization"
            },
            {
                "name": "DATLEN",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "data length to be transferred"
            },
            {
                "name": "CHLEN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "channel length (number of bits per audio channel)"
            },
            {
                "name": "CKPOL",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "serial audio clock polarity"
            },
            {
                "name": "FIXCH",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "fixed channel length in slave"
            },
            {
                "name": "WSINV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "word select inversion\nThis bit is used to invert the default polarity of WS signal.\nWS is LOW.\nIn PCM mode the start of frame is indicated by a rising edge.\nWS is HIGH.\nIn PCM mode the start of frame is indicated by a falling edge."
            },
            {
                "name": "DATFMT",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "data format"
            },
            {
                "name": "I2SDIV",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "I2S linear prescaler\nI2SDIV can take any values except the value 1, when ODD is also equal to 1.\nRefer to  for details"
            },
            {
                "name": "ODD",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "odd factor for the prescaler\nRefer to  for details"
            },
            {
                "name": "MCKOE",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "master clock output enable"
            }
        ]
    },
    "1140882432": {
        "name": "TAMP_CR1",
        "address": 1140882432,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 1",
        "fields": [
            {
                "name": "TAMP1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN1 enable"
            },
            {
                "name": "TAMP2E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN2 enable"
            },
            {
                "name": "ITAMP1E",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Internal tamper 1 enable"
            },
            {
                "name": "ITAMP2E",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Internal tamper 2 enable"
            },
            {
                "name": "ITAMP3E",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 enable"
            },
            {
                "name": "ITAMP4E",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Internal tamper 4 enable"
            },
            {
                "name": "ITAMP5E",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 enable"
            },
            {
                "name": "ITAMP6E",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 enable"
            },
            {
                "name": "ITAMP7E",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Internal tamper 7 enable"
            },
            {
                "name": "ITAMP8E",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Internal tamper 8 enable"
            },
            {
                "name": "ITAMP9E",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Internal tamper 9 enable"
            },
            {
                "name": "ITAMP11E",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Internal tamper 11 enable"
            },
            {
                "name": "ITAMP12E",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Internal tamper 12 enable"
            },
            {
                "name": "ITAMP13E",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Internal tamper 13 enable"
            },
            {
                "name": "ITAMP15E",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Internal tamper 15 enable"
            }
        ]
    },
    "1140882436": {
        "name": "TAMP_CR2",
        "address": 1140882436,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 2",
        "fields": [
            {
                "name": "TAMP1NOER",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper 1 no erase"
            },
            {
                "name": "TAMP2NOER",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper 2 no erase"
            },
            {
                "name": "TAMP1MSK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Tamper 1 mask\nThe tamper 1 interrupt must not be enabled when TAMP1MSK is set."
            },
            {
                "name": "TAMP2MSK",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Tamper 2 mask\nThe tamper 2 interrupt must not be enabled when TAMP2MSK is set."
            },
            {
                "name": "BKBLOCK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Backup registers and device secretssup(1)/sup access blocked"
            },
            {
                "name": "BKERASE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Backup registers and device secretssup(1)/sup erase\nWriting '1' to this bit reset the backup registers and device secretssup(1)/sup. Writing 0 has no effect. This bit is always read as 0."
            },
            {
                "name": "TAMP1TRG",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Active level for tamper 1 input\nIf TAMPFLT = 00 Tamper 1 input rising edge triggers a tamper detection event.\nIf TAMPFLT = 00 Tamper 1 input falling edge triggers a tamper detection event."
            },
            {
                "name": "TAMP2TRG",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Active level for tamper 2 input\nIf TAMPFLT = 00 Tamper 2 input rising edge triggers a tamper detection event.\nIf TAMPFLT = 00 Tamper 2 input falling edge triggers a tamper detection event."
            }
        ]
    },
    "1140882440": {
        "name": "TAMP_CR3",
        "address": 1140882440,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 3",
        "fields": [
            {
                "name": "ITAMP1NOER",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Internal Tamper 1 no erase"
            },
            {
                "name": "ITAMP2NOER",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Internal Tamper 2 no erase"
            },
            {
                "name": "ITAMP3NOER",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Internal Tamper 3 no erase"
            },
            {
                "name": "ITAMP4NOER",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Internal Tamper 4 no erase"
            },
            {
                "name": "ITAMP5NOER",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Internal Tamper 5 no erase"
            },
            {
                "name": "ITAMP6NOER",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Internal Tamper 6 no erase"
            },
            {
                "name": "ITAMP7NOER",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Internal Tamper 7 no erase"
            },
            {
                "name": "ITAMP8NOER",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Internal Tamper 8 no erase"
            },
            {
                "name": "ITAMP9NOER",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Internal Tamper 9 no erase"
            },
            {
                "name": "ITAMP11NOER",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Internal Tamper 11 no erase"
            },
            {
                "name": "ITAMP12NOER",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Internal Tamper 12 no erase"
            },
            {
                "name": "ITAMP13NOER",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Internal Tamper 13 no erase"
            },
            {
                "name": "ITAMP15NOER",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Internal Tamper 15 no erase"
            }
        ]
    },
    "1140882444": {
        "name": "TAMP_FLTCR",
        "address": 1140882444,
        "size": 32,
        "access": "",
        "desc": "TAMP filter control register",
        "fields": [
            {
                "name": "TAMPFREQ",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Tamper sampling frequency\nDetermines the frequency at which each of the TAMP_INx inputs are sampled."
            },
            {
                "name": "TAMPFLT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "TAMP_INx filter count\nThese bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs."
            },
            {
                "name": "TAMPPRCH",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "TAMP_INx precharge duration\nThese bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs."
            },
            {
                "name": "TAMPPUDIS",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TAMP_INx pull-up disable\nThis bit determines if each of the TAMPx pins are precharged before each sample."
            }
        ]
    },
    "1140882448": {
        "name": "TAMP_ATCR1",
        "address": 1140882448,
        "size": 32,
        "access": "",
        "desc": "TAMP active tamper control register 1",
        "fields": [
            {
                "name": "TAMP1AM",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper 1 active mode"
            },
            {
                "name": "TAMP2AM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper 2 active mode"
            },
            {
                "name": "ATOSEL1",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Active tamper shared output 1 selection\nThe selected output must be available in the package pinout"
            },
            {
                "name": "ATOSEL2",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Active tamper shared output 2 selection\nThe selected output must be available in the package pinout"
            },
            {
                "name": "ATOSEL3",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Active tamper shared output 3 selection\nThe selected output must be available in the package pinout"
            },
            {
                "name": "ATCKSEL",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "Active tamper RTC asynchronous prescaler clock selection\nThese bits selects the RTC asynchronous prescaler stage output. The selected clock is CK_ATPRE.\nf CK_ATPRE  = f RTCCLK  / 2supATCKSEL /supwhen (PREDIV_A+1) = 128.\n...\nNote: These bits can be written only when all active tampers are disabled. The write protection remains for up to 1.5 CK_ATPRE cycles after all the active tampers are disable."
            },
            {
                "name": "ATPER",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "Active tamper output change period\nThe tamper output is changed every CK_ATPER = (2supATPER /supx CK_ATPRE) cycles. Refer to Table 239: Minimum ATPER value."
            },
            {
                "name": "ATOSHARE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Active tamper output sharing\nTAMP_IN1 is compared with TAMPOUTSEL1\nTAMP_IN2 is compared with TAMPOUTSEL2\nTAMP_IN3 is compared with TAMPOUTSEL3\nTAMP_IN4 is compared with TAMPOUTSEL4\nTAMP_IN5 is compared with TAMPOUTSEL5\nTAMP_IN6 is compared with TAMPOUTSEL6\nTAMP_IN7 is compared with TAMPOUTSEL7\nTAMP_IN8 is compared with TAMPOUTSEL8"
            },
            {
                "name": "FLTEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Active tamper filter enable"
            }
        ]
    },
    "1140882452": {
        "name": "TAMP_ATSEEDR",
        "address": 1140882452,
        "size": 32,
        "access": "",
        "desc": "TAMP active tamper seed register",
        "fields": [
            {
                "name": "SEED",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Pseudo-random generator seed value\nThis register must be written four times with 32-bit values to provide the 128-bit seed to the PRNG. Writing to this register automatically sends the seed value to the PRNG."
            }
        ]
    },
    "1140882456": {
        "name": "TAMP_ATOR",
        "address": 1140882456,
        "size": 32,
        "access": "",
        "desc": "TAMP active tamper output register",
        "fields": [
            {
                "name": "PRNG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Pseudo-random generator value\nThis field provides the values of the PRNG output. Because of potential inconsistencies due to synchronization delays, PRNG must be read at least twice. The read value is correct if it is equal to previous read value."
            },
            {
                "name": "SEEDF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Seed running flag\nThis flag is set by hardware when a new seed is written in the TAMP_ATSEEDR. It is cleared by hardware when the PRNG has absorbed this new seed, and by system reset. The TAMP APB cock must not be switched off as long as SEEDF is set."
            },
            {
                "name": "INITS",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Active tamper initialization status\nThis flag is set by hardware when the PRNG has absorbed the first 128-bit seed, meaning that the enabled active tampers are functional. This flag is cleared when the active tampers are disabled."
            }
        ]
    },
    "1140882460": {
        "name": "TAMP_ATCR2",
        "address": 1140882460,
        "size": 32,
        "access": "",
        "desc": "TAMP active tamper control register 2",
        "fields": [
            {
                "name": "ATOSEL1",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "Active tamper shared output 1 selection\nThe selected output must be available in the package pinout.\nBits 9:8 are the mirror of ATOSEL1[1:0] in the TAMP_ATCR1, and so can also be read or\nwritten through TAMP_ATCR1."
            },
            {
                "name": "ATOSEL2",
                "bitOffset": 11,
                "bitWidth": 3,
                "desc": "Active tamper shared output 2 selection\nThe selected output must be available in the package pinout.\nBits 12:11 are the mirror of ATOSEL2[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1."
            },
            {
                "name": "ATOSEL3",
                "bitOffset": 14,
                "bitWidth": 3,
                "desc": "Active tamper shared output 3 selection\nThe selected output must be available in the package pinout.\nBits 15:14 are the mirror of ATOSEL3[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1."
            },
            {
                "name": "ATOSEL4",
                "bitOffset": 17,
                "bitWidth": 3,
                "desc": "Active tamper shared output 4 selection\nThe selected output must be available in the package pinout.\nBits 18:17 are the mirror of ATOSEL2[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1."
            },
            {
                "name": "ATOSEL5",
                "bitOffset": 20,
                "bitWidth": 3,
                "desc": "Active tamper shared output 5 selection\nThe selected output must be available in the package pinout."
            },
            {
                "name": "ATOSEL6",
                "bitOffset": 23,
                "bitWidth": 3,
                "desc": "Active tamper shared output 6 selection\nThe selected output must be available in the package pinout."
            },
            {
                "name": "ATOSEL7",
                "bitOffset": 26,
                "bitWidth": 3,
                "desc": "Active tamper shared output 7 selection\nThe selected output must be available in the package pinout."
            },
            {
                "name": "ATOSEL8",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "Active tamper shared output 8 selection\nThe selected output must be available in the package pinout."
            }
        ]
    },
    "1140882464": {
        "name": "TAMP_CFGR",
        "address": 1140882464,
        "size": 32,
        "access": "",
        "desc": "TAMP configuration register",
        "fields": [
            {
                "name": "BKPRW",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Backup registers read/write protection offset\nProtection zone 1 is defined for backup registers from TAMP_BKP0R to TAMP_BKPxR (x = BKPRW-1, from 0 to 128).\nNote: If BKPRW = 0: there is no protection zone 1.\nNote: If BKPRWPRIV is set, BKPRW[7:0] can be written only in privileged mode."
            },
            {
                "name": "BKPW",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Backup registers write protection offset\nProtection zone 2 is defined for backup registers from TAMP_BKPyR (y = BKPRW, from 0 to 128) to TAMP_BKPzR (z = BKPW-1, from 0 to 128, BKPW greater than or equal BKPRW):\nProtection zone 3 defined for backup registers from TAMP_BKPtR (t = BKPW, from 0 to 127).."
            }
        ]
    },
    "1140882468": {
        "name": "TAMP_PRIVCFGR",
        "address": 1140882468,
        "size": 32,
        "access": "",
        "desc": "TAMP privilege configuration register",
        "fields": [
            {
                "name": "CNT1PRIV",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Monotonic counter 1 privilege protection"
            },
            {
                "name": "BKPRWPRIV",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Backup registers zone 1 privilege protection"
            },
            {
                "name": "BKPWPRIV",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Backup registers zone 2 privilege protection"
            },
            {
                "name": "TAMPPRIV",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Tamper privilege protection (excluding backup registers)\nNote: Refer to Section 32.3.6: TAMP privilege protection modes for details on the read protection."
            }
        ]
    },
    "1140882476": {
        "name": "TAMP_IER",
        "address": 1140882476,
        "size": 32,
        "access": "",
        "desc": "TAMP interrupt enable register",
        "fields": [
            {
                "name": "TAMP1IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper 1 interrupt enable"
            },
            {
                "name": "TAMP2IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper 2 interrupt enable"
            },
            {
                "name": "ITAMP1IE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Internal tamper 1 interrupt enable"
            },
            {
                "name": "ITAMP2IE",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Internal tamper 2 interrupt enable"
            },
            {
                "name": "ITAMP3IE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 interrupt enable"
            },
            {
                "name": "ITAMP4IE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Internal tamper 4 interrupt enable"
            },
            {
                "name": "ITAMP5IE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 interrupt enable"
            },
            {
                "name": "ITAMP6IE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 interrupt enable"
            },
            {
                "name": "ITAMP7IE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Internal tamper 7 interrupt enable"
            },
            {
                "name": "ITAMP8IE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Internal tamper 8 interrupt enable"
            },
            {
                "name": "ITAMP9IE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Internal tamper 9 interrupt enable"
            },
            {
                "name": "ITAMP11IE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Internal tamper 11 interrupt enable"
            },
            {
                "name": "ITAMP12IE",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Internal tamper 12 interrupt enable"
            },
            {
                "name": "ITAMP13IE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Internal tamper 13 interrupt enable"
            },
            {
                "name": "ITAMP15IE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Internal tamper 15 interrupt enable"
            }
        ]
    },
    "1140882480": {
        "name": "TAMP_SR",
        "address": 1140882480,
        "size": 32,
        "access": "",
        "desc": "TAMP status register",
        "fields": [
            {
                "name": "TAMP1F",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TAMP1 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP1 input."
            },
            {
                "name": "TAMP2F",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TAMP2 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP2 input."
            },
            {
                "name": "ITAMP1F",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Internal tamper 1 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 1."
            },
            {
                "name": "ITAMP2F",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Internal tamper 2 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 2."
            },
            {
                "name": "ITAMP3F",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 3."
            },
            {
                "name": "ITAMP4F",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Internal tamper 4 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 4."
            },
            {
                "name": "ITAMP5F",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 5."
            },
            {
                "name": "ITAMP6F",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 6."
            },
            {
                "name": "ITAMP7F",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Internal tamper 7 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 7."
            },
            {
                "name": "ITAMP8F",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Internal tamper 8 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 8."
            },
            {
                "name": "ITAMP9F",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Internal tamper 9 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 9."
            },
            {
                "name": "ITAMP11F",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Internal tamper 11 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 11."
            },
            {
                "name": "ITAMP12F",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Internal tamper 12 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 12."
            },
            {
                "name": "ITAMP13F",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Internal tamper 13 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 13."
            },
            {
                "name": "ITAMP15F",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Internal tamper 15 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 15."
            }
        ]
    },
    "1140882484": {
        "name": "TAMP_MISR",
        "address": 1140882484,
        "size": 32,
        "access": "",
        "desc": "TAMP masked interrupt status register",
        "fields": [
            {
                "name": "TAMP1MF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TAMP1 interrupt masked flag\nThis flag is set by hardware when the tamper 1 interrupt is raised."
            },
            {
                "name": "TAMP2MF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TAMP2 interrupt masked flag\nThis flag is set by hardware when the tamper 2 interrupt is raised."
            },
            {
                "name": "ITAMP1MF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Internal tamper 1  interrupt masked flag\nThis flag is set by hardware when the internal tamper 1 interrupt is raised."
            },
            {
                "name": "ITAMP2MF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Internal tamper 2  interrupt masked flag\nThis flag is set by hardware when the internal tamper 2 interrupt is raised."
            },
            {
                "name": "ITAMP3MF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3  interrupt masked flag\nThis flag is set by hardware when the internal tamper 3 interrupt is raised."
            },
            {
                "name": "ITAMP4MF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Internal tamper 4  interrupt masked flag\nThis flag is set by hardware when the internal tamper 4 interrupt is raised."
            },
            {
                "name": "ITAMP5MF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5  interrupt masked flag\nThis flag is set by hardware when the internal tamper 5 interrupt is raised."
            },
            {
                "name": "ITAMP6MF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6  interrupt masked flag\nThis flag is set by hardware when the internal tamper 6 interrupt is raised."
            },
            {
                "name": "ITAMP7MF",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Internal tamper 7 tamper  interrupt masked flag\nThis flag is set by hardware when the internal tamper 7  interrupt is raised."
            },
            {
                "name": "ITAMP8MF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Internal tamper 8 interrupt masked flag\nThis flag is set by hardware when the internal tamper 8 interrupt is raised."
            },
            {
                "name": "ITAMP9MF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "internal tamper 9 interrupt masked flag\nThis flag is set by hardware when the internal tamper 9 interrupt is raised."
            },
            {
                "name": "ITAMP11MF",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "internal tamper 11 interrupt masked flag\nThis flag is set by hardware when the internal tamper 11 interrupt is raised."
            },
            {
                "name": "ITAMP12MF",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "internal tamper 12 interrupt masked flag\nThis flag is set by hardware when the internal tamper 12 interrupt is raised."
            },
            {
                "name": "ITAMP13MF",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "internal tamper 13 interrupt masked flag\nThis flag is set by hardware when the internal tamper 13 interrupt is raised."
            },
            {
                "name": "ITAMP15MF",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "internal tamper 15 interrupt masked flag\nThis flag is set by hardware when the internal tamper 15 interrupt is raised."
            }
        ]
    },
    "1140882492": {
        "name": "TAMP_SCR",
        "address": 1140882492,
        "size": 32,
        "access": "",
        "desc": "TAMP status clear register",
        "fields": [
            {
                "name": "CTAMP1F",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear TAMP1 detection flag\nWriting 1 in this bit clears the TAMP1F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP2F",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear TAMP2 detection flag\nWriting 1 in this bit clears the TAMP2F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP1F",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Clear ITAMP1 detection flag\nWriting 1 in this bit clears the ITAMP1F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP2F",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Clear ITAMP2 detection flag\nWriting 1 in this bit clears the ITAMP2F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP3F",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Clear ITAMP3 detection flag\nWriting 1 in this bit clears the ITAMP3F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP4F",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Clear ITAMP4 detection flag\nWriting 1 in this bit clears the ITAMP4F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP5F",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Clear ITAMP5 detection flag\nWriting 1 in this bit clears the ITAMP5F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP6F",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Clear ITAMP6 detection flag\nWriting 1 in this bit clears the ITAMP6F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP7F",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Clear ITAMP7 detection flag\nWriting 1 in this bit clears the ITAMP7F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP8F",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Clear ITAMP8 detection flag\nWriting 1 in this bit clears the ITAMP8F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP9F",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Clear ITAMP9 detection flag\nWriting 1 in this bit clears the ITAMP9F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP11F",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Clear ITAMP11 detection flag\nWriting 1 in this bit clears the ITAMP11F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP12F",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Clear ITAMP12 detection flag\nWriting 1 in this bit clears the ITAMP12F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP13F",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Clear ITAMP13 detection flag\nWriting 1 in this bit clears the ITAMP13F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP15F",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Clear ITAMP15 detection flag\nWriting 1 in this bit clears the ITAMP15F bit in the TAMP_SR register."
            }
        ]
    },
    "1140882496": {
        "name": "TAMP_COUNT1R",
        "address": 1140882496,
        "size": 32,
        "access": "",
        "desc": "TAMP monotonic counter 1 register",
        "fields": [
            {
                "name": "COUNT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "This register is read-only only and is incremented by one when a write access is done to this register. This register cannot roll-over and is frozen when reaching the maximum value."
            }
        ]
    },
    "1140882516": {
        "name": "TAMP_ERCFGR",
        "address": 1140882516,
        "size": 32,
        "access": "",
        "desc": "TAMP erase configuration register",
        "fields": [
            {
                "name": "ERCFG0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Configurable device secrets configuration"
            }
        ]
    },
    "1140882688": {
        "name": "TAMP_BKP0R",
        "address": 1140882688,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 0 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882692": {
        "name": "TAMP_BKP1R",
        "address": 1140882692,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 1 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882696": {
        "name": "TAMP_BKP2R",
        "address": 1140882696,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 2 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882700": {
        "name": "TAMP_BKP3R",
        "address": 1140882700,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 3 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882704": {
        "name": "TAMP_BKP4R",
        "address": 1140882704,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 4 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882708": {
        "name": "TAMP_BKP5R",
        "address": 1140882708,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 5 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882712": {
        "name": "TAMP_BKP6R",
        "address": 1140882712,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 6 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882716": {
        "name": "TAMP_BKP7R",
        "address": 1140882716,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 7 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882720": {
        "name": "TAMP_BKP8R",
        "address": 1140882720,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 8 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882724": {
        "name": "TAMP_BKP9R",
        "address": 1140882724,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 9 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882728": {
        "name": "TAMP_BKP10R",
        "address": 1140882728,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 10 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882732": {
        "name": "TAMP_BKP11R",
        "address": 1140882732,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 11 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882736": {
        "name": "TAMP_BKP12R",
        "address": 1140882736,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 12 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882740": {
        "name": "TAMP_BKP13R",
        "address": 1140882740,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 13 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882744": {
        "name": "TAMP_BKP14R",
        "address": 1140882744,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 14 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882748": {
        "name": "TAMP_BKP15R",
        "address": 1140882748,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 15 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882752": {
        "name": "TAMP_BKP16R",
        "address": 1140882752,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 16 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882756": {
        "name": "TAMP_BKP17R",
        "address": 1140882756,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 17 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882760": {
        "name": "TAMP_BKP18R",
        "address": 1140882760,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 18 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882764": {
        "name": "TAMP_BKP19R",
        "address": 1140882764,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 19 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882768": {
        "name": "TAMP_BKP20R",
        "address": 1140882768,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 20 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882772": {
        "name": "TAMP_BKP21R",
        "address": 1140882772,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 21 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882776": {
        "name": "TAMP_BKP22R",
        "address": 1140882776,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 22 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882780": {
        "name": "TAMP_BKP23R",
        "address": 1140882780,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 23 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882784": {
        "name": "TAMP_BKP24R",
        "address": 1140882784,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 24 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882788": {
        "name": "TAMP_BKP25R",
        "address": 1140882788,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 25 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882792": {
        "name": "TAMP_BKP26R",
        "address": 1140882792,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 26 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882796": {
        "name": "TAMP_BKP27R",
        "address": 1140882796,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 27 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882800": {
        "name": "TAMP_BKP28R",
        "address": 1140882800,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 28 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882804": {
        "name": "TAMP_BKP29R",
        "address": 1140882804,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 29 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882808": {
        "name": "TAMP_BKP30R",
        "address": 1140882808,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 30 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1140882812": {
        "name": "TAMP_BKP31R",
        "address": 1140882812,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 31 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set."
            }
        ]
    },
    "1073818624": {
        "name": "TIM1_CR1",
        "address": 1073818624,
        "size": 22,
        "access": "",
        "desc": "TIM1 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction\nNote: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode."
            },
            {
                "name": "CMS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Center-aligned mode selection\nNote: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\nThis bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and the dead-time and sampling clock (t DTS )used by the dead-time generators and the digital filters (tim_etr_in, tim_tix),"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            },
            {
                "name": "DITHEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Dithering enable\nNote: The DITHEN bit can only be modified when CEN bit is reset."
            }
        ]
    },
    "1073818628": {
        "name": "TIM1_CR2",
        "address": 1073818628,
        "size": 32,
        "access": "",
        "desc": "TIM1 control register 2",
        "fields": [
            {
                "name": "CCPC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare preloaded control\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCUS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare control update selection\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "MMS[2:0]: Master mode selection\nThese bits select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:\nOther codes reserved\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "tim_ti1 selection"
            },
            {
                "name": "OIS1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Output idle state 1 (tim_oc1 output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OIS1N",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Output idle state 1 (tim_oc1n output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OIS2",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output idle state 2 (tim_oc2 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS2N",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output idle state 2 (tim_oc2n output)\nRefer to OIS1N bit"
            },
            {
                "name": "OIS3",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Output idle state 3 (tim_oc3n output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS3N",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Output idle state 3 (tim_oc3n output)\nRefer to OIS1N bit"
            },
            {
                "name": "OIS4",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Output idle state 4 (tim_oc4 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS4N",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Output idle state 4 (tim_oc4n output)\nRefer to OIS1N bit"
            },
            {
                "name": "OIS5",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output idle state 5 (tim_oc5 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS6",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Output idle state 6 (tim_oc6 output)\nRefer to OIS1 bit"
            },
            {
                "name": "MMS2",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Master mode selection 2\nThese bits allow the information to be sent to ADC for synchronization (tim_trgo2) to be selected. The combination is as follows:\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "MMS_1",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "MMS[3]"
            }
        ]
    },
    "1073818632": {
        "name": "TIM1_SMCR",
        "address": 1073818632,
        "size": 32,
        "access": "",
        "desc": "TIM1 slave mode control register",
        "fields": [
            {
                "name": "SMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "SMS[2:0]: Slave mode selection"
            },
            {
                "name": "OCCS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "OCREF clear selection\nThis bit is used to select the OCREF clear source."
            },
            {
                "name": "TS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "TS[2:0]: Trigger selection\nThis bitfield is combined with TS[4:3] bits.\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee Table 605: TIMx internal trigger connection for more details on tim_itrx meaning for each Timer.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/slave mode"
            },
            {
                "name": "ETF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "External trigger filter\nThis bit-field then defines the frequency used to sample tim_etrp signal and the length of the digital filter applied to tim_etrp. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "ETPS",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "External trigger prescaler\nExternal trigger signal tim_etrp frequency must be at most 1/4 of TIMxCLK frequency. A prescaler can be enabled to reduce tim_etrp frequency. It is useful when inputting fast external clocks on tim_etr_in."
            },
            {
                "name": "ECE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "External clock enable\nThis bit enables External clock mode 2.\nNote: Setting the ECE bit has the same effect as selecting external clock mode 1 with tim_trgi connected to tim_etrf (SMS=111 and TS=00111).\nIt is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, tim_trgi must not be connected to tim_etrf in this case (TS bits must not be 00111).\nNote: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is tim_etrf."
            },
            {
                "name": "ETP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "External trigger polarity\nThis bit selects whether tim_etr_in or tim_etr_in is used for trigger operations"
            },
            {
                "name": "SMS_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "SMS[3]"
            },
            {
                "name": "TS_1",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "TS[4:3]"
            },
            {
                "name": "SMSPE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "SMS preload enable\nThis bit selects whether the SMS[3:0] bitfield is preloaded"
            },
            {
                "name": "SMSPS",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "SMS preload source\nThis bit selects whether the events that triggers the SMS[3:0] bitfield transfer from preload to active"
            }
        ]
    },
    "1073818636": {
        "name": "TIM1_DIER",
        "address": 1073818636,
        "size": 32,
        "access": "",
        "desc": "TIM1 DMA/interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 interrupt enable"
            },
            {
                "name": "CC3IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 interrupt enable"
            },
            {
                "name": "CC4IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 interrupt enable"
            },
            {
                "name": "COMIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "BIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 2 DMA request enable"
            },
            {
                "name": "CC3DE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 3 DMA request enable"
            },
            {
                "name": "CC4DE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/compare 4 DMA request enable"
            },
            {
                "name": "COMDE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "COM DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            },
            {
                "name": "IDXIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Index interrupt enable"
            },
            {
                "name": "DIRIE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Direction change interrupt enable"
            },
            {
                "name": "IERRIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Index error interrupt enable"
            },
            {
                "name": "TERRIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transition error interrupt enable"
            }
        ]
    },
    "1073818640": {
        "name": "TIM1_SR",
        "address": 1073818640,
        "size": 32,
        "access": "",
        "desc": "TIM1 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by a trigger event (refer to Section 65.6.3: TIM1 slave mode control register (TIM1_SMCR)), if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in downcounting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC3IF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC4IF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "COMIF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt flag\nThis flag is set by hardware on COM event (when capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software."
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\nThis flag is set by hardware on the TRG trigger event (active edge detected on tim_trgi input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software."
            },
            {
                "name": "BIF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt flag\nThis flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active."
            },
            {
                "name": "B2IF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Break 2 interrupt flag\nThis flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 2 overcapture flag\nRefer to CC1OF description"
            },
            {
                "name": "CC3OF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 3 overcapture flag\nRefer to CC1OF description"
            },
            {
                "name": "CC4OF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/compare 4 overcapture flag\nRefer to CC1OF description"
            },
            {
                "name": "SBIF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "System break interrupt flag\nThis flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active.\nThis flag must be reset to re-start PWM operation."
            },
            {
                "name": "CC5IF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Compare 5 interrupt flag\nRefer to CC1IF description\nNote: Channel 5 can only be configured as output."
            },
            {
                "name": "CC6IF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Compare 6 interrupt flag\nRefer to CC1IF description\nNote: Channel 6 can only be configured as output."
            },
            {
                "name": "IDXF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Index interrupt flag\nThis flag is set by hardware when an index event is detected. It is cleared by software by writing it to '0'."
            },
            {
                "name": "DIRF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Direction change interrupt flag\nThis flag is set by hardware when the direction changes in encoder mode (DIR bit value in TIMx_CR is changing). It is cleared by software by writing it to '0'."
            },
            {
                "name": "IERRF",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Index error interrupt flag\nThis flag is set by hardware when an index error is detected. It is cleared by software by writing it to '0'."
            },
            {
                "name": "TERRF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transition error interrupt flag\nThis flag is set by hardware when a transition error is detected in encoder mode. It is cleared by software by writing it to '0'."
            }
        ]
    },
    "1073818644": {
        "name": "TIM1_EGR",
        "address": 1073818644,
        "size": 22,
        "access": "",
        "desc": "TIM1 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 generation\nRefer to CC1G description"
            },
            {
                "name": "CC3G",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 generation\nRefer to CC1G description"
            },
            {
                "name": "CC4G",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 generation\nRefer to CC1G description"
            },
            {
                "name": "COMG",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/compare control update generation\nThis bit can be set by software, it is automatically cleared by hardware\nNote: This bit acts only on channels having a complementary output."
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            },
            {
                "name": "BG",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            },
            {
                "name": "B2G",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Break 2 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073818648": {
        "name": "TIM1_CCMR1_Input",
        "address": 1073818648,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare mode register 1 [alternate]",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/compare 1 Selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = '0' in TIMx_CCER)."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1). The prescaler is reset as soon as CC1E='0' (TIMx_CCER register)."
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\nThis bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E = '0' in TIMx_CCER)."
            },
            {
                "name": "IC2PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler"
            },
            {
                "name": "IC2F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 2 filter"
            }
        ]
    },
    "1073818652": {
        "name": "TIM1_CCMR2_Input",
        "address": 1073818652,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare mode register 2 [alternate]",
        "fields": [
            {
                "name": "CC3S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC3S bits are writable only when the channel is OFF (CC3E = '0' in TIMx_CCER)."
            },
            {
                "name": "IC3PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler"
            },
            {
                "name": "IC3F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 3 filter"
            },
            {
                "name": "CC4S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC4S bits are writable only when the channel is OFF (CC4E = '0' in TIMx_CCER)."
            },
            {
                "name": "IC4PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler"
            },
            {
                "name": "IC4F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 4 filter"
            }
        ]
    },
    "1073818656": {
        "name": "TIM1_CCER",
        "address": 1073818656,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 output enable\nWhen CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to Table 619 for details.\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 output polarity\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\nCC1NP=1, CC1P=1:\tnon-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\nCC1NP=1, CC1P=0:\tthe configuration is reserved, it must not be used.\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 1 complementary output enable\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 1 complementary output polarity\nCC1 channel configured as output:\nCC1 channel configured as input:\nThis bit is used in conjunction with CC1P to define the polarity of tim_ti1fp1 and tim_ti2fp1. Refer to CC1P description.\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (channel configured as output).\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 2 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/compare 2 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC2NE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Capture/compare 2 complementary output enable\nRefer to CC1NE description"
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/compare 2 complementary output polarity\nRefer to CC1NP description"
            },
            {
                "name": "CC3E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Capture/compare 3 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC3P",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 3 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC3NE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 3 complementary output enable\nRefer to CC1NE description"
            },
            {
                "name": "CC3NP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 3 complementary output polarity\nRefer to CC1NP description"
            },
            {
                "name": "CC4E",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/compare 4 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Capture/compare 4 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC4NE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Capture/compare 4 complementary output enable\nRefer to CC1NE description"
            },
            {
                "name": "CC4NP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Capture/compare 4 complementary output polarity\nRefer to CC1NP description"
            },
            {
                "name": "CC5E",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/compare 5 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC5P",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/compare 5 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC6E",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Capture/compare 6 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC6P",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Capture/compare 6 output polarity\nRefer to CC1P description"
            }
        ]
    },
    "1073818660": {
        "name": "TIM1_CNT",
        "address": 1073818660,
        "size": 32,
        "access": "",
        "desc": "TIM1 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value\nNon-dithering mode (DITHEN = 0)\nThe register holds the counter value.\nDithering mode (DITHEN = 1)\nThe register only holds the non-dithered part in CNT[15:0]. The fractional part is not available."
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0."
            }
        ]
    },
    "1073818664": {
        "name": "TIM1_PSC",
        "address": 1073818664,
        "size": 22,
        "access": "",
        "desc": "TIM1 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\nThe counter clock frequency (f tim_cnt_ck ) is equal to f tim_psc_ck  / (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in 'reset mode')."
            }
        ]
    },
    "1073818668": {
        "name": "TIM1_ARR",
        "address": 1073818668,
        "size": 32,
        "access": "",
        "desc": "TIM1 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the Section 65.3.3: Time-base unit on page 4457 for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null.\nNon-dithering mode (DITHEN = 0)\nThe register holds the auto-reload value.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part."
            }
        ]
    },
    "1073818672": {
        "name": "TIM1_RCR",
        "address": 1073818672,
        "size": 22,
        "access": "",
        "desc": "TIM1 repetition counter register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Repetition counter reload value\nThis bitfield defines the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable. It also defines the update interrupt generation rate, if this interrupt is enable.\nWhen the repetition down-counter reaches zero, an update event is generated and it restarts counting from REP value. As the repetition counter is reloaded with REP value only at the repetition update event UEV, any write to the TIMx_RCR register is not taken in account until the next repetition update event.\nIt means in PWM mode (REP+1) corresponds to:\nthe number of PWM periods in edge-aligned mode\nthe number of half PWM period in center-aligned mode."
            }
        ]
    },
    "1073818676": {
        "name": "TIM1_CCR1",
        "address": 1073818676,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 1 value\nIf channel CC1 is configured as output: CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value in CCR1[15:0]. The CCR1[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR1[19:4]. The CCR1[3:0] bitfield contains the dithered part.\nIf channel CC1 is configured as input: CR1 is the counter value transferred by the last input capture 1 event (tim_ic1). The TIMx_CCR1 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe register holds the capture value in CCR1[15:0]. The CCR1[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR1[19:4]. The CCR1[3:0] bits are reset."
            }
        ]
    },
    "1073818680": {
        "name": "TIM1_CCR2",
        "address": 1073818680,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 2 value\nIf channel CC2 is configured as output: CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc2 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value in CCR2[15:0]. The CCR2[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR2[19:4]. The CCR2[3:0] bitfield contains the dithered part.\nIf channel CC2 is configured as input: CCR2 is the counter value transferred by the last input capture 2 event (tim_ic2). The TIMx_CCR2 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe register holds the capture value in CCR2[15:0]. The CCR2[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR2[19:4]. The CCR2[3:0] bits are reset."
            }
        ]
    },
    "1073818684": {
        "name": "TIM1_CCR3",
        "address": 1073818684,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare value\nIf channel CC3 is configured as output: CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc3 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value in CCR3[15:0]. The CCR3[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR3[19:4]. The CCR3[3:0] bitfield contains the dithered part.\nIf channel CC3 is configured as input: CCR3 is the counter value transferred by the last input capture 3 event (tim_ic3). The TIMx_CCR3 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe register holds the capture value in CCR3[15:0]. The CCR3[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR3[19:4]. The CCR3[3:0] bits are reset."
            }
        ]
    },
    "1073818688": {
        "name": "TIM1_CCR4",
        "address": 1073818688,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare value\nIf channel CC4 is configured as output: CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on tim_oc4 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value in CCR4[15:0]. The CCR4[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR4[19:4]. The CCR4[3:0] bitfield contains the dithered part.\nIf channel CC4 is configured as input: CCR4 is the counter value transferred by the last input capture 4 event (tim_ic4). The TIMx_CCR4 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe register holds the capture value in CCR4[15:0]. The CCR4[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR4[19:4]. The CCR4[3:0] bits are reset."
            }
        ]
    },
    "1073818692": {
        "name": "TIM1_BDTR",
        "address": 1073818692,
        "size": 32,
        "access": "",
        "desc": "TIM1 break and dead-time register",
        "fields": [
            {
                "name": "DTG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time generator setup\nThis bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.\nDTG[7:5]=0xx = DT=DTG[7:0]x t dtg  with t dtg =t DTS .\nDTG[7:5]=10x = DT=(64+DTG[5:0])xt dtg  with T dtg =2xt DTS .\nDTG[7:5]=110 = DT=(32+DTG[4:0])xt dtg  with T dtg =8xt DTS .\nDTG[7:5]=111 = DT=(32+DTG[4:0])xt dtg  with T dtg =16xt DTS .\nExample if T DTS =125ns (8MHz), dead-time possible values are:\n0 to 15875 ns by 125 ns steps,\n16 us to 31750 ns by 250 ns steps,\n32 us to 63us by 1 us steps,\n64 us to 126 us by 2 us steps\nNote: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "LOCK",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Lock configuration\nThese bits offer a write protection against software errors.\nNote: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset."
            },
            {
                "name": "OSSI",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Off-state selection for idle mode\nThis bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs.\nSee OC/OCN enable description for more details (Section 65.6.11: TIM1 capture/compare enable register (TIM1_CCER)).\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OSSR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Off-state selection for Run mode\nThis bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.\nSee OC/OCN enable description for more details (Section 65.6.11: TIM1 capture/compare enable register (TIM1_CCER)).\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Break enable\nThis bit enables the complete break protection (including all sources connected to bk_acth and BKIN sources, as per Figure 635: Break and Break2 circuitry overview).\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Break polarity\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "AOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Automatic output enable\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "MOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Main output enable\nThis bit is cleared asynchronously by hardware as soon as one of the break inputs is active (tim_brk or tim_brk2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.\nIn response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.\nSee OC/OCN enable description for more details (Section 65.6.11: TIM1 capture/compare enable register (TIM1_CCER))."
            },
            {
                "name": "BKF",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Break filter\nThis bit-field defines the frequency used to sample tim_brk input and the length of the digital filter applied to tim_brk. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2F",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Break 2 filter\nThis bit-field defines the frequency used to sample tim_brk2 input and the length of the digital filter applied to tim_brk2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2E",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Break 2 enable\nThis bit enables the complete break 2 protection (including all sources connected to bk_acth and BKIN sources, as per Figure 635: Break and Break2 circuitry overview).\nNote: The BRKIN2 must only be used with OSSR = OSSI = 1.\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2P",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Break 2 polarity\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKDSRM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Break disarm\nThis bit is cleared by hardware when no break source is active.\nThe BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2DSRM",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Break2 disarm\nRefer to BKDSRM description"
            },
            {
                "name": "BKBID",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Break bidirectional\nIn the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2BID",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Break2 bidirectional\nRefer to BKBID description"
            }
        ]
    },
    "1073818696": {
        "name": "TIM1_CCR5",
        "address": 1073818696,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare register 5",
        "fields": [
            {
                "name": "CCR5",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 5 value\nCCR5 is the value to be loaded in the actual capture/compare 5 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc5 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value in CCR5[15:0]. The CCR5[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR5[19:4]. The CCR5[3:0] bitfield contains the dithered part."
            },
            {
                "name": "GC5C1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Group channel 5 and channel 1\nDistortion on channel 1 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).\nNote: it is also possible to apply this distortion on combined PWM signals."
            },
            {
                "name": "GC5C2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Group channel 5 and channel 2\nDistortion on channel 2 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).\nNote: it is also possible to apply this distortion on combined PWM signals."
            },
            {
                "name": "GC5C3",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Group channel 5 and channel 3\nDistortion on channel 3 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2).\nNote: it is also possible to apply this distortion on combined PWM signals."
            }
        ]
    },
    "1073818700": {
        "name": "TIM1_CCR6",
        "address": 1073818700,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare register 6",
        "fields": [
            {
                "name": "CCR6",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 6 value\nCCR6 is the value to be loaded in the actual capture/compare 6 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC6PE). Else the preload value is copied in the active capture/compare 6 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc6 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value in CCR6[15:0]. The CCR6[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR6[19:4]. The CCR6[3:0] bitfield contains the dithered part."
            }
        ]
    },
    "1073818704": {
        "name": "TIM1_CCMR3",
        "address": 1073818704,
        "size": 32,
        "access": "",
        "desc": "TIM1 capture/compare mode register 3",
        "fields": [
            {
                "name": "OC5FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output compare 5 fast enable"
            },
            {
                "name": "OC5PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output compare 5 preload enable"
            },
            {
                "name": "OC5M",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "OC5M[2:0]: Output compare 5 mode"
            },
            {
                "name": "OC5CE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Output compare 5 clear enable"
            },
            {
                "name": "OC6FE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output compare 6 fast enable"
            },
            {
                "name": "OC6PE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output compare 6 preload enable"
            },
            {
                "name": "OC6M",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "OC6M[2:0]: Output compare 6 mode"
            },
            {
                "name": "OC6CE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Output compare 6 clear enable"
            },
            {
                "name": "OC5M_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "OC5M[3]"
            },
            {
                "name": "OC6M_1",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "OC6M[3]"
            }
        ]
    },
    "1073818708": {
        "name": "TIM1_DTR2",
        "address": 1073818708,
        "size": 32,
        "access": "",
        "desc": "TIM1 timer deadtime register 2",
        "fields": [
            {
                "name": "DTGF",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time falling edge generator setup\nThis bit-field defines the duration of the dead-time inserted between the complementary outputs, on the falling edge.\nDTGF[7:5]=0xx = DTF=DTGF[7:0]x t dtg  with t dtg =t DTS .\nDTGF[7:5]=10x = DTF=(64+DTGF[5:0])xt dtg  with T dtg =2xt DTS .\nDTGF[7:5]=110 = DTF=(32+DTGF[4:0])xt dtg  with T dtg =8xt DTS .\nDTGF[7:5]=111 = DTF=(32+DTGF[4:0])xt dtg  with T dtg =16xt DTS .\nExample if T DTS =125ns (8MHz), dead-time possible values are:\n0 to 15875 ns by 125 ns steps,\n16 us to 31750 ns by 250 ns steps,\n32 us to 63us by 1 us steps,\n64 us to 126 us by 2 us steps\nNote: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "DTAE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Deadtime asymmetric enable\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "DTPE",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Deadtime preload enable\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073818712": {
        "name": "TIM1_ECR",
        "address": 1073818712,
        "size": 32,
        "access": "",
        "desc": "TIM1 timer encoder control register",
        "fields": [
            {
                "name": "IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Index enable\nThis bit indicates if the Index event resets the counter."
            },
            {
                "name": "IDIR",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Index direction\nThis bit indicates in which direction the Index event resets the counter.\nNote: The IDR[1:0] bitfield must be written when IE bit is reset (index disabled)."
            },
            {
                "name": "IBLK",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Index blanking\nThis bit indicates if the Index event is conditioned by the tim_ti3 input"
            },
            {
                "name": "FIDX",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "First index\nThis bit indicates if the first index only is taken into account"
            },
            {
                "name": "IPOS",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Index positioning\nIn quadrature encoder mode (SMS[3:0] = 0001, 0010, 0011, 1110, 1111), this bit indicates in which AB input configuration the Index event resets the counter.\nIn directional clock mode or clock plus direction mode (SMS[3:0] = 1010, 1011, 1100, 1101), these bits indicates on which level the Index event resets the counter. In bidirectional clock mode, this applies for both clock inputs.\nx0: Index resets the counter when clock is 0\nx1: Index resets the counter when clock is 1\nNote: IPOS[1] bit is not significant"
            },
            {
                "name": "PW",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Pulse width\nThis bitfield defines the pulse duration, as following:\nt PW  = PW[7:0] x t PWG "
            },
            {
                "name": "PWPRSC",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "Pulse width prescaler\nThis bitfield sets the clock prescaler for the pulse generator, as following:\nt PWG  = (2sup(PWPRSC[2:0])/sup) x t tim_ker_ck "
            }
        ]
    },
    "1073818716": {
        "name": "TIM1_TISEL",
        "address": 1073818716,
        "size": 32,
        "access": "",
        "desc": "TIM1 timer input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Selects tim_ti1[0..15] input\n...\nRefer to Section 65.3.2: TIM1 pins and internal signals for interconnects list."
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Selects tim_ti2[0..15] input\n...\nRefer to Section 65.3.2: TIM1 pins and internal signals for interconnects list."
            },
            {
                "name": "TI3SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Selects tim_ti3[0..15] input\n...\nRefer to Section 65.3.2: TIM1 pins and internal signals for interconnects list."
            },
            {
                "name": "TI4SEL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Selects tim_ti4[0..15] input\n...\nRefer to Section 65.3.2: TIM1 pins and internal signals for interconnects list."
            }
        ]
    },
    "1073818720": {
        "name": "TIM1_AF1",
        "address": 1073818720,
        "size": 32,
        "access": "",
        "desc": "TIM1 alternate function option register 1",
        "fields": [
            {
                "name": "BKINE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIMx_BKIN input enable\nThis bit enables the TIMx_BKIN alternate function input for the timer's tim_brk input. TIMx_BKIN input is 'ORed' with the other tim_brk sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "tim_brk_cmp1 enable\nThis bit enables the tim_brk_cmp1 for the timer's tim_brk input. tim_brk_cmp1 output is 'ORed' with the other tim_brk sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "tim_brk_cmp2 enable\nThis bit enables the tim_brk_cmp2 for the timer's tim_brk input. tim_brk_cmp2 output is 'ORed' with the other tim_brk sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP3E",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "tim_brk_cmp3 enable\nThis bit enables the tim_brk_cmp3 for the timer's tim_brk input. tim_brk_cmp3 output is 'ORed' with the other tim_brk sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP4E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "tim_brk_cmp4 enable\nThis bit enables the tim_brk_cmp4 for the timer's tim_brk input. tim_brk_cmp4 output is 'ORed' with the other tim_brk sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP5E",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "tim_brk_cmp5 enable\nThis bit enables the tim_brk_cmp5 for the timer's tim_brk input. tim_brk_cmp5 output is 'ORed' with the other tim_brk sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP6E",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "tim_brk_cmp6 enable\nThis bit enables the tim_brk_cmp6 for the timer's tim_brk input. tim_brk_cmp6 output is 'ORed' with the other tim_brk sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP7E",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "tim_brk_cmp7 enable\nThis bit enables the tim_brk_cmp7 for the timer's tim_brk input. tim_brk_cmp7 output is 'ORed' with the other tim_brk sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP8E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "tim_brk_cmp8 enable\nThis bit enables the tim_brk_cmp8 for the timer's tim_brk input. tim_brk_cmp8 output is 'ORed' with the other tim_brk sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKINP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "TIMx_BKIN input polarity\nThis bit selects the TIMx_BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "tim_brk_cmp1 input polarity\nThis bit selects the tim_brk_cmp1 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "tim_brk_cmp2 input polarity\nThis bit selects the tim_brk_cmp2 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP3P",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "tim_brk_cmp3 input polarity\nThis bit selects the tim_brk_cmp3 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "tim_brk_cmp4 input polarity\nThis bit selects the tim_brk_cmp4 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "ETRSEL",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "etr_in source selection\nThese bits select the etr_in input source.\n...\nRefer to Section 65.3.2: TIM1 pins and internal signals for product specific implementation.\nNote: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073818724": {
        "name": "TIM1_AF2",
        "address": 1073818724,
        "size": 32,
        "access": "",
        "desc": "TIM1 alternate function register 2",
        "fields": [
            {
                "name": "BK2INE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIMx_BKIN2 input enable\nThis bit enables the TIMx_BKIN2 alternate function input for the timer's tim_brk2 input. TIMx_BKIN2 input is 'ORed' with the other tim_brk2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp1 enable\nThis bit enables the tim_brk2_cmp1 for the timer's tim_brk2 input. tim_brk2_cmp1 output is 'ORed' with the other tim_brk2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp2 enable\nThis bit enables the tim_brk2_cmp2 for the timer's tim_brk2 input. tim_brk2_cmp2 output is 'ORed' with the other tim_brk2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP3E",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp3 enable\nThis bit enables the tim_brk2_cmp3 for the timer's tim_brk2 input. tim_brk2_cmp3 output is 'ORed' with the other tim_brk2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP4E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp4 enable\nThis bit enables the tim_brk2_cmp4 for the timer's tim_brk2 input. tim_brk2_cmp4 output is 'ORed' with the other tim_brk2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP5E",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp5 enable\nThis bit enables the tim_brk2_cmp5 for the timer's tim_brk2 input. tim_brk2_cmp5 output is 'ORed' with the other tim_brk2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP6E",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp6 enable\nThis bit enables the tim_brk2_cmp6 for the timer's tim_brk2 input. tim_brk2_cmp6 output is 'ORed' with the other tim_brk2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP7E",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp7 enable\nThis bit enables the tim_brk2_cmp7 for the timer's tim_brk2 input. tim_brk2_cmp7 output is 'ORed' with the other tim_brk2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP8E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp8 enable\nThis bit enables the tim_brk2_cmp8 for the timer's tim_brk2 input. tim_brk2_cmp8 output is 'ORed' with the other tim_brk2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2INP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "TIMx_BKIN2 input polarity\nThis bit selects the TIMx_BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp1 input polarity\nThis bit selects the tim_brk2_cmp1 input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp2 input polarity\nThis bit selects the tim_brk2_cmp2 input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP3P",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp3 input polarity\nThis bit selects the tim_brk2_cmp3 input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp4 input polarity\nThis bit selects the tim_brk2_cmp4 input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OCRSEL",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "ocref_clr source selection\nThese bits select the ocref_clr input source.\n...\nRefer to Section 65.3.2: TIM1 pins and internal signals for product specific information.\nNote: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073819612": {
        "name": "TIM1_DCR",
        "address": 1073819612,
        "size": 32,
        "access": "",
        "desc": "TIM1 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\nThis 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n..."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\nThis 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).\n...\nExample: Let us consider the following transfer: DBL = 7 bytes & DBA = TIM2_CR1.\nIf DBL = 7 bytes and DBA = TIM2_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:\n(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL\nIn this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data are copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA\nAccording to the configuration of the DMA Data Size, several cases may occur:\nIf the DMA Data Size is configured in half-words, 16-bit data are transferred to each of the 7 registers.\nIf the DMA Data Size is configured in bytes, the data are also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA."
            },
            {
                "name": "DBSS",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "DMA burst source selection\nThis bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).\nOthers: reserved"
            }
        ]
    },
    "1073819616": {
        "name": "TIM1_DMAR",
        "address": 1073819616,
        "size": 32,
        "access": "",
        "desc": "TIM1 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "DMA register for burst accesses\nA read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR)."
            }
        ]
    },
    "1073741824": {
        "name": "TIM2_CR1",
        "address": 1073741824,
        "size": 22,
        "access": "",
        "desc": "TIM2 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\nCEN is cleared automatically in one-pulse mode, when an update event occurs."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction\nNote: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode."
            },
            {
                "name": "CMS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Center-aligned mode selection\nNote: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\nThis bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and sampling clock used by the digital filters (tim_etr_in, tim_tix),"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            },
            {
                "name": "DITHEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Dithering Enable\nNote: The DITHEN bit can only be modified when CEN bit is reset."
            }
        ]
    },
    "1073741828": {
        "name": "TIM2_CR2",
        "address": 1073741828,
        "size": 32,
        "access": "",
        "desc": "TIM2 control register 2",
        "fields": [
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\nThese bits allow to select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:\ntim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).\nOthers: Reserved\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "tim_ti1 selection"
            },
            {
                "name": "MMS2",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Master mode selection\nThese bits allow to select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:\ntim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).\nOthers: Reserved\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            }
        ]
    },
    "1073741832": {
        "name": "TIM2_SMCR",
        "address": 1073741832,
        "size": 32,
        "access": "",
        "desc": "TIM2 slave mode control register",
        "fields": [
            {
                "name": "SMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nNote: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on tim_ti1f, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo signal must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "OCCS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "OCREF clear selection\nThis bit is used to select the OCREF clear source\nNote: If the OCREF clear selection feature is not supported, this bit is reserved and forced by hardware to '0'. ."
            },
            {
                "name": "TS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee  for product specific implementation details.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/Slave mode"
            },
            {
                "name": "ETF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "External trigger filter\nThis bit-field then defines the frequency used to sample tim_etrp signal and the length of the digital filter applied to tim_etrp. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "ETPS",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "External trigger prescaler\nExternal trigger signal tim_etrp frequency must be at most 1/4 of tim_ker_ck frequency. A prescaler can be enabled to reduce tim_etrp frequency. It is useful when inputting fast external clocks on tim_etr_in."
            },
            {
                "name": "ECE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "External clock enable\nThis bit enables External clock mode 2.\nNote: Setting the ECE bit has the same effect as selecting external clock mode 1 with tim_trgi connected to tim_etrf (SMS=111 and TS=00111).\nIt is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, tim_trgi must not be connected to tim_etrf in this case (TS bits must not be 00111).\nIf external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is tim_etrf."
            },
            {
                "name": "ETP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "External trigger polarity\nThis bit selects whether tim_etr_in or tim_etr_in is used for trigger operations"
            },
            {
                "name": "SMS_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nNote: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on tim_ti1f, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo signal must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TS_1",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee  for product specific implementation details.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "SMSPE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "SMS preload enable\nThis bit selects whether the SMS[3:0] bitfield is preloaded"
            },
            {
                "name": "SMSPS",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "SMS preload source\nThis bit selects whether the events that triggers the SMS[3:0] bitfield transfer from preload to active"
            }
        ]
    },
    "1073741836": {
        "name": "TIM2_DIER",
        "address": 1073741836,
        "size": 32,
        "access": "",
        "desc": "TIM2 DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt enable"
            },
            {
                "name": "CC3IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt enable"
            },
            {
                "name": "CC4IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 DMA request enable"
            },
            {
                "name": "CC3DE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 DMA request enable"
            },
            {
                "name": "CC4DE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            },
            {
                "name": "IDXIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Index interrupt enable"
            },
            {
                "name": "DIRIE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Direction change interrupt enable"
            },
            {
                "name": "IERRIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Index error interrupt enable"
            },
            {
                "name": "TERRIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transition error interrupt enable"
            }
        ]
    },
    "1073741840": {
        "name": "TIM2_SR",
        "address": 1073741840,
        "size": 32,
        "access": "",
        "desc": "TIM2 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow or underflow and if UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in downcounting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC3IF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC4IF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\nThis flag is set by hardware on the TRG trigger event (active edge detected on tim_trgi input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 2 overcapture flag\nrefer to CC1OF description"
            },
            {
                "name": "CC3OF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 overcapture flag\nrefer to CC1OF description"
            },
            {
                "name": "CC4OF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 overcapture flag\nrefer to CC1OF description"
            },
            {
                "name": "IDXF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Index interrupt flag\nThis flag is set by hardware when an index event is detected. It is cleared by software by\nwriting it to '0'."
            },
            {
                "name": "DIRF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Direction change interrupt flag\nThis flag is set by hardware when the direction changes in encoder mode (DIR bit value in\nTIMx_CR is changing). It is cleared by software by writing it to '0'."
            },
            {
                "name": "IERRF",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Index error interrupt flag\nThis flag is set by hardware when an index error is detected. It is cleared by software by\nwriting it to '0'."
            },
            {
                "name": "TERRF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transition error interrupt flag\nThis flag is set by hardware when a transition error is detected in encoder mode. It is cleared\nby software by writing it to '0'."
            }
        ]
    },
    "1073741844": {
        "name": "TIM2_EGR",
        "address": 1073741844,
        "size": 22,
        "access": "",
        "desc": "TIM2 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 generation\nRefer to CC1G description"
            },
            {
                "name": "CC3G",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 generation\nRefer to CC1G description"
            },
            {
                "name": "CC4G",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 generation\nRefer to CC1G description"
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073741848": {
        "name": "TIM2_CCMR1_Input",
        "address": 1073741848,
        "size": 32,
        "access": "",
        "desc": "TIM2 capture/compare mode register 1 [alternate]",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register)."
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\nThis bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC2PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler"
            },
            {
                "name": "IC2F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 2 filter"
            }
        ]
    },
    "1073741852": {
        "name": "TIM2_CCMR2_Input",
        "address": 1073741852,
        "size": 32,
        "access": "",
        "desc": "TIM2 capture/compare mode register 2 [alternate]",
        "fields": [
            {
                "name": "CC3S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC3PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler"
            },
            {
                "name": "IC3F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 3 filter"
            },
            {
                "name": "CC4S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC4PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler"
            },
            {
                "name": "IC4F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 4 filter"
            }
        ]
    },
    "1073741856": {
        "name": "TIM2_CCER",
        "address": 1073741856,
        "size": 22,
        "access": "",
        "desc": "TIM2 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity.\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\nCC1NP=1, CC1P=1:\tnon-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\nCC1NP=1, CC1P=0:\tthis configuration is reserved, it must not be used."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity.\nCC1 channel configured as output: CC1NP must be kept cleared in this case.\nCC1 channel configured as input: This bit is used in conjunction with CC1P to define tim_ti1fp1/tim_ti2fp1 polarity. refer to CC1P description."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output enable.\nRefer to CC1E description"
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity.\nrefer to CC1P description"
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity.\nRefer to CC1NP description"
            },
            {
                "name": "CC3E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output enable.\nRefer to CC1E description"
            },
            {
                "name": "CC3P",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity.\nRefer to CC1P description"
            },
            {
                "name": "CC3NP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity.\nRefer to CC1NP description"
            },
            {
                "name": "CC4E",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output enable.\nrefer to CC1E description"
            },
            {
                "name": "CC4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity.\nRefer to CC1P description"
            },
            {
                "name": "CC4NP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity.\nRefer to CC1NP description"
            }
        ]
    },
    "1073741860": {
        "name": "TIM2_CNT",
        "address": 1073741860,
        "size": 32,
        "access": "",
        "desc": "TIM2 counter ",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "or UIFCPY: Value depends on IUFREMAP in TIMx_CR1.\nIf UIFREMAP = 0\nnullMost significant bit of counter value\nIf UIFREMAP = 1\nUIFCPY: UIF Copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register\nnullLeast significant part of counter value\nNon-dithering mode (DITHEN = 0)\nThe register holds the counter value.\nDithering mode (DITHEN = 1)\nThe register holds the non-dithered part in CNT[30:0]. The fractional part is not available."
            }
        ]
    },
    "1073741864": {
        "name": "TIM2_PSC",
        "address": 1073741864,
        "size": 22,
        "access": "",
        "desc": "TIM2 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\nThe counter clock frequency tim_cnt_ck is equal to ftim_psc_ck / (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in 'reset mode')."
            }
        ]
    },
    "1073741868": {
        "name": "TIM2_ARR",
        "address": 1073741868,
        "size": 32,
        "access": "",
        "desc": "TIM2 auto-reload register ",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the  for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null.\nNon-dithering mode (DITHEN = 0)\nThe register holds the auto-reload value.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in ARR[31:4]. The ARR[3:0] bitfield contains the dithered part."
            }
        ]
    },
    "1073741876": {
        "name": "TIM2_CCR1",
        "address": 1073741876,
        "size": 32,
        "access": "",
        "desc": "TIM2 capture/compare register 1 ",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Capture/compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR1[31:4]. The CCR1[3:0] bitfield contains the dithered part.\nIf channel CC1 is configured as input:\nCCR1 is the counter value transferred by the last input capture 1 event (tim_ic1). The TIMx_CCR1 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe register holds the capture value.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR1[31:0]. The CCR1[3:0] bits are reset."
            }
        ]
    },
    "1073741880": {
        "name": "TIM2_CCR2",
        "address": 1073741880,
        "size": 32,
        "access": "",
        "desc": "TIM2 capture/compare register 2 ",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Capture/compare 2 value\nIf channel CC2 is configured as output:\nCCR2 is the value to be loaded in the actual capture/compare 2 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc2 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR2[31:4]. The CCR2[3:0] bitfield contains the dithered part.\nIf channel CC2 is configured as input:\nCCR2 is the counter value transferred by the last input capture 2 event (tim_ic2). The TIMx_CCR2 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe register holds the capture value.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR2[31:0]. The CCR2[3:0] bits are reset."
            }
        ]
    },
    "1073741884": {
        "name": "TIM2_CCR3",
        "address": 1073741884,
        "size": 32,
        "access": "",
        "desc": "TIM2 capture/compare register 3 ",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Capture/compare 3 value\nIf channel CC3 is configured as output:\nCCR3 is the value to be loaded in the actual capture/compare 3 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc3 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR3[31:4]. The CCR3[3:0] bitfield contains the dithered part.\nIf channel CC3 is configured as input:\nCCR3 is the counter value transferred by the last input capture 3 event (tim_ic3). The TIMx_CCR3 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe register holds the capture value.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR3[31:0]. The CCR3[3:0] bits are reset."
            }
        ]
    },
    "1073741888": {
        "name": "TIM2_CCR4",
        "address": 1073741888,
        "size": 32,
        "access": "",
        "desc": "TIM2 capture/compare register 4 ",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Capture/compare 4 value\nIf channel CC4 is configured as output:\nCCR4 is the value to be loaded in the actual capture/compare 4 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR4 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc4 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR4[31:4]. The CCR4[3:0] bitfield contains the dithered part.\nIf channel CC4 is configured as input:\nCCR4 is the counter value transferred by the last input capture 4 event (tim_ic4). The TIMx_CCR4 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe register holds the capture value.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR4[31:0]. The CCR4[3:0] bits are reset."
            }
        ]
    },
    "1073741912": {
        "name": "TIM2_ECR",
        "address": 1073741912,
        "size": 32,
        "access": "",
        "desc": "TIM2 timer encoder control register",
        "fields": [
            {
                "name": "IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Index enable\nThis bit indicates if the Index event resets the counter."
            },
            {
                "name": "IDIR",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Index direction\nThis bit indicates in which direction the Index event resets the counter.\nNote: The IDR[1:0] bitfield must be written when IE bit is reset (index disabled)."
            },
            {
                "name": "IBLK",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Index blanking\nThis bit indicates if the Index event is conditioned by the tim_ti3 input"
            },
            {
                "name": "FIDX",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "First index\nThis bit indicates if the first index only is taken into account"
            },
            {
                "name": "IPOS",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Index positioning\nIn quadrature encoder mode (SMS[3:0] = 0001, 0010, 0011, 1110, 1111), this bit indicates in which AB input configuration the Index event resets the counter.\nIn directional clock mode or clock plus direction mode (SMS[3:0] = 1010, 1011, 1100, 1101), these bits indicates on which level the Index event resets the counter. In bidirectional clock mode, this applies for both clock inputs.\nx0: Index resets the counter when clock is 0\nx1: Index resets the counter when clock is 1\nNote: IPOS[1] bit is not significant"
            },
            {
                "name": "PW",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Pulse width\nThis bitfield defines the pulse duration, as following:\ntPW = PW[7:0] x tPWG"
            },
            {
                "name": "PWPRSC",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "Pulse width prescaler\nThis bitfield sets the clock prescaler for the pulse generator, as following:\ntPWG = (2(PWPRSC[2:0])) x ttim_ker_ck"
            }
        ]
    },
    "1073741916": {
        "name": "TIM2_TISEL",
        "address": 1073741916,
        "size": 32,
        "access": "",
        "desc": "TIM2 timer input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Selects tim_ti1[0..15] input\n...\nRefer to  for product specific implementation."
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Selects tim_ti2[0..15] input\n...\nRefer to  for product specific implementation."
            },
            {
                "name": "TI3SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Selects tim_ti3[0..15] input\n...\nRefer to  for product specific implementation."
            },
            {
                "name": "TI4SEL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Selects tim_ti4[0..15] input\n...\nRefer to  for product specific implementation."
            }
        ]
    },
    "1073741920": {
        "name": "TIM2_AF1",
        "address": 1073741920,
        "size": 32,
        "access": "",
        "desc": "TIM2 alternate function register 1",
        "fields": [
            {
                "name": "ETRSEL",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "etr_in source selection\nThese bits select the etr_in input source.\n...\nRefer to  for product specific implementation."
            }
        ]
    },
    "1073741924": {
        "name": "TIM2_AF2",
        "address": 1073741924,
        "size": 32,
        "access": "",
        "desc": "TIM2 alternate function register 2",
        "fields": [
            {
                "name": "OCRSEL",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "ocref_clr source selection\nThese bits select the ocref_clr input source.\n...\nRefer to  for product specific implementation."
            }
        ]
    },
    "1073742812": {
        "name": "TIM2_DCR",
        "address": 1073742812,
        "size": 32,
        "access": "",
        "desc": "TIM2 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\nThis 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n..."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\nThis 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).\n...\nExample: Let us consider the following transfer: DBL = 7 bytes & DBA = TIM2_CR1.\nIf DBL = 7 bytes and DBA = TIM2_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:\n(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL\nIn this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data are copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA\nAccording to the configuration of the DMA Data Size, several cases may occur:\nIf the DMA Data Size is configured in half-words, 16-bit data are transferred to each of the 7 registers.\nIf the DMA Data Size is configured in bytes, the data are also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA."
            },
            {
                "name": "DBSS",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "DMA burst source selection\nThis bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).\nOthers: reserved"
            }
        ]
    },
    "1073742816": {
        "name": "TIM2_DMAR",
        "address": 1073742816,
        "size": 32,
        "access": "",
        "desc": "TIM2 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "DMA register for burst accesses\nA read or write operation to the DMAR register accesses the register located at the address\n(TIMx_CR1 address) + (DBA + DMA index) x 4\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR)."
            }
        ]
    },
    "1073742848": {
        "name": "TIM3_CR1",
        "address": 1073742848,
        "size": 22,
        "access": "",
        "desc": "TIM3 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\nCEN is cleared automatically in one-pulse mode, when an update event occurs."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction\nNote: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode."
            },
            {
                "name": "CMS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Center-aligned mode selection\nNote: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\nThis bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and sampling clock used by the digital filters (tim_etr_in, tim_tix),"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            },
            {
                "name": "DITHEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Dithering Enable\nNote: The DITHEN bit can only be modified when CEN bit is reset."
            }
        ]
    },
    "1073742852": {
        "name": "TIM3_CR2",
        "address": 1073742852,
        "size": 32,
        "access": "",
        "desc": "TIM3 control register 2",
        "fields": [
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\nThese bits allow to select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:\ntim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).\nOthers: Reserved\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "tim_ti1 selection"
            },
            {
                "name": "MMS2",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Master mode selection\nThese bits allow to select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:\ntim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).\nOthers: Reserved\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            }
        ]
    },
    "1073742856": {
        "name": "TIM3_SMCR",
        "address": 1073742856,
        "size": 32,
        "access": "",
        "desc": "TIM3 slave mode control register",
        "fields": [
            {
                "name": "SMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nNote: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on tim_ti1f, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo signal must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "OCCS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "OCREF clear selection\nThis bit is used to select the OCREF clear source\nNote: If the OCREF clear selection feature is not supported, this bit is reserved and forced by hardware to '0'. ."
            },
            {
                "name": "TS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee  for product specific implementation details.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/Slave mode"
            },
            {
                "name": "ETF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "External trigger filter\nThis bit-field then defines the frequency used to sample tim_etrp signal and the length of the digital filter applied to tim_etrp. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "ETPS",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "External trigger prescaler\nExternal trigger signal tim_etrp frequency must be at most 1/4 of tim_ker_ck frequency. A prescaler can be enabled to reduce tim_etrp frequency. It is useful when inputting fast external clocks on tim_etr_in."
            },
            {
                "name": "ECE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "External clock enable\nThis bit enables External clock mode 2.\nNote: Setting the ECE bit has the same effect as selecting external clock mode 1 with tim_trgi connected to tim_etrf (SMS=111 and TS=00111).\nIt is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, tim_trgi must not be connected to tim_etrf in this case (TS bits must not be 00111).\nIf external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is tim_etrf."
            },
            {
                "name": "ETP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "External trigger polarity\nThis bit selects whether tim_etr_in or tim_etr_in is used for trigger operations"
            },
            {
                "name": "SMS_2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nNote: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on tim_ti1f, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo signal must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TS_2",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee  for product specific implementation details.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "SMSPE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "SMS preload enable\nThis bit selects whether the SMS[3:0] bitfield is preloaded"
            },
            {
                "name": "SMSPS",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "SMS preload source\nThis bit selects whether the events that triggers the SMS[3:0] bitfield transfer from preload to active"
            }
        ]
    },
    "1073742860": {
        "name": "TIM3_DIER",
        "address": 1073742860,
        "size": 32,
        "access": "",
        "desc": "TIM3 DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt enable"
            },
            {
                "name": "CC3IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt enable"
            },
            {
                "name": "CC4IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 DMA request enable"
            },
            {
                "name": "CC3DE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 DMA request enable"
            },
            {
                "name": "CC4DE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            },
            {
                "name": "IDXIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Index interrupt enable"
            },
            {
                "name": "DIRIE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Direction change interrupt enable"
            },
            {
                "name": "IERRIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Index error interrupt enable"
            },
            {
                "name": "TERRIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transition error interrupt enable"
            }
        ]
    },
    "1073742864": {
        "name": "TIM3_SR",
        "address": 1073742864,
        "size": 32,
        "access": "",
        "desc": "TIM3 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow or underflow and if UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in downcounting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC3IF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC4IF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\nThis flag is set by hardware on the TRG trigger event (active edge detected on tim_trgi input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 2 overcapture flag\nrefer to CC1OF description"
            },
            {
                "name": "CC3OF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 overcapture flag\nrefer to CC1OF description"
            },
            {
                "name": "CC4OF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 overcapture flag\nrefer to CC1OF description"
            },
            {
                "name": "IDXF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Index interrupt flag\nThis flag is set by hardware when an index event is detected. It is cleared by software by\nwriting it to '0'."
            },
            {
                "name": "DIRF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Direction change interrupt flag\nThis flag is set by hardware when the direction changes in encoder mode (DIR bit value in\nTIMx_CR is changing). It is cleared by software by writing it to '0'."
            },
            {
                "name": "IERRF",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Index error interrupt flag\nThis flag is set by hardware when an index error is detected. It is cleared by software by\nwriting it to '0'."
            },
            {
                "name": "TERRF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transition error interrupt flag\nThis flag is set by hardware when a transition error is detected in encoder mode. It is cleared\nby software by writing it to '0'."
            }
        ]
    },
    "1073742868": {
        "name": "TIM3_EGR",
        "address": 1073742868,
        "size": 22,
        "access": "",
        "desc": "TIM3 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 generation\nRefer to CC1G description"
            },
            {
                "name": "CC3G",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 generation\nRefer to CC1G description"
            },
            {
                "name": "CC4G",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 generation\nRefer to CC1G description"
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073742872": {
        "name": "TIM3_CCMR1_Input",
        "address": 1073742872,
        "size": 32,
        "access": "",
        "desc": "TIM3 capture/compare mode register 1 [alternate]",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\nThis bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register)."
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\nThis bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC2PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler"
            },
            {
                "name": "IC2F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 2 filter"
            }
        ]
    },
    "1073742876": {
        "name": "TIM3_CCMR2_Input",
        "address": 1073742876,
        "size": 32,
        "access": "",
        "desc": "TIM3 capture/compare mode register 2 [alternate]",
        "fields": [
            {
                "name": "CC3S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC3PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler"
            },
            {
                "name": "IC3F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 3 filter"
            },
            {
                "name": "CC4S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC4PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler"
            },
            {
                "name": "IC4F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 4 filter"
            }
        ]
    },
    "1073742880": {
        "name": "TIM3_CCER",
        "address": 1073742880,
        "size": 22,
        "access": "",
        "desc": "TIM3 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity.\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\nCC1NP=1, CC1P=1:\tnon-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\nCC1NP=1, CC1P=0:\tthis configuration is reserved, it must not be used."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity.\nCC1 channel configured as output: CC1NP must be kept cleared in this case.\nCC1 channel configured as input: This bit is used in conjunction with CC1P to define tim_ti1fp1/tim_ti2fp1 polarity. refer to CC1P description."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output enable.\nRefer to CC1E description"
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity.\nrefer to CC1P description"
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity.\nRefer to CC1NP description"
            },
            {
                "name": "CC3E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output enable.\nRefer to CC1E description"
            },
            {
                "name": "CC3P",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity.\nRefer to CC1P description"
            },
            {
                "name": "CC3NP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity.\nRefer to CC1NP description"
            },
            {
                "name": "CC4E",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output enable.\nrefer to CC1E description"
            },
            {
                "name": "CC4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity.\nRefer to CC1P description"
            },
            {
                "name": "CC4NP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity.\nRefer to CC1NP description"
            }
        ]
    },
    "1073742884": {
        "name": "TIM3_CNT",
        "address": 1073742884,
        "size": 32,
        "access": "",
        "desc": "TIM3 counter ",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value'\nNon-dithering mode (DITHEN = 0)\nThe register holds the counter value.\nDithering mode (DITHEN = 1)\nThe register holds the non-dithered part in CNT[15:0]. The fractional part is not available."
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Value depends on IUFREMAP in TIMx_CR1.\nIf UIFREMAP = 0\nReserved\nIf UIFREMAP = 1\nUIFCPY: UIF Copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register"
            }
        ]
    },
    "1073742888": {
        "name": "TIM3_PSC",
        "address": 1073742888,
        "size": 22,
        "access": "",
        "desc": "TIM3 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\nThe counter clock frequency tim_cnt_ck is equal to ftim_psc_ck / (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in 'reset mode')."
            }
        ]
    },
    "1073742892": {
        "name": "TIM3_ARR",
        "address": 1073742892,
        "size": 32,
        "access": "",
        "desc": "TIM3 auto-reload register ",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Low Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the  for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null.\nNon-dithering mode (DITHEN = 0)\nThe register holds the auto-reload value.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part."
            }
        ]
    },
    "1073742900": {
        "name": "TIM3_CCR1",
        "address": 1073742900,
        "size": 32,
        "access": "",
        "desc": "TIM3 capture/compare register 1 ",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value in CCR1[15:0]. The CCR1[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR1[19:4]. The CCR1[3:0] bitfield contains the dithered part.\nIf channel CC1 is configured as input:\nCCR1 is the counter value transferred by the last input capture 1 event (tim_ic1). The TIMx_CCR1 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe CCR1[15:0] bits hold the capture value. The CCR1[19:16] bits are reserved.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR1[19:0]. The CCR1[3:0] bits are reset."
            }
        ]
    },
    "1073742904": {
        "name": "TIM3_CCR2",
        "address": 1073742904,
        "size": 32,
        "access": "",
        "desc": "TIM3 capture/compare register 2 ",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 1 value\nIf channel CC2 is configured as output:\nCCR2 is the value to be loaded in the actual capture/compare 2 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc2 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value in CCR2[15:0]. The CCR2[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR2[19:4]. The CCR2[3:0] bitfield contains the dithered part.\nIf channel CC2 is configured as input:\nCCR2 is the counter value transferred by the last input capture 2 event (tim_ic2). The TIMx_CCR2 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe CCR2[15:0] bits hold the capture value. The CCR2[19:16] bits are reserved.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR2[19:0]. The CCR2[3:0] bits are reset."
            }
        ]
    },
    "1073742908": {
        "name": "TIM3_CCR3",
        "address": 1073742908,
        "size": 32,
        "access": "",
        "desc": "TIM3 capture/compare register 3 ",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 3 value\nIf channel CC3 is configured as output:\nCCR3 is the value to be loaded in the actual capture/compare 3 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc3 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value in CCR3[15:0]. The CCR3[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR3[19:4]. The CCR3[3:0] bitfield contains the dithered part.\nIf channel CC3 is configured as input:\nCCR3 is the counter value transferred by the last input capture 3 event (tim_ic3). The TIMx_CCR3 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe CCR3[15:0] bits hold the capture value. The CCR3[19:16] bits are reserved.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR3[19:0]. The CCR3[3:0] bits are reset."
            }
        ]
    },
    "1073742912": {
        "name": "TIM3_CCR4",
        "address": 1073742912,
        "size": 32,
        "access": "",
        "desc": "TIM3 capture/compare register 4 ",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 4 value\nIf channel CC4 is configured as output:\nCCR4 is the value to be loaded in the actual capture/compare 4 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR4 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc4 output.\nNon-dithering mode (DITHEN = 0)\nThe register holds the compare value in CCR4[15:0]. The CCR4[19:16] bits are reset.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in CCR4[19:4]. The CCR4[3:0] bitfield contains the dithered part.\nIf channel CC4 is configured as input:\nCCR4 is the counter value transferred by the last input capture 4 event (tim_ic4). The TIMx_CCR4 register is read-only and cannot be programmed.\nNon-dithering mode (DITHEN = 0)\nThe CCR4[15:0] bits hold the capture value. The CCR4[19:16] bits are reserved.\nDithering mode (DITHEN = 1)\nThe register holds the capture in CCR4[19:0]. The CCR4[3:0] bits are reset."
            }
        ]
    },
    "1073742936": {
        "name": "TIM3_ECR",
        "address": 1073742936,
        "size": 32,
        "access": "",
        "desc": "TIM3 timer encoder control register",
        "fields": [
            {
                "name": "IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Index enable\nThis bit indicates if the Index event resets the counter."
            },
            {
                "name": "IDIR",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Index direction\nThis bit indicates in which direction the Index event resets the counter.\nNote: The IDR[1:0] bitfield must be written when IE bit is reset (index disabled)."
            },
            {
                "name": "IBLK",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Index blanking\nThis bit indicates if the Index event is conditioned by the tim_ti3 input"
            },
            {
                "name": "FIDX",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "First index\nThis bit indicates if the first index only is taken into account"
            },
            {
                "name": "IPOS",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Index positioning\nIn quadrature encoder mode (SMS[3:0] = 0001, 0010, 0011, 1110, 1111), this bit indicates in which AB input configuration the Index event resets the counter.\nIn directional clock mode or clock plus direction mode (SMS[3:0] = 1010, 1011, 1100, 1101), these bits indicates on which level the Index event resets the counter. In bidirectional clock mode, this applies for both clock inputs.\nx0: Index resets the counter when clock is 0\nx1: Index resets the counter when clock is 1\nNote: IPOS[1] bit is not significant"
            },
            {
                "name": "PW",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Pulse width\nThis bitfield defines the pulse duration, as following:\ntPW = PW[7:0] x tPWG"
            },
            {
                "name": "PWPRSC",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "Pulse width prescaler\nThis bitfield sets the clock prescaler for the pulse generator, as following:\ntPWG = (2(PWPRSC[2:0])) x ttim_ker_ck"
            }
        ]
    },
    "1073742940": {
        "name": "TIM3_TISEL",
        "address": 1073742940,
        "size": 32,
        "access": "",
        "desc": "TIM3 timer input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Selects tim_ti1[0..15] input\n...\nRefer to  for product specific implementation."
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Selects tim_ti2[0..15] input\n...\nRefer to  for product specific implementation."
            },
            {
                "name": "TI3SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Selects tim_ti3[0..15] input\n...\nRefer to  for product specific implementation."
            },
            {
                "name": "TI4SEL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Selects tim_ti4[0..15] input\n...\nRefer to  for product specific implementation."
            }
        ]
    },
    "1073742944": {
        "name": "TIM3_AF1",
        "address": 1073742944,
        "size": 32,
        "access": "",
        "desc": "TIM3 alternate function register 1",
        "fields": [
            {
                "name": "ETRSEL",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "etr_in source selection\nThese bits select the etr_in input source.\n...\nRefer to  for product specific implementation."
            }
        ]
    },
    "1073742948": {
        "name": "TIM3_AF2",
        "address": 1073742948,
        "size": 32,
        "access": "",
        "desc": "TIM3 alternate function register 2",
        "fields": [
            {
                "name": "OCRSEL",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "ocref_clr source selection\nThese bits select the ocref_clr input source.\n...\nRefer to  for product specific implementation."
            }
        ]
    },
    "1073743836": {
        "name": "TIM3_DCR",
        "address": 1073743836,
        "size": 32,
        "access": "",
        "desc": "TIM3 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\nThis 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n..."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\nThis 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).\n...\nExample: Let us consider the following transfer: DBL = 7 bytes & DBA = TIM2_CR1.\nIf DBL = 7 bytes and DBA = TIM2_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:\n(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL\nIn this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data are copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA\nAccording to the configuration of the DMA Data Size, several cases may occur:\nIf the DMA Data Size is configured in half-words, 16-bit data are transferred to each of the 7 registers.\nIf the DMA Data Size is configured in bytes, the data are also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA."
            },
            {
                "name": "DBSS",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "DMA burst source selection\nThis bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).\nOthers: reserved"
            }
        ]
    },
    "1073743840": {
        "name": "TIM3_DMAR",
        "address": 1073743840,
        "size": 32,
        "access": "",
        "desc": "TIM3 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "DMA register for burst accesses\nA read or write operation to the DMAR register accesses the register located at the address\n(TIMx_CR1 address) + (DBA + DMA index) x 4\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR)."
            }
        ]
    },
    "1073745920": {
        "name": "TIM6_CR1",
        "address": 1073745920,
        "size": 22,
        "access": "",
        "desc": "TIM6 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nCEN is cleared automatically in one-pulse mode, when an update event occurs."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            },
            {
                "name": "DITHEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Dithering enable\nNote: The DITHEN bit can only be modified when CEN bit is reset."
            }
        ]
    },
    "1073745924": {
        "name": "TIM6_CR2",
        "address": 1073745924,
        "size": 22,
        "access": "",
        "desc": "TIM6 control register 2",
        "fields": [
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\nThese bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\nNote: The clock of the slave timer or he peripheral receiving the tim_trgo must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            }
        ]
    },
    "1073745932": {
        "name": "TIM6_DIER",
        "address": 1073745932,
        "size": 22,
        "access": "",
        "desc": "TIM6 DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            }
        ]
    },
    "1073745936": {
        "name": "TIM6_SR",
        "address": 1073745936,
        "size": 22,
        "access": "",
        "desc": "TIM6 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nOn counter overflow if UDIS = 0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0 and UDIS = 0 in the TIMx_CR1 register."
            }
        ]
    },
    "1073745940": {
        "name": "TIM6_EGR",
        "address": 1073745940,
        "size": 22,
        "access": "",
        "desc": "TIM6 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            }
        ]
    },
    "1073745956": {
        "name": "TIM6_CNT",
        "address": 1073745956,
        "size": 32,
        "access": "",
        "desc": "TIM6 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value\nNon-dithering mode (DITHEN = 0)\nThe register holds the counter value.\nDithering mode (DITHEN = 1)\nThe register only holds the non-dithered part in CNT[15:0]. The fractional part is not available."
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0."
            }
        ]
    },
    "1073745960": {
        "name": "TIM6_PSC",
        "address": 1073745960,
        "size": 22,
        "access": "",
        "desc": "TIM6 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\nThe counter clock frequency ftim_cnt_ck is equal to ftim_psc_ck / (PSC[15:0] + 1).\nPSC contains the value to be loaded into the active prescaler register at each update event.\n(including when the counter is cleared through UG bit of TIMx_EGR register."
            }
        ]
    },
    "1073745964": {
        "name": "TIM6_ARR",
        "address": 1073745964,
        "size": 32,
        "access": "",
        "desc": "TIM6 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Auto-reload value\nARR is the value to be loaded into the actual auto-reload register.\nRefer to  for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null.\nNon-dithering mode (DITHEN = 0)\nThe register holds the auto-reload value in ARR[15:0]. The ARR[19:16] bits are reserved.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part."
            }
        ]
    },
    "1073746944": {
        "name": "TIM7_CR1",
        "address": 1073746944,
        "size": 22,
        "access": "",
        "desc": "TIM7 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nCEN is cleared automatically in one-pulse mode, when an update event occurs."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            },
            {
                "name": "DITHEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Dithering enable\nNote: The DITHEN bit can only be modified when CEN bit is reset."
            }
        ]
    },
    "1073746948": {
        "name": "TIM7_CR2",
        "address": 1073746948,
        "size": 22,
        "access": "",
        "desc": "TIM7 control register 2",
        "fields": [
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\nThese bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\nNote: The clock of the slave timer or he peripheral receiving the tim_trgo must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            }
        ]
    },
    "1073746956": {
        "name": "TIM7_DIER",
        "address": 1073746956,
        "size": 22,
        "access": "",
        "desc": "TIM7 DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            }
        ]
    },
    "1073746960": {
        "name": "TIM7_SR",
        "address": 1073746960,
        "size": 22,
        "access": "",
        "desc": "TIM7 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nOn counter overflow if UDIS = 0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS = 0 and UDIS = 0 in the TIMx_CR1 register."
            }
        ]
    },
    "1073746964": {
        "name": "TIM7_EGR",
        "address": 1073746964,
        "size": 22,
        "access": "",
        "desc": "TIM7 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            }
        ]
    },
    "1073746980": {
        "name": "TIM7_CNT",
        "address": 1073746980,
        "size": 32,
        "access": "",
        "desc": "TIM7 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value\nNon-dithering mode (DITHEN = 0)\nThe register holds the counter value.\nDithering mode (DITHEN = 1)\nThe register only holds the non-dithered part in CNT[15:0]. The fractional part is not available."
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0."
            }
        ]
    },
    "1073746984": {
        "name": "TIM7_PSC",
        "address": 1073746984,
        "size": 22,
        "access": "",
        "desc": "TIM7 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\nThe counter clock frequency ftim_cnt_ck is equal to ftim_psc_ck / (PSC[15:0] + 1).\nPSC contains the value to be loaded into the active prescaler register at each update event.\n(including when the counter is cleared through UG bit of TIMx_EGR register."
            }
        ]
    },
    "1073746988": {
        "name": "TIM7_ARR",
        "address": 1073746988,
        "size": 32,
        "access": "",
        "desc": "TIM7 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Auto-reload value\nARR is the value to be loaded into the actual auto-reload register.\nRefer to  for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null.\nNon-dithering mode (DITHEN = 0)\nThe register holds the auto-reload value in ARR[15:0]. The ARR[19:16] bits are reserved.\nDithering mode (DITHEN = 1)\nThe register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part."
            }
        ]
    },
    "1073821696": {
        "name": "USART_CR1_enabled",
        "address": 1073821696,
        "size": 32,
        "access": "",
        "desc": "USART control register 1 [alternate] ",
        "fields": [
            {
                "name": "UE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.\nNote: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.\nThe DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.\nIn Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value."
            },
            {
                "name": "UESM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\nNote: It is recommended to set the UESM bit just before entering low-power mode, and clear it when exiting low-power mode."
            },
            {
                "name": "RE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software."
            },
            {
                "name": "TE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit ('0' followed by '1') sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1'. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.\nIn Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts."
            },
            {
                "name": "IDLEIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "IDLE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFNEIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFNFIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PEIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "PE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "PCE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "WAKE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver wakeup method\nThis bit determines the USART wakeup method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "M0",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "MME",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Mute mode enable\nThis bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software."
            },
            {
                "name": "CMIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Character match interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "OVER8",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Oversampling mode\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In LIN, IrDA and Smartcard modes, this bit must be kept cleared."
            },
            {
                "name": "DEDT",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Driver Enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nIf the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "DEAT",
                "bitOffset": 21,
                "bitWidth": 5,
                "desc": "Driver Enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "RTOIE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receiver timeout interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. ."
            },
            {
                "name": "EOBIE",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "End of Block interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "M1",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] = '00': 1 start bit, 8 Data bits, n Stop bit\nM[1:0] = '01': 1 start bit, 9 Data bits, n Stop bit\nM[1:0] = '10': 1 start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In 7-bits data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported."
            },
            {
                "name": "FIFOEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "FIFO mode enable\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: FIFO mode can be used on standard UART communication, in SPI Master/Slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes."
            },
            {
                "name": "TXFEIE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TXFIFO empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFFIE",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RXFIFO Full interrupt enable\nThis bit is set and cleared by software."
            }
        ]
    },
    "1073821700": {
        "name": "USART_CR2",
        "address": 1073821700,
        "size": 32,
        "access": "",
        "desc": "USART control register 2 ",
        "fields": [
            {
                "name": "SLVEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Synchronous Slave mode enable\nWhen the SLVEN bit is set, the Synchronous slave mode is enabled.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "DIS_NSS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "When the DIS_NSS bit is set, the NSS pin input is ignored.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "ADDM7",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "7-bit Address Detection/4-bit Address Detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\nThis bit can only be written when the USART is disabled (UE=0)\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively."
            },
            {
                "name": "LBDL",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LIN break detection length\nThis bit is for selection between 11 bit or 10 bit break detection.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "LBDIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LIN break detection interrupt enable\nBreak interrupt mask (break detection using break delimiter).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "LBCL",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Last bit clock pulse\nThis bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the SCLK pin in Synchronous mode.\nThe last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CPHA",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Clock phase\nThis bit is used to select the phase of the clock output on the SCLK pin in Synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see  and )\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CPOL",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Clock polarity\nThis bit enables the user to select the polarity of the clock output on the SCLK pin in Synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CLKEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Clock enable\nThis bit enables the user to enable the SCLK pin.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If neither Synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to .\nIn Smartcard mode, in order to provide correctly the SCLK clock to the smartcard, the steps below must be respected:\nUE = 0\nSCEN = 1\nGTPR configuration\nCLKEN= 1\nUE = 1"
            },
            {
                "name": "STOP",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "stop bits\nThese bits are used for programming the stop bits.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "LINEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "LIN mode enable\nThis bit is set and cleared by software.\nThe LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "SWAP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Swap TX/RX pins\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "RXINV",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "RX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "TXINV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "DATAINV",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Binary data inversion\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "MSBFIRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Most significant bit first\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "ABREN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Auto baud rate enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "ABRMOD",
                "bitOffset": 21,
                "bitWidth": 2,
                "desc": "Auto baud rate mode\nThese bits are set and cleared by software.\nThis bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0).\nNote: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example 0xAA for MSBFIRST)\nIf the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "RTOEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Receiver timeout enable\nThis bit is set and cleared by software.\nWhen this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register).\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "ADD",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Address of the USART node\nThese bits give the address of the USART node in Mute mode or a character code to be recognized in low-power or Run mode:\nIn Mute mode: they are used in multiprocessor communication to wakeup from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.\nIn low-power mode: they are used for wake up from low-power mode on character match.\nWhen WUS[1:0] is programmed to 0b00 (WUF active on address match), the wakeup from low-power mode is performed when the received character corresponds to the character programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit), and WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by transmitter should be equal to 1.\nIn Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.\nThese bits can only be written when the reception is disabled (RE = 0) or when the USART is disabled (UE = 0)."
            }
        ]
    },
    "1073821704": {
        "name": "USART_CR3",
        "address": 1073821704,
        "size": 32,
        "access": "",
        "desc": "USART control register 3 ",
        "fields": [
            {
                "name": "EIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1or UDR = 1 in the USART_ISR register)."
            },
            {
                "name": "IREN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "IrDA mode enable\nThis bit is set and cleared by software.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "IRLP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "IrDA low-power\nThis bit is used for selecting between normal and low-power IrDA modes\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "HDSEL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Half-duplex selection\nSelection of Single-wire Half-duplex mode\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "NACK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Smartcard NACK enable\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "SCEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Smartcard mode enable\nThis bit is used for enabling Smartcard mode.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "DMAR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA enable receiver\nThis bit is set/reset by software"
            },
            {
                "name": "DMAT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA enable transmitter\nThis bit is set/reset by software"
            },
            {
                "name": "RTSE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "RTS enable\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CTSE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS enable\nThis bit can only be written when the USART is disabled (UE=0)\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CTSIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS interrupt enable\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "ONEBIT",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "One sample bit method enable\nThis bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "OVRDIS",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun Disable\nThis bit is used to disable the receive overrun detection.\nthe ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data are written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: This control bit enables checking the communication flow w/o reading the data"
            },
            {
                "name": "DDRE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DMA Disable on Reception Error\nThis bit can only be written when the USART is disabled (UE=0).\nNote: The reception errors are: parity error, framing error or noise error."
            },
            {
                "name": "DEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. ."
            },
            {
                "name": "DEP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Driver enable polarity selection\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "SCARCNT",
                "bitOffset": 17,
                "bitWidth": 3,
                "desc": "Smartcard auto-retry count\nThis bitfield specifies the number of retries for transmission and reception in Smartcard mode.\nIn Transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set).\nIn Reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set).\nThis bitfield must be programmed only when the USART is disabled (UE=0).\nWhen the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to stop retransmission.\nNote: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "WUS0",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2297."
            },
            {
                "name": "WUS1",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2297."
            },
            {
                "name": "WUFIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode interrupt enable\nThis bit is set and cleared by software.\nNote: WUFIE must be set before entering in low-power mode.\nIf the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2297."
            },
            {
                "name": "TXFTIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TCBGTIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Transmission Complete before guard time, interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "RXFTCFG",
                "bitOffset": 25,
                "bitWidth": 3,
                "desc": "Receive FIFO threshold configuration\nRemaining combinations: Reserved"
            },
            {
                "name": "RXFTIE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "RXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFTCFG",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "TXFIFO threshold configuration\nRemaining combinations: Reserved"
            }
        ]
    },
    "1073821708": {
        "name": "USART_BRR",
        "address": 1073821708,
        "size": 32,
        "access": "",
        "desc": "USART baud rate register ",
        "fields": [
            {
                "name": "BRR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "USART baud rate\nBRR[15:4]\nBRR[15:4] correspond to USARTDIV[15:4]\nBRR[3:0]\nWhen OVER8 = 0, BRR[3:0] = USARTDIV[3:0].\nWhen OVER8 = 1:\nBRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.\nBRR[3] must be kept cleared."
            }
        ]
    },
    "1073821712": {
        "name": "USART_GTPR",
        "address": 1073821712,
        "size": 32,
        "access": "",
        "desc": "USART guard time and prescaler register ",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Prescaler value\nPSC[7:0] = IrDA Normal and Low-power baud rate\nThis bitfield is used for programming the prescaler for dividing the USART source clock to achieve the low-power frequency:\nThe source clock is divided by the value given in the register (8 significant bits):\n...\nPSC[4:0]: Prescaler value\nThis bitfield is used for programming the prescaler for dividing the USART source clock to provide the Smartcard clock.\nThe value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency:\n...\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: Bits [7:5] must be kept cleared if Smartcard mode is used.\nThis bitfield is reserved and forced by hardware to '0' when the Smartcard and IrDA modes are not supported. Refer to ."
            },
            {
                "name": "GT",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "Guard time value\nThis bitfield is used to program the Guard time value in terms of number of baud clock periods.\nThis is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            }
        ]
    },
    "1073821716": {
        "name": "USART_RTOR",
        "address": 1073821716,
        "size": 32,
        "access": "",
        "desc": "USART receiver timeout register ",
        "fields": [
            {
                "name": "RTO",
                "bitOffset": 0,
                "bitWidth": 24,
                "desc": "Receiver timeout value\nThis bitfield gives the Receiver timeout value in terms of number of bit duration.\nIn Standard mode, the RTOF flag is set if, after the last received character, no new start bit is detected for more than the RTO value.\nIn Smartcard mode, this value is used to implement the CWT and BWT. See Smartcard chapter for more details. In the standard, the CWT/BWT measurement is done starting from the start bit of the last received character.\nNote: This value must only be programmed once per received character."
            },
            {
                "name": "BLEN",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Block Length\nThis bitfield gives the Block length in Smartcard T=1 Reception. Its value equals the number of information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1.\nExamples:\nBLEN = 0 - 0 information characters + LEC\nBLEN = 1 - 0 information characters + CRC\nBLEN = 255 - 254 information characters + CRC (total 256 characters))\nIn Smartcard mode, the Block length counter is reset when TXE=0 (TXFE = 0 in case FIFO mode is enabled).\nThis bitfield can be used also in other modes. In this case, the Block length counter is reset when RE=0 (receiver disabled) and/or when the EOBCF bit is written to 1.\nNote: This value can be programmed after the start of the block reception (using the data from the LEN character in the Prologue Field). It must be programmed only once per received block."
            }
        ]
    },
    "1073821720": {
        "name": "USART_RQR",
        "address": 1073821720,
        "size": 32,
        "access": "",
        "desc": "USART request register ",
        "fields": [
            {
                "name": "ABRRQ",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "auto baud rate request\nWriting 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an automatic baud rate measurement on the next received data frame.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "SBKRQ",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\nNote: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit."
            },
            {
                "name": "MMRQ",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Mute mode request\nWriting 1 to this bit puts the USART in Mute mode and resets the RWU flag."
            },
            {
                "name": "RXFRQ",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Receive data flush request\nWriting 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.\nThis enables to discard the received data without reading them, and avoid an overrun condition."
            },
            {
                "name": "TXFRQ",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Transmit data flush request\nWhen FIFO mode is disabled, writing '1' to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value.\nWhen FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes.\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register."
            }
        ]
    },
    "1073821724": {
        "name": "USART_ISR_enabled",
        "address": 1073821724,
        "size": 32,
        "access": "",
        "desc": "USART interrupt and status register ",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error\nThis bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\nNote: This error is associated with the character in the USART_RDR."
            },
            {
                "name": "FE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE = 1 in the USART_CR1 register.\nNote: This error is associated with the character in the USART_RDR."
            },
            {
                "name": "NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NFCF bit in the USART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.\nWhen the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page 2317).\nThis error is associated with the character in the USART_RDR."
            },
            {
                "name": "ORE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.\nAn interrupt is generated if RXFNEIE=1 or EIE = 1 in the USART_CR1 register.\nNote: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.\nThis bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register."
            },
            {
                "name": "IDLE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.\nNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).\nIf Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set."
            },
            {
                "name": "RXFNE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty\nRXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO.\nRXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.\nAn interrupt is generated if RXFNEIE=1 in the USART_CR1 register."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag behaves as follows:\nWhen TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXE/TXFE is set.\nWhen TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached.\nWhen TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred.\nWhen TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty.\nAn interrupt is generated if TCIE=1 in the USART_CR1 register.\nTC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register."
            },
            {
                "name": "TXFNF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full\nTXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR.\nAn interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register.\nNote: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE is set at the same time).\nThis bit is used during single buffer transmission."
            },
            {
                "name": "LBDF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\nNote: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "CTSIF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS interrupt flag\nThis bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE=1 in the USART_CR3 register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "CTS",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "RTOF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.\nAn interrupt is generated if RTOIE=1 in the USART_CR2 register.\nIn Smartcard mode, the timeout corresponds to the CWT or BWT timings.\nNote: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.\nThe counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.\nIf the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "EOBF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "End of block flag\nThis bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.\nAn interrupt is generated if EOBIE = 1 in the USART_CR1 register.\nIt is cleared by software, writing 1 to EOBCF in the USART_ICR register.\nNote: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "UDR",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SPI slave underrun error flag\nIn Slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.\nNote: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "ABRE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "ABRF",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case)\nIt is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "BUSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not)."
            },
            {
                "name": "CMF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE=1in the USART_CR1 register."
            },
            {
                "name": "SBKF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission."
            },
            {
                "name": "RWU",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Receiver wakeup from Mute mode\nThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.\nWhen wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "WUF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode flag\nThis bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE=1 in the USART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nIf the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "TEACK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.\nIt can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period."
            },
            {
                "name": "REACK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.\nIt can be used to verify that the USART is ready for reception before entering low-power mode.\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "TXFE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO Empty\nThis bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.\nAn interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register."
            },
            {
                "name": "RXFF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "RXFIFO Full\nThis bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the USART_RDR register.\nAn interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register."
            },
            {
                "name": "TCBGT",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmission complete before guard time flag\nThis bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.\nIt is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register.\nThis bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.\nNote: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1'. Refer to on page 2297."
            },
            {
                "name": "RXFT",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "RXFIFO threshold flag\nThis bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the USART_CR3 register.\nNote: When the RXFTCFG threshold is configured to '101', RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data."
            },
            {
                "name": "TXFT",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "TXFIFO threshold flag\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register."
            }
        ]
    },
    "1073821728": {
        "name": "USART_ICR",
        "address": 1073821728,
        "size": 32,
        "access": "",
        "desc": "USART interrupt flag clear register ",
        "fields": [
            {
                "name": "PECF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error clear flag\nWriting 1 to this bit clears the PE flag in the USART_ISR register."
            },
            {
                "name": "FECF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error clear flag\nWriting 1 to this bit clears the FE flag in the USART_ISR register."
            },
            {
                "name": "NECF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the USART_ISR register."
            },
            {
                "name": "ORECF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the USART_ISR register."
            },
            {
                "name": "IDLECF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the USART_ISR register."
            },
            {
                "name": "TXFECF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TXFIFO empty clear flag\nWriting 1 to this bit clears the TXFE flag in the USART_ISR register."
            },
            {
                "name": "TCCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the USART_ISR register."
            },
            {
                "name": "TCBGTCF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transmission complete before Guard time clear flag\nWriting 1 to this bit clears the TCBGT flag in the USART_ISR register."
            },
            {
                "name": "LBDCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "LIN break detection clear flag\nWriting 1 to this bit clears the LBDF flag in the USART_ISR register.\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CTSCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the USART_ISR register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "RTOCF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver timeout clear flag\nWriting 1 to this bit clears the RTOF flag in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to page 2297."
            },
            {
                "name": "EOBCF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "End of block clear flag\nWriting 1 to this bit clears the EOBF flag in the USART_ISR register.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "UDRCF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SPI slave underrun clear flag\nWriting 1 to this bit clears the UDRF flag in the USART_ISR register.\nNote: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to"
            },
            {
                "name": "CMCF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match clear flag\nWriting 1 to this bit clears the CMF flag in the USART_ISR register."
            },
            {
                "name": "WUCF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the USART_ISR register.\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 2297."
            }
        ]
    },
    "1073821732": {
        "name": "USART_RDR",
        "address": 1073821732,
        "size": 32,
        "access": "",
        "desc": "USART receive data register ",
        "fields": [
            {
                "name": "RDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Receive data value\nContains the received data character.\nThe RDR register provides the parallel interface between the input shift register and the internal bus (see ).\nWhen receiving with the parity enabled, the value read in the MSB bit is the received parity bit."
            }
        ]
    },
    "1073821736": {
        "name": "USART_TDR",
        "address": 1073821736,
        "size": 32,
        "access": "",
        "desc": "USART transmit data register ",
        "fields": [
            {
                "name": "TDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Transmit data value\nContains the data character to be transmitted.\nThe USART_TDR register provides the parallel interface between the internal bus and the output shift register (see ).\nWhen transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.\nNote: This register must be written only when TXE/TXFNF=1."
            }
        ]
    },
    "1073821740": {
        "name": "USART_PRESC",
        "address": 1073821740,
        "size": 32,
        "access": "",
        "desc": "USART prescaler register ",
        "fields": [
            {
                "name": "PRESCALER",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Clock prescaler\nThe USART input clock can be divided by a prescaler factor:\nRemaining combinations: Reserved\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to '1011' i.e. input clock divided by 256."
            }
        ]
    },
    "1073831936": {
        "name": "USB_CHEP0R",
        "address": 1073831936,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 0 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to 'STALL' or 'NAK' for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThe STATTX bits contain the information about the channel status. Refer to  for the full descriptions ('Host mode' descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK."
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to 'STALL' or 'NAK' for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint host with HUB only\nHost mode\nThis bit is set by the software to send an LS transaction to the corresponding endpoint."
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073831940": {
        "name": "USB_CHEP1R",
        "address": 1073831940,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 1 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to 'STALL' or 'NAK' for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThe STATTX bits contain the information about the channel status. Refer to  for the full descriptions ('Host mode' descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK."
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to 'STALL' or 'NAK' for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint host with HUB only\nHost mode\nThis bit is set by the software to send an LS transaction to the corresponding endpoint."
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073831944": {
        "name": "USB_CHEP2R",
        "address": 1073831944,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 2 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to 'STALL' or 'NAK' for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThe STATTX bits contain the information about the channel status. Refer to  for the full descriptions ('Host mode' descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK."
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to 'STALL' or 'NAK' for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint host with HUB only\nHost mode\nThis bit is set by the software to send an LS transaction to the corresponding endpoint."
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073831948": {
        "name": "USB_CHEP3R",
        "address": 1073831948,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 3 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to 'STALL' or 'NAK' for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThe STATTX bits contain the information about the channel status. Refer to  for the full descriptions ('Host mode' descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK."
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to 'STALL' or 'NAK' for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint host with HUB only\nHost mode\nThis bit is set by the software to send an LS transaction to the corresponding endpoint."
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073831952": {
        "name": "USB_CHEP4R",
        "address": 1073831952,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 4 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to 'STALL' or 'NAK' for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThe STATTX bits contain the information about the channel status. Refer to  for the full descriptions ('Host mode' descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK."
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to 'STALL' or 'NAK' for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint host with HUB only\nHost mode\nThis bit is set by the software to send an LS transaction to the corresponding endpoint."
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073831956": {
        "name": "USB_CHEP5R",
        "address": 1073831956,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 5 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to 'STALL' or 'NAK' for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThe STATTX bits contain the information about the channel status. Refer to  for the full descriptions ('Host mode' descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK."
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to 'STALL' or 'NAK' for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint host with HUB only\nHost mode\nThis bit is set by the software to send an LS transaction to the corresponding endpoint."
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073831960": {
        "name": "USB_CHEP6R",
        "address": 1073831960,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 6 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to 'STALL' or 'NAK' for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThe STATTX bits contain the information about the channel status. Refer to  for the full descriptions ('Host mode' descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK."
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to 'STALL' or 'NAK' for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint host with HUB only\nHost mode\nThis bit is set by the software to send an LS transaction to the corresponding endpoint."
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073831964": {
        "name": "USB_CHEP7R",
        "address": 1073831964,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 7 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATTX bits to NAK, when a correct transfer has occurred (VTTX = 1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STATTX bits to 'STALL' or 'NAK' for an isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThe STATTX bits contain the information about the channel status. Refer to  for the full descriptions ('Host mode' descriptions). Whereas in Device mode, these bits contain the status that are given out on the following transaction, in Host mode they capture the status last received from the device. If a NAK is received, STATTX contains the value indicating NAK."
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to Device mode)\nIf the endpoint/channel is isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGTX remains unchanged, while writing 1 makes the bit value to toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written.\nHost mode\nSame as VTRX behavior but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the UTYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints and usage in Device mode.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in Endpoint/channel type encoding. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral does not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet is accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of isochronous channels/endpoints is explained in transfers in Device mode"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page 2492. These bits can be toggled by software to initialize their value. When the application software writes 0, the value remains unchanged, while writing 1 makes the bit value to toggle. Hardware sets the STATRX bits to NAK when a correct transfer has occurred (VTRX = 1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledges a new transaction.\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints and usage in Device mode).\nIf the endpoint is defined as isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STATRX bits to 'STALL' or 'NAK' for an isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing 1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STATRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the host execution list. If the aborted transaction was already under execution it is regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nA host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the host frame scheduler to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel is re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not isochronous, this bit contains the expected value of the data toggle bit (0 = DATA0, 1 = DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to Device mode).\nIf the endpoint/channel is isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers in Device mode). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes 0, the value of DTOGRX remains unchanged, while writing 1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only 0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the CTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STATRX field of this register. One NAKed transaction keeps pending and is automatically retried by the host at the next frame, or the host can immediately retry by resetting STATRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STATRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STATRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STATRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STATRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\n- A transaction ended with error sets this bit.\nErrors can be seen via the bits ERR_RX (host mode only).\nThis bit is read/write but only 0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can use this bit to monitor the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint host with HUB only\nHost mode\nThis bit is set by the software to send an LS transaction to the corresponding endpoint."
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Received error for an OUT/SETUP transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Received error for an IN transaction\nHost mode\nThis bit is set by the hardware when an error (for example no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set, a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "THREE_ERR_TX",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "Three errors for an OUT or SETUP transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an OUT transaction. THREE_ERR_TX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            },
            {
                "name": "THREE_ERR_RX",
                "bitOffset": 29,
                "bitWidth": 2,
                "desc": "Three errors for an IN transaction\nHost mode\nThis bit is set by the hardware when 3 consecutive transaction errors occurred on the USB bus for an IN transaction. THREE_ERR_RX is not generated for isochronous transactions. The software can only clear this bit.\nCoding of the received error:"
            }
        ]
    },
    "1073832000": {
        "name": "USB_CNTR",
        "address": 1073832000,
        "size": 32,
        "access": "",
        "desc": "",
        "fields": [
            {
                "name": "USBRST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USB Reset\nSoftware can set this bit to reset the USB core, exactly as it happens when receiving a RESET signaling on the USB.The USB peripheral, in response to a RESET, resets its internal protocol state machine. Reception and transmission are disabled until the RST_DCON bit is cleared. All configuration registers do not reset: the microcontroller must explicitly clear these registers (this is to ensure that the RST_DCON interrupt can be safely delivered, and any transaction immediately followed by a RESET can be completed). The function address and endpoint registers are reset by an USB reset event.\nSoftware sets this bit to drive USB reset state on the bus and initialize the device. USB reset terminates as soon as this bit is cleared by software."
            },
            {
                "name": "PDWN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Power down\nThis bit is used to completely switch off all USB-related analog parts if it is required to completely disable the USB peripheral for any reason. When this bit is set, the USB peripheral is disconnected from the transceivers and it cannot be used."
            },
            {
                "name": "SUSPRDY",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Suspend state effective\nThis bit is set by hardware as soon as the suspend state entered through the SUSPEN control gets internally effective. In this state USB activity is suspended, USB clock is gated, transceiver is set in low power mode by disabling the differential receiver. Only asynchronous wakeup logic and single ended receiver is kept alive to detect remote wakeup or resume events.\nSoftware must poll this bit to confirm it to be set before any STOP mode entry.\nThis bit is cleared by hardware simultaneously to the WAKEUP flag being set."
            },
            {
                "name": "SUSPEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Suspend state enable\nSoftware can set this bit when the SUSP interrupt is received, which is issued when no traffic is received by the USB peripheral for 3 ms. Software can also set this bit when the L1REQ interrupt is received with positive acknowledge sent.\nAs soon as the suspend state is propagated internally all device activity is stopped, USB clock is gated, USB transceiver is set into low power mode and the SUSPRDY bit is set by hardware. In the case that device application wants to pursue more aggressive power saving by stopping the USB clock source and by moving the microcontroller to stop mode, as in the case of bus powered device application, it must first wait few cycles to see the SUSPRDY = 1 acknowledge the suspend request.\nThis bit is cleared by hardware simultaneous with the WAKEUP flag set.\nSoftware can set this bit when host application has nothing scheduled for the next frames and wants to enter long term power saving. When set, it stops immediately SOF generation and any other host activity, gates the USB clock and sets the transceiver in low power mode. If any USB transaction is on-going at the time SUSPEN is set, suspend is entered at the end of the current transaction.\nAs soon as suspend state is propagated internally and gets effective the SUSPRDY bit is set. In the case that host application wants to pursue more aggressive power saving by stopping the USB clock source and by moving the micro-controller to STOP mode, it must first wait few cycles to see SUSPRDY=1 acknowledge to the suspend request.\nThis bit is cleared by hardware simultaneous with the WAKEUP flag set."
            },
            {
                "name": "L2RES",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "L2 remote wakeup / resume driver\nDevice mode\nThe microcontroller can set this bit to send remote wake-up signaling to the host. It must be activated, according to USB specifications, for no less than 1 ms and no more than 15 ms after which the host PC is ready to drive the resume sequence up to its end.\nHost mode\nSoftware sets this bit to send resume signaling to the device.\nSoftware clears this bit to send end of resume to device and restart SOF generation.\nIn the context of remote wake up, this bit is to be set following the WAKEUP interrupt."
            },
            {
                "name": "L1RES",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "L1 remote wakeup / resume driver\nDevice mode\nSoftware sets this bit to send a LPM L1 50 us remote wakeup signaling to the host. After the signaling ends, this bit is cleared by hardware."
            },
            {
                "name": "L1REQM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPM L1 state request interrupt mask"
            },
            {
                "name": "ESOFM",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Expected start of frame interrupt mask"
            },
            {
                "name": "SOFM",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Start of frame interrupt mask"
            },
            {
                "name": "RST_DCONM",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "USB reset request (Device mode) or device connect/disconnect (Host mode) interrupt mask"
            },
            {
                "name": "SUSPM",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Suspend mode interrupt mask"
            },
            {
                "name": "WKUPM",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Wakeup interrupt mask"
            },
            {
                "name": "ERRM",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Error interrupt mask"
            },
            {
                "name": "PMAOVRM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Packet memory area over / underrun interrupt mask"
            },
            {
                "name": "CTRM",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Correct transfer interrupt mask"
            },
            {
                "name": "THR512M",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "512 byte threshold interrupt mask"
            },
            {
                "name": "DDISCM",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Device disconnection mask\nHost mode"
            },
            {
                "name": "HOST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "HOST mode\nHOST bit selects betweens host or device USB mode of operation. It must be set before enabling the USB peripheral by the function enable bit."
            }
        ]
    },
    "1073832004": {
        "name": "USB_ISTR",
        "address": 1073832004,
        "size": 32,
        "access": "",
        "desc": "USB interrupt status register ",
        "fields": [
            {
                "name": "IDN",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Device Endpoint / host channel identification number\nThese bits are written by the hardware according to the host channel or device endpoint number, which generated the interrupt request. If several endpoint/channel transactions are pending, the hardware writes the identification number related to the endpoint/channel having the highest priority defined in the following way: two levels are defined, in order of priority: isochronous and double-buffered bulk channels/endpoints are considered first and then the others are examined. If more than one endpoint/channel from the same set is requesting an interrupt, the IDN bits in USB_ISTR register are assigned according to the lowest requesting register, CHEP0R having the highest priority followed by CHEP1R and so on. The application software can assign a register to each endpoint/channel according to this priority scheme, so as to order the concurring endpoint/channel requests in a suitable way. These bits are read only."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction of transaction\nThis bit is written by the hardware according to the direction of the successful transaction, which generated the interrupt request.\nIf DIR bit = 0, VTTX bit is set in the USB_CHEPnR register related to the interrupting endpoint. The interrupting transaction is of IN type (data transmitted by the USB peripheral to the host PC).\nIf DIR bit = 1, VTRX bit or both VTTX/VTRX are set in the USB_CHEPnR register related to the interrupting endpoint. The interrupting transaction is of OUT type (data received by the USB peripheral from the host PC) or two pending transactions are waiting to be processed.\nThis information can be used by the application software to access the USB_CHEPnR bits related to the triggering transaction since it represents the direction having the interrupt pending. This bit is read-only."
            },
            {
                "name": "L1REQ",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPM L1 state request\nDevice mode\nThis bit is set by the hardware when LPM command to enter the L1 state is successfully received and acknowledged. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "ESOF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Expected start of frame\nDevice mode\nThis bit is set by the hardware when an SOF packet is expected but not received. The host sends an SOF packet each 1 ms, but if the device does not receive it properly, the suspend timer issues this interrupt. If three consecutive ESOF interrupts are generated (for example three SOF packets are lost) without any traffic occurring in between, a SUSP interrupt is generated. This bit is set even when the missing SOF packets occur while the suspend timer is not yet locked. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "SOF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Start of frame\nThis bit signals the beginning of a new USB frame and it is set when a SOF packet arrives through the USB bus. The interrupt service routine may monitor the SOF events to have a 1 ms synchronization event to the USB host and to safely read the USB_FNR register which is updated at the SOF packet reception (this could be useful for isochronous applications). This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "RST_DCON",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "USB reset request (Device mode) or device connect/disconnect (Host mode)\nDevice mode\nThis bit is set by hardware when an USB reset is released by the host and the bus returns to idle. USB reset state is internally detected after the sampling of 60 consecutive SE0 cycles.\nHost mode\nThis bit is set by hardware when device connection or device disconnection is detected. Device connection is signaled after J state is sampled for 22 cycles consecutively from unconnected state. Device disconnection is signaled after SE0 state is seen for 22 bit times consecutively from connected state."
            },
            {
                "name": "SUSP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Suspend mode request\nDevice mode\nThis bit is set by the hardware when no traffic has been received for 3 ms, indicating a suspend mode request from the USB bus. The suspend condition check is enabled immediately after any USB reset and it is disabled by the hardware when the suspend mode is active (SUSPEN=1) until the end of resume sequence. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "WKUP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Wakeup\nThis bit is set to 1 by the hardware when, during suspend mode, activity is detected that wakes up the USB peripheral. This event asynchronously clears the SUSPRDY bit in the CTLR register and activates the USB_WAKEUP line, which can be used to notify the rest of the device (for example wakeup unit) about the start of the resume process. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "ERR",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Error\nThis flag is set whenever one of the errors listed below has occurred:\nNANS:\tNo ANSwer. The timeout for a host response has expired.\nCRC:\tCyclic redundancy check error. One of the received CRCs, either in the token or in the data, was wrong.\nBST:\tBit stuffing error. A bit stuffing error was detected anywhere in the PID, data, and/or CRC.\nFVIO:\tFraming format violation. A non-standard frame was received (EOP not in the right place, wrong token sequence, etc.).\nThe USB software can usually ignore errors, since the USB peripheral and the PC host manage retransmission in case of errors in a fully transparent way. This interrupt can be useful during the software development phase, or to monitor the quality of transmission over the USB bus, to flag possible problems to the user (for example loose connector, too noisy environment, broken conductor in the USB cable and so on). This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "PMAOVR",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Packet memory area over / underrun\nThis bit is set if the microcontroller has not been able to respond in time to an USB memory request. The USB peripheral handles this event in the following way: During reception an ACK handshake packet is not sent, during transmission a bit-stuff error is forced on the transmitted stream; in both cases the host retries the transaction. The PMAOVR interrupt should never occur during normal operations. Since the failed transaction is retried by the host, the application software has the chance to speed-up device operations during this interrupt handling, to be ready for the next transaction retry; however this does not happen during isochronous transfers (no isochronous transaction is anyway retried) leading to a loss of data in this case. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "CTR",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Completed transfer in host mode\nThis bit is set by the hardware to indicate that an endpoint/channel has successfully completed a transaction; using DIR and IDN bits software can determine which endpoint/channel requested the interrupt. This bit is read-only."
            },
            {
                "name": "THR512",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "512 byte threshold interrupt\nThis bit is set to 1 by the hardware when 512 bytes have been transmitted or received during isochronous transfers. This bit is read/write but only 0 can be written and writing 1 has no effect. Note that no information is available to indicate the associated channel/endpoint, however in practice only one ISO endpoint/channel with such large packets can be supported, so that channel."
            },
            {
                "name": "DDISC",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Device connection\nHost mode\nThis bit is set when a device connection is detected. This bit is read/write but only 0 can be written and writing 1 has no effect."
            },
            {
                "name": "DCON_STAT",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Device connection status\nHost mode:\nThis bit contains information about device connection status. It is set by hardware when a LS/FS device is attached to the host while it is reset when the device is disconnected."
            },
            {
                "name": "LS_DCON",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Low speed device connected\nHost mode:\nThis bit is set by hardware when an LS device connection is detected. Device connection is signaled after LS J-state is sampled for 22 consecutive cycles of the USB clock (48 MHz) from the unconnected state."
            }
        ]
    },
    "1073832008": {
        "name": "USB_FNR",
        "address": 1073832008,
        "size": 32,
        "access": "",
        "desc": "USB frame number register ",
        "fields": [
            {
                "name": "FN",
                "bitOffset": 0,
                "bitWidth": 11,
                "desc": "Frame number\nThis bit field contains the 11-bits frame number contained in the last received SOF packet. The frame number is incremented for every frame sent by the host and it is useful for isochronous transfers. This bit field is updated on the generation of an SOF interrupt."
            },
            {
                "name": "LSOF",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "Lost SOF\nDevice mode\nThese bits are written by the hardware when an ESOF interrupt is generated, counting the number of consecutive SOF packets lost. At the reception of an SOF packet, these bits are cleared."
            },
            {
                "name": "LCK",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Locked\nDevice mode\nThis bit is set by the hardware when at least two consecutive SOF packets have been received after the end of an USB reset condition or after the end of an USB resume sequence. Once locked, the frame timer remains in this state until an USB reset or USB suspend event occurs."
            },
            {
                "name": "RXDM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Receive data - line status\nThis bit can be used to observe the status of received data minus upstream port data line. It can be used during end-of-suspend routines to help determining the wakeup event."
            },
            {
                "name": "RXDP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Receive data + line status\nThis bit can be used to observe the status of received data plus upstream port data line. It can be used during end-of-suspend routines to help determining the wakeup event."
            }
        ]
    },
    "1073832012": {
        "name": "USB_DADDR",
        "address": 1073832012,
        "size": 32,
        "access": "",
        "desc": "USB_DADDR",
        "fields": [
            {
                "name": "ADD",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Device address\nDevice mode\nThese bits contain the USB function address assigned by the host PC during the enumeration process. Both this field and the endpoint/channel address (EA) field in the associated USB_CHEPnR register must match with the information contained in a USB token in order to handle a transaction to the required endpoint.\nHost mode\nThese bits contain the address transmitted with the LPM transaction"
            },
            {
                "name": "EF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Enable function\nThis bit is set by the software to enable the USB Device. The address of this device is contained in the following ADD[6:0] bits. If this bit is at 0 no transactions are handled, irrespective of the settings of USB_CHEPnR registers."
            }
        ]
    },
    "1073832020": {
        "name": "USB_LPMCSR",
        "address": 1073832020,
        "size": 32,
        "access": "",
        "desc": "USB_LPMCSR",
        "fields": [
            {
                "name": "LPMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPM support enable\nDevice mode\nThis bit is set by the software to enable the LPM support within the USB Device. If this bit is at 0 no LPM transactions are handled."
            },
            {
                "name": "LPMACK",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPM token acknowledge enable\nDevice mode:\nThe NYET/ACK is returned only on a successful LPM transaction:\nNo errors in both the EXT token and the LPM token (else ERROR)\nA valid bLinkState = 0001B (L1) is received (else STALL)"
            },
            {
                "name": "REMWAKE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "bRemoteWake value\nDevice mode\nThis bit contains the bRemoteWake value received with last ACKed LPM Token"
            },
            {
                "name": "BESL",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "BESL value\nDevice mode\nThese bits contain the BESL value received with last ACKed LPM Token"
            }
        ]
    },
    "1073832024": {
        "name": "USB_BCDR",
        "address": 1073832024,
        "size": 32,
        "access": "",
        "desc": "USB_BCDR",
        "fields": [
            {
                "name": "BCDEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Battery charging detector (BCD) enable\nDevice mode\nThis bit is set by the software to enable the BCD support within the USB Device. When enabled, the USB PHY is fully controlled by BCD and cannot be used for normal communication. Once the BCD discovery is finished, the BCD should be placed in OFF mode by clearing this bit to 0 in order to allow the normal USB operation."
            },
            {
                "name": "DCDEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Data contact detection (DCD) mode enable\nDevice mode\nThis bit is set by the software to put the BCD into DCD mode. Only one detection mode (DCD, PD, SD or OFF) should be selected to work correctly."
            },
            {
                "name": "PDEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Primary detection (PD) mode enable\nDevice mode\nThis bit is set by the software to put the BCD into PD mode. Only one detection mode (DCD, PD, SD or OFF) should be selected to work correctly."
            },
            {
                "name": "SDEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Secondary detection (SD) mode enable\nDevice mode\nThis bit is set by the software to put the BCD into SD mode. Only one detection mode (DCD, PD, SD or OFF) should be selected to work correctly."
            },
            {
                "name": "DCDET",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Data contact detection (DCD) status\nDevice mode\nThis bit gives the result of DCD."
            },
            {
                "name": "PDET",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Primary detection (PD) status\nDevice mode\nThis bit gives the result of PD."
            },
            {
                "name": "SDET",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Secondary detection (SD) status\nDevice mode\nThis bit gives the result of SD."
            },
            {
                "name": "PS2DET",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DM pull-up detection status\nDevice mode\nThis bit is active only during PD and gives the result of comparison between DM voltage level and VLGC threshold. In normal situation, the DM level should be below this threshold. If it is above, it means that the DM is externally pulled high. This can be caused by connection to a PS2 port (which pulls-up both DP and DM lines) or to some proprietary charger not following the BCD specification."
            },
            {
                "name": "DPPU_DPD",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DP pull-up / DPDM pull-down\nDevice mode\nThis bit is set by software to enable the embedded pull-up on DP line. Clearing it to 0 can be used to signal disconnect to the host when needed by the user software.\nHost mode\nThis bit is set by software to enable the embedded pull-down on DP and DM lines."
            }
        ]
    },
    "1073753088": {
        "name": "WWDG_CR",
        "address": 1073753088,
        "size": 32,
        "access": "",
        "desc": "WWDG control register ",
        "fields": [
            {
                "name": "T",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "7-bit counter (MSB to LSB)\nThese bits contain the value of the watchdog counter, decremented every\n(4096 x 2WDGTB[2:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared)."
            },
            {
                "name": "WDGA",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Activation bit\nThis bit is set by software and only cleared by hardware after a reset. When WDGA = 1, the watchdog can generate a reset."
            }
        ]
    },
    "1073753092": {
        "name": "WWDG_CFR",
        "address": 1073753092,
        "size": 32,
        "access": "",
        "desc": "WWDG configuration register ",
        "fields": [
            {
                "name": "W",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "7-bit window value\nThese bits contain the window value to be compared with the down-counter."
            },
            {
                "name": "EWI",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Early wakeup interrupt\nWhen set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset."
            },
            {
                "name": "WDGTB",
                "bitOffset": 11,
                "bitWidth": 3,
                "desc": "Timer base\nThe timebase of the prescaler can be modified as follows:"
            }
        ]
    },
    "1073753096": {
        "name": "WWDG_SR",
        "address": 1073753096,
        "size": 32,
        "access": "",
        "desc": "WWDG status register ",
        "fields": [
            {
                "name": "EWIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Early wakeup interrupt flag\nThis bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing '0'. Writing '1' has no effect. This bit is also set if the interrupt is not enabled."
            }
        ]
    }
}