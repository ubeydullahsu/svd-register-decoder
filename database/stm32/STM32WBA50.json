{
    "1174540288": {
        "name": "ADC_ISR",
        "address": 1174540288,
        "size": 32,
        "access": "read-write",
        "desc": "ADC interrupt and status register",
        "fields": [
            {
                "name": "ADRDY",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC ready\n\nThis bit is set by hardware after the ADC has been enabled (ADEN = 1) and when the ADC reaches a state where it is ready to accept conversion requests.\n\nIt is cleared by software writing 1 to it."
            },
            {
                "name": "EOSMP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "End of sampling flag\n\nThis bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by writing 1 to it."
            },
            {
                "name": "EOC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "End of conversion flag\n\nThis bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register."
            },
            {
                "name": "EOS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "End of sequence flag\n\nThis bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it."
            },
            {
                "name": "OVR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "ADC overrun\n\nThis bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it."
            },
            {
                "name": "AWD1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog 1 flag\n\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by writing 1 to it."
            },
            {
                "name": "AWD2",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog 2 flag\n\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software writing 1 to it."
            },
            {
                "name": "AWD3",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog 3 flag\n\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by writing 1 to it."
            },
            {
                "name": "EOCAL",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "End of calibration flag\n\nThis bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it."
            },
            {
                "name": "LDORDY",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "LDO ready\n\nThis bit is set by hardware. It indicates that the ADC internal LDO output is ready.\n\nIt is cleared by software by writing 1 to it."
            }
        ]
    },
    "1174540292": {
        "name": "ADC_IER",
        "address": 1174540292,
        "size": 32,
        "access": "read-write",
        "desc": "ADC interrupt enable register",
        "fields": [
            {
                "name": "ADRDYIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC ready interrupt enable\n\nThis bit is set and cleared by software to enable/disable the ADC Ready interrupt.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOSMPIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "End of sampling flag interrupt enable\n\nThis bit is set and cleared by software to enable/disable the end of the sampling phase interrupt.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOCIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "End of conversion interrupt enable\n\nThis bit is set and cleared by software to enable/disable the end of conversion interrupt.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOSIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "End of conversion sequence interrupt enable\n\nThis bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "OVRIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Overrun interrupt enable\n\nThis bit is set and cleared by software to enable/disable the overrun interrupt.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD1IE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog 1 interrupt enable\n\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\n\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2IE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog 2 interrupt enable\n\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\n\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3IE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog 3 interrupt enable\n\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\n\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOCALIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "End of calibration interrupt enable\n\nThis bit is set and cleared by software to enable/disable the end of calibration interrupt.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "LDORDYIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "LDO ready interrupt enable\n\nThis bit is set and cleared by software. It is used to enable/disable the LDORDY interrupt.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensure that no conversion is ongoing)."
            }
        ]
    },
    "1174540296": {
        "name": "ADC_CR",
        "address": 1174540296,
        "size": 32,
        "access": "read-write",
        "desc": "ADC control register",
        "fields": [
            {
                "name": "ADEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC enable command\n\nThis bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set.\n\nIt is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.\n\nNote: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL = 0, ADSTP = 0, ADSTART = 0, ADDIS = 0 and ADEN = 0)"
            },
            {
                "name": "ADDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ADC disable command\n\nThis bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state).\n\nIt is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time).\n\nNote: Setting ADDIS to 1 is only effective when ADEN = 1 and ADSTART = 0 (which ensures that no conversion is ongoing)"
            },
            {
                "name": "ADSTART",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "ADC start conversion command\n\nThis bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware trigger configuration).\n\nIt is cleared by hardware:\n\nIn single conversion mode (CONT = 0, DISCEN = 0), when software trigger is selected (EXTEN = 00): at the assertion of the end of Conversion Sequence (EOS) flag.\n\nIn discontinuous conversion mode(CONT=0, DISCEN = 1), when the software trigger is selected (EXTEN = 00): at the assertion of the end of Conversion (EOC) flag.\n\nIn all other cases: after the execution of the ADSTP command, at the same time as the ADSTP bit is cleared by hardware.\n\nNote: The software is allowed to set ADSTART only when ADEN = 1 and ADDIS = 0 (ADC is enabled and there is no pending request to disable the ADC)."
            },
            {
                "name": "ADSTP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "ADC stop conversion command\n\nThis bit is set by software to stop and discard an ongoing conversion (ADSTP Command).\n\nIt is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command.\n\nNote: To clear the A/D converter state, ADSTP must be set to 1 even if ADSTART is cleared to 0 after the software trigger A/D conversion. It is recommended to set ADSTP to 1 whenever the configuration needs to be modified."
            },
            {
                "name": "ADVREGEN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "ADC voltage regulator enable\n\nThis bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tsubADCVREG_SETUP/sub.\n\nIt is cleared by software to disable the voltage regulator. It can be cleared only if ADEN is et to 0.\n\nNote: The software is allowed to program this bit field only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0)."
            },
            {
                "name": "ADCAL",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "ADC calibration\n\nThis bit is set by software to start the calibration of the ADC.\n\nIt is cleared by hardware after calibration is complete.\n\nNote: The software is allowed to set ADCAL only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0, AUTOFF = 0, and ADEN = 0).\n\nNote: The software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN is set to 1 and ADSTART is cleared to 0 by writing ADSTP to 1 (ADC enabled and no conversion is ongoing)."
            }
        ]
    },
    "1174540300": {
        "name": "ADC_CFGR1",
        "address": 1174540300,
        "size": 32,
        "access": "read-write",
        "desc": "ADC configuration register 1",
        "fields": [
            {
                "name": "DMAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Direct memory access enable\n\nThis bit is set and cleared by software to enable the generation of DMA requests. This allows the automatic management of the converted data by the DMA controller. For more details, refer to Section : Managing converted data using the DMA on page 632.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "DMACFG",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Direct memory access configuration\n\nThis bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN = 1.\n\nFor more details, refer to Section : Managing converted data using the DMA on page 632\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "RES",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Data resolution\n\nThese bits are written by software to select the resolution of the conversion.\n\nNote: The software is allowed to write these bits only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "SCANDIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Scan sequence direction\n\nThis bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELRMOD bit is cleared to 0.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "ALIGN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Data alignment\n\nThis bit is set and cleared by software to select right or left alignment. Refer to Figure 78: Data alignment and resolution (oversampling disabled: OVSE = 0) on page 631\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EXTSEL",
                "bitOffset": 6,
                "bitWidth": 3,
                "desc": "External trigger selection\n\nThese bits select the external event used to trigger the start of conversion (refer to table ADC interconnection in Section 20.4.2: ADC pins and internal signals for details):\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EXTEN",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "External trigger enable and polarity selection\n\nThese bits are set and cleared by software to select the external trigger polarity and enable the trigger.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "OVRMOD",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun management mode\n\nThis bit is set and cleared by software and configure the way data overruns are managed.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "CONT",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Single / continuous conversion mode\n\nThis bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared.\n\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN = 1 and CONT = 1.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "WAIT",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Wait conversion mode\n\nThis bit is set and cleared by software to enable/disable wait conversion mode.sup./sup\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "DISCEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Discontinuous mode\n\nThis bit is set and cleared by software to enable/disable discontinuous mode.\n\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN = 1 and CONT = 1.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSELRMOD",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Mode selection of the ADC_CHSELR register\n\nThis bit is set and cleared by software to control the ADC_CHSELR feature:\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD1SGL",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Enable the watchdog on a single channel or on all channels\n\nThis bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD1EN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Analog watchdog enable\n\nThis bit is set and cleared by software.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD1CH",
                "bitOffset": 26,
                "bitWidth": 5,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.\n\n.....\n\nOthers: Reserved\n\nThe channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            }
        ]
    },
    "1174540304": {
        "name": "ADC_CFGR2",
        "address": 1174540304,
        "size": 32,
        "access": "read-write",
        "desc": "ADC configuration register 2",
        "fields": [
            {
                "name": "OVSE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Oversampler Enable\n\nThis bit is set and cleared by software.\n\nNote: Software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "OVSR",
                "bitOffset": 2,
                "bitWidth": 3,
                "desc": "Oversampling ratio\n\nThis bit filed defines the number of oversampling ratio.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "OVSS",
                "bitOffset": 5,
                "bitWidth": 4,
                "desc": "Oversampling shift\n\nThis bit is set and cleared by software.\n\nOthers: Reserved\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1(which ensures that no conversion is ongoing)."
            },
            {
                "name": "TOVS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Triggered Oversampling\n\nThis bit is set and cleared by software.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "LFTRIG",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Low frequency trigger mode enable\n\nThis bit must be set by software.\n\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 by writing ADSTP to 1 (this ensures that no conversion is ongoing)."
            }
        ]
    },
    "1174540308": {
        "name": "ADC_SMPR",
        "address": 1174540308,
        "size": 32,
        "access": "read-write",
        "desc": "ADC sampling time register",
        "fields": [
            {
                "name": "SMP1",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Sampling time selection 1\n\nThese bits are written by software to select the sampling time that applies to all channels.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMP2",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Sampling time selection 2\n\nThese bits are written by software to select the sampling time that applies to all channels.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL0",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL1",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL2",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL3",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL4",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL5",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL6",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL7",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL8",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL9",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL10",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL11",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL12",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL13",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\n\nThese bits are written by software to define which sampling time is used.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1174540320": {
        "name": "ADC_AWD1TR",
        "address": 1174540320,
        "size": 32,
        "access": "read-write",
        "desc": "ADC watchdog threshold register",
        "fields": [
            {
                "name": "LT1",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Analog watchdog 1 lower threshold\n\nThese bits are written by software to define the lower threshold for the analog watchdog.\n\nRefer to Section 20.4.25: Analog window watchdog on page 638."
            },
            {
                "name": "HT1",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Analog watchdog 1 higher threshold\n\nThese bits are written by software to define the higher threshold for the analog watchdog.\n\nRefer to Section 20.4.25: Analog window watchdog on page 638."
            }
        ]
    },
    "1174540324": {
        "name": "ADC_AWD2TR",
        "address": 1174540324,
        "size": 32,
        "access": "read-write",
        "desc": "ADC watchdog threshold register",
        "fields": [
            {
                "name": "LT2",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Analog watchdog 2 lower threshold\n\nThese bits are written by software to define the lower threshold for the analog watchdog.\n\nRefer to Section 20.4.25: Analog window watchdog on page 638."
            },
            {
                "name": "HT2",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Analog watchdog 2 higher threshold\n\nThese bits are written by software to define the higher threshold for the analog watchdog.\n\nRefer to Section 20.4.25: Analog window watchdog on page 638."
            }
        ]
    },
    "1174540328": {
        "name": "ADC_CHSELR",
        "address": 1174540328,
        "size": 32,
        "access": "read-write",
        "desc": "ADC channel selection register [alternate]",
        "fields": [
            {
                "name": "CHSEL0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSEL13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Channel x selection\n\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\n\nNote: The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1174540332": {
        "name": "ADC_AWD3TR",
        "address": 1174540332,
        "size": 32,
        "access": "read-write",
        "desc": "ADC watchdog threshold register",
        "fields": [
            {
                "name": "LT3",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Analog watchdog 3lower threshold\n\nThese bits are written by software to define the lower threshold for the analog watchdog.\n\nRefer to Section 20.4.25: Analog window watchdog on page 638."
            },
            {
                "name": "HT3",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Analog watchdog 3 higher threshold\n\nThese bits are written by software to define the higher threshold for the analog watchdog.\n\nRefer to Section 20.4.25: Analog window watchdog on page 638."
            }
        ]
    },
    "1174540352": {
        "name": "ADC_DR",
        "address": 1174540352,
        "size": 32,
        "access": "read-only",
        "desc": "ADC data register",
        "fields": [
            {
                "name": "DATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Converted data\n\nThese bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in Figure 78: Data alignment and resolution (oversampling disabled: OVSE = 0) on page 631.\n\nJust after a calibration is complete, DATA[6:0] contains the calibration factor."
            }
        ]
    },
    "1174540356": {
        "name": "ADC_PWR",
        "address": 1174540356,
        "size": 32,
        "access": "read-write",
        "desc": "ADC data register",
        "fields": [
            {
                "name": "AUTOFF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Auto-off mode bit\n\nThis bit is set and cleared by software. it is used to enable/disable the Auto-off mode.\n\nNote: The software is allowed to write this bit only when ADEN bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "DPD",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Deep-power-down mode bit\n\nThis bit is set and cleared by software. It is used to enable/disable Deep-power-down mode in Autonomous mode when the ADC is not used.\n\nNote: The software is allowed to write this bit only when ADEN bit is cleared to 0 (this ensures that no conversion is ongoing).\n\nNote: Setting DPD in Auto-off mode automatically disables the LDO."
            }
        ]
    },
    "1174540448": {
        "name": "ADC_AWD2CR",
        "address": 1174540448,
        "size": 32,
        "access": "read-write",
        "desc": "ADC Analog Watchdog 2 Configuration register",
        "fields": [
            {
                "name": "AWD2CH0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\n\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1174540452": {
        "name": "ADC_AWD3CR",
        "address": 1174540452,
        "size": 32,
        "access": "read-write",
        "desc": "ADC Analog Watchdog 3 Configuration register",
        "fields": [
            {
                "name": "AWD3CH0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\n\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\n\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1174540484": {
        "name": "ADC_CALFACT",
        "address": 1174540484,
        "size": 32,
        "access": "read-write",
        "desc": "ADC Calibration factor",
        "fields": [
            {
                "name": "CALFACT",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Calibration factor\n\nThese bits are written by hardware or by software.\n\nOnce a calibration is complete, they are updated by hardware with the calibration factors.\n\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new calibration is launched.\n\nJust after a calibration is complete, DATA[6:0] contains the calibration factor.\n\nNote: Software can write these bits only when ADEN = 1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing)."
            }
        ]
    },
    "1174541064": {
        "name": "ADC_CCR",
        "address": 1174541064,
        "size": 32,
        "access": "read-write",
        "desc": "ADC common configuration register",
        "fields": [
            {
                "name": "PRESC",
                "bitOffset": 18,
                "bitWidth": 4,
                "desc": "ADC prescaler\n\nSet and cleared by software to select the frequency of the clock to the ADC.\n\nOther: Reserved\n\nNote: Software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0)."
            },
            {
                "name": "VREFEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "VsubREFINT/sub enable\n\nThis bit is set and cleared by software to enable/disable the VsubREFINT/sub buffer.\n\nNote: Software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "VSENSESEL",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Temperature sensor selection\n\nThis bit is set and cleared by software to enable/disable the temperature sensor.\n\nNote: Software is allowed to write this bit only when ADSTART is cleared to 0 by writing ADSTP to 1 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1108082688": {
        "name": "AES_CR",
        "address": 1108082688,
        "size": 32,
        "access": "",
        "desc": "AES control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Enable\nThis bit enables/disables the AES peripheral.\nAt any moment, clearing then setting the bit re-initializes the AES peripheral.\nThis bit is automatically cleared by hardware upon the completion of the key preparation (MODE[1:0] at 01) and upon the completion of GCM/GMAC/CCM initialization phase.\nThe bit cannot be set as long as KEYVALID=0."
            },
            {
                "name": "DATATYPE",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Data type\nThis bitfield defines the format of data written in the AES_DINR register or read from the AES_DOUTR register, through selecting the mode of data swapping. This swapping is defined in Section23.4.17: AES data registers and data swapping.\nAttempts to write the bitfield are ignored when BUSY is set, as well as when EN is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "MODE",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Operating mode\nThis bitfield selects the AES operating mode:\nAttempts to write the bitfield are ignored when BUSY is set, as well as when EN is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "CHMOD",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "CHMOD[1:0]: Chaining mode\nThis bitfield selects the AES chaining mode:\nothers: Reserved\nAttempts to write the bitfield are ignored when BUSY is set, as well as when EN is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "DMAINEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "DMA input enable\nWhen this bit is set, DMA requests are automatically generated by the peripheral during the input data phase.\nSetting this bit is ignored when MODE[1:0] is at 01 (key derivation)."
            },
            {
                "name": "DMAOUTEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "DMA output enable\nWhen this bit is set, DMA requests are automatically generated by the peripheral during the output data phase.\nSetting this bit is ignored when MODE[1:0] is at 01 (key derivation)."
            },
            {
                "name": "GCMPH",
                "bitOffset": 13,
                "bitWidth": 2,
                "desc": "GCM or CCM phase selection\nThis bitfield selects the phase, applicable only with GCM, GMAC or CCM chaining modes. This bitfield has no effect if GCM, GMAC or CCM algorithm is not selected with CHMOD[2:0]."
            },
            {
                "name": "CHMOD_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CHMOD[2]"
            },
            {
                "name": "KEYSIZE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Key size selection\nThis bitfield defines the key length in bits of the key used by AES.\nAttempts to write the bit are ignored when BUSY is set, as well as when the EN is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "NPBLB",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Number of padding bytes in last block\nThis padding information must be filled by software before processing the last block of GCM payload encryption or CCM payload decryption, otherwise authentication tag computation is incorrect.\n..."
            },
            {
                "name": "KMOD",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Key mode selection\nThe bitfield defines how the AES key can be used by the application. KEYSIZE must be correctly initialized when setting KMOD[1:0] different from zero.\nOthers: Reserved\nAttempts to write the bitfield are ignored when BUSY is set, as well as when EN is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "IPRST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "AES peripheral software reset\nSetting the bit resets the AES peripheral, putting all registers to their default values, except the IPRST bit itself. Hence, any key-relative data are lost. For this reason, it is recommended to set the bit before handing over the AES to a less secure application.\nThe bit must be low while writing any configuration registers."
            }
        ]
    },
    "1108082692": {
        "name": "AES_SR",
        "address": 1108082692,
        "size": 32,
        "access": "",
        "desc": "AES status register",
        "fields": [
            {
                "name": "RDERRF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Read error flag\nThis bit is set when an unexpected read to the AES_DOUTR register occurred. When set RDERRF bit has no impact on the AES operations.\nThis flag is cleared by setting the RWEIF bit in AES_ICR register.\nIf RWEIE bit is set in AES_IER register an interrupt is generated when RDERRF is set. It is cleared by setting the RWEIF bit of the AES_ICR register."
            },
            {
                "name": "WRERRF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Write error flag\nThis bit is set when an unexpected write to the AES_DINR register occurred. When set WRERRF bit has no impact on the AES operations.\nThis flag is cleared by setting the RWEIF bit in AES_ICR register.\nIf RWEIE bit is set in AES_IER register an interrupt is generated when WRERRF is set. It is cleared by setting the RWEIF bit of the AES_ICR register."
            },
            {
                "name": "BUSY",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Busy\nThis flag indicates whether AES is idle or busy.\nAES is flagged as idle when disabled or when the last processing is completed.\nAES is flagged as busy when processing a block data, preparing a key (ECB or CBC decryption only), or transferring a shared key from SAES peripheral.\nWhen GCM encryption is selected, this flag must be at zero before suspending current process to manage a higher-priority message."
            },
            {
                "name": "KEYVALID",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Key valid flag\nThis bit is set by hardware when the key of size defined by KEYSIZE is loaded in AES_KEYRx key registers.\nThe EN bit can only be set when KEYVALID is set.\nIn normal mode when KEYSEL[2:0] is at 000, the key must be written in the key registers in the correct sequence, otherwise the KEIF flag is set and KEYVALID remains cleared.\nWhen KEYSEL[2:0] is different from zero, the BUSY flag is automatically set by AES. When the key is loaded successfully, BUSY is cleared and KEYVALID set. Upon an error, KEIF is set, BUSY cleared and KEYVALID remains cleared.\nIf set, KEIF must be cleared through the AES_ICR register, otherwise KEYVALID cannot be set. See the KEIF flag description for more details.\nFor further information on key loading, refer to Section23.4.18: AES key registers."
            }
        ]
    },
    "1108082696": {
        "name": "AES_DINR",
        "address": 1108082696,
        "size": 32,
        "access": "",
        "desc": "AES data input register",
        "fields": [
            {
                "name": "DIN",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Input data word\nA four-fold sequential write to this bitfield during the Input phase results in writing a complete 16-bytes block of input data to the AES peripheral. From the first to the fourth write, the corresponding data weights are [127:96], [95:64], [63:32], and [31:0]. Upon each write, the data from the 32-bit input buffer are handled by the data swap block according to the DATATYPE[1:0] bitfield, then written into the AES core 16-bytes input buffer.\nReads return zero."
            }
        ]
    },
    "1108082700": {
        "name": "AES_DOUTR",
        "address": 1108082700,
        "size": 32,
        "access": "",
        "desc": "AES data output register",
        "fields": [
            {
                "name": "DOUT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Output data word\nThis read-only bitfield fetches a 32-bit output buffer. A four-fold sequential read of this bitfield, upon\nthe computation completion (CCF flag set), virtually reads a complete 16-byte block of output data from\nthe AES peripheral. Before reaching the output buffer, the data produced by the AES core are\nhandled by the data swap block according to the DATATYPE[1:0] bitfield.\nData weights from the first to the fourth read operation are: [127:96], [95:64], [63:32], and [31:0]."
            }
        ]
    },
    "1108082704": {
        "name": "AES_KEYR0",
        "address": 1108082704,
        "size": 32,
        "access": "",
        "desc": "AES key register 0",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [31:0]\nThis write-only bitfield contains the bits [31:0] of the AES encryption or decryption key, depending on the operating mode MODE[1:0] in AES_CR.\nThe AES_KEYRx registers may be written only when KEYSIZE value is correct and when the AES peripheral is disabled (EN bit of the AES_CR register cleared). A special writing sequence is also required, as described in KEYVALID bit of the AES_SR register. Note that, if KMOD[1:0] is at 10 (shared key), the key is directly loaded from SAES peripheral to AES_KEYRx registers (hence writes to key register is ignored and KEIF is set).\nWhen KEYVALID is set a write to this register clears KEYVALID if AES is disabled."
            }
        ]
    },
    "1108082708": {
        "name": "AES_KEYR1",
        "address": 1108082708,
        "size": 32,
        "access": "",
        "desc": "AES key register 1",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [63:32]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.\nWhen KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR."
            }
        ]
    },
    "1108082712": {
        "name": "AES_KEYR2",
        "address": 1108082712,
        "size": 32,
        "access": "",
        "desc": "AES key register 2",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [95:64]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.\nWhen KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR."
            }
        ]
    },
    "1108082716": {
        "name": "AES_KEYR3",
        "address": 1108082716,
        "size": 32,
        "access": "",
        "desc": "AES key register 3",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [127:96]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.\nWhen KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR."
            }
        ]
    },
    "1108082720": {
        "name": "AES_IVR0",
        "address": 1108082720,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 0",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [31:0]\nAES_IVRx registers store the 128-bit initialization vector or the nonce, depending on the chaining mode selected. This value is updated by the AES core after each computation round (when applicable).\nWrite to this register is ignored when EN bit is set in AES_SR register"
            }
        ]
    },
    "1108082724": {
        "name": "AES_IVR1",
        "address": 1108082724,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 1",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [63:32]\nRefer to the AES_IVR0 register for description of the IVI[128:0] bitfield."
            }
        ]
    },
    "1108082728": {
        "name": "AES_IVR2",
        "address": 1108082728,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 2",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [95:64]\nRefer to the AES_IVR0 register for description of the IVI[128:0] bitfield."
            }
        ]
    },
    "1108082732": {
        "name": "AES_IVR3",
        "address": 1108082732,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 3",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [127:96]\nRefer to the AES_IVR0 register for description of the IVI[128:0] bitfield."
            }
        ]
    },
    "1108082736": {
        "name": "AES_KEYR4",
        "address": 1108082736,
        "size": 32,
        "access": "",
        "desc": "AES key register 4",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [159:128]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.\nWriting to this register has no effect when key size is 128-bit (KEYSIZE=0). When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR."
            }
        ]
    },
    "1108082740": {
        "name": "AES_KEYR5",
        "address": 1108082740,
        "size": 32,
        "access": "",
        "desc": "AES key register 5",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [191:160]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.\nWriting to this register has no effect when key size is 128-bit (KEYSIZE=0). When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR."
            }
        ]
    },
    "1108082744": {
        "name": "AES_KEYR6",
        "address": 1108082744,
        "size": 32,
        "access": "",
        "desc": "AES key register 6",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [223:192]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.\nWriting to this register has no effect when key size is 128-bit (KEYSIZE=0). When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR."
            }
        ]
    },
    "1108082748": {
        "name": "AES_KEYR7",
        "address": 1108082748,
        "size": 32,
        "access": "",
        "desc": "AES key register 7",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [255:224]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield.\nWriting to this register has no effect when key size is 128-bit (KEYSIZE=0). When KEYVALID is set in AES_SR a write to this register clears KEYVALID if EN is cleared in AES_CR."
            }
        ]
    },
    "1108082752": {
        "name": "AES_SUSPR0",
        "address": 1108082752,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1108082756": {
        "name": "AES_SUSPR1",
        "address": 1108082756,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1108082760": {
        "name": "AES_SUSPR2",
        "address": 1108082760,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1108082764": {
        "name": "AES_SUSPR3",
        "address": 1108082764,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1108082768": {
        "name": "AES_SUSPR4",
        "address": 1108082768,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1108082772": {
        "name": "AES_SUSPR5",
        "address": 1108082772,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1108082776": {
        "name": "AES_SUSPR6",
        "address": 1108082776,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1108082780": {
        "name": "AES_SUSPR7",
        "address": 1108082780,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Suspend data\nAES_SUSPRx registers contain the complete internal register states of the AES when the GCM, GMAC or CCM processing of the current task is suspended to process a higher-priority task. Refer to Section23.4.8: AES suspend and resume operations for more details.\nRead to this register returns zero when EN bit is cleared in AES_SR register.\nAES_SUSPRx registers are not used in other chaining modes than GCM, GMAC or CCM."
            }
        ]
    },
    "1108083456": {
        "name": "AES_IER",
        "address": 1108083456,
        "size": 32,
        "access": "",
        "desc": "AES interrupt enable register",
        "fields": [
            {
                "name": "CCFIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Computation complete flag interrupt enable\nThis bit enables or disables (masks) the AES interrupt generation when CCF (computation complete flag) is set."
            },
            {
                "name": "RWEIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Read or write error interrupt enable\nThis bit enables or disables (masks) the AES interrupt generation when RWEIF (read and/or write error flag) is set."
            },
            {
                "name": "KEIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Key error interrupt enable\nThis bit enables or disables (masks) the AES interrupt generation when KEIF (key error flag) is set."
            }
        ]
    },
    "1108083460": {
        "name": "AES_ISR",
        "address": 1108083460,
        "size": 32,
        "access": "",
        "desc": "AES interrupt status register",
        "fields": [
            {
                "name": "CCF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Computation complete flag\nThis flag indicates whether the computation is completed. It is significant only when the DMAOUTEN bit is cleared, and it may stay high when DMAOUTEN is set.\nCCF bit is cleared when application sets the corresponding bit of AES_ICR register. An interrupt is generated if the CCFIE bit has been previously set in the AES_IER register."
            },
            {
                "name": "RWEIF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Read or write error interrupt flag\nThis read-only bit is set by hardware when a RDERRF or a WRERRF error flag is set in the AES_SR register.\nRWEIF bit is cleared when application sets the corresponding bit of AES_ICR register. An interrupt is generated if the RWEIE bit has been previously set in the AES_IER register.\nThis flags has no meaning when key derivation mode is selected."
            },
            {
                "name": "KEIF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Key error interrupt flag\nThis read-only bit is set by hardware when key information failed to load into key registers.\nSetting the corresponding bit of the AES_ICR register clears the KEIF and generates interrupt if the KEIE bit of the AES_IER register is set.\nKEIF is triggered upon any of the following errors:\nAES_KEYRx register write does not respect the correct order. (For KEYSIZE=0, AES_KEYR0 then AES_KEYR1 then AES_KEYR2 then AES_KEYR3 register, or reverse. For KEYSIZE set, AES_KEYR0 then AES_KEYR1 then AES_KEYR2 then AES_KEYR3 then AES_KEYR4 then AES_KEYR5 then AES_KEYR6 then AES_KEYR7, or reverse).\nKEIF must be cleared by the application software, otherwise KEYVALID cannot be set."
            }
        ]
    },
    "1108083464": {
        "name": "AES_ICR",
        "address": 1108083464,
        "size": 32,
        "access": "",
        "desc": "AES interrupt clear register",
        "fields": [
            {
                "name": "CCF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Computation complete flag clear\nSetting this bit clears the CCF status bit of the AES_ISR register."
            },
            {
                "name": "RWEIF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Read or write error interrupt flag clear\nSetting this bit clears the RWEIF status bit of the AES_ISR register, and clears both RDERRF and WRERRF flags in the AES_SR register."
            },
            {
                "name": "KEIF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Key error interrupt flag clear\nSetting this bit clears the KEIF status bit of the AES_ISR register."
            }
        ]
    },
    "1073885184": {
        "name": "CRC_DR",
        "address": 1073885184,
        "size": 32,
        "access": "read-write",
        "desc": "CRC data register",
        "fields": [
            {
                "name": "DR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Data register bits\nThis register is used to write new data to the CRC calculator.\nIt holds the previous CRC calculation result when it is read.\nIf the data size is less than 32 bits, the least significant bits are used to write/read the correct value."
            }
        ]
    },
    "1073885188": {
        "name": "CRC_IDR",
        "address": 1073885188,
        "size": 32,
        "access": "read-write",
        "desc": "CRC independent data register",
        "fields": [
            {
                "name": "IDR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "General-purpose 32-bit data register bits\nThese bits can be used as a temporary storage location for four bytes.\nThis register is not affected by CRC resets generated by the RESET bit in the CRC_CR register"
            }
        ]
    },
    "1073885192": {
        "name": "CRC_CR",
        "address": 1073885192,
        "size": 32,
        "access": "read-write",
        "desc": "CRC control register",
        "fields": [
            {
                "name": "RESET",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RESET bit\nThis bit is set by software to reset the CRC calculation unit and set the data register to the value stored in the CRC_INIT register. This bit can only be set, it is automatically cleared by hardware"
            },
            {
                "name": "POLYSIZE",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Polynomial size\nThese bits control the size of the polynomial."
            },
            {
                "name": "REV_IN",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Reverse input data\nThese bits control the reversal of the bit order of the input data"
            },
            {
                "name": "REV_OUT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Reverse output data\n\nThis bit controls the reversal of the bit order of the output data."
            }
        ]
    },
    "1073885200": {
        "name": "CRC_INIT",
        "address": 1073885200,
        "size": 32,
        "access": "read-write",
        "desc": "CRC initial value",
        "fields": [
            {
                "name": "CRC_INIT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Programmable initial CRC value\n\nThis register is used to write the CRC initial value."
            }
        ]
    },
    "1073885204": {
        "name": "CRC_POL",
        "address": 1073885204,
        "size": 32,
        "access": "read-write",
        "desc": "CRC polynomial",
        "fields": [
            {
                "name": "POL",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Programmable polynomial\n\nThis register is used to write the coefficients of the polynomial to be used for CRC calculation.\n\nIf the polynomial size is less than 32 bits, the least significant bits have to be used to program the correct value."
            }
        ]
    },
    "3758374912": {
        "name": "DBGMCU_IDCODER",
        "address": 3758374912,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU identity code register",
        "fields": [
            {
                "name": "DEV_ID",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Device ID"
            },
            {
                "name": "REV_ID",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Revision ID"
            }
        ]
    },
    "3758374916": {
        "name": "DBGMCU_SCR",
        "address": 3758374916,
        "size": 32,
        "access": "read-write",
        "desc": "DBGMCU status and configuration register",
        "fields": [
            {
                "name": "DBG_STOP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Allows debug in Stop mode\n\nWrite access can be protected by PWR_SECCFGR.LPMSEC.\n\nThe CPU debug and DBGMCU clocks remain active and the HSI16 oscillators is used as system clock during Stop debug mode, allowing CPU debug capability. On exit from Stop mode, the clock settings are set to the Stop mode exit state."
            },
            {
                "name": "DBG_STANDBY",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Allows debug in Standby mode\n\nWrite access can be protected by PWR_SECCFGR.LPMSEC.\n\nThe CPU debug and DBGMCU clocks remain active and the HSI16 oscillator is used as system clock, the supply and SRAM memory content is maintained during Standby debug mode, allowing CPU debug capability. On exit from Standby mode, a standby reset is performed."
            },
            {
                "name": "LPMS",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "Device low power mode selected\n\n10x: Standby mode\n\nothers reserved"
            },
            {
                "name": "STOPF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Device Stop flag"
            },
            {
                "name": "SBF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Device Standby flag"
            },
            {
                "name": "CS",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "CPU Sleep"
            },
            {
                "name": "CDS",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "CPU DeepSleep"
            }
        ]
    },
    "3758374920": {
        "name": "DBGMCU_APB1LFZR",
        "address": 3758374920,
        "size": 32,
        "access": "read-write",
        "desc": "DBGMCU APB1L peripheral freeze register",
        "fields": [
            {
                "name": "DBG_TIM2_STOP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 stop in CPU debug\n\nWrite access can be protected by GTZC_TZSC.TIM2SEC."
            },
            {
                "name": "DBG_TIM3_STOP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 stop in CPU debug\n\nWrite access can be protected by GTZC_TZSC.TIM3SEC."
            },
            {
                "name": "DBG_WWDG_STOP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "WWDG stop in CPU debug\n\nWrite access can be protected by GTZC_TZSC.WWDGSEC"
            },
            {
                "name": "DBG_IWDG_STOP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "IWDG stop in CPU debug\n\nWrite access can be protected by GTZC_TZSC.IWDGSEC."
            },
            {
                "name": "DBG_I2C1_STOP",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 SMBUS timeout stop in CPU debug\n\nWrite access can be protected by GTZC_TZSC.I2C1SEC."
            }
        ]
    },
    "3758374924": {
        "name": "DBGMCU_APB1HFZR",
        "address": 3758374924,
        "size": 32,
        "access": "read-write",
        "desc": "DBGMCU APB1H peripheral freeze register",
        "fields": [
            {
                "name": "DBG_LPTIM2_STOP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LPTIM2 stop in CPU debug\n\nWrite access can be protected by GTZC_TZSC.LPTIM2SEC."
            }
        ]
    },
    "3758374928": {
        "name": "DBGMCU_APB2FZR",
        "address": 3758374928,
        "size": 32,
        "access": "read-write",
        "desc": "DBGMCU APB2 peripheral freeze register",
        "fields": [
            {
                "name": "DBG_TIM1_STOP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 stop in CPU debug\n\nWrite access can be protected by GTZC_TZSC.TIM1SEC."
            },
            {
                "name": "DBG_TIM16_STOP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 stop in CPU debug\n\nWrite access can be protected by GTZC_TZSC.TIM16SEC."
            },
            {
                "name": "DBG_TIM17_STOP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "TIM17 stop in CPU debug\n\nWrite access can be protected by GTZC_TZSC.TIM17SEC."
            }
        ]
    },
    "3758374948": {
        "name": "DBGMCU_APB7FZR",
        "address": 3758374948,
        "size": 32,
        "access": "read-write",
        "desc": "DBGMCU APB7 peripheral freeze register",
        "fields": [
            {
                "name": "DBG_I2C3_STOP",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "I2C3 stop in CPU debug\n\nAccess can be protected by GTZC_TZSC.I2C3SEC."
            },
            {
                "name": "DBG_LPTIM1_STOP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "LPTIM1 stop in CPU debug\n\nAccess can be protected by GTZC_TZSC.LPTIM1SEC."
            },
            {
                "name": "DBG_RTC_STOP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "RTC stop in CPU debug\n\nAccess can be protected by GTZC_TZSC.TIM17SEC.\n\nCan only be accessed secure when one or more features in the RTC or TAMP is/are secure."
            }
        ]
    },
    "3758374952": {
        "name": "DBGMCU_AHB1FZR",
        "address": 3758374952,
        "size": 32,
        "access": "read-write",
        "desc": "DBGMCU AHB1 peripheral freeze register",
        "fields": [
            {
                "name": "DBG_GPDMA1_CH0_STOP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPDMA 1 channel 0 stop in CPU debug\n\nWrite access can be protected by GPDMA_SECCFGR.SEC0."
            },
            {
                "name": "DBG_GPDMA1_CH1_STOP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "GPDMA 1 channel 1 stop in CPU debug\n\nWrite access can be protected by GPDMA_SECCFGR.SEC1."
            },
            {
                "name": "DBG_GPDMA1_CH2_STOP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "GPDMA 1 channel 2 stop in CPU debug\n\nWrite access can be protected by GPDMA_SECCFGR.SEC2."
            },
            {
                "name": "DBG_GPDMA1_CH3_STOP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "GPDMA 1 channel 3 stop in CPU debug\n\nWrite access can be protected by GPDMA_SECCFGR.SEC3."
            },
            {
                "name": "DBG_GPDMA1_CH4_STOP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "GPDMA 1 channel 4 stop in CPU debug\n\nWrite access can be protected by GPDMA_SECCFGR.SEC4."
            },
            {
                "name": "DBG_GPDMA1_CH5_STOP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "GPDMA 1 channel 5 stop in CPU debug\n\nWrite access can be protected by GPDMA_SECCFGR.SEC5."
            },
            {
                "name": "DBG_GPDMA1_CH6_STOP",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "GPDMA 1 channel 6 stop in CPU debug\n\nWrite access can be protected by GPDMA_SECCFGR.SEC6."
            },
            {
                "name": "DBG_GPDMA1_CH7_STOP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "GPDMA 1 channel 7 stop in CPU debug\n\nWrite access can be protected by GPDMA_SECCFGR.SEC7."
            }
        ]
    },
    "3758375164": {
        "name": "DBGMCU_SR",
        "address": 3758375164,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU status register",
        "fields": [
            {
                "name": "AP_PRESENT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Bit n identifies whether access port APn is present in device\n\nBit n = 0: APn absent\n\nBit n = 1: APn present"
            },
            {
                "name": "AP_ENABLED",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Bit n identifies whether access port APn is open (can be accessed via the debug port) or locked (debug access to the APn is blocked, except for DBGMCU access)\n\nBit n = 0: APn locked (except for access to DBGMCU)\n\nBit n = 1: APn enabled"
            }
        ]
    },
    "3758375168": {
        "name": "DBGMCU_DBG_AUTH_HOST",
        "address": 3758375168,
        "size": 32,
        "access": "write-only",
        "desc": "DBGMCU debug host authentication register",
        "fields": [
            {
                "name": "AUTH_KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Device authentication key\n\nThe device specific 64-bit authentication key (OEMn key) must be written to this register (in two successive 32-bit writes, least significant word first) to permit RDP regression. Writing a wrong key locks access to the device and prevent code execution from the Flash memory."
            }
        ]
    },
    "3758375172": {
        "name": "DBGMCU_DBG_AUTH_DEVICE",
        "address": 3758375172,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU debug device authentication register",
        "fields": [
            {
                "name": "AUTH_ID",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Device specific ID\n\nDevice specific ID used for RDP regression."
            }
        ]
    },
    "3758376924": {
        "name": "DBGMCU_PNCR",
        "address": 3758376924,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU part number codification register",
        "fields": [
            {
                "name": "CODIFICATION",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Part number codification"
            }
        ]
    },
    "3758378960": {
        "name": "DBGMCU_PIDR4",
        "address": 3758378960,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU CoreSight peripheral identity register 4",
        "fields": [
            {
                "name": "JEP106CON",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "JEP106 continuation code"
            },
            {
                "name": "F4KCOUNT",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Register file size"
            }
        ]
    },
    "3758378976": {
        "name": "DBGMCU_PIDR0",
        "address": 3758378976,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU CoreSight peripheral identity register 0",
        "fields": [
            {
                "name": "PARTNUM",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Part number bits [7:0]"
            }
        ]
    },
    "3758378980": {
        "name": "DBGMCU_PIDR1",
        "address": 3758378980,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU CoreSight peripheral identity register 1",
        "fields": [
            {
                "name": "PARTNUM",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Part number bits [11:8]"
            },
            {
                "name": "JEP106ID",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "JEP106 identity code bits [3:0]"
            }
        ]
    },
    "3758378984": {
        "name": "DBGMCU_PIDR2",
        "address": 3758378984,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU CoreSight peripheral identity register 2",
        "fields": [
            {
                "name": "JEP106ID",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "JEP106 identity code bits [6:4]"
            },
            {
                "name": "JEDEC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "JEDEC assigned value"
            },
            {
                "name": "REVISION",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Component revision number"
            }
        ]
    },
    "3758378988": {
        "name": "DBGMCU_PIDR3",
        "address": 3758378988,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU CoreSight peripheral identity register 3",
        "fields": [
            {
                "name": "CMOD",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Customer modified"
            },
            {
                "name": "REVAND",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Metal fix version"
            }
        ]
    },
    "3758378992": {
        "name": "DBGMCU_CIDR0",
        "address": 3758378992,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU CoreSight component identity register 0",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Component ID bits [7:0]"
            }
        ]
    },
    "3758378996": {
        "name": "DBGMCU_CIDR1",
        "address": 3758378996,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU CoreSight peripheral identity register 1",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Component ID bits [11:8]"
            },
            {
                "name": "CLASS",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Component ID bits [15:12] - component class"
            }
        ]
    },
    "3758379000": {
        "name": "DBGMCU_CIDR2",
        "address": 3758379000,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU CoreSight component identity register 2",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Component ID bits [23:16]"
            }
        ]
    },
    "3758379004": {
        "name": "DBGMCU_CIDR3",
        "address": 3758379004,
        "size": 32,
        "access": "read-only",
        "desc": "DBGMCU CoreSight component identity register 3",
        "fields": [
            {
                "name": "PREAMBLE",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Component ID bits [31:24]"
            }
        ]
    },
    "1174544384": {
        "name": "EXTI_RTSR1",
        "address": 1174544384,
        "size": 32,
        "access": "",
        "desc": "EXTI rising trigger selection register",
        "fields": [
            {
                "name": "RT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            },
            {
                "name": "RT16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, RTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RTx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RTx can only be accessed with privileged access. Unprivileged write to this bit x is discarded, unprivileged read returns 0."
            }
        ]
    },
    "1174544388": {
        "name": "EXTI_FTSR1",
        "address": 1174544388,
        "size": 32,
        "access": "",
        "desc": "EXTI falling trigger selection register",
        "fields": [
            {
                "name": "FT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            },
            {
                "name": "FT16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable event input x\nWhen EXTI_SECCFGR.SECx is disabled, FTx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FTx can only be accessed with secure access. Non-secure write to this FTx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FTx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FTx can only be accessed with privileged access. Unprivileged write to this FTx is discarded, unprivileged read returns 0."
            }
        ]
    },
    "1174544392": {
        "name": "EXTI_SWIER1",
        "address": 1174544392,
        "size": 32,
        "access": "",
        "desc": "EXTI software interrupt event register",
        "fields": [
            {
                "name": "SWI0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            },
            {
                "name": "SWI16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Software interrupt on event x\nWhen EXTI_SECFGR.SECx is disabled, SWIx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, SWIx can only be accessed with secure access. Non-secure write to this SWI x is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SWIx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SWIx can only be accessed with privileged access. Unprivileged write to this SWIx is discarded, unprivileged read returns 0.\nA software interrupt is generated independently from the setting in EXTI_RTSR and EXTI_FTSR. It always returns 0 when read."
            }
        ]
    },
    "1174544396": {
        "name": "EXTI_RPR1",
        "address": 1174544396,
        "size": 32,
        "access": "",
        "desc": "EXTI rising edge pending register",
        "fields": [
            {
                "name": "RPIF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "RPIF16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, RPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, RPIFx can only be accessed with secure access. Non-secure write to this RPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, RPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, RPIFx can only be accessed with privileged access. Unprivileged write to this RPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the rising edge event or an EXTI_SWIER software trigger arrives on the configurable event line. This bit is cleared by writing 1 to it."
            }
        ]
    },
    "1174544400": {
        "name": "EXTI_FPR1",
        "address": 1174544400,
        "size": 32,
        "access": "",
        "desc": "EXTI falling edge pending register",
        "fields": [
            {
                "name": "FPIF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            },
            {
                "name": "FPIF16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "configurable event inputs x falling edge pending bit\nWhen EXTI_SECCFGR.SECx is disabled, FPIFx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, FPIFx can only be accessed with secure access. Non-secure write to this FPIFx is discarded, non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, FPIFx can be accessed with unprivileged and privileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, FPIFx can only be accessed with privileged access. Unprivileged write to this FPIFx is discarded, unprivileged read returns 0.\nThis bit is set when the falling edge event arrives on the configurable event line. This bit is cleared by writing 1 to it."
            }
        ]
    },
    "1174544404": {
        "name": "EXTI_SECCFGR1",
        "address": 1174544404,
        "size": 32,
        "access": "",
        "desc": "EXTI security configuration register",
        "fields": [
            {
                "name": "SEC0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            },
            {
                "name": "SEC16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_PRIVCFGR.PRIVx is disabled, SECx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, SECx can only be written with privileged access. Unprivileged write to this SECx is discarded."
            }
        ]
    },
    "1174544408": {
        "name": "EXTI_PRIVCFGR1",
        "address": 1174544408,
        "size": 32,
        "access": "",
        "desc": "EXTI privilege configuration register",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            },
            {
                "name": "PRIV16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Security enable on event input x\nWhen EXTI_SECCFGR.SECx is disabled, PRIVx can be accessed with secure and non-secure access.\nWhen EXTI_SECCFGR.SECx is enabled, PRIVx can only be written with secure access. Non-secure write to this PRIVx is discarded."
            }
        ]
    },
    "1174544480": {
        "name": "EXTI_EXTICR1",
        "address": 1174544480,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register",
        "fields": [
            {
                "name": "EXTI0",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI0 GPIO port selection\nThese bits are written by software to select the source input for EXTI0 external interrupt.\nWhen EXTI_SECCFGR.SEC0 is disabled, EXTI0 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC0 is enabled, EXTI0 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV0 is disabled, EXTI0 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV0 is enabled, EXTI0 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI1",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI1 GPIO port selection\nThese bits are written by software to select the source input for EXTI1 external interrupt.\nWhen EXTI_SECCFGR.SEC1 is disabled, EXTI1 can be accessed with\nnon-secure and secure access.\nWhen EXTI_SECCFGR.SEC1 is enabled, EXTI1 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV1 is disabled, EXTI1 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV1 is enabled, EXTI1 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI2",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI2 GPIO port selection\nThese bits are written by software to select the source input for EXTI2 external interrupt.\nWhen EXTI_SECCFGR.SEC2 is disabled, EXTI2 can be accessed with\nnon-secure and secure access.\nWhen EXTI_SECCFGR.SEC2 is enabled, EXTI2 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV2 is disabled, EXTI2 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV2 is enabled, EXTI2 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI3",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI3 GPIO port selection\nThese bits are written by software to select the source input for EXTI3 external interrupt.\nWhen EXTI_SECCFGR.SEC3 is disabled, EXTI3 can be accessed with\nnon-secure and secure access.\nWhen EXTI_SECCFGR.SEC3 is enabled, EXTI3 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV3 is disabled, EXTI3 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV3 is enabled, EXTI3 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            }
        ]
    },
    "1174544484": {
        "name": "EXTI_EXTICR2",
        "address": 1174544484,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register",
        "fields": [
            {
                "name": "EXTI4",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI4 GPIO port selection\nThese bits are written by software to select the source input for EXTI4 external interrupt.\nWhen EXTI_SECCFGR.SEC4 is disabled, EXTI4 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC4 is enabled, EXTI4 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV4 is disabled, EXTI4 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV4 is enabled, EXTI4 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI5",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI5 GPIO port selection\nThese bits are written by software to select the source input for EXTI5 external interrupt.\nWhen EXTI_SECCFGR.SEC5 is disabled, EXTI5 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC5 is enabled, EXTI5 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV5 is disabled, EXTI5 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV5 is enabled, EXTI5 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI6",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI6 GPIO port selection\nThese bits are written by software to select the source input for EXTI6 external interrupt.\nWhen EXTI_SECCFGR.SEC6 is disabled, EXTI6 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC6 is enabled, EXTI6 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV6 is disabled, EXTI6 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV6 is enabled, EXTI6 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI7",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI7 GPIO port selection\nThese bits are written by software to select the source input for EXTI7 external interrupt.\nWhen EXTI_SECCFGR.SEC7 is disabled, EXTI7 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC7 is enabled, EXTI7 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV7 is disabled, EXTI7 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV7 is enabled, EXTI7 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            }
        ]
    },
    "1174544488": {
        "name": "EXTI_EXTICR3",
        "address": 1174544488,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register",
        "fields": [
            {
                "name": "EXTI8",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI8 GPIO port selection\nThese bits are written by software to select the source input for EXTI8 external interrupt.\nWhen EXTI_SECCFGR.SEC8 is disabled, EXTI8 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC8 is enabled, EXTI8 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV8 is disabled, EXTI8 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV8 is enabled, EXTI8 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI9",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI9 GPIO port selection\nThese bits are written by software to select the source input for EXTI9 external interrupt.\nWhen EXTI_SECCFGR.SEC9 is disabled, EXTI9 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC9 is enabled, EXTI9 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV9 is disabled, EXTI9 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV9 is enabled, EXTI9 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI10",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI10 GPIO port selection\nThese bits are written by software to select the source input for EXTI10 external interrupt.\nWhen EXTI_SECCFGR.SEC10 is disabled, EXTI10 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC10 is enabled, EXTI10 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV10 is disabled, EXTI10 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV10 is enabled, EXTI10 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI11",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI11 GPIO port selection\nThese bits are written by software to select the source input for EXTI11 external interrupt.\nWhen EXTI_SECCFGR.SEC11 is disabled, EXTI11 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC11 is enabled, EXTI11 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV11 is disabled, EXTI11 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV11 is enabled, EXTI11 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            }
        ]
    },
    "1174544492": {
        "name": "EXTI_EXTICR4",
        "address": 1174544492,
        "size": 32,
        "access": "",
        "desc": "EXTI external interrupt selection register",
        "fields": [
            {
                "name": "EXTI12",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "EXTI0 GPIO port selection\nThese bits are written by software to select the source input for EXTI12 external interrupt.\nWhen EXTI_SECCFGR.SEC12 is disabled, EXTI12 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC12 is enabled, EXTI12 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV12 is disabled, EXTI12 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV12 is enabled, EXTI12 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI13",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "EXTI13 GPIO port selection\nThese bits are written by software to select the source input for EXTI13 external interrupt.\nWhen EXTI_SECCFGR.SEC13 is disabled, EXTI13 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC13 is enabled, EXTI13 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV13 is disabled, EXTI13 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV13 is enabled, EXTI13 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI14",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "EXTI14 GPIO port selection\nThese bits are written by software to select the source input for EXTI14 external interrupt.\nWhen EXTI_SECCFGR.SEC14 is disabled, EXTI14 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC14 is enabled, EXTI14 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV14 is disabled, EXTI14 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV14 is enabled, EXTI14 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            },
            {
                "name": "EXTI15",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "EXTI15 GPIO port selection\nThese bits are written by software to select the source input for EXTI15 external interrupt.\nWhen EXTI_SECCFGR.SEC15 is disabled, EXTI15 can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SEC15 is enabled, EXTI15 can only be accessed with secure access. Non-secure write is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIV15 is disabled, EXTI15 can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIV15 is enabled, EXTI15 can only be accessed with privileged access. Unprivileged write to this bit is discarded.\nOthers: reserved"
            }
        ]
    },
    "1174544496": {
        "name": "EXTI_LOCKR",
        "address": 1174544496,
        "size": 32,
        "access": "",
        "desc": "EXTI lock register",
        "fields": [
            {
                "name": "LOCK",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Global security and privilege configuration registers (EXTI_SECCFGR and EXTI_PRIVCFGR) lock\nThis bit is written once after reset."
            }
        ]
    },
    "1174544512": {
        "name": "EXTI_IMR1",
        "address": 1174544512,
        "size": 32,
        "access": "",
        "desc": "EXTI CPU wakeup with interrupt mask register",
        "fields": [
            {
                "name": "IM0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "IM16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, IMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, IMx can only be accessed with secure access. Non-secure write to this bit is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, IMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, IMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            }
        ]
    },
    "1174544516": {
        "name": "EXTI_EMR1",
        "address": 1174544516,
        "size": 32,
        "access": "",
        "desc": "EXTI CPU wakeup with event mask register",
        "fields": [
            {
                "name": "EM0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            },
            {
                "name": "EM16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CPU wakeup with event generation mask on event input x\nWhen EXTI_SECCFGR.SECx is disabled, EMx can be accessed with non-secure and secure access.\nWhen EXTI_SECCFGR.SECx is enabled, EMx can only be accessed with secure access. Non-secure write to this bit x is discarded and non-secure read returns 0.\nWhen EXTI_PRIVCFGR.PRIVx is disabled, EMx can be accessed with privileged and unprivileged access.\nWhen EXTI_PRIVCFGR.PRIVx is enabled, EMx can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            }
        ]
    },
    "1073881088": {
        "name": "FLASH_ACR",
        "address": 1073881088,
        "size": 32,
        "access": "",
        "desc": "FLASH access control register",
        "fields": [
            {
                "name": "LATENCY",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Latency\nThese bits represent the ratio between the AHB hclk1 clock period and the Flash memory access time.\nAccess to the bit can be secured by RCC SYSCLKSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with FLASH SPRIV or when non-secure with FLASH NSPRIV.\n...\nNote: Before entering Stop 1 mode software must set FLASH wait state latency to at least 1."
            },
            {
                "name": "PRFTEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Prefetch enable\nThis bit enables the prefetch buffer in the embedded Flash memory.\nThis bit can be protected against unprivileged access by FLASH NSPRIV."
            },
            {
                "name": "LPM",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Low-power read mode\nThis bit puts the Flash memory in low-power read mode.\nAccess to the bit can be secured by PWR LPMSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with FLASH SPRIV or when non-secure with FLASH NSPRIV.\nThis bit can't be written when a Flash program or erase operation is busy (BSY = 1) or when the write buffer is not empty (WDW = 1). Changing this bit while a Flash program or erase operation is busy (BSY = 1) is rejected."
            },
            {
                "name": "PDREQ",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Flash power-down mode request\nThis bit requests Flash to enter power-down mode. When Flash enters power-down mode, this bit is cleared by hardware and the PDKEYR is locked.\nThis bit is write-protected with FLASH_PDKEYR.\nAccess to the bit can be secured by PWR LPMSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with FLASH SPRIV or when non-secure with FLASH NSPRIV."
            },
            {
                "name": "SLEEP_PD",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Flash memory power-down mode during Sleep mode\nThis bit determines whether the Flash memory is in power-down mode or Idle mode when the device is in Sleep mode.\nAccess to the bit can be secured by PWR LPMSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with FLASH SPRIV or when non-secure with FLASH NSPRIV.\nThe Flash must not be put in power-down while a program or an erase operation is ongoing."
            }
        ]
    },
    "1073881096": {
        "name": "FLASH_NSKEYR",
        "address": 1073881096,
        "size": 32,
        "access": "",
        "desc": "FLASH key register",
        "fields": [
            {
                "name": "NSKEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Flash memory non-secure key\nThe following values must be written consecutively to unlock the FLASH_NSCR1 register, allowing the Flash memory non-secure programming/erasing operations:\nKEY1: 0x45670123\nKEY2: 0xCDEF89AB"
            }
        ]
    },
    "1073881100": {
        "name": "FLASH_SECKEYR",
        "address": 1073881100,
        "size": 32,
        "access": "",
        "desc": "FLASH secure key register",
        "fields": [
            {
                "name": "SECKEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Flash memory secure key\nThe following values must be written consecutively to unlock the FLASH_SECCR1 register, allowing the Flash memory secure programming/erasing operations:\nKEY1: 0x45670123\nKEY2: 0xCDEF89AB"
            }
        ]
    },
    "1073881104": {
        "name": "FLASH_OPTKEYR",
        "address": 1073881104,
        "size": 32,
        "access": "",
        "desc": "FLASH option key register",
        "fields": [
            {
                "name": "OPTKEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Option byte key\nThe LOCK bit in the FLASH_NSCR1 must be cleared before doing the unlock sequence for OPTLOCK bit. The following values must be written consecutively to unlock the FLASH_NSCR1.OPTSTRT and OBL_LAUNCH register bits concerning user option operations:\nKEY1: 0x08192A3B\nKEY2: 0x4C5D6E7F"
            }
        ]
    },
    "1073881112": {
        "name": "FLASH_PDKEYR",
        "address": 1073881112,
        "size": 32,
        "access": "",
        "desc": "FLASH power-down key register",
        "fields": [
            {
                "name": "PDKEY1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Flash power-down key\nThe following values must be written consecutively to unlock the PDREQ bit in FLASH_ACR:\nPDKEY_1: 0x04152637\nPDKEY_2: 0xFAFBFCFD"
            }
        ]
    },
    "1073881120": {
        "name": "FLASH_NSSR",
        "address": 1073881120,
        "size": 32,
        "access": "",
        "desc": "FLASH status register",
        "fields": [
            {
                "name": "EOP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Non-secure end of operation\nThis bit is set by hardware when one or more Flash memory non-secure operation (program/erase) has been completed successfully. This bit is set only if the non-secure end of operation interrupts are enabled (EOPIE = 1 in FLASH_NSCR1). This bit is cleared by writing1."
            },
            {
                "name": "OPERR",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Non-secure operation error\nThis bit is set by hardware when a Flash memory non-secure operation (program/erase) completes unsuccessfully. This bit is set only if non-secure error interrupts are enabled (NSERRIE = 1). This bit is cleared by writing 1."
            },
            {
                "name": "PROGERR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Non-secure programming error\nThis bit is set by hardware when a non-secure quad-word address to be programmed contains a value different from all 1 before programming, except if the data to write is all 0. This bit is cleared by writing 1."
            },
            {
                "name": "WRPERR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Non-secure write protection error\nThis bit is set by hardware when a non-secure address to be erased/programmed belongs to a write-protected part (by WRP or HDP) of the Flash memory. This bit is cleared by writing 1.\nRefer to Section7.3.10: Flash memory errors flags for full conditions of error flag setting."
            },
            {
                "name": "PGAERR",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Non-secure programming alignment error\nThis bit is set by hardware when the first word to be programmed is not aligned with a quad-word address, or the second, third or forth word does not belong to the same quad-word address. This bit is cleared by writing 1."
            },
            {
                "name": "SIZERR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Non-secure size error\nThis bit is set by hardware when the size of the access is a byte or half-word during a non-secure program sequence. Only quad-word programming is allowed by means of successive word accesses. This bit is cleared by writing 1."
            },
            {
                "name": "PGSERR",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Non-secure programming sequence error\nThis bit is set by hardware when programming sequence is not correct. It is cleared by writing 1.\nRefer to Section7.3.10: Flash memory errors flags for full conditions of error flag setting."
            },
            {
                "name": "OPTWERR",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Option write error\nThis bit is set by hardware when the options bytes are written with an invalid configuration or when modifying options in RDP level 2.. It is cleared by writing 1.\nRefer to Section7.3.10: Flash memory errors flags for full conditions of error flag setting."
            },
            {
                "name": "BSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Non-secure busy\nThis indicates that a Flash memory secure or non-secure operation is in progress. This bit is set at the beginning of a Flash operation and reset when the operation finishes or when an error occurs."
            },
            {
                "name": "WDW",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Non-secure wait data to write\nThis bit indicates that the Flash memory write buffer has been written by a secure or non-secure operation. It is set when the first data is stored in the buffer and cleared when the write is performed in the Flash memory."
            },
            {
                "name": "OEM1LOCK",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "OEM1 key RDP lock\nThis bit indicates that the OEM1 key read during the OBL is not virgin. When set, the OEM1 key RDP lock mechanism is active."
            },
            {
                "name": "OEM2LOCK",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "OEM2 key RDP lock\nThis bit indicates that the OEM2 key read during the OBL is not virgin. When set, the OEM2 key RDP lock mechanism is active."
            },
            {
                "name": "PD",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Flash in power-down mode\nThis bit indicates that the Flash memory is in power-down state. It is reset when Flash is in normal mode or being awaken."
            }
        ]
    },
    "1073881124": {
        "name": "FLASH_SECSR",
        "address": 1073881124,
        "size": 32,
        "access": "",
        "desc": "FLASH secure status register",
        "fields": [
            {
                "name": "EOP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Secure end of operation\nThis bit is set by hardware when one or more Flash memory secure operation (program/erase) has been completed successfully. This bit is set only if the secure end of operation interrupts are enabled (EOPIE = 1 in FLASH_SECCR1). This bit is cleared by writing1."
            },
            {
                "name": "OPERR",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Secure operation error\nThis bit is set by hardware when a Flash memory secure operation (program/erase) completes unsuccessfully. This bit is set only if secure error interrupts are enabled (SECERRIE = 1). This bit is cleared by writing 1."
            },
            {
                "name": "PROGERR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Secure programming error\nThis bit is set by hardware when a secure quad-word address to be programmed contains a value different from all 1 before programming, except if the data to write is all 0. This bit is cleared by writing 1."
            },
            {
                "name": "WRPERR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Secure write protection error\nThis bit is set by hardware when an secure address to be erased/programmed belongs to a write-protected part (by WRP or HDP) of the Flash memory. This bit is cleared by writing 1.\nRefer to Section7.3.10: Flash memory errors flags for full conditions of error flag setting."
            },
            {
                "name": "PGAERR",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Secure programming alignment error\nThis bit is set by hardware when the first word to be programmed is not aligned with a quad-word address, or the second, third or forth word does not belong to the same quad-word address.This bit is cleared by writing 1."
            },
            {
                "name": "SIZERR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Secure size error\nThis bit is set by hardware when the size of the access is a byte or half-word during a secure program sequence. Only quad-word programming is allowed by means of successive word accesses.This bit is cleared by writing 1."
            },
            {
                "name": "PGSERR",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Secure programming sequence error\nThis bit is set by hardware when programming sequence is not correct. It is cleared by writing 1.\nRefer to Section7.3.10: Flash memory errors flags for full conditions of error flag setting."
            },
            {
                "name": "BSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Secure busy\nThis bit indicates that a Flash memory secure or non-secure operation is in progress. This is set on the beginning of a Flash operation and reset when the operation finishes or when an error occurs."
            },
            {
                "name": "WDW",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Secure wait data to write\nThis bit indicates that the Flash memory write buffer has been written by a secure or non-secure operation. It is set when the first data is stored in the buffer and cleared when the write is performed in the Flash memory."
            }
        ]
    },
    "1073881128": {
        "name": "FLASH_NSCR1",
        "address": 1073881128,
        "size": 32,
        "access": "",
        "desc": "FLASH control register",
        "fields": [
            {
                "name": "PG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Non-secure programming"
            },
            {
                "name": "PER",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Non-secure page erase"
            },
            {
                "name": "MER",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Non-secure Flash mass erase\nThis bit triggers the Flash non-secure mass erase (all Flash user pages) when set."
            },
            {
                "name": "PNB",
                "bitOffset": 3,
                "bitWidth": 7,
                "desc": "Non-secure page number selection\nThese bits select the page to erase.\n...\nNote that bit 9 is reserved on STM32WBA5xEx devices."
            },
            {
                "name": "BWR",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Non-secure burst write programming mode\nWhen set, this bit selects the burst write programming mode."
            },
            {
                "name": "STRT",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Non-secure operation start\nThis bit triggers a non-secure erase operation when set. If MER and PER bits are reset and the STRT bit is set, the PGSERR bit in FLASH_NSSR is set (this condition is forbidden).\nThis bit is set only by software and is cleared when the BSY bit is cleared in FLASH_NSSR."
            },
            {
                "name": "OPTSTRT",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Options modification start\nThis bit triggers an option bytes erase and program operation when set. This bit is write-protected with OPTLOCK.. This bit is set only by software, and is cleared when the BSY bit is cleared in FLASH_NSSR."
            },
            {
                "name": "EOPIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Non-secure end of operation interrupt enable\nThis bit enables the interrupt generation when the EOP bit in the FLASH_NSSR is set to 1."
            },
            {
                "name": "ERRIE",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Non-secure error interrupt enable\nThis bit enables the interrupt generation when the OPERR bit in the FLASH_NSSR is set to 1."
            },
            {
                "name": "OBL_LAUNCH",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Force the option byte loading\nWhen set to 1, this bit forces the option byte reloading. This bit is cleared only when the option byte loading is complete. This bit is write-protected with OPTLOCK.\nNote: The LSE oscillator must be disabled, LSEON = 0 and LSERDY = 0, before starting OBL_LAUNCH."
            },
            {
                "name": "OPTLOCK",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Option lock\nThis bit is set only. When set, the FLASH_NSCR1.OPTSRT and OBL_LAUNCH bits concerning user options write access is locked. This bit is cleared by hardware after detecting the unlock sequence in FLASH_OPTKEYR. The FLASH_NSCR1.LOCK bit must be cleared before doing the FLASH_OPTKEYR unlock sequence.\nIn case of an unsuccessful unlock operation, this bit remains set until the next reset."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Non-secure lock\nThis bit is set only.\nWhen set, the FLASH_NSCR1 register write access is locked. This bit is cleared by hardware after detecting the unlock sequence in FLASH_NSKEYR.\nIn case of an unsuccessful unlock operation, this bit remains set until the next system reset."
            }
        ]
    },
    "1073881132": {
        "name": "FLASH_SECCR1",
        "address": 1073881132,
        "size": 32,
        "access": "",
        "desc": "FLASH secure control register",
        "fields": [
            {
                "name": "PG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Secure programming"
            },
            {
                "name": "PER",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Secure page erase"
            },
            {
                "name": "MER",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Secure Flash mass erase\nThis bit triggers the Flash secure mass erase (all Flash user pages) when set."
            },
            {
                "name": "PNB",
                "bitOffset": 3,
                "bitWidth": 7,
                "desc": "Secure page number selection\nThese bits select the page to erase:\n...\nNote that bit 9 is reserved on STM32WBA5xEx devices."
            },
            {
                "name": "BWR",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Secure burst write programming mode\nWhen set, this bit selects the burst write programming mode."
            },
            {
                "name": "STRT",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Secure start\nThis bit triggers a secure erase operation when set. If MER and PER bits are reset and the STRT bit is set, the PGSERR in the FLASH_SECSR is set (this condition is forbidden).\nThis bit is set only by software and is cleared when the BSY bit is cleared in FLASH_SECSR."
            },
            {
                "name": "EOPIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Secure End of operation interrupt enable\nThis bit enables the interrupt generation when the EOP bit in FLASH_SECSR is set to 1."
            },
            {
                "name": "ERRIE",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Secure error interrupt enable\nThis bit enables the interrupt generation when the OPERR bit in FLASH_SECSR is set to 1."
            },
            {
                "name": "INV",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Flash memory security state invert\nThis bit inverts the Flash memory security state."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Secure lock\nThis bit is set only. When set, the FLASH_SECCR1 register is locked. It is cleared by hardware after detecting the unlock sequence in FLASH_SECKEYR register.\nIn case of an unsuccessful unlock operation, this bit remains set until the next system reset."
            }
        ]
    },
    "1073881136": {
        "name": "FLASH_ECCR",
        "address": 1073881136,
        "size": 32,
        "access": "",
        "desc": "FLASH ECC register",
        "fields": [
            {
                "name": "ADDR_ECC",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "ECC fail address\nThis field indicates which address is concerned by the ECC error correction or by the double ECC error detection. The address is given relative to Flash base address, from offset 0x00000 to 0xFFFF0.\nNote that bit 19 is reserved on STM32WBAxEx devices."
            },
            {
                "name": "SYSF_ECC",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "System Flash memory ECC fail\nThis bit indicates that the ECC error correction or double ECC error detection is located in the system Flash memory."
            },
            {
                "name": "ECCIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "ECC correction interrupt enable\nThis bit enables the interrupt generation when the ECCC bit in the FLASH_ECCR register is set."
            },
            {
                "name": "ECCC",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "ECC correction\nThis bit is set by hardware when one ECC error has been detected and corrected (only if ECCC and ECCD were previously cleared). An interrupt is generated if ECCIE is set. This bit is cleared by writing 1."
            },
            {
                "name": "ECCD",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "ECC detection\nThis bit is set by hardware when two ECC errors have been detected (only if ECCC and ECCD were previously cleared). When this bit is set, a NMI is generated. This bit is cleared by writing 1."
            }
        ]
    },
    "1073881140": {
        "name": "FLASH_OPSR",
        "address": 1073881140,
        "size": 32,
        "access": "",
        "desc": "FLASH operation status register",
        "fields": [
            {
                "name": "ADDR_OP",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Interrupted operation address\nThis field indicates which address in the Flash memory was accessed when reset occurred. The address is given relative to the Flash base address, from offset 0x00000 to 0xFFFF0.\nNote that bit 19 is reserved on STM32WBAxEx devices."
            },
            {
                "name": "SYSF_OP",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Operation in system Flash memory interrupted\nThis bit indicates that the reset occurred during an operation in the system Flash memory."
            },
            {
                "name": "CODE_OP",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "Flash memory operation code\nThis field indicates which Flash memory operation has been interrupted by a system reset:"
            }
        ]
    },
    "1073881144": {
        "name": "FLASH_NSCR2",
        "address": 1073881144,
        "size": 32,
        "access": "",
        "desc": "FLASH control 2 register",
        "fields": [
            {
                "name": "PS",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Program suspend request"
            },
            {
                "name": "ES",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Erase suspend request"
            }
        ]
    },
    "1073881148": {
        "name": "FLASH_SECCR2",
        "address": 1073881148,
        "size": 32,
        "access": "",
        "desc": "FLASH secure control 2 register",
        "fields": [
            {
                "name": "PS",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Program suspend request"
            },
            {
                "name": "ES",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Erase suspend request"
            }
        ]
    },
    "1073881152": {
        "name": "FLASH_OPTR",
        "address": 1073881152,
        "size": 32,
        "access": "",
        "desc": "FLASH option register",
        "fields": [
            {
                "name": "RDP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Readout protection level\nOthers: Level 1 (memories readout protection active)\nNote: Refer to Section7.6.2: Readout protection (RDP) for more details."
            },
            {
                "name": "BOR_LEV",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "BOR reset level\nThese bits contain the VsubDD/sub supply level threshold that activates/releases the reset."
            },
            {
                "name": "NRST_STOP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Reset generation in Stop mode"
            },
            {
                "name": "NRST_STDBY",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Reset generation in Standby mode"
            },
            {
                "name": "SRAM1_RST",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SRAM1 erase upon system reset"
            },
            {
                "name": "IWDG_SW",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Independent watchdog enable selection"
            },
            {
                "name": "IWDG_STOP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Independent watchdog counter freeze in Stop mode"
            },
            {
                "name": "IWDG_STDBY",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Independent watchdog counter freeze in Standby mode"
            },
            {
                "name": "WWDG_SW",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Window watchdog selection"
            },
            {
                "name": "SRAM2_PE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "SRAM2 parity check enable"
            },
            {
                "name": "SRAM2_RST",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "SRAM2 erase when system reset"
            },
            {
                "name": "NSWBOOT0",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Software BOOT0"
            },
            {
                "name": "NBOOT0",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "NBOOT0 option bit"
            },
            {
                "name": "TZEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Global TrustZone security enable"
            }
        ]
    },
    "1073881156": {
        "name": "FLASH_NSBOOTADD0R",
        "address": 1073881156,
        "size": 32,
        "access": "",
        "desc": "FLASH boot address 0 register",
        "fields": [
            {
                "name": "NSBOOTADD0",
                "bitOffset": 7,
                "bitWidth": 25,
                "desc": "Non-secure boot base address 0\nThis address is only used when TZEN = 0.\nThe non-secure boot memory address can be programmed to any address in the valid address range (see Table 28: Boot space versus RDP protection) with a granularity of 128 bytes. These bits correspond to address [31:7]. The NSBOOTADD0 option bytes are selected following the BOOT0 pin or NSWBOOT0 state.\nExamples:\nNSBOOTADD0[24:0] = 0x0100000: Boot from Flash memory (0x0800 0000)\nNSBOOTADD0[24:0] = 0x017F100: Boot from system memory bootloader (0x0BF8 8000)\nNSBOOTADD0[24:0] = 0x0400200: Boot from SRAM2 on S-Bus (0x2001 0000)"
            }
        ]
    },
    "1073881160": {
        "name": "FLASH_NSBOOTADD1R",
        "address": 1073881160,
        "size": 32,
        "access": "",
        "desc": "FLASH boot address 1 register",
        "fields": [
            {
                "name": "NSBOOTADD1",
                "bitOffset": 7,
                "bitWidth": 25,
                "desc": "Non-secure boot address 1\nThis address is only used when TZEN = 0.\nThe non-secure boot memory address can be programmed to any address in the valid address range (see Table 28: Boot space versus RDP protection) with a granularity of 128 bytes. These bits correspond to address [31:7]. The NSBOOTADD0 option bytes are selected following the BOOT0 pin or NSWBOOT0 state.\nExamples:\nNSBOOTADD1[24:0] = 0x0100000: Boot from Flash memory (0x0800 0000)\nNSBOOTADD1[24:0] = 0x017F100: Boot from system memory bootloader (0x0BF8 8000)\nNSBOOTADD1[24:0] = 0x0400200: Boot from SRAM2 (0x2001 0000)"
            }
        ]
    },
    "1073881164": {
        "name": "FLASH_SECBOOTADD0R",
        "address": 1073881164,
        "size": 32,
        "access": "",
        "desc": "FLASH secure boot address 0 register",
        "fields": [
            {
                "name": "BOOT_LOCK",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Boot lock\nThis lock is only used when TZEN = 0.\nWhen set, the boot is always forced to base address value programmed in SECBOOTADD0[24:0] option bytes whatever the boot selection option. When set, this bit can only be cleared by an RDP regression level 1 to level 0."
            },
            {
                "name": "SECBOOTADD0",
                "bitOffset": 7,
                "bitWidth": 25,
                "desc": "Secure boot base address 0\nThis address is only used when TZEN = 1.\nThe secure boot memory address can be programmed to any address in the valid address range (see Table28: Boot space versus RDP protection) with a granularity of 128 bytes. This bits correspond to address [31:7] The SECBOOTADD0 option bytes are selected following the BOOT0 pin or NSWBOOT0 state.\nExamples:\nSECBOOTADD0[24:0] = 0x018 0000: Boot from secure user Flash memory (0x0C00 0000)\nSECBOOTADD0[24:0] = 0x01F F000: Boot from RSS system Flash memory (0x0FF8 0000)\nSECBOOTADD0[24:0] = 0x060 0000: Boot from secure SRAM1 on S-Bus (0x3000 0000)"
            }
        ]
    },
    "1073881168": {
        "name": "FLASH_SECWMR1",
        "address": 1073881168,
        "size": 32,
        "access": "",
        "desc": "FLASH secure watermark register 1",
        "fields": [
            {
                "name": "SECWM_PSTRT",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Start page of secure area\nThis field contains the first page of the secure area."
            },
            {
                "name": "SECWM_PEND",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "End page of secure area\nThis field contains the last page of the secure area."
            }
        ]
    },
    "1073881172": {
        "name": "FLASH_SECWMR2",
        "address": 1073881172,
        "size": 32,
        "access": "",
        "desc": "FLASH secure watermark register 2",
        "fields": [
            {
                "name": "HDP_PEND",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "End page of secure hide protection area\nThis field contains the last page of the secure HDP area."
            },
            {
                "name": "HDPEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Secure Hide protection area enable"
            }
        ]
    },
    "1073881176": {
        "name": "FLASH_WRPAR",
        "address": 1073881176,
        "size": 32,
        "access": "",
        "desc": "FLASH WRP area A address register",
        "fields": [
            {
                "name": "WRPA_PSTRT",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "WPR area A start page\nThis field contains the first page of the WPR area A.\nNote that bit 6 is reserved on STM32WBAxEx devices."
            },
            {
                "name": "WRPA_PEND",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "WPR area A end page\nThis field contains the last page of the WPR area A.\nNote that bit 22 is reserved on STM32WBAxEx devices."
            },
            {
                "name": "UNLOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "WPR area A unlock"
            }
        ]
    },
    "1073881180": {
        "name": "FLASH_WRPBR",
        "address": 1073881180,
        "size": 32,
        "access": "",
        "desc": "FLASH WRP area B address register",
        "fields": [
            {
                "name": "WRPB_PSTRT",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "WRP area B start page\nThis field contains the first page of the WRP area B.\nNote that bit 6 is reserved on STM32WBAxEx devices."
            },
            {
                "name": "WRPB_PEND",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "WRP area B end page\nThis field contains the last page of the WRP area B.\nNote that bit 22 is reserved on STM32WBAxEx devices."
            },
            {
                "name": "UNLOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "WPR area B unlock"
            }
        ]
    },
    "1073881200": {
        "name": "FLASH_OEM1KEYR1",
        "address": 1073881200,
        "size": 32,
        "access": "",
        "desc": "FLASH OEM1 key register 1",
        "fields": [
            {
                "name": "OEM1KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "OEM1 key least significant bytes"
            }
        ]
    },
    "1073881204": {
        "name": "FLASH_OEM1KEYR2",
        "address": 1073881204,
        "size": 32,
        "access": "",
        "desc": "FLASH OEM1 key register 2",
        "fields": [
            {
                "name": "OEM1KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "OEM1 key most significant bytes"
            }
        ]
    },
    "1073881208": {
        "name": "FLASH_OEM2KEYR1",
        "address": 1073881208,
        "size": 32,
        "access": "",
        "desc": "FLASH OEM2 key register 1",
        "fields": [
            {
                "name": "OEM2KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "OEM2 key least significant bytes"
            }
        ]
    },
    "1073881212": {
        "name": "FLASH_OEM2KEYR2",
        "address": 1073881212,
        "size": 32,
        "access": "",
        "desc": "FLASH OEM2 key register 2",
        "fields": [
            {
                "name": "OEM2KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "OEM2 key most significant bytes"
            }
        ]
    },
    "1073881216": {
        "name": "FLASH_SECBBR1",
        "address": 1073881216,
        "size": 32,
        "access": "",
        "desc": "FLASH secure block based register 1",
        "fields": [
            {
                "name": "SECBB0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            }
        ]
    },
    "1073881220": {
        "name": "FLASH_SECBBR2",
        "address": 1073881220,
        "size": 32,
        "access": "",
        "desc": "FLASH secure block based register 2",
        "fields": [
            {
                "name": "SECBB0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            },
            {
                "name": "SECBB31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "page secure/non-secure attribution\nEach bit is used to set one page security attribution."
            }
        ]
    },
    "1073881280": {
        "name": "FLASH_SECHDPCR",
        "address": 1073881280,
        "size": 32,
        "access": "",
        "desc": "FLASH secure HDP control register",
        "fields": [
            {
                "name": "HDP_ACCDIS",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Secure HDP area access disable\nWhen set, this bit is only cleared by a system reset."
            }
        ]
    },
    "1073881284": {
        "name": "FLASH_PRIFCFGR",
        "address": 1073881284,
        "size": 32,
        "access": "",
        "desc": "FLASH privilege configuration register",
        "fields": [
            {
                "name": "SPRIV",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Privileged protection for secure registers\nThis bit is secure write protected. It can only be written by a secure privileged access when TrustZone is enabled (TZEN=1)."
            },
            {
                "name": "NSPRIV",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Privileged protection for non-secure registers"
            }
        ]
    },
    "1073881296": {
        "name": "FLASH_PRIVBBR1",
        "address": 1073881296,
        "size": 32,
        "access": "",
        "desc": "FLASH privilege block based register 1",
        "fields": [
            {
                "name": "PRIVBB0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            }
        ]
    },
    "1073881300": {
        "name": "FLASH_PRIVBBR2",
        "address": 1073881300,
        "size": 32,
        "access": "",
        "desc": "FLASH privilege block based register 2",
        "fields": [
            {
                "name": "PRIVBB0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            }
        ]
    },
    "1073881304": {
        "name": "FLASH_PRIVBBR3",
        "address": 1073881304,
        "size": 32,
        "access": "",
        "desc": "FLASH privilege block based register 3",
        "fields": [
            {
                "name": "PRIVBB0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            }
        ]
    },
    "1073881308": {
        "name": "FLASH_PRIVBBR4",
        "address": 1073881308,
        "size": 32,
        "access": "",
        "desc": "FLASH privilege block based register 4",
        "fields": [
            {
                "name": "PRIVBB0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            },
            {
                "name": "PRIVBB31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "page privileged/unprivileged attribution\nEach bit is used to set one page privilege attribution in Flash."
            }
        ]
    },
    "1073872896": {
        "name": "GPDMA_SECCFGR",
        "address": 1073872896,
        "size": 32,
        "access": "",
        "desc": "GPDMA secure configuration register",
        "fields": [
            {
                "name": "SEC0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "secure state of channel x"
            },
            {
                "name": "SEC1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "secure state of channel x"
            },
            {
                "name": "SEC2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "secure state of channel x"
            },
            {
                "name": "SEC3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "secure state of channel x"
            },
            {
                "name": "SEC4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "secure state of channel x"
            },
            {
                "name": "SEC5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "secure state of channel x"
            },
            {
                "name": "SEC6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "secure state of channel x"
            },
            {
                "name": "SEC7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "secure state of channel x"
            }
        ]
    },
    "1073872900": {
        "name": "GPDMA_PRIVCFGR",
        "address": 1073872900,
        "size": 32,
        "access": "",
        "desc": "GPDMA privileged configuration register",
        "fields": [
            {
                "name": "PRIV0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            },
            {
                "name": "PRIV7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "privileged state of channel x"
            }
        ]
    },
    "1073872904": {
        "name": "GPDMA_RCFGLOCKR",
        "address": 1073872904,
        "size": 32,
        "access": "",
        "desc": "GPDMA configuration lock register",
        "fields": [
            {
                "name": "LOCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset\nThis bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset."
            },
            {
                "name": "LOCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset\nThis bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset."
            },
            {
                "name": "LOCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset\nThis bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset."
            },
            {
                "name": "LOCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset\nThis bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset."
            },
            {
                "name": "LOCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset\nThis bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset."
            },
            {
                "name": "LOCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset\nThis bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset."
            },
            {
                "name": "LOCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset\nThis bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset."
            },
            {
                "name": "LOCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "lock the configuration of GPDMA_SECCFGR.SECx and GPDMA_PRIVCFGR.PRIVx, until a global GPDMA reset\nThis bit is cleared after reset and, once set, it cannot be reset until a global GPDMA reset."
            }
        ]
    },
    "1073872908": {
        "name": "GPDMA_MISR",
        "address": 1073872908,
        "size": 32,
        "access": "",
        "desc": "GPDMA non-secure masked interrupt status register",
        "fields": [
            {
                "name": "MIS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            },
            {
                "name": "MIS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "masked interrupt status of channel x"
            }
        ]
    },
    "1073872912": {
        "name": "GPDMA_SMISR",
        "address": 1073872912,
        "size": 32,
        "access": "",
        "desc": "GPDMA secure masked interrupt status register",
        "fields": [
            {
                "name": "MIS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "masked interrupt status of the secure channel x"
            },
            {
                "name": "MIS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "masked interrupt status of the secure channel x"
            },
            {
                "name": "MIS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "masked interrupt status of the secure channel x"
            },
            {
                "name": "MIS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "masked interrupt status of the secure channel x"
            },
            {
                "name": "MIS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "masked interrupt status of the secure channel x"
            },
            {
                "name": "MIS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "masked interrupt status of the secure channel x"
            },
            {
                "name": "MIS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "masked interrupt status of the secure channel x"
            },
            {
                "name": "MIS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "masked interrupt status of the secure channel x"
            }
        ]
    },
    "1073872976": {
        "name": "GPDMA_C0LBAR",
        "address": 1073872976,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073872988": {
        "name": "GPDMA_C0FCR",
        "address": 1073872988,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073872992": {
        "name": "GPDMA_C0SR",
        "address": 1073872992,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073872996": {
        "name": "GPDMA_C0CR",
        "address": 1073872996,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873040": {
        "name": "GPDMA_C0TR1",
        "address": 1073873040,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\nNote: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination"
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "SSEC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer from the source\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DSEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer to the destination\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure."
            }
        ]
    },
    "1073873044": {
        "name": "GPDMA_C0TR2",
        "address": 1073873044,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.\nThe user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:"
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub."
            }
        ]
    },
    "1073873048": {
        "name": "GPDMA_C0BR1",
        "address": 1073873048,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873052": {
        "name": "GPDMA_C0SAR",
        "address": 1073873052,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873056": {
        "name": "GPDMA_C0DAR",
        "address": 1073873056,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873100": {
        "name": "GPDMA_C0LLR",
        "address": 1073873100,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 0 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873104": {
        "name": "GPDMA_C1LBAR",
        "address": 1073873104,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873116": {
        "name": "GPDMA_C1FCR",
        "address": 1073873116,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873120": {
        "name": "GPDMA_C1SR",
        "address": 1073873120,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873124": {
        "name": "GPDMA_C1CR",
        "address": 1073873124,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873168": {
        "name": "GPDMA_C1TR1",
        "address": 1073873168,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\nNote: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination"
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "SSEC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer from the source\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DSEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer to the destination\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure."
            }
        ]
    },
    "1073873172": {
        "name": "GPDMA_C1TR2",
        "address": 1073873172,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.\nThe user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:"
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger.\nIf the channel x is enabled (GPDMA_CxCR.EN asserted) with TRIGPOL[1:0] = 00 or 11, these TRIGM[1:0] bits are ignored."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub."
            }
        ]
    },
    "1073873176": {
        "name": "GPDMA_C1BR1",
        "address": 1073873176,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873180": {
        "name": "GPDMA_C1SAR",
        "address": 1073873180,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873184": {
        "name": "GPDMA_C1DAR",
        "address": 1073873184,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873228": {
        "name": "GPDMA_C1LLR",
        "address": 1073873228,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 1 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873232": {
        "name": "GPDMA_C2LBAR",
        "address": 1073873232,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873244": {
        "name": "GPDMA_C2FCR",
        "address": 1073873244,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873248": {
        "name": "GPDMA_C2SR",
        "address": 1073873248,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873252": {
        "name": "GPDMA_C2CR",
        "address": 1073873252,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873296": {
        "name": "GPDMA_C2TR1",
        "address": 1073873296,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\nNote: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination"
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "SSEC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer from the source\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DSEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer to the destination\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure."
            }
        ]
    },
    "1073873300": {
        "name": "GPDMA_C2TR2",
        "address": 1073873300,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.\nThe user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:"
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub."
            }
        ]
    },
    "1073873304": {
        "name": "GPDMA_C2BR1",
        "address": 1073873304,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873308": {
        "name": "GPDMA_C2SAR",
        "address": 1073873308,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873312": {
        "name": "GPDMA_C2DAR",
        "address": 1073873312,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873356": {
        "name": "GPDMA_C2LLR",
        "address": 1073873356,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 2 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873360": {
        "name": "GPDMA_C3LBAR",
        "address": 1073873360,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873372": {
        "name": "GPDMA_C3FCR",
        "address": 1073873372,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873376": {
        "name": "GPDMA_C3SR",
        "address": 1073873376,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873380": {
        "name": "GPDMA_C3CR",
        "address": 1073873380,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873424": {
        "name": "GPDMA_C3TR1",
        "address": 1073873424,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\nNote: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination"
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "SSEC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer from the source\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DSEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer to the destination\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure."
            }
        ]
    },
    "1073873428": {
        "name": "GPDMA_C3TR2",
        "address": 1073873428,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.\nThe user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:"
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub."
            }
        ]
    },
    "1073873432": {
        "name": "GPDMA_C3BR1",
        "address": 1073873432,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873436": {
        "name": "GPDMA_C3SAR",
        "address": 1073873436,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873440": {
        "name": "GPDMA_C3DAR",
        "address": 1073873440,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873484": {
        "name": "GPDMA_C3LLR",
        "address": 1073873484,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 3 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873488": {
        "name": "GPDMA_C4LBAR",
        "address": 1073873488,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873500": {
        "name": "GPDMA_C4FCR",
        "address": 1073873500,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873504": {
        "name": "GPDMA_C4SR",
        "address": 1073873504,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873508": {
        "name": "GPDMA_C4CR",
        "address": 1073873508,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873552": {
        "name": "GPDMA_C4TR1",
        "address": 1073873552,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\nNote: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination"
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "SSEC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer from the source\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DSEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer to the destination\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure."
            }
        ]
    },
    "1073873556": {
        "name": "GPDMA_C4TR2",
        "address": 1073873556,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.\nThe user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:"
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub."
            }
        ]
    },
    "1073873560": {
        "name": "GPDMA_C4BR1",
        "address": 1073873560,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873564": {
        "name": "GPDMA_C4SAR",
        "address": 1073873564,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873568": {
        "name": "GPDMA_C4DAR",
        "address": 1073873568,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873612": {
        "name": "GPDMA_C4LLR",
        "address": 1073873612,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 4 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873616": {
        "name": "GPDMA_C5LBAR",
        "address": 1073873616,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873628": {
        "name": "GPDMA_C5FCR",
        "address": 1073873628,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873632": {
        "name": "GPDMA_C5SR",
        "address": 1073873632,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873636": {
        "name": "GPDMA_C5CR",
        "address": 1073873636,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873680": {
        "name": "GPDMA_C5TR1",
        "address": 1073873680,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\nNote: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination"
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "SSEC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer from the source\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DSEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer to the destination\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure."
            }
        ]
    },
    "1073873684": {
        "name": "GPDMA_C5TR2",
        "address": 1073873684,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.\nThe user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:"
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub."
            }
        ]
    },
    "1073873688": {
        "name": "GPDMA_C5BR1",
        "address": 1073873688,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873692": {
        "name": "GPDMA_C5SAR",
        "address": 1073873692,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873696": {
        "name": "GPDMA_C5DAR",
        "address": 1073873696,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873740": {
        "name": "GPDMA_C5LLR",
        "address": 1073873740,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 5 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873744": {
        "name": "GPDMA_C6LBAR",
        "address": 1073873744,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873756": {
        "name": "GPDMA_C6FCR",
        "address": 1073873756,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873760": {
        "name": "GPDMA_C6SR",
        "address": 1073873760,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873764": {
        "name": "GPDMA_C6CR",
        "address": 1073873764,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873808": {
        "name": "GPDMA_C6TR1",
        "address": 1073873808,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\nNote: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination"
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "SSEC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer from the source\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DSEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer to the destination\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure."
            }
        ]
    },
    "1073873812": {
        "name": "GPDMA_C6TR2",
        "address": 1073873812,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.\nThe user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:"
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub."
            }
        ]
    },
    "1073873816": {
        "name": "GPDMA_C6BR1",
        "address": 1073873816,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873820": {
        "name": "GPDMA_C6SAR",
        "address": 1073873820,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873824": {
        "name": "GPDMA_C6DAR",
        "address": 1073873824,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873868": {
        "name": "GPDMA_C6LLR",
        "address": 1073873868,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 6 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1073873872": {
        "name": "GPDMA_C7LBAR",
        "address": 1073873872,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 linked-list base address register",
        "fields": [
            {
                "name": "LBA",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "linked-list base address of GPDMA channel x"
            }
        ]
    },
    "1073873884": {
        "name": "GPDMA_C7FCR",
        "address": 1073873884,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 flag clear register",
        "fields": [
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag clear"
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag clear"
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag clear"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag clear"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag clear"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag clear"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag clear"
            }
        ]
    },
    "1073873888": {
        "name": "GPDMA_C7SR",
        "address": 1073873888,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 status register",
        "fields": [
            {
                "name": "IDLEF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "idle flag\nThis idle flag is deasserted by hardware when the channel is enabled (GPDMA_CxCR.EN = 1) with a valid channel configuration (no USEF to be immediately reported).\nThis idle flag is asserted after hard reset or by hardware when the channel is back in idle state (in suspended or disabled state)."
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete flag\nA transfer complete event is either a block transfer complete, or a LLI transfer complete including the upload of the next LLI if any, or the full linked-list completion, depending on the transfer complete event mode (GPDMA_CxTR2.TCEM[1:0])."
            },
            {
                "name": "HTF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer flag\nA half block transfer occurs when half of the bytes of the source block size (rounded up integer of GPDMA_CxBR1.BNDT[15:0]/2) has been transferred to the destination."
            },
            {
                "name": "DTEF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error flag"
            },
            {
                "name": "ULEF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error flag"
            },
            {
                "name": "USEF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error flag"
            },
            {
                "name": "SUSPF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension flag"
            },
            {
                "name": "TOF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun flag"
            },
            {
                "name": "FIFOL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "monitored FIFO level\nNumber of available write beats in the FIFO, in units of the programmed destination data width (see GPDMA_CxTR1.DDW_LOG2[1:0], in units of bytes, half-words, or words).\nNote: After having suspended an active transfer, the user may need to read FIFOL[7:0], additionally to GPDMA_CxBR1.BDNT[15:0] to know how many data have been transferred to the destination. Before reading, the user may wait for the transfer to be suspended (GPDMA_CxSR.SUSPF = 1)."
            }
        ]
    },
    "1073873892": {
        "name": "GPDMA_C7CR",
        "address": 1073873892,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 0. Else:\nthis bit is deasserted by hardware when there is a transfer error (master bus error or user setting error) or when there is a channel transfer complete (channel ready to be configured, for example if LSM=1 at the end of a single execution of the LLI).\nElse, this bit can be asserted by software.\nWriting 0 into this EN bit is ignored."
            },
            {
                "name": "RESET",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "reset\nThis bit is write only. Writing 0 has no impact. Writing 1 implies the reset of the following: the FIFO, the channel internal state, SUSP and EN bits (whatever is written receptively in bit 2 and bit 0).\nThe reset is effective when the channel is in steady state, meaning one of the following:\n- active channel in suspended state (GPDMA_CxSR.SUSPF = 1 and GPDMA_CxSR.IDLEF = GPDMA_CxCR.EN = 1)\n- channel in disabled state (GPDMA_CxSR.IDLEF = 1 and GPDMA_CxCR.EN = 0).\nAfter writing a RESET, to continue using this channel, the user must explicitly reconfigure the channel including the hardware-modified configuration registers (GPDMA_CxBR1, GPDMA_CxSAR and GPDMA_CxDAR) before enabling again the channel (see the programming sequence in Figure 44)."
            },
            {
                "name": "SUSP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "suspend\nWriting 1 into the field RESET (bit 1) causes the hardware to de-assert this bit, whatever is written into this bit 2. Else:\nSoftware must write 1 in order to suspend an active channel (channel with an ongoing GPDMA transfer over its master ports).\nThe software must write 0 in order to resume a suspended channel, following the programming sequence detailed in Figure 43."
            },
            {
                "name": "TCIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable"
            },
            {
                "name": "HTIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "half transfer complete interrupt enable"
            },
            {
                "name": "DTEIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "data transfer error interrupt enable"
            },
            {
                "name": "ULEIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "update link transfer error interrupt enable"
            },
            {
                "name": "USEIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "user setting error interrupt enable"
            },
            {
                "name": "SUSPIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "completed suspension interrupt enable"
            },
            {
                "name": "TOIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "trigger overrun interrupt enable"
            },
            {
                "name": "LSM",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Link step mode\nFirst the (possible 1D/repeated) block transfer is executed as defined by the current internal register file until GPDMA_CxBR1.BNDT[15:0] = 0. Secondly the next linked-list data structure is conditionally uploaded from memory as defined by GPDMA_CxLLR. Then channel execution is completed.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "LAP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "linked-list allocated port\nThis bit is used to allocate the master port for the update of the GPDMA linked-list registers from the memory.\nNote: This bit must be written when EN=0. This bit is read-only when EN=1."
            },
            {
                "name": "PRIO",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "priority level of the channel x GPDMA transfer versus others\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            }
        ]
    },
    "1073873936": {
        "name": "GPDMA_C7TR1",
        "address": 1073873936,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 transfer register 1",
        "fields": [
            {
                "name": "SDW_LOG2",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "binary logarithm of the source data width of a burst in bytes\nSetting a 8-byte data width causes a user setting error to be reported and no transfer is issued.\nA source block size must be a multiple of the source data width (GPDMA_CxBR1.BNDT[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and no transfer is issued.\nNote: A source burst transfer must have an aligned address with its data width (start address GPDMA_CxSAR[2:0] versus SDW_LOG2[1:0]). Otherwise, a user setting error is reported and none transfer is issued."
            },
            {
                "name": "SINC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "source incrementing burst\nThe source address, pointed by GPDMA_CxSAR, is kept constant after a burst beat/single transfer or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "SBL_1",
                "bitOffset": 4,
                "bitWidth": 6,
                "desc": "source burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If SBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width SDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "PAM",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "padding/alignment mode\nIf DDW_LOG2[1:0] = SDW_LOG2[1:0]: if the data width of a burst destination transfer is equal to the data width of a burst source transfer, these bits are ignored.\nElse, in the following enumerated values, the condition PAM_1 is when destination data width is higher that source data width, and the condition PAM_2 is when destination data width is higher than source data width.\n1x: successive source data are FIFO queued and packed at the destination data width, in a left (LSB) to right (MSB) order (named little endian), before a destination transfer\nNote: 1x: source data is FIFO queued and unpacked at the destination data width, to be transferred in a left (LSB) to right (MSB) order (named little endian) to the destination"
            },
            {
                "name": "SBX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "source byte exchange within the unaligned half-word of each source word\nIf the source data width is shorter than a word, this bit is ignored.\nIf the source data width is a word:"
            },
            {
                "name": "SAP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "source allocated port\nThis bit is used to allocate the master port for the source transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "SSEC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer from the source\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx =1 . A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this SSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer from the source is non-secure."
            },
            {
                "name": "DDW_LOG2",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "binary logarithm of the destination data width of a burst, in bytes\nSetting a 8-byte data width causes a user setting error to be reported and none transfer is issued.\nNote: A destination burst transfer must have an aligned address with its data width (start address GPDMA_CxDAR[2:0] versus DDW_LOG2[1:0]). Otherwise a user setting error is reported and no transfer is issued."
            },
            {
                "name": "DINC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "destination incrementing burst\nThe destination address, pointed by GPDMA_CxDAR, is kept constant after a burst beat/single transfer, or is incremented by the offset value corresponding to a contiguous data after a burst beat/single transfer."
            },
            {
                "name": "DBL_1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "destination burst length minus 1, between 0 and 63\nThe burst length unit is one data named beat within a burst. If DBL_1[5:0] =0 , the burst can be named as single. Each data/beat has a width defined by the destination data width DDW_LOG2[1:0].\nNote: If a burst transfer crossed a 1-Kbyte address boundary on a AHB transfer, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the AHB protocol.\nNote: If a burst transfer is of length greater than the FIFO size of the channel x, the GPDMA modifies and shortens the programmed burst into singles or bursts of lower length, to be compliant with the FIFO size. Transfer performance is lower, with GPDMA re-arbitration between effective and lower singles/bursts, but the data integrity is guaranteed."
            },
            {
                "name": "DBX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "destination byte exchange\nIf the destination data size is a byte, this bit is ignored.\nIf the destination data size is not a byte:"
            },
            {
                "name": "DHX",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "destination half-word exchange\nIf the destination data size is shorter than a word, this bit is ignored.\nIf the destination data size is a word:"
            },
            {
                "name": "DAP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "destination allocated port\nThis bit is used to allocate the master port for the destination transfer\nNote: This bit must be written when EN = 0. This bit is read-only when EN = 1."
            },
            {
                "name": "DSEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "security attribute of the GPDMA transfer to the destination\nIf GPDMA_SECCFGR.SECx = 1 and the access is secure:\nThis is a secure register bit. This bit can only be read by a secure software. This bit must be written by a secure software when GPDMA_SECCFGR.SECx = 1. A secure write is ignored when GPDMA_SECCFGR.SECx = 0.\nWhen GPDMA_SECCFGR.SECx is deasserted, this DSEC bit is also deasserted by hardware (on a secure reconfiguration of the channel as non-secure), and the GPDMA transfer to the destination is non-secure."
            }
        ]
    },
    "1073873940": {
        "name": "GPDMA_C7TR2",
        "address": 1073873940,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 transfer register 2",
        "fields": [
            {
                "name": "REQSEL",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "GPDMA hardware request selection\nThese bits are ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else, the selected hardware request is internally taken into account as per Section 16.3.3.\nThe user must not assign a same input hardware request (same REQSEL[5:0] value) to different active GPDMA channels (GPDMA_CxCR.EN = 1 and GPDMA_CxTR2.SWREQ = 0 for these channels). GPDMA is not intended to hardware support the case of simultaneous enabled channels incorrectly configured with a same hardware peripheral request signal, and there is no user setting error reporting."
            },
            {
                "name": "SWREQ",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "software request\nThis bit is internally taken into account when GPDMA_CxCR.EN is asserted."
            },
            {
                "name": "DREQ",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "destination hardware request\nThis bit is ignored if channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer). Else:"
            },
            {
                "name": "BREQ",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Block hardware request\nIf the channel x is activated (GPDMA_CxCR.EN asserted) with SWREQ = 1 (software request for a memory-to-memory transfer), this bit is ignored. Else:"
            },
            {
                "name": "TRIGM",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "trigger mode\nThese bits define the transfer granularity for its conditioning by the trigger."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "trigger event input selection\nThese bits select the trigger event input of the GPDMA transfer (as per Section 16.3.5), with an active trigger event if TRIGPOL[1:0] different 00."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "trigger event polarity\nThese bits define the polarity of the selected trigger event input defined by TRIGSEL[4:0]."
            },
            {
                "name": "TCEM",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "transfer complete event mode\nThese bits define the transfer granularity for the transfer complete and half transfer complete events generation.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] = 0), then neither the complete transfer event nor the half transfer event is generated.\nNote: If the initial LLIsub0 /subdata transfer is null/void (i.e. directly programmed by the internal register file with GPDMA_CxBR1.BNDT[15:0] =0 ), then the half transfer event is not generated, and the transfer complete event is generated when is completed the loading of the LLIsub1/sub."
            }
        ]
    },
    "1073873944": {
        "name": "GPDMA_C7BR1",
        "address": 1073873944,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 block register 1",
        "fields": [
            {
                "name": "BNDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "block number of data bytes to transfer from the source\nBlock size transferred from the source. When the channel is enabled, this field becomes read-only and is decremented, indicating the remaining number of data items in the current source block to be transferred. BNDT[15:0] is programmed in number of bytes, maximum source block size is 64 Kbytes -1.\nOnce the last data transfer is completed (BNDT[15:0] = 0):\n- if GPDMA_CxLLR.UB1 = 1, this field is updated by the LLI in the memory.\n- if GPDMA_CxLLR.UB1 = 0 and if there is at least one non null Uxx update bit, this field is internally restored to the programmed value.\n- if all GPDMA_CxLLR.Uxx = 0 and if GPDMA_CxLLR.LA[15:0] = 0, this field is internally restored to the programmed value (infinite/continuous last LLI).\n- if GPDMA_CxLLR = 0, this field is kept as zero following the last LLI data transfer.\nNote: A non-null source block size must be a multiple of the source data width (BNDT[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued.\nNote: When configured in packing mode (GPDMA_CxTR1.PAM[1] = 1 and destination data width different from source data width), a non-null source block size must be a multiple of the destination data width (BNDT[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873948": {
        "name": "GPDMA_C7SAR",
        "address": 1073873948,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 source address register",
        "fields": [
            {
                "name": "SA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "source address\nThis field is the pointer to the address from which the next data is read.\nDuring the channel activity, depending on the source addressing mode (GPDMA_CxTR1.SINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.SDW_LOG2[1:0]) after each burst source data, reflecting the next address from which data is read.\nDuring the channel activity, this address is updated after each completed source burst, consequently to:\nthe programmed source burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.SINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.SBL_1[5:0] and GPDMA_CxTR1.SDW_LOG2[21:0]\nthe additional source incremented/decremented offset value as programmed by GPDMA_CxBR1.SDEC\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.USA = 1.\nNote: A source address must be aligned with the programmed data width of a source burst (SA[2:0] versus GPDMA_CxTR1.SDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873952": {
        "name": "GPDMA_C7DAR",
        "address": 1073873952,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 destination address register",
        "fields": [
            {
                "name": "DA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "destination address\nThis field is the pointer to the address from which the next data is written.\nDuring the channel activity, depending on the destination addressing mode (GPDMA_CxTR1.DINC), this field is kept fixed or incremented by the data width (GPDMA_CxTR1.DDW_LOG2[21:0]) after each burst destination data, reflecting the next address from which data is written.\nDuring the channel activity, this address is updated after each completed destination burst, consequently to:\nthe programmed destination burst; either in fixed addressing mode or in contiguous-data incremented mode. If contiguously incremented (GPDMA_CxTR1.DINC = 1), then the additional address offset value is the programmed burst size, as defined by GPDMA_CxTR1.DBL_1[5:0] and GPDMA_CxTR1.DDW_LOG2[1:0]\nthe additional destination incremented/decremented offset value as programmed by GPDMA_CxBR1.DDEC.\nIn linked-list mode, after a LLI data transfer is completed, this register is automatically updated by the GPDMA from the memory, provided the LLI is set with GPDMA_CxLLR.UDA = 1.\nNote: A destination address must be aligned with the programmed data width of a destination burst (DA[2:0] versus GPDMA_CxTR1.DDW_LOG2[1:0]). Else, a user setting error is reported and no transfer is issued."
            }
        ]
    },
    "1073873996": {
        "name": "GPDMA_C7LLR",
        "address": 1073873996,
        "size": 32,
        "access": "",
        "desc": "GPDMA channel 7 linked-list address register",
        "fields": [
            {
                "name": "LA",
                "bitOffset": 2,
                "bitWidth": 14,
                "desc": "pointer (16-bit low-significant address) to the next linked-list data structure\nIf UT1 = UT2 = UB1 = USA = UDA = ULL = 0 and if LA[15:20] = 0, the current LLI is the last one. The channel transfer is completed without any update of the linked-list GPDMA register file.\nElse, this field is the pointer to the memory address offset from which the next linked-list data structure is automatically fetched from, once the data transfer is completed, in order to conditionally update the linked-list GPDMA internal register file (GPDMA_CxCTR1, GPDMA_CxTR2, GPDMA_CxBR1, GPDMA_CxSAR, GPDMA_CxDAR and GPDMA_CxLLR).\nNote: The user must program the pointer to be 32-bit aligned. The two low-significant bits are write ignored."
            },
            {
                "name": "ULL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxLLR register from memory\nThis bit is used to control the update of GPDMA_CxLLR from the memory during the link transfer."
            },
            {
                "name": "UDA",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxDAR register from memory\nThis bit is used to control the update of GPDMA_CxDAR from the memory during the link transfer."
            },
            {
                "name": "USA",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "update GPDMA_CxSAR from memory\nThis bit controls the update of GPDMA_CxSAR from the memory during the link transfer."
            },
            {
                "name": "UB1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxBR1 from memory\nThis bit controls the update of GPDMA_CxBR1 from the memory during the link transfer. If UB1 = 0 and if GPDMA_CxLLR different 0, the linked-list is not completed. GPDMA_CxBR1.BNDT[15:0] is then restored to the programmed value after data transfer is completed and before the link transfer."
            },
            {
                "name": "UT2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR2 from memory\nThis bit controls the update of GPDMA_CxTR2 from the memory during the link transfer."
            },
            {
                "name": "UT1",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Update GPDMA_CxTR1 from memory\nThis bit controls the update of GPDMA_CxTR1 from the memory during the link transfer."
            }
        ]
    },
    "1107427328": {
        "name": "GPIOA_MODER",
        "address": 1107427328,
        "size": 32,
        "access": "",
        "desc": "GPIO port A mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 0"
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 1"
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 2"
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 3"
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 5"
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 6"
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 7"
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 8"
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 9"
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 10"
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 11"
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 12"
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 13"
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 14"
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 15\nThese bits are written by software to configure the I/O mode.\nAccess can be protected by GPIOA SEC15."
            }
        ]
    },
    "1107427332": {
        "name": "GPIOA_OTYPER",
        "address": 1107427332,
        "size": 32,
        "access": "",
        "desc": "GPIO port A output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOA SECy."
            }
        ]
    },
    "1107427336": {
        "name": "GPIOA_OSPEEDR",
        "address": 1107427336,
        "size": 32,
        "access": "",
        "desc": "GPIO port A output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 0"
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 1"
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 2"
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 3"
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 5"
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 6"
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 7"
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 8"
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 9"
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 10"
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 11"
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 12"
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 13"
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 14"
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 15\nThese bits are written by software to configure the I/O output speed.\nAccess can be protected by GPIOA SEC15.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed."
            }
        ]
    },
    "1107427340": {
        "name": "GPIOA_PUPDR",
        "address": 1107427340,
        "size": 32,
        "access": "",
        "desc": "GPIO port A pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 0"
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 1"
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 2"
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 3"
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 5"
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 6"
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 7"
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 8"
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 9"
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 10"
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 11"
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 12"
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 13"
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 14"
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 15\nThese bits are written by software to configure the I/O pull-up or pull-down\nAccess can be protected by GPIOA SEC15."
            }
        ]
    },
    "1107427344": {
        "name": "GPIOA_IDR",
        "address": 1107427344,
        "size": 32,
        "access": "",
        "desc": "GPIO port A input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOA SECy."
            }
        ]
    },
    "1107427348": {
        "name": "GPIOA_ODR",
        "address": 1107427348,
        "size": 32,
        "access": "",
        "desc": "GPIO port A output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOA SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOA_BSRR or GPIOA_BRR registers ."
            }
        ]
    },
    "1107427352": {
        "name": "GPIOA_BSRR",
        "address": 1107427352,
        "size": 32,
        "access": "",
        "desc": "GPIO port A bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy"
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            }
        ]
    },
    "1107427356": {
        "name": "GPIOA_LCKR",
        "address": 1107427356,
        "size": 32,
        "access": "",
        "desc": "GPIO port A configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nAccess can be protected by any GPIOA SECy.\n- LOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\n- LOCK key read\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCKR[15:0] must not change.\nNote: Any error in the lock sequence aborts the LOCK.\nNote: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1107427360": {
        "name": "GPIOA_AFRL",
        "address": 1107427360,
        "size": 32,
        "access": "",
        "desc": "GPIO port A alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 0"
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 1"
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 2"
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 3"
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 5"
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 6"
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 7\nThese bits are written by software to configure alternate function I/Os.\nAccess can be protected by GPIOA SECy."
            }
        ]
    },
    "1107427364": {
        "name": "GPIOA_AFRH",
        "address": 1107427364,
        "size": 32,
        "access": "",
        "desc": "GPIO port A alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 8"
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 9"
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 10"
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 11"
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 12"
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 13"
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 14"
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 15\nThese bits are written by software to configure alternate function I/Os.\nAccess can be protected by GPIOA SEC15."
            }
        ]
    },
    "1107427368": {
        "name": "GPIOA_BRR",
        "address": 1107427368,
        "size": 32,
        "access": "",
        "desc": "GPIO port A bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOA SECy."
            }
        ]
    },
    "1107427376": {
        "name": "GPIOA_SECCFGR",
        "address": 1107427376,
        "size": 32,
        "access": "",
        "desc": "GPIO port A secure configuration register",
        "fields": [
            {
                "name": "SEC0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            }
        ]
    },
    "1107428352": {
        "name": "GPIOB_MODER",
        "address": 1107428352,
        "size": 32,
        "access": "",
        "desc": "GPIO port B mode register",
        "fields": [
            {
                "name": "MODE0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 0"
            },
            {
                "name": "MODE1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 1"
            },
            {
                "name": "MODE2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 2"
            },
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 3"
            },
            {
                "name": "MODE4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 4"
            },
            {
                "name": "MODE5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 5"
            },
            {
                "name": "MODE6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 6"
            },
            {
                "name": "MODE7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 7"
            },
            {
                "name": "MODE8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 8"
            },
            {
                "name": "MODE9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 9"
            },
            {
                "name": "MODE10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 10\nNote that bits 21:20 are reserved on STM32WBA55xx devices."
            },
            {
                "name": "MODE11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 11"
            },
            {
                "name": "MODE12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 12"
            },
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 13"
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 14"
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 15\nThese bits are written by software to configure the I/O mode.\nAccess can be protected by GPIOB SEC15."
            }
        ]
    },
    "1107428356": {
        "name": "GPIOB_OTYPER",
        "address": 1107428356,
        "size": 32,
        "access": "",
        "desc": "GPIO port B output type register",
        "fields": [
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            }
        ]
    },
    "1107428360": {
        "name": "GPIOB_OSPEEDR",
        "address": 1107428360,
        "size": 32,
        "access": "",
        "desc": "GPIO port B output speed register",
        "fields": [
            {
                "name": "OSPEED0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 0"
            },
            {
                "name": "OSPEED1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 1"
            },
            {
                "name": "OSPEED2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 2"
            },
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 3"
            },
            {
                "name": "OSPEED4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 4"
            },
            {
                "name": "OSPEED5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 5"
            },
            {
                "name": "OSPEED6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 6"
            },
            {
                "name": "OSPEED7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 7"
            },
            {
                "name": "OSPEED8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 8"
            },
            {
                "name": "OSPEED9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 9"
            },
            {
                "name": "OSPEED10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 10\nNote that bits 21:20 are reserved on STM32WBA55xx devices."
            },
            {
                "name": "OSPEED11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 11"
            },
            {
                "name": "OSPEED12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 12"
            },
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 13"
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 14"
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 15\nThese bits are written by software to configure the I/O output speed.\nAccess can be protected by GPIOB SEC15.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed."
            }
        ]
    },
    "1107428364": {
        "name": "GPIOB_PUPDR",
        "address": 1107428364,
        "size": 32,
        "access": "",
        "desc": "GPIO port B pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 0"
            },
            {
                "name": "PUPD1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 1"
            },
            {
                "name": "PUPD2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 2"
            },
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 3"
            },
            {
                "name": "PUPD4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 4"
            },
            {
                "name": "PUPD5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 5"
            },
            {
                "name": "PUPD6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 6"
            },
            {
                "name": "PUPD7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 7"
            },
            {
                "name": "PUPD8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 8"
            },
            {
                "name": "PUPD9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 9"
            },
            {
                "name": "PUPD10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 10\nNote that bits 21:20 are reserved on STM32WBA55xx devices."
            },
            {
                "name": "PUPD11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 11"
            },
            {
                "name": "PUPD12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 12"
            },
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 13"
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 14"
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port configuration I/O pin 15\nThese bits are written by software to configure the I/O pull-up or pull-down\nAccess can be protected by GPIOB SEC15."
            }
        ]
    },
    "1107428368": {
        "name": "GPIOB_IDR",
        "address": 1107428368,
        "size": 32,
        "access": "",
        "desc": "GPIO port B input data register",
        "fields": [
            {
                "name": "ID0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            }
        ]
    },
    "1107428372": {
        "name": "GPIOB_ODR",
        "address": 1107428372,
        "size": 32,
        "access": "",
        "desc": "GPIO port B output data register",
        "fields": [
            {
                "name": "OD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOB_BSRR or GPIOB_BRR registers."
            }
        ]
    },
    "1107428376": {
        "name": "GPIOB_BSRR",
        "address": 1107428376,
        "size": 32,
        "access": "",
        "desc": "GPIO port B bit set/reset register",
        "fields": [
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 26 is reserved on STM32WBA55xx devices.\nNote: If both BSy and BRy are set, BSy has priority."
            }
        ]
    },
    "1107428380": {
        "name": "GPIOB_LCKR",
        "address": 1107428380,
        "size": 32,
        "access": "",
        "desc": "GPIO port B configuration lock register",
        "fields": [
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nAccess can be protected by any GPIOB SECy.\n- LOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:0]\nWR LCKR[16] = 0 + LCKR[15:0]\nWR LCKR[16] = 1 + LCKR[15:0]\n- LOCK key read\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCKR[15:0] must not change.\nNote: Any error in the lock sequence aborts the LOCK.\nNote: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1107428384": {
        "name": "GPIOB_AFRL",
        "address": 1107428384,
        "size": 32,
        "access": "",
        "desc": "GPIO port B alternate function low register",
        "fields": [
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 0"
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 1"
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 2"
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 3"
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 4"
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 5"
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 6"
            },
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 7\nThese bits are written by software to configure alternate function I/Os.\nAccess can be protected by GPIOB SEC7."
            }
        ]
    },
    "1107428388": {
        "name": "GPIOB_AFRH",
        "address": 1107428388,
        "size": 32,
        "access": "",
        "desc": "GPIO port B alternate function high register",
        "fields": [
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 8"
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 9"
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 10\nNote that bit 11:8 are reserved on STM32WBA55xx devices."
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 11"
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 12"
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 13"
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 14"
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port I/O pin 15\nThese bits are written by software to configure alternate function I/Os.\nAccess can be protected by GPIOB SEC15."
            }
        ]
    },
    "1107428392": {
        "name": "GPIOB_BRR",
        "address": 1107428392,
        "size": 32,
        "access": "",
        "desc": "GPIO port B bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOB SECy.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            }
        ]
    },
    "1107428400": {
        "name": "GPIOB_SECCFGR",
        "address": 1107428400,
        "size": 32,
        "access": "",
        "desc": "GPIO port B secure configuration register",
        "fields": [
            {
                "name": "SEC0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            },
            {
                "name": "SEC15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "I/O pin of port secure bit enable y\nThese bits are written by software to enabled the security I/O port pin.\nNote that bit 10 is reserved on STM32WBA55xx devices."
            }
        ]
    },
    "1107429376": {
        "name": "GPIOC_MODER",
        "address": 1107429376,
        "size": 32,
        "access": "",
        "desc": "GPIO port C mode register",
        "fields": [
            {
                "name": "MODE13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port C configuration I/O pin 13"
            },
            {
                "name": "MODE14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port C configuration I/O pin 14"
            },
            {
                "name": "MODE15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port C configuration I/O pin 15\nThese bits are written by software to configure the I/O mode.\nAccess can be protected by GPIOC SEC15."
            }
        ]
    },
    "1107429380": {
        "name": "GPIOC_OTYPER",
        "address": 1107429380,
        "size": 32,
        "access": "",
        "desc": "GPIO port C output type register",
        "fields": [
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C configuration I/O pin y\nThese bits are written by software to configure the I/O output type.\nAccess can be protected by GPIOC SECy."
            }
        ]
    },
    "1107429384": {
        "name": "GPIOC_OSPEEDR",
        "address": 1107429384,
        "size": 32,
        "access": "",
        "desc": "GPIOC port output speed register",
        "fields": [
            {
                "name": "OSPEED13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port C configuration I/O pin 13"
            },
            {
                "name": "OSPEED14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port C configuration I/O pin 14"
            },
            {
                "name": "OSPEED15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port C configuration I/O pin 15\nThese bits are written by software to configure the I/O output speed.\nAccess can be protected by GPIOC SEC15.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed."
            }
        ]
    },
    "1107429388": {
        "name": "GPIOC_PUPDR",
        "address": 1107429388,
        "size": 32,
        "access": "",
        "desc": "GPIO port C pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port C configuration I/O pin 13"
            },
            {
                "name": "PUPD14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port C configuration I/O pin 14"
            },
            {
                "name": "PUPD15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port C configuration I/O pin 15\nThese bits are written by software to configure the I/O pull-up or pull-down\nAccess can be protected by GPIOC SEC15."
            }
        ]
    },
    "1107429392": {
        "name": "GPIOC_IDR",
        "address": 1107429392,
        "size": 32,
        "access": "",
        "desc": "GPIO port C input data register",
        "fields": [
            {
                "name": "ID13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "ID14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "ID15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C input data I/O pin y\nThese bits are read-only. They contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOC SECy."
            }
        ]
    },
    "1107429396": {
        "name": "GPIOC_ODR",
        "address": 1107429396,
        "size": 32,
        "access": "",
        "desc": "GPIO port C output data register",
        "fields": [
            {
                "name": "OD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOC SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOC_BSRR or GPIOC_BRR registers."
            },
            {
                "name": "OD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOC SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOC_BSRR or GPIOC_BRR registers."
            },
            {
                "name": "OD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C output data I/O pin y\nThese bits can be read and written by software.\nAccess can be protected by GPIOC SECy.\nNote: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOC_BSRR or GPIOC_BRR registers."
            }
        ]
    },
    "1107429400": {
        "name": "GPIOC_BSRR",
        "address": 1107429400,
        "size": 32,
        "access": "",
        "desc": "GPIO port C bit set/reset register",
        "fields": [
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C set I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port C reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOC SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port C reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOC SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            },
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port C reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOC SECy.\nNote: If both BSy and BRy are set, BSy has priority."
            }
        ]
    },
    "1107429404": {
        "name": "GPIOC_LCKR",
        "address": 1107429404,
        "size": 32,
        "access": "",
        "desc": "GPIO port C configuration lock register",
        "fields": [
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C lock I/O pin y\nThese bits are read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nAccess is protected by any GPIOC SECy.\n- LOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[15:13]\nWR LCKR[16] = 0 + LCKR[15:13]\nWR LCKR[16] = 1 + LCKR[15:13]\n- LOCK key read\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:13] must not change.\nNote: Any error in the lock sequence aborts the LOCK.\nNote: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1107429412": {
        "name": "GPIOC_AFRH",
        "address": 1107429412,
        "size": 32,
        "access": "",
        "desc": "GPIO port C alternate function high register",
        "fields": [
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port C I/O pin 13"
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port C I/O pin 14"
            },
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port C I/O pin 15\nThese bits are written by software to configure alternate function I/Os.\nAccess can be protected by GPIOC SEC15."
            }
        ]
    },
    "1107429416": {
        "name": "GPIOC_BRR",
        "address": 1107429416,
        "size": 32,
        "access": "",
        "desc": "GPIO port C bit reset register",
        "fields": [
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOC SECy."
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port reset I/O pin y\nThese bits are write-only. A read to these bits returns the value 0.\nAccess can be protected by GPIOC SECy."
            }
        ]
    },
    "1107429424": {
        "name": "GPIOC_SECCFGR",
        "address": 1107429424,
        "size": 32,
        "access": "",
        "desc": "GPIO port C secure configuration register",
        "fields": [
            {
                "name": "SEC13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "I/O pin of port C secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "I/O pin of port C secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            },
            {
                "name": "SEC15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "I/O pin of port C secure bit enable y\nThese bits are written by software to enabled the security I/O port pin."
            }
        ]
    },
    "1107434496": {
        "name": "GPIOH_MODER",
        "address": 1107434496,
        "size": 32,
        "access": "",
        "desc": "GPIO port H mode register",
        "fields": [
            {
                "name": "MODE3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port H configuration I/O pin 3\nThese bits are written by software to configure the I/O mode.\nAccess can be protected by GPIOH SEC3."
            }
        ]
    },
    "1107434500": {
        "name": "GPIOH_OTYPER",
        "address": 1107434500,
        "size": 32,
        "access": "",
        "desc": "GPIO port H output type register",
        "fields": [
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port H configuration I/O pin 3\nThis bit is written by software to configure the I/O output type.\nAccess can be protected by GPIOH SEC3."
            }
        ]
    },
    "1107434504": {
        "name": "GPIOH_OSPEEDR",
        "address": 1107434504,
        "size": 32,
        "access": "",
        "desc": "GPIO port H output speed register",
        "fields": [
            {
                "name": "OSPEED3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port H configuration I/O pin 3\nThese bits are written by software to configure the I/O output speed.\nAccess can be protected by GPIOH SEC3.\nNote: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed."
            }
        ]
    },
    "1107434508": {
        "name": "GPIOH_PUPDR",
        "address": 1107434508,
        "size": 32,
        "access": "",
        "desc": "GPIO port H pull-up/pull-down register",
        "fields": [
            {
                "name": "PUPD3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port H configuration I/O pin 3\nThese bits are written by software to configure the I/O pull-up or pull-down\nAccess can be protected by GPIOH SEC3."
            }
        ]
    },
    "1107434512": {
        "name": "GPIOH_IDR",
        "address": 1107434512,
        "size": 32,
        "access": "",
        "desc": "GPIO port H input data register",
        "fields": [
            {
                "name": "ID3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port H input data I/O pin 3\nThis bit is read-only. It contain the input value of the corresponding I/O port.\nAccess can be protected by GPIOH SEC3."
            }
        ]
    },
    "1107434516": {
        "name": "GPIOH_ODR",
        "address": 1107434516,
        "size": 32,
        "access": "",
        "desc": "GPIO port H output data register",
        "fields": [
            {
                "name": "OD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port H output data I/O pin 3\nThis bits can be read and written by software.\nAccess can be protected by GPIOH SEC3.\nNote: For atomic bit set/reset, the OD bit can be individually set and/or reset by writing to the GPIOH_BSRR or GPIOH_BRR registers."
            }
        ]
    },
    "1107434520": {
        "name": "GPIOH_BSRR",
        "address": 1107434520,
        "size": 32,
        "access": "",
        "desc": "GPIO port H bit set/reset register",
        "fields": [
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port H set I/O pin 3\nThis bit is write-only. A read to this bit returns the value 0.\nAccess can be protected by GPIOH SEC3."
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port H reset I/O pin 3\nThis bit is write-only. A read to this bit returns the value 0.\nAccess can be protected by GPIOH SEC3.\nNote: If both BS3 and BR3 are set, BS3 has priority."
            }
        ]
    },
    "1107434524": {
        "name": "GPIOH_LCKR",
        "address": 1107434524,
        "size": 32,
        "access": "",
        "desc": "GPIO port H configuration lock register",
        "fields": [
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port H lock I/O pin 3\nThis bit is read/write but can only be written when the LCKK bit is 0\nAccess can be protected by GPIOH SEC3."
            },
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\nAccess is protected by GPIOH SEC3.\n- LOCK key write sequence:\nWR LCKR[16] = 1 + LCKR[3]\nWR LCKR[16] = 0 + LCKR[3]\nWR LCKR[16] = 1 + LCKR[3]\n- LOCK key read\nRD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK3 must not change.\nNote: Any error in the lock sequence aborts the LOCK.\nNote: After the first LOCK sequence on any bit of the port, any read access on the LCKK bit returns 1 until the next MCU reset or peripheral reset."
            }
        ]
    },
    "1107434528": {
        "name": "GPIOH_AFRL",
        "address": 1107434528,
        "size": 32,
        "access": "",
        "desc": "GPIO port H alternate function low register",
        "fields": [
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port H I/O pin 3\nThese bits are written by software to configure alternate function I/Os.\nAccess can be protected by GPIOH SEC3."
            }
        ]
    },
    "1107434536": {
        "name": "GPIOH_BRR",
        "address": 1107434536,
        "size": 32,
        "access": "",
        "desc": "GPIO port H bit reset register",
        "fields": [
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port H reset I/O pin 3\nThis bit is write-only. A read to this bit returns the value 0.\nAccess can be protected by GPIOH SEC3."
            }
        ]
    },
    "1107434544": {
        "name": "GPIOH_SECCFGR",
        "address": 1107434544,
        "size": 32,
        "access": "",
        "desc": "GPIO port H secure configuration register",
        "fields": [
            {
                "name": "SEC3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "I/O pin of port H secure bit enable 3\nThis bit is written by software to enabled the security I/O port pin."
            }
        ]
    },
    "1108083712": {
        "name": "HASH_CR",
        "address": 1108083712,
        "size": 32,
        "access": "read-write",
        "desc": "HASH control register",
        "fields": [
            {
                "name": "INIT",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Initialize message digest calculation\n\nWriting this bit to 1 resets the hash processor core, so that the HASH is ready to compute the message digest of a new message.\n\nWriting this bit to 0 has no effect. Reading this bit always return 0."
            },
            {
                "name": "DMAE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "DMA enable\n\nAfter this bit is set it is cleared by hardware while the last data of the message is written into the hash processor.\n\nSetting this bit to 0 while a DMA transfer is ongoing is not aborting this current transfer. Instead, the DMA interface of the IP remains internally enabled until the transfer is completed or INIT is written to 1.\n\nSetting INIT bit to 1 does not clear DMAE bit."
            },
            {
                "name": "DATATYPE",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Data type selection\n\nDefines the format of the data entered into the HASH_DIN register:"
            },
            {
                "name": "MODE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Mode selection\n\nThis bit selects the HASH or HMAC mode for the selected algorithm:\n\nThis selection is only taken into account when the INIT bit is set. Changing this bit during a computation has no effect."
            },
            {
                "name": "NBW",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Number of words already pushed\n\nRefer to NBWP[3:0] bitfield of HASH_SR for the description.\n\nThis bitfield is read-only."
            },
            {
                "name": "DINNE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "DIN not empty\n\nRefer to DINNE bit of HASH_SR for the description.\n\nThis bit is read-only."
            },
            {
                "name": "MDMAT",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Multiple DMA transfers\n\nThis bit is set when hashing large files when multiple DMA transfers are needed."
            },
            {
                "name": "LKEY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Long key selection\n\nThis bit selects between short key (less than or equal 64 bytes) or long key ( 64 bytes) in HMAC mode.\n\nThis selection is only taken into account when the INIT and MODE bits are both set. Changing this bit during a computation has no effect."
            },
            {
                "name": "ALGO",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Algorithm selection\n\nThese bits select the hash algorithm.\n\nThis selection is only taken into account when the INIT bit is set. Changing this bitfield during a computation has no effect.\n\nWhen ALGO bitfield is updated and INIT bit is set, NBWE in HASH_SR is automatically updated to 0x11."
            }
        ]
    },
    "1108083716": {
        "name": "HASH_DIN",
        "address": 1108083716,
        "size": 32,
        "access": "write-only",
        "desc": "HASH data input register",
        "fields": [
            {
                "name": "DATAIN",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Data input\n\nWriting this register pushes the current register content into the IN FIFO, and the register takes the new value presented on the AHB databus.\n\nReading this register returns zeros."
            }
        ]
    },
    "1108083720": {
        "name": "HASH_STR",
        "address": 1108083720,
        "size": 32,
        "access": "read-write",
        "desc": "HASH start register",
        "fields": [
            {
                "name": "NBLW",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Number of valid bits in the last word\n\nWhen the last word of the message bit string is written in HASH_DIN register, the hash processor takes only the valid bits specified as below, after internal data swapping:\n\n...\n\nThe above mechanism is valid only if DCAL = 0. If NBLW[4:0] bitfield is written while DCAL is set to 1, the NBLW[4:0] bitfield remains unchanged. In other words it is not possible to configure NBLW[4:0] and set DCAL at the same time.\n\nReading NBLW[4:0] bitfield returns the last value written to NBLW[4:0]."
            },
            {
                "name": "DCAL",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Digest calculation\n\nWriting this bit to 1 starts the message padding, using the previously written value of NBLW[4:0], and starts the calculation of the final message digest with all data words written to the input FIFO since the INIT bit was last written to 1.\n\nReading this bit returns 0."
            }
        ]
    },
    "1108083724": {
        "name": "HASH_HRA0",
        "address": 1108083724,
        "size": 32,
        "access": "read-only",
        "desc": "HASH aliased digest register 0",
        "fields": [
            {
                "name": "H0",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108083728": {
        "name": "HASH_HRA1",
        "address": 1108083728,
        "size": 32,
        "access": "read-only",
        "desc": "HASH aliased digest register 1",
        "fields": [
            {
                "name": "H1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108083732": {
        "name": "HASH_HRA2",
        "address": 1108083732,
        "size": 32,
        "access": "read-only",
        "desc": "HASH aliased digest register 2",
        "fields": [
            {
                "name": "H2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108083736": {
        "name": "HASH_HRA3",
        "address": 1108083736,
        "size": 32,
        "access": "read-only",
        "desc": "HASH aliased digest register 3",
        "fields": [
            {
                "name": "H3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108083740": {
        "name": "HASH_HRA4",
        "address": 1108083740,
        "size": 32,
        "access": "read-only",
        "desc": "HASH aliased digest register 4",
        "fields": [
            {
                "name": "H4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108083744": {
        "name": "HASH_IMR",
        "address": 1108083744,
        "size": 32,
        "access": "read-write",
        "desc": "HASH interrupt enable register",
        "fields": [
            {
                "name": "DINIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Data input interrupt enable"
            },
            {
                "name": "DCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Digest calculation completion interrupt enable"
            }
        ]
    },
    "1108083748": {
        "name": "HASH_SR",
        "address": 1108083748,
        "size": 32,
        "access": "read-write",
        "desc": "HASH status register",
        "fields": [
            {
                "name": "DINIS",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Data input interrupt status\n\nThis bit is set by hardware when the FIFO is ready to get a new block (16 locations are free). It is cleared by writing it to 0 or by writing the HASH_DIN register.\n\nWhen DINIS=0, HASH_CSRx registers reads as zero."
            },
            {
                "name": "DCIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Digest calculation completion interrupt status\n\nThis bit is set by hardware when a digest becomes ready (the whole message has been processed). It is cleared by writing it to 0 or by writing the INIT bit to 1 in the HASH_CR register."
            },
            {
                "name": "DMAS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "DMA Status\n\nThis bit provides information on the DMA interface activity. It is set with DMAE and cleared when DMAE = 0 and no DMA transfer is ongoing. No interrupt is associated with this bit."
            },
            {
                "name": "BUSY",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Busy bit"
            },
            {
                "name": "NBWP",
                "bitOffset": 9,
                "bitWidth": 5,
                "desc": "Number of words already pushed\n\nThis bitfield is the exact number of words in the message that have already been pushed into the FIFO. NBWP is incremented by one when a write access is performed to the HASH_DIN register.\n\nWhen a digest calculation starts, NBWP is updated to NBWP- block size (in words), and NBWP goes to zero when the INIT bit is written to 1."
            },
            {
                "name": "DINNE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DIN not empty\n\nThis bit is set when the HASH_DIN register holds valid data (that is after being written at least once). It is cleared when either the INIT bit (initialization) or the DCAL bit (completion of the previous message processing) is written to 1."
            },
            {
                "name": "NBWE",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Number of words expected\n\nThis bitfield reflects the number of words in the message that must be pushed into the FIFO to trigger a partial computation. NBWE is decremented by 1 when a write access is performed to the HASH_DIN register.\n\nNBWE is set to the expected block size +1 in words (0x11) when INIT bit is set in HASH_CR, and it is set to the expected block size when partial digest calculation ends."
            }
        ]
    },
    "1108083960": {
        "name": "HASH_CSR0",
        "address": 1108083960,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 0",
        "fields": [
            {
                "name": "CS0",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083964": {
        "name": "HASH_CSR1",
        "address": 1108083964,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 1",
        "fields": [
            {
                "name": "CS1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083968": {
        "name": "HASH_CSR2",
        "address": 1108083968,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 2",
        "fields": [
            {
                "name": "CS2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083972": {
        "name": "HASH_CSR3",
        "address": 1108083972,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 3",
        "fields": [
            {
                "name": "CS3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083976": {
        "name": "HASH_CSR4",
        "address": 1108083976,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 4",
        "fields": [
            {
                "name": "CS4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083980": {
        "name": "HASH_CSR5",
        "address": 1108083980,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 5",
        "fields": [
            {
                "name": "CS5",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083984": {
        "name": "HASH_CSR6",
        "address": 1108083984,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 6",
        "fields": [
            {
                "name": "CS6",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083988": {
        "name": "HASH_CSR7",
        "address": 1108083988,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 7",
        "fields": [
            {
                "name": "CS7",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083992": {
        "name": "HASH_CSR8",
        "address": 1108083992,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 8",
        "fields": [
            {
                "name": "CS8",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108083996": {
        "name": "HASH_CSR9",
        "address": 1108083996,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 9",
        "fields": [
            {
                "name": "CS9",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084000": {
        "name": "HASH_CSR10",
        "address": 1108084000,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 10",
        "fields": [
            {
                "name": "CS10",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084004": {
        "name": "HASH_CSR11",
        "address": 1108084004,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 11",
        "fields": [
            {
                "name": "CS11",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084008": {
        "name": "HASH_CSR12",
        "address": 1108084008,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 12",
        "fields": [
            {
                "name": "CS12",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084012": {
        "name": "HASH_CSR13",
        "address": 1108084012,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 13",
        "fields": [
            {
                "name": "CS13",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084016": {
        "name": "HASH_CSR14",
        "address": 1108084016,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 14",
        "fields": [
            {
                "name": "CS14",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084020": {
        "name": "HASH_CSR15",
        "address": 1108084020,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 15",
        "fields": [
            {
                "name": "CS15",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084024": {
        "name": "HASH_CSR16",
        "address": 1108084024,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 16",
        "fields": [
            {
                "name": "CS16",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084028": {
        "name": "HASH_CSR17",
        "address": 1108084028,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 17",
        "fields": [
            {
                "name": "CS17",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084032": {
        "name": "HASH_CSR18",
        "address": 1108084032,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 18",
        "fields": [
            {
                "name": "CS18",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084036": {
        "name": "HASH_CSR19",
        "address": 1108084036,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 19",
        "fields": [
            {
                "name": "CS19",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084040": {
        "name": "HASH_CSR20",
        "address": 1108084040,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 20",
        "fields": [
            {
                "name": "CS20",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084044": {
        "name": "HASH_CSR21",
        "address": 1108084044,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 21",
        "fields": [
            {
                "name": "CS21",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084048": {
        "name": "HASH_CSR22",
        "address": 1108084048,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 22",
        "fields": [
            {
                "name": "CS22",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084052": {
        "name": "HASH_CSR23",
        "address": 1108084052,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 23",
        "fields": [
            {
                "name": "CS23",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084056": {
        "name": "HASH_CSR24",
        "address": 1108084056,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 24",
        "fields": [
            {
                "name": "CS24",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084060": {
        "name": "HASH_CSR25",
        "address": 1108084060,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 25",
        "fields": [
            {
                "name": "CS25",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084064": {
        "name": "HASH_CSR26",
        "address": 1108084064,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 26",
        "fields": [
            {
                "name": "CS26",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084068": {
        "name": "HASH_CSR27",
        "address": 1108084068,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 27",
        "fields": [
            {
                "name": "CS27",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084072": {
        "name": "HASH_CSR28",
        "address": 1108084072,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 28",
        "fields": [
            {
                "name": "CS28",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084076": {
        "name": "HASH_CSR29",
        "address": 1108084076,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 29",
        "fields": [
            {
                "name": "CS29",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084080": {
        "name": "HASH_CSR30",
        "address": 1108084080,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 30",
        "fields": [
            {
                "name": "CS30",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084084": {
        "name": "HASH_CSR31",
        "address": 1108084084,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 31",
        "fields": [
            {
                "name": "CS31",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084088": {
        "name": "HASH_CSR32",
        "address": 1108084088,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 32",
        "fields": [
            {
                "name": "CS32",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084092": {
        "name": "HASH_CSR33",
        "address": 1108084092,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 33",
        "fields": [
            {
                "name": "CS33",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084096": {
        "name": "HASH_CSR34",
        "address": 1108084096,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 34",
        "fields": [
            {
                "name": "CS34",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084100": {
        "name": "HASH_CSR35",
        "address": 1108084100,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 35",
        "fields": [
            {
                "name": "CS35",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084104": {
        "name": "HASH_CSR36",
        "address": 1108084104,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 36",
        "fields": [
            {
                "name": "CS36",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084108": {
        "name": "HASH_CSR37",
        "address": 1108084108,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 37",
        "fields": [
            {
                "name": "CS37",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084112": {
        "name": "HASH_CSR38",
        "address": 1108084112,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 38",
        "fields": [
            {
                "name": "CS38",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084116": {
        "name": "HASH_CSR39",
        "address": 1108084116,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 39",
        "fields": [
            {
                "name": "CS39",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084120": {
        "name": "HASH_CSR40",
        "address": 1108084120,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 40",
        "fields": [
            {
                "name": "CS40",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084124": {
        "name": "HASH_CSR41",
        "address": 1108084124,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 41",
        "fields": [
            {
                "name": "CS41",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084128": {
        "name": "HASH_CSR42",
        "address": 1108084128,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 42",
        "fields": [
            {
                "name": "CS42",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084132": {
        "name": "HASH_CSR43",
        "address": 1108084132,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 43",
        "fields": [
            {
                "name": "CS43",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084136": {
        "name": "HASH_CSR44",
        "address": 1108084136,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 44",
        "fields": [
            {
                "name": "CS44",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084140": {
        "name": "HASH_CSR45",
        "address": 1108084140,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 45",
        "fields": [
            {
                "name": "CS45",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084144": {
        "name": "HASH_CSR46",
        "address": 1108084144,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 46",
        "fields": [
            {
                "name": "CS46",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084148": {
        "name": "HASH_CSR47",
        "address": 1108084148,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 47",
        "fields": [
            {
                "name": "CS47",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084152": {
        "name": "HASH_CSR48",
        "address": 1108084152,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 48",
        "fields": [
            {
                "name": "CS48",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084156": {
        "name": "HASH_CSR49",
        "address": 1108084156,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 49",
        "fields": [
            {
                "name": "CS49",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084160": {
        "name": "HASH_CSR50",
        "address": 1108084160,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 50",
        "fields": [
            {
                "name": "CS50",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084164": {
        "name": "HASH_CSR51",
        "address": 1108084164,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 51",
        "fields": [
            {
                "name": "CS51",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084168": {
        "name": "HASH_CSR52",
        "address": 1108084168,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 52",
        "fields": [
            {
                "name": "CS52",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084172": {
        "name": "HASH_CSR53",
        "address": 1108084172,
        "size": 32,
        "access": "read-write",
        "desc": "HASH context swap register 53",
        "fields": [
            {
                "name": "CS53",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Context swap x\n\nRefer to Section 25.7.7: HASH context swap registers introduction."
            }
        ]
    },
    "1108084496": {
        "name": "HASH_HR0",
        "address": 1108084496,
        "size": 32,
        "access": "read-only",
        "desc": "HASH digest register 0",
        "fields": [
            {
                "name": "H0",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084500": {
        "name": "HASH_HR1",
        "address": 1108084500,
        "size": 32,
        "access": "read-only",
        "desc": "HASH digest register 1",
        "fields": [
            {
                "name": "H1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084504": {
        "name": "HASH_HR2",
        "address": 1108084504,
        "size": 32,
        "access": "read-only",
        "desc": "HASH digest register 2",
        "fields": [
            {
                "name": "H2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084508": {
        "name": "HASH_HR3",
        "address": 1108084508,
        "size": 32,
        "access": "read-only",
        "desc": "HASH digest register 3",
        "fields": [
            {
                "name": "H3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084512": {
        "name": "HASH_HR4",
        "address": 1108084512,
        "size": 32,
        "access": "read-only",
        "desc": "HASH digest register 4",
        "fields": [
            {
                "name": "H4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084516": {
        "name": "HASH_HR5",
        "address": 1108084516,
        "size": 32,
        "access": "read-only",
        "desc": "HASH supplementary digest register 5",
        "fields": [
            {
                "name": "H5",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084520": {
        "name": "HASH_HR6",
        "address": 1108084520,
        "size": 32,
        "access": "read-only",
        "desc": "HASH supplementary digest register 6",
        "fields": [
            {
                "name": "H6",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108084524": {
        "name": "HASH_HR7",
        "address": 1108084524,
        "size": 32,
        "access": "read-only",
        "desc": "HASH supplementary digest register 7",
        "fields": [
            {
                "name": "H7",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Hash data x\n\nRefer to Section 25.7.4: HASH digest registers introduction."
            }
        ]
    },
    "1108089856": {
        "name": "HSEM_R0",
        "address": 1108089856,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 0",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089860": {
        "name": "HSEM_R1",
        "address": 1108089860,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 1",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089864": {
        "name": "HSEM_R2",
        "address": 1108089864,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 2",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089868": {
        "name": "HSEM_R3",
        "address": 1108089868,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 3",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089872": {
        "name": "HSEM_R4",
        "address": 1108089872,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 4",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089876": {
        "name": "HSEM_R5",
        "address": 1108089876,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 5",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089880": {
        "name": "HSEM_R6",
        "address": 1108089880,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 6",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089884": {
        "name": "HSEM_R7",
        "address": 1108089884,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 7",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089888": {
        "name": "HSEM_R8",
        "address": 1108089888,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 8",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089892": {
        "name": "HSEM_R9",
        "address": 1108089892,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 9",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089896": {
        "name": "HSEM_R10",
        "address": 1108089896,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 10",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089900": {
        "name": "HSEM_R11",
        "address": 1108089900,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 11",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089904": {
        "name": "HSEM_R12",
        "address": 1108089904,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 12",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089908": {
        "name": "HSEM_R13",
        "address": 1108089908,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 13",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089912": {
        "name": "HSEM_R14",
        "address": 1108089912,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 14",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089916": {
        "name": "HSEM_R15",
        "address": 1108089916,
        "size": 32,
        "access": "",
        "desc": "HSEM register semaphore 15",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore PROCID\nWritten by software\n-When the semaphore is free and the LOCK is written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition, PROCID is set to the written data.\n- When the semaphore is unlocked, LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the PROCID is cleared to 0.\n- When the semaphore is unlocked, LOCK bit written to 0 and AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match the AHB bus master definition, the PROCID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PROCID is not affected.\n- An authorized read returns the stored PROCID value."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1 and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master protection.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master protection, the LOCKID is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 or AHB bus master ID does not match LOCKID and/or SEC or PRIV do not match AHB bus master protection, the LOCKID is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the LOCKID is not affected.\n- An authorized read returns the stored LOCKID value."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the SEC is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the SEC is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the SEC is not affected.\n- An authorized read returns the stored SEC value."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nWritten by software\n- When the semaphore is free and the LOCK bit is at the same time written to 1, and the LOCKID matches the AHB bus master ID, SEC and PRIV matches the AHB bus master definition.\n- When the semaphore is unlocked (LOCK written to 0 and AHB bus master ID matched LOCKID, SEC and PRIV matches the AHB bus master definition, the PRIV is cleared to 0.\n- When the semaphore is unlocked (LOCK bit written to 0 and AHB bus master ID  does not match LOCKID and/or SEC or PRIV do not match AHB bus master definition, the PRIV is not affected.\n- Write when LOCK bit is already 1 (semaphore locked), the PRIV is not affected.\n- An authorized read returns the stored PRIV value."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit can be written and read by software."
            }
        ]
    },
    "1108089984": {
        "name": "HSEM_RLR0",
        "address": 1108089984,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 0",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108089988": {
        "name": "HSEM_RLR1",
        "address": 1108089988,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 1",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108089992": {
        "name": "HSEM_RLR2",
        "address": 1108089992,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 2",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108089996": {
        "name": "HSEM_RLR3",
        "address": 1108089996,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 3",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090000": {
        "name": "HSEM_RLR4",
        "address": 1108090000,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 4",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090004": {
        "name": "HSEM_RLR5",
        "address": 1108090004,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 5",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090008": {
        "name": "HSEM_RLR6",
        "address": 1108090008,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 6",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090012": {
        "name": "HSEM_RLR7",
        "address": 1108090012,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 7",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090016": {
        "name": "HSEM_RLR8",
        "address": 1108090016,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 8",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090020": {
        "name": "HSEM_RLR9",
        "address": 1108090020,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 9",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090024": {
        "name": "HSEM_RLR10",
        "address": 1108090024,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 10",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090028": {
        "name": "HSEM_RLR11",
        "address": 1108090028,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 11",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090032": {
        "name": "HSEM_RLR12",
        "address": 1108090032,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 12",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090036": {
        "name": "HSEM_RLR13",
        "address": 1108090036,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 13",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090040": {
        "name": "HSEM_RLR14",
        "address": 1108090040,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 14",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090044": {
        "name": "HSEM_RLR15",
        "address": 1108090044,
        "size": 32,
        "access": "",
        "desc": "HSEM read lock register semaphore 15",
        "fields": [
            {
                "name": "PROCID",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Semaphore processor ID\nThis field is read only by software at this address.\n- On a read when the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PROCID to 0.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PROCID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Semaphore LOCKID\nThis field is read only by software at this address.\nOn a read, when the semaphore is free, the hardware sets the LOCKID to the AHB bus master ID reading the semaphore. The LOCKID of the AHB bus master locking the semaphore is read.\nOn a read when the semaphore is locked, this field returns the LOCKID of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Semaphore secure.\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the SEC to the valid AHB bus master security definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the SEC of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Semaphore privilege\nThis field is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and hardware sets the PRIV to the valid AHB bus master privileged definition.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns the PRIV of the AHB bus master that has locked the semaphore."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Lock indication\nThis bit is read only by software at this address.\n- When the semaphore is free:\nA read with a valid AHB bus master ID and SEC and PRIV locks the semaphore and returns 1.\n- When the semaphore is locked:\nA read with a valid AHB bus master ID and SEC and PRIV returns 1 (the LOCKID and SEC and PRIV and PROCID reflect the already locked semaphore information)."
            }
        ]
    },
    "1108090112": {
        "name": "HSEM_IER",
        "address": 1108090112,
        "size": 32,
        "access": "",
        "desc": "HSEM non-secure interrupt enable register",
        "fields": [
            {
                "name": "ISE",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Non-secure Interrupt semaphore x enable bit\nThis bit is read and written by software.\nWhen semaphore x SECx is disabled, bit x can be accessed with secure and non-secure access.\nWhen semaphore x SECx is enabled, bit x is forced to 0 and cannot be accessed, write to this bit is discarded and a read returns 0.\nWhen semaphore x PRIVx is disabled, bit x can be accessed with privilege and unprivileged access.\nWhen semaphore x PRIVx is enabled, bit x can be accessed only with privileged access. Unprivileged write to this bit is discarded, unprivileged read returns 0."
            }
        ]
    },
    "1108090116": {
        "name": "HSEM_ICR",
        "address": 1108090116,
        "size": 32,
        "access": "",
        "desc": "HSEM non-secure interrupt clear register",
        "fields": [
            {
                "name": "ISC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Non-secure Interrupt semaphore x clear bit\nThis bit is written by software, and is always read 0.\nWhen semaphore x SECx is disabled, bit x can be accessed with secure and non-secure access.\nWhen semaphore x SECx is enabled, bit x cannot be accessed, write to this bit is discarded.\nWhen semaphore x PRIVx is disabled, bit x can be accessed with privileged and unprivileged access.\nWhen semaphore x PRIVx is enabled, bit x can only be accessed with privileged access. Unprivileged write to this bit is discarded."
            }
        ]
    },
    "1108090120": {
        "name": "HSEM_ISR",
        "address": 1108090120,
        "size": 32,
        "access": "",
        "desc": "HSEM non-secure interrupt status register",
        "fields": [
            {
                "name": "ISF",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Interrupt semaphore x status bit before enable (mask)\nThis bit is set by hardware, and reset only by software. This bit is cleared by software writing the corresponding HSEM_ICR bit."
            }
        ]
    },
    "1108090124": {
        "name": "HSEM_MISR",
        "address": 1108090124,
        "size": 32,
        "access": "",
        "desc": "HSEM non-secure interrupt status register",
        "fields": [
            {
                "name": "MISF",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Masked non-secure interrupt semaphore x status bit after enable (mask)\nThis bit is set by hardware and read only by software. This bit is cleared by software writing the corresponding HSEM_ICR bit. This bit is read as 0 when semaphore x status is masked in HSEM_IER bit x.\nWhen semaphore x SECx is disabled, bit x can be accessed with secure and non-secure access.\nWhen semaphore x SECx is enabled, bit x cannot be accessed, read returns 0.\nWhen semaphore x PRIVx is disabled, bit x can be accessed with privileged and unprivileged access.\nWhen semaphore x PRIVx is enabled, bit x can be accessed only with privileged access. Unprivileged read returns 0."
            }
        ]
    },
    "1108090240": {
        "name": "HSEM_SIER",
        "address": 1108090240,
        "size": 32,
        "access": "",
        "desc": "HSEM secure interrupt enable register",
        "fields": [
            {
                "name": "SISE",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Secure interrupt semaphore x enable bit\nThis bit is read and written by software.\nWhen semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.\nWhen semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. secure unprivileged write to this bit is discarded, secure unprivileged read return 0 value."
            }
        ]
    },
    "1108090244": {
        "name": "HSEM_SICR",
        "address": 1108090244,
        "size": 32,
        "access": "",
        "desc": "HSEM secure interrupt clear register",
        "fields": [
            {
                "name": "SISC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Secure interrupt semaphore x clear bit\nThis bit is written by software, and is always read 0.\nWhen semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.\nWhen semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. Secure unprivileged write to this bit is discarded."
            }
        ]
    },
    "1108090248": {
        "name": "HSEM_SISR",
        "address": 1108090248,
        "size": 32,
        "access": "",
        "desc": "HSEM secure interrupt status register",
        "fields": [
            {
                "name": "SISF",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Secure interrupt semaphore x status bit before enable (mask)\nThis bit is set by hardware and read only by software.\nBit is cleared by software writing the corresponding HSEM_SCnICR bit x.\nWhen semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.\nWhen semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. Secure unprivileged read return 0 value."
            }
        ]
    },
    "1108090252": {
        "name": "HSEM_MSISR",
        "address": 1108090252,
        "size": 32,
        "access": "",
        "desc": "HSEM secure masked interrupt status register",
        "fields": [
            {
                "name": "SMISF",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Secure masked interrupt semaphore x status bit after enable (mask)\nThis bit is set by hardware and read only by software.\nBit is cleared by software writing the corresponding HSEM_SCnICR bit x.\nBit is read as 0 when semaphore x status is masked in HSEM_SCnIER bit x.\nWhen semaphore x PRIVx is disabled, bit x can be accessed with secure privilege and secure unprivileged access.\nWhen semaphore x PRIVx is enabled, bit x can be accessed only with secure privilege access. Secure unprivileged read return 0 value."
            }
        ]
    },
    "1108090368": {
        "name": "HSEM_SECCFGR",
        "address": 1108090368,
        "size": 32,
        "access": "",
        "desc": "HSEM security configuration register",
        "fields": [
            {
                "name": "SEC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Semaphore x security attribute\nThis bit is set and cleared by software."
            }
        ]
    },
    "1108090384": {
        "name": "HSEM_PRIVCFGR",
        "address": 1108090384,
        "size": 32,
        "access": "",
        "desc": "HSEM privilege configuration register",
        "fields": [
            {
                "name": "PRIV",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Semaphore x privilege attribute\nThis bit is set and cleared by software.\nWhen semaphore x SECx is disabled, bit x can be write accessed with secure privileged and non-secure privileged access.\nWhen semaphore x SECx is enabled, bit x can only be write accessed with secure privilege access. Non-secure privileged write access is discarded. Both secure and non-secure read return the register bit x value"
            }
        ]
    },
    "1108090416": {
        "name": "HSEM_CR",
        "address": 1108090416,
        "size": 32,
        "access": "",
        "desc": "HSEM clear register",
        "fields": [
            {
                "name": "LOCKID",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "LOCKID of semaphores to be cleared\nThis field can be written by software and is always read 0.\nThis field indicates the LOCKID for which the semaphores are cleared when writing the HSEM_CR."
            },
            {
                "name": "SEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SEC value of semaphores to be cleared.\nThis field can be written by software, is always read 0.\nIndicates the SEC for which the CID semaphores are cleared when writing the HSEM_CR"
            },
            {
                "name": "PRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "PRIV value of semaphores to be cleared.\nThis field can be written by software, is always read 0.\nIndicates the PRIV for which the CID semaphores are cleared when writing the HSEM_CR."
            },
            {
                "name": "KEY",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Semaphore clear key\nThis field can be written by software and is always read 0.\nIf this key value does not match HSEM_KEYR.KEY, semaphores are not affected.\nIf this key value matches HSEM_KEYR.KEY, all semaphores matching the LOCKID are cleared to the free state."
            }
        ]
    },
    "1108090420": {
        "name": "HSEM_KEYR",
        "address": 1108090420,
        "size": 32,
        "access": "",
        "desc": "HSEM interrupt clear register",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Semaphore clear key\nThis field can be written and read by software.\nKey value to match when clearing semaphores."
            }
        ]
    },
    "1073939456": {
        "name": "ICACHE_CR",
        "address": 1073939456,
        "size": 32,
        "access": "",
        "desc": "ICACHE control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "enable"
            },
            {
                "name": "CACHEINV",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "cache invalidation\nSet by software and cleared by hardware when the BUSYF flag is set (during cache maintenance operation). Writing 0 has no effect."
            },
            {
                "name": "WAYSEL",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "cache associativity mode selection\nThis bit allows user to choose ICACHE set-associativity. It can be written by software only when cache is disabled (EN=0)."
            },
            {
                "name": "HITMEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "hit monitor enable"
            },
            {
                "name": "MISSMEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "miss monitor enable"
            },
            {
                "name": "HITMRST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "hit monitor reset"
            },
            {
                "name": "MISSMRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "miss monitor reset"
            }
        ]
    },
    "1073939460": {
        "name": "ICACHE_SR",
        "address": 1073939460,
        "size": 32,
        "access": "",
        "desc": "ICACHE status register",
        "fields": [
            {
                "name": "BUSYF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "busy flag"
            },
            {
                "name": "BSYENDF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "busy end flag"
            },
            {
                "name": "ERRF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "cache error flag"
            }
        ]
    },
    "1073939464": {
        "name": "ICACHE_IER",
        "address": 1073939464,
        "size": 32,
        "access": "",
        "desc": "ICACHE interrupt enable register",
        "fields": [
            {
                "name": "BSYENDIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "interrupt enable on busy end\nSet by software to enable an interrupt generation at the end of a cache invalidate operation."
            },
            {
                "name": "ERRIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "interrupt enable on cache error\nSet by software to enable an interrupt generation in case of cache functional error (cacheable write access)"
            }
        ]
    },
    "1073939468": {
        "name": "ICACHE_FCR",
        "address": 1073939468,
        "size": 32,
        "access": "",
        "desc": "ICACHE flag clear register",
        "fields": [
            {
                "name": "CBSYENDF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "clear busy end flag\nSet by software."
            },
            {
                "name": "CERRF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "clear cache error flag\nSet by software."
            }
        ]
    },
    "1073939472": {
        "name": "ICACHE_HMONR",
        "address": 1073939472,
        "size": 32,
        "access": "",
        "desc": "ICACHE hit monitor register",
        "fields": [
            {
                "name": "HITMON",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "cache hit monitor counter"
            }
        ]
    },
    "1073939476": {
        "name": "ICACHE_MMONR",
        "address": 1073939476,
        "size": 32,
        "access": "",
        "desc": "ICACHE miss monitor register",
        "fields": [
            {
                "name": "MISSMON",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "cache miss monitor counter"
            }
        ]
    },
    "1073939488": {
        "name": "ICACHE_CRR0",
        "address": 1073939488,
        "size": 32,
        "access": "",
        "desc": "ICACHE region 0 configuration register",
        "fields": [
            {
                "name": "BASEADDR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "base address for region x\nThis alias address is replaced by REMAPADDR field.\nThe only useful bits are [28:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored."
            },
            {
                "name": "RSIZE",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "size for region x"
            },
            {
                "name": "REN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "enable for region x"
            },
            {
                "name": "REMAPADDR",
                "bitOffset": 16,
                "bitWidth": 11,
                "desc": "remapped address for region x\nThis field replaces the alias address defined by BASEADDR field.\nThe only useful bits are [31:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored."
            },
            {
                "name": "MSTSEL",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "AHB cache master selection for region x"
            },
            {
                "name": "HBURST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "output burst type for region x"
            }
        ]
    },
    "1073939492": {
        "name": "ICACHE_CRR1",
        "address": 1073939492,
        "size": 32,
        "access": "",
        "desc": "ICACHE region 1 configuration register",
        "fields": [
            {
                "name": "BASEADDR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "base address for region x\nThis alias address is replaced by REMAPADDR field.\nThe only useful bits are [28:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored."
            },
            {
                "name": "RSIZE",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "size for region x"
            },
            {
                "name": "REN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "enable for region x"
            },
            {
                "name": "REMAPADDR",
                "bitOffset": 16,
                "bitWidth": 11,
                "desc": "remapped address for region x\nThis field replaces the alias address defined by BASEADDR field.\nThe only useful bits are [31:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored."
            },
            {
                "name": "MSTSEL",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "AHB cache master selection for region x"
            },
            {
                "name": "HBURST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "output burst type for region x"
            }
        ]
    },
    "1073939496": {
        "name": "ICACHE_CRR2",
        "address": 1073939496,
        "size": 32,
        "access": "",
        "desc": "ICACHE region 2 configuration register",
        "fields": [
            {
                "name": "BASEADDR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "base address for region x\nThis alias address is replaced by REMAPADDR field.\nThe only useful bits are [28:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored."
            },
            {
                "name": "RSIZE",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "size for region x"
            },
            {
                "name": "REN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "enable for region x"
            },
            {
                "name": "REMAPADDR",
                "bitOffset": 16,
                "bitWidth": 11,
                "desc": "remapped address for region x\nThis field replaces the alias address defined by BASEADDR field.\nThe only useful bits are [31:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored."
            },
            {
                "name": "MSTSEL",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "AHB cache master selection for region x"
            },
            {
                "name": "HBURST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "output burst type for region x"
            }
        ]
    },
    "1073939500": {
        "name": "ICACHE_CRR3",
        "address": 1073939500,
        "size": 32,
        "access": "",
        "desc": "ICACHE region 3 configuration register",
        "fields": [
            {
                "name": "BASEADDR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "base address for region x\nThis alias address is replaced by REMAPADDR field.\nThe only useful bits are [28:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored."
            },
            {
                "name": "RSIZE",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "size for region x"
            },
            {
                "name": "REN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "enable for region x"
            },
            {
                "name": "REMAPADDR",
                "bitOffset": 16,
                "bitWidth": 11,
                "desc": "remapped address for region x\nThis field replaces the alias address defined by BASEADDR field.\nThe only useful bits are [31:RI], where 21 less than or equal RI less than or equal 27 is the number of bits of RSIZE (see Section 18.4.7). If the programmed value has more LSBs, the useless bits are ignored."
            },
            {
                "name": "MSTSEL",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "AHB cache master selection for region x"
            },
            {
                "name": "HBURST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "output burst type for region x"
            }
        ]
    },
    "1073754112": {
        "name": "IWDG_KR",
        "address": 1073754112,
        "size": 32,
        "access": "",
        "desc": "IWDG key register",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Key value (write only, read 0x0000)\nThese bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0.\nWriting the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see Section 29.4.6: Register access protection)\nWriting the key value 0xCCCC starts the watchdog (except if the hardware watchdog option is selected)"
            }
        ]
    },
    "1073754116": {
        "name": "IWDG_PR",
        "address": 1073754116,
        "size": 32,
        "access": "",
        "desc": "IWDG prescaler register",
        "fields": [
            {
                "name": "PR",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Prescaler divider\nThese bits are write access protected see Section 29.4.6: Register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the IWDG status register (IWDG_SR) must be reset in order to be able to change the prescaler divider.\nOthers: divider / 1024\nNote: Reading this register returns the prescaler value from the VsubDD/sub voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG status register (IWDG_SR) is reset."
            }
        ]
    },
    "1073754120": {
        "name": "IWDG_RLR",
        "address": 1073754120,
        "size": 32,
        "access": "",
        "desc": "IWDG reload register",
        "fields": [
            {
                "name": "RL",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter reload value\nThese bits are write access protected see Register access protection. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG key register (IWDG_KR). The watchdog counter counts down from this value. The timeout period is a function of this value and the prescaler.clock. It is not recommended to set RL[11:0] to a value lower than 2.\nThe RVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.\nNote: Reading this register returns the reload value from the VsubDD/sub voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on it. For this reason the value read from this register is valid only when the RVU bit in the IWDG status register (IWDG_SR) is reset."
            }
        ]
    },
    "1073754124": {
        "name": "IWDG_SR",
        "address": 1073754124,
        "size": 32,
        "access": "",
        "desc": "IWDG status register",
        "fields": [
            {
                "name": "PVU",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Watchdog prescaler value update\nThis bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VsubDD/sub voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).\nThe prescaler value can be updated only when PVU bit is reset."
            },
            {
                "name": "RVU",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Watchdog counter reload value update\nThis bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VsubDD/sub voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).\nThe reload value can be updated only when RVU bit is reset."
            },
            {
                "name": "WVU",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Watchdog counter window value update\nThis bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VsubDD/sub voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).\nThe window value can be updated only when WVU bit is reset.\nThis bit is generated only if generic 'window' = 1"
            },
            {
                "name": "EWU",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Watchdog interrupt comparator value update\nThis bit is set by hardware to indicate that an update of the interrupt comparator value (EWIT[11:0]) or an update of the EWIE is ongoing. It is reset by hardware when the update operation is completed in the VsubDD/sub voltage domain (takes up to three periods of the IWDG kernel clock iwdg_ker_ck).\nThe EWIT[11:0] and EWIE fields can be updated only when EWU bit is reset."
            },
            {
                "name": "ONF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Watchdog enable status bit\nSet to '1' by hardware as soon as the IWDG is started, remains to '1' until the IWDG is reset."
            },
            {
                "name": "EWIF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Watchdog early interrupt flag\nThis bit is set to '1' by hardware in order to indicate that an early interrupt is pending. This bit must be cleared by the software by writing the bit EWIC of IWDG_EWCR register to '1'."
            }
        ]
    },
    "1073754128": {
        "name": "IWDG_WINR",
        "address": 1073754128,
        "size": 32,
        "access": "",
        "desc": "IWDG window register",
        "fields": [
            {
                "name": "WIN",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter window value\nThese bits are write access protected, see Section 29.4.6, they contain the high limit of the window value to be compared with the downcounter.\nTo prevent a reset, the IWDCNT downcounter must be reloaded when its value is lower than WIN[11:0]+1 and greater than 1.\nThe WVU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.\nNote: Reading this register returns the reload value from the VsubDD/sub voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG status register (IWDG_SR) is reset."
            }
        ]
    },
    "1073754132": {
        "name": "IWDG_EWCR",
        "address": 1073754132,
        "size": 32,
        "access": "",
        "desc": "IWDG early wakeup interrupt register",
        "fields": [
            {
                "name": "EWIT",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter window value\nThese bits are write access protected (see Section 29.4.6). They are written by software to define at which position of the IWDCNT down-counter the early wakeup interrupt must be generated. The early interrupt is generated when the IWDCNT is lower or equal to EWIT[11:0] - 1.\nEWIT[11:0] must be bigger than 1.\nAn interrupt is generated only if EWIE = 1.\nThe EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the reload value.\nNote: Reading this register returns the Early wakeup comparator value and the Interrupt enable bit from the VsubDD/sub voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing, hence the value read from this register is valid only when the EWU bit in the IWDG status register (IWDG_SR) is reset."
            },
            {
                "name": "EWIC",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Watchdog early interrupt acknowledge\nThe software must write a 1 into this bit in order to acknowledge the early wakeup interrupt and to clear the EWIF flag. Writing 0 has not effect, reading this flag returns a 0."
            },
            {
                "name": "EWIE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Watchdog early interrupt enable\nSet and reset by software.\nThe EWU bit in the IWDG status register (IWDG_SR) must be reset to be able to change the value of this bit."
            }
        ]
    },
    "1174415360": {
        "name": "I2C_CR1",
        "address": 1174415360,
        "size": 32,
        "access": "",
        "desc": "I2C control register 1",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Peripheral enable\nNote: When PE = 0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles."
            },
            {
                "name": "TXIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TX Interrupt enable"
            },
            {
                "name": "RXIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "RX Interrupt enable"
            },
            {
                "name": "ADDRIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address match Interrupt enable (slave only)"
            },
            {
                "name": "NACKIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not acknowledge received Interrupt enable"
            },
            {
                "name": "STOPIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Stop detection Interrupt enable"
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transfer Complete interrupt enable\nNote: Any of these events generate an interrupt:\nNote: Transfer Complete (TC)\nNote: Transfer Complete Reload (TCR)"
            },
            {
                "name": "ERRIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Error interrupts enable\nNote: Any of these errors generate an interrupt:\nNote: Arbitration Loss (ARLO)\nNote: Bus Error detection (BERR)\nNote: Overrun/Underrun (OVR)\nNote: Timeout detection (TIMEOUT)\nNote: PEC error detection (PECERR)\nNote: Alert pin event detection (ALERT)"
            },
            {
                "name": "DNF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Digital noise filter\nThese bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tsubI2CCLK/sub\nsub.../sub\nNote: If the analog filter is also enabled, the digital filter is added to the analog filter.\nNote: This filter can only be programmed when the I2C is disabled (PE = 0)."
            },
            {
                "name": "ANFOFF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Analog noise filter OFF\nNote: This bit can only be programmed when the I2C is disabled (PE = 0)."
            },
            {
                "name": "TXDMAEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "DMA transmission requests enable"
            },
            {
                "name": "RXDMAEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DMA reception requests enable"
            },
            {
                "name": "SBC",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Slave byte control\nThis bit is used to enable hardware byte control in slave mode."
            },
            {
                "name": "NOSTRETCH",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Clock stretching disable\nThis bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.\nNote: This bit can only be programmed when the I2C is disabled (PE = 0)."
            },
            {
                "name": "WUPEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Wakeup from Stop mode enable\nNote: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation.\nNote: WUPEN can be set only when DNF = '0000'"
            },
            {
                "name": "GCEN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "General call enable"
            },
            {
                "name": "SMBHEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "SMBus host address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            },
            {
                "name": "SMBDEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "SMBus device default address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            },
            {
                "name": "ALERTEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "SMBus alert enable\nNote: When ALERTEN=0, the SMBA pin can be used as a standard GPIO.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            },
            {
                "name": "PECEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "PEC enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            },
            {
                "name": "FMP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Fast-mode Plus 20 mA drive enable"
            },
            {
                "name": "ADDRACLR",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Address match flag (ADDR) automatic clear"
            },
            {
                "name": "STOPFACLR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "STOP detection flag (STOPF) automatic clear"
            }
        ]
    },
    "1174415364": {
        "name": "I2C_CR2",
        "address": 1174415364,
        "size": 32,
        "access": "",
        "desc": "I2C control register 2",
        "fields": [
            {
                "name": "SADD",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Slave address (master mode)\nIn 7-bit addressing mode (ADD10 = 0):\nSADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care.\nIn 10-bit addressing mode (ADD10 = 1):\nSADD[9:0] should be written with the 10-bit slave address to be sent.\nNote: Changing these bits when the START bit is set is not allowed."
            },
            {
                "name": "RD_WRN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Transfer direction (master mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "ADD10",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "10-bit addressing mode (master mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "HEAD10R",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "10-bit address header only read direction (master receiver mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "START",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Start generation\nThis bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by an address matched in slave mode, by a timeout error detection, or when PE = 0.\nIf the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer.\nOtherwise setting this bit generates a START condition once the bus is free.\nNote: Writing '0' to this bit has no effect.\nNote: The START bit can be set even if the bus is BUSY or I2C is in slave mode.\nNote: This bit has no effect when RELOAD is set."
            },
            {
                "name": "STOP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Stop generation (master mode)\nThe bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.\nIn Master Mode:\nNote: Writing '0' to this bit has no effect."
            },
            {
                "name": "NACK",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "NACK generation (slave mode)\nThe bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE = 0.\nNote: Writing '0' to this bit has no effect.\nNote: This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value.\nNote: When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value.\nNote: When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value."
            },
            {
                "name": "NBYTES",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Number of bytes\nThe number of bytes to be transmitted/received is programmed there. This field is don't care in slave mode with SBC=0.\nNote: Changing these bits when the START bit is set is not allowed."
            },
            {
                "name": "RELOAD",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "NBYTES reload mode\nThis bit is set and cleared by software."
            },
            {
                "name": "AUTOEND",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Automatic end mode (master mode)\nThis bit is set and cleared by software.\nNote: This bit has no effect in slave mode or when the RELOAD bit is set."
            },
            {
                "name": "PECBYTE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Packet error checking byte\nThis bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE = 0.\nNote: Writing '0' to this bit has no effect.\nNote: This bit has no effect when RELOAD is set.\nNote: This bit has no effect is slave mode when SBC=0.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            }
        ]
    },
    "1174415368": {
        "name": "I2C_OAR1",
        "address": 1174415368,
        "size": 32,
        "access": "",
        "desc": "I2C own address 1 register",
        "fields": [
            {
                "name": "OA1",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Interface own slave address\n7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care.\n10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.\nNote: These bits can be written only when OA1EN=0."
            },
            {
                "name": "OA1MODE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Own Address 1 10-bit mode\nNote: This bit can be written only when OA1EN=0."
            },
            {
                "name": "OA1EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Own Address 1 enable"
            }
        ]
    },
    "1174415372": {
        "name": "I2C_OAR2",
        "address": 1174415372,
        "size": 32,
        "access": "",
        "desc": "I2C own address 2 register",
        "fields": [
            {
                "name": "OA2",
                "bitOffset": 1,
                "bitWidth": 7,
                "desc": "Interface address\n7-bit addressing mode: 7-bit address\nNote: These bits can be written only when OA2EN=0."
            },
            {
                "name": "OA2MSK",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "Own Address 2 masks\nNote: These bits can be written only when OA2EN=0.\nNote: As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches."
            },
            {
                "name": "OA2EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Own Address 2 enable"
            }
        ]
    },
    "1174415376": {
        "name": "I2C_TIMINGR",
        "address": 1174415376,
        "size": 32,
        "access": "",
        "desc": "I2C timing register",
        "fields": [
            {
                "name": "SCLL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "SCL low period (master mode)\nThis field is used to generate the SCL low period in master mode.\ntsubSCLL /sub= (SCLL+1) x tsubPRESC/sub\nNote: SCLL is also used to generate tsubBUF /suband tsubSU:STA /subtimings."
            },
            {
                "name": "SCLH",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "SCL high period (master mode)\nThis field is used to generate the SCL high period in master mode.\ntsubSCLH /sub= (SCLH+1) x tsubPRESC/sub\nNote: SCLH is also used to generate tsubSU:STO /suband tsubHD:STA /subtiming."
            },
            {
                "name": "SDADEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Data hold time\nThis field is used to generate the delay tsubSDADEL /subbetween SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsubSDADEL/sub.\ntsubSDADEL/sub= SDADEL x tsubPRESC/sub\nNote: SDADEL is used to generate tsubHD:DAT /subtiming."
            },
            {
                "name": "SCLDEL",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Data setup time\nThis field is used to generate a delay tsubSCLDEL /subbetween SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsubSCLDEL/sub.\ntsubSCLDEL /sub= (SCLDEL+1) x tsubPRESC/sub\nNote: tsubSCLDEL/sub is used to generate tsubSU:DAT /subtiming."
            },
            {
                "name": "PRESC",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Timing prescaler\nThis field is used to prescale i2c_ker_ck in order to generate the clock period tsubPRESC /subused for data setup and hold counters (refer to FMPI2C timings on page 1928) and for SCL high and low level counters (refer to FMPI2C master initialization on page 1951).\ntsubPRESC /sub= (PRESC+1) x tsubI2CCLK/sub"
            }
        ]
    },
    "1174415380": {
        "name": "I2C_TIMEOUTR",
        "address": 1174415380,
        "size": 32,
        "access": "",
        "desc": "I2C timeout register",
        "fields": [
            {
                "name": "TIMEOUTA",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Bus Timeout A\nThis field is used to configure:\nThe SCL low timeout condition tsubTIMEOUT/sub when TIDLE=0\ntsubTIMEOUT/sub= (TIMEOUTA+1) x 2048 x tsubI2CCLK/sub\nThe bus idle condition (both SCL and SDA high) when TIDLE=1\ntsubIDLE/sub= (TIMEOUTA+1) x 4 x tsubI2CCLK/sub\nNote: These bits can be written only when TIMOUTEN=0."
            },
            {
                "name": "TIDLE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Idle clock timeout detection\nNote: This bit can be written only when TIMOUTEN=0."
            },
            {
                "name": "TIMOUTEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Clock timeout enable"
            },
            {
                "name": "TIMEOUTB",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Bus timeout B\nThis field is used to configure the cumulative clock extension timeout:\nIn master mode, the master cumulative clock low extend time (tsubLOW:MEXT/sub) is detected\nIn slave mode, the slave cumulative clock low extend time (tsubLOW:SEXT/sub) is detected\ntsubLOW:EXT/sub= (TIMEOUTB+1) x 2048 x tsubI2CCLK/sub\nNote: These bits can be written only when TEXTEN=0."
            },
            {
                "name": "TEXTEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Extended clock timeout enable"
            }
        ]
    },
    "1174415384": {
        "name": "I2C_ISR",
        "address": 1174415384,
        "size": 32,
        "access": "",
        "desc": "I2C interrupt and status register",
        "fields": [
            {
                "name": "TXE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Transmit data register empty (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register.\nThis bit can be written to '1' by software in order to flush the transmit data register I2C_TXDR.\nNote: This bit is set by hardware when PE = 0."
            },
            {
                "name": "TXIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transmit interrupt status (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register.\nThis bit can be written to '1' by software when NOSTRETCH = 1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN = 1).\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "RXNE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receive data register not empty (receivers)\nThis bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "ADDR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address matched (slave mode)\nThis bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "NACKF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not Acknowledge received flag\nThis flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "STOPF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Stop detection flag\nThis flag is set by hardware when a STOP condition is detected on the bus and the peripheral is involved in this transfer:\neither as a master, provided that the STOP condition is generated by the peripheral.\nor as a slave, provided that the peripheral has been addressed previously during this transfer.\nIt is cleared by software by setting the STOPCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transfer Complete (master mode)\nThis flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "TCR",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transfer Complete Reload\nThis flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value.\nNote: This bit is cleared by hardware when PE = 0.\nNote: This flag is only for master mode, or for slave mode when the SBC bit is set."
            },
            {
                "name": "BERR",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Bus error\nThis flag is set by hardware when a misplaced Start or STOP condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "ARLO",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Arbitration lost\nThis flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "OVR",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Overrun/Underrun (slave mode)\nThis flag is set by hardware in slave mode with NOSTRETCH = 1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.\nNote: This bit is cleared by hardware when PE = 0."
            },
            {
                "name": "PECERR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "PEC Error in reception\nThis flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit.\nNote: This bit is cleared by hardware when PE = 0.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            },
            {
                "name": "TIMEOUT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Timeout or tsubLOW/sub detection flag\nThis flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit.\nNote: This bit is cleared by hardware when PE = 0.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            },
            {
                "name": "ALERT",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SMBus alert\nThis flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit.\nNote: This bit is cleared by hardware when PE = 0.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            },
            {
                "name": "BUSY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Bus busy\nThis flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a STOP condition is detected, or when PE = 0."
            },
            {
                "name": "DIR",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Transfer direction (Slave mode)\nThis flag is updated when an address match event occurs (ADDR = 1)."
            },
            {
                "name": "ADDCODE",
                "bitOffset": 17,
                "bitWidth": 7,
                "desc": "Address match code (Slave mode)\nThese bits are updated with the received address when an address match event occurs (ADDR = 1).\nIn the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address."
            }
        ]
    },
    "1174415388": {
        "name": "I2C_ICR",
        "address": 1174415388,
        "size": 32,
        "access": "",
        "desc": "I2C interrupt clear register",
        "fields": [
            {
                "name": "ADDRCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address matched flag clear\nWriting 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register."
            },
            {
                "name": "NACKCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not Acknowledge flag clear\nWriting 1 to this bit clears the NACKF flag in I2C_ISR register."
            },
            {
                "name": "STOPCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "STOP detection flag clear\nWriting 1 to this bit clears the STOPF flag in the I2C_ISR register."
            },
            {
                "name": "BERRCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Bus error flag clear\nWriting 1 to this bit clears the BERRF flag in the I2C_ISR register."
            },
            {
                "name": "ARLOCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Arbitration lost flag clear\nWriting 1 to this bit clears the ARLO flag in the I2C_ISR register."
            },
            {
                "name": "OVRCF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Overrun/Underrun flag clear\nWriting 1 to this bit clears the OVR flag in the I2C_ISR register."
            },
            {
                "name": "PECCF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "PEC Error flag clear\nWriting 1 to this bit clears the PECERR flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            },
            {
                "name": "TIMOUTCF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Timeout detection flag clear\nWriting 1 to this bit clears the TIMEOUT flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            },
            {
                "name": "ALERTCF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Alert flag clear\nWriting 1 to this bit clears the ALERT flag in the I2C_ISR register.\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to Section 52.3: FMPI2C implementation."
            }
        ]
    },
    "1174415392": {
        "name": "I2C_PECR",
        "address": 1174415392,
        "size": 32,
        "access": "",
        "desc": "I2C PEC register",
        "fields": [
            {
                "name": "PEC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Packet error checking register\nThis field contains the internal PEC when PECEN=1.\nThe PEC is cleared by hardware when PE = 0."
            }
        ]
    },
    "1174415396": {
        "name": "I2C_RXDR",
        "address": 1174415396,
        "size": 32,
        "access": "",
        "desc": "I2C receive data register",
        "fields": [
            {
                "name": "RXDATA",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit receive data\nData byte received from the Isup2/supC bus"
            }
        ]
    },
    "1174415400": {
        "name": "I2C_TXDR",
        "address": 1174415400,
        "size": 32,
        "access": "",
        "desc": "I2C transmit data register",
        "fields": [
            {
                "name": "TXDATA",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit transmit data\nData byte to be transmitted to the Isup2/supC bus\nNote: These bits can be written only when TXE = 1."
            }
        ]
    },
    "1174415404": {
        "name": "I2C_AUTOCR",
        "address": 1174415404,
        "size": 32,
        "access": "",
        "desc": "I2C Autonomous mode control register",
        "fields": [
            {
                "name": "TCDMAEN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA request enable on Transfer Complete event"
            },
            {
                "name": "TCRDMAEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA request enable on Transfer Complete Reload event"
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Trigger selection (refer to Section 52.4.3: FMPI2C pins and internal signals I2C interconnections tables).\n...\nNote: This bit can be written only when PE = 0"
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Trigger polarity\nNote: This bit can be written only when PE = 0"
            },
            {
                "name": "TRIGEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Trigger enable\nWhen a trigger is detected, a START condition is sent and the transfer is launched as defined in I2C_CR2."
            }
        ]
    },
    "1174422528": {
        "name": "LPTIM1_ISR_output",
        "address": 1174422528,
        "size": 32,
        "access": "",
        "desc": "LPTIM1 interrupt and status register [alternate]",
        "fields": [
            {
                "name": "CC1IF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Compare 1 interrupt flag\nIf channel CC1 is configured as output:\nThe CC1IF flag is set by hardware to inform application that LPTIM_CNT register value matches the compare register's value. CC1IF flag can be cleared by writing 1 to the CC1CF bit in the LPTIM_ICR register."
            },
            {
                "name": "ARRM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match\nARRM is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register."
            },
            {
                "name": "EXTTRIG",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger edge event\nEXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CMP1OK",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK\nCMP1OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR1 register has been successfully completed. CMP1OK flag can be cleared by writing 1 to the CMP1OKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "ARROK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK\nARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "UP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Counter direction change down to up\nIn Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "DOWN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Counter direction change up to down\nIn Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "UE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPTIM update event occurred\nUE is set by hardware to inform application that an update event was generated. The corresponding interrupt or DMA request is generated if enabled. UE flag can be cleared by writing 1 to the UECF bit in the LPTIM_ICR register. The UE flag is automatically cleared by hardware once the LPTIM_ARR register is written by any bus master like CPU or DMA."
            },
            {
                "name": "REPOK",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK\nREPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_RCR register has been successfully completed. REPOK flag can be cleared by writing 1 to the REPOKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CC2IF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Compare 2 interrupt flag\nIf channel CC2 is configured as output:\nThe CC2IF flag is set by hardware to inform application that LPTIM_CNT register value matches the\ncompare register's value. CC2IF flag can be cleared by writing 1 to the CC2CF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "CMP2OK",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK\nCMP2OK is set by hardware to inform application that the APB bus write operation to the LPTIM_CCR2 register has been successfully completed. CMP2OK flag can be cleared by writing 1 to the CMP2OKCF bit in the LPTIM_ICR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "DIEROK",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Interrupt enable register update OK\nDIEROK is set by hardware to inform application that the APB bus write operation to the LPTIM_DIER register has been successfully completed. DIEROK flag can be cleared by writing 1 to the DIEROKCF bit in the LPTIM_ICR register."
            }
        ]
    },
    "1174422532": {
        "name": "LPTIM1_ICR_output",
        "address": 1174422532,
        "size": 32,
        "access": "",
        "desc": "LPTIM1 interrupt clear register [alternate]",
        "fields": [
            {
                "name": "CC1CF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 clear flag\nWriting 1 to this bit clears the CC1IF flag in the LPTIM_ISR register."
            },
            {
                "name": "ARRMCF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match clear flag\nWriting 1 to this bit clears the ARRM flag in the LPTIM_ISR register"
            },
            {
                "name": "EXTTRIGCF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge clear flag\nWriting 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register"
            },
            {
                "name": "CMP1OKCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK clear flag\nWriting 1 to this bit clears the CMP1OK flag in the LPTIM_ISR register."
            },
            {
                "name": "ARROKCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK clear flag\nWriting 1 to this bit clears the ARROK flag in the LPTIM_ISR register"
            },
            {
                "name": "UPCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP clear flag\nWriting 1 to this bit clear the UP flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "DOWNCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down clear flag\nWriting 1 to this bit clear the DOWN flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "UECF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Update event clear flag\nWriting 1 to this bit clear the UE flag in the LPTIM_ISR register."
            },
            {
                "name": "REPOKCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK clear flag\nWriting 1 to this bit clears the REPOK flag in the LPTIM_ISR register."
            },
            {
                "name": "CC2CF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 2 clear flag\nWriting 1 to this bit clears the CC2IF flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "CMP2OKCF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK clear flag\nWriting 1 to this bit clears the CMP2OK flag in the LPTIM_ISR register.\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "DIEROKCF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Interrupt enable register update OK clear flag\nWriting 1 to this bit clears the DIEROK flag in the LPTIM_ISR register."
            }
        ]
    },
    "1174422536": {
        "name": "LPTIM1_DIER_output",
        "address": 1174422536,
        "size": 32,
        "access": "",
        "desc": "LPTIM1 interrupt enable register [alternate]",
        "fields": [
            {
                "name": "CC1IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt enable"
            },
            {
                "name": "ARRMIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match Interrupt Enable"
            },
            {
                "name": "EXTTRIGIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge Interrupt Enable"
            },
            {
                "name": "CMP1OKIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register 1 update OK interrupt enable"
            },
            {
                "name": "ARROKIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK Interrupt Enable"
            },
            {
                "name": "UPIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "DOWNIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "UEIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Update event interrupt enable"
            },
            {
                "name": "REPOKIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Repetition register update OK interrupt Enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 2 interrupt enable\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "CMP2OKIE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Compare register 2 update OK interrupt enable\nNote: If LPTIM does not implement at least 2 channels this bit is reserved. Refer to Section69.3."
            },
            {
                "name": "UEDE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Update event DMA request enable\nNote: If LPTIM does not implement at least 1 channel this bit is reserved. Refer to Section69.3."
            }
        ]
    },
    "1174414336": {
        "name": "LPUART_CR1",
        "address": 1174414336,
        "size": 32,
        "access": "read-write",
        "desc": "LPUART control register 1",
        "fields": [
            {
                "name": "UE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPUART enable\n\nWhen this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software.\n\nNote: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit.\n\nNote: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit."
            },
            {
                "name": "UESM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPUART enable in low-power mode\n\nWhen this bit is cleared, the LPUART cannot request its kernel clock and is not functional in low-power mode.\n\nWhen this bit is set, the LPUART can wake up the MCU from low-power mode.\n\nThis bit is set and cleared by software.\n\nNote: The UESM bit must be set at the initialization phase.\n\nNote: If the LPUART does not support the Wakeup from low-power mode, this bit is reserved and must be kept at reset value. Refer to Section 79.3: LPUART implementation on page 4652."
            },
            {
                "name": "RE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receiver enable\n\nThis bit enables the receiver. It is set and cleared by software."
            },
            {
                "name": "TE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transmitter enable\n\nThis bit enables the transmitter. When the Autonomous mode is not used, TE bit is set and cleared by software. When the Autonomous mode is used, TE bit becomes a status bit, which is set and cleared by hardware.\n\nNote: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.\n\nNote: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts."
            },
            {
                "name": "IDLEIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "IDLE interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFNEIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFNFIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "PEIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "PE interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "PS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Parity selection\n\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "PCE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Parity control enable\n\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "WAKE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver wakeup method\n\nThis bit determines the LPUART wakeup method from Mute mode. It is set or cleared by software.\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "M0",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Word length\n\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description).\n\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "MME",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Mute mode enable\n\nThis bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software."
            },
            {
                "name": "CMIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Character match interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "DEDT",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Driver Enable deassertion time\n\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section 79.4.14: RS232 Hardware flow control and RS485 Driver Enable.\n\nIf the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DEAT",
                "bitOffset": 21,
                "bitWidth": 5,
                "desc": "Driver Enable assertion time\n\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer Section 78.5.21: RS232 Hardware flow control and RS485 Driver Enable.\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "M1",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Word length\n\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\n\nM[1:0] = 00: 1 Start bit, 8 Data bits, n Stop bit\n\nM[1:0] = 01: 1 Start bit, 9 Data bits, n Stop bit\n\nM[1:0] = '10: 1 Start bit, 7 Data bits, n Stop bit\n\nThis bit can only be written when the LPUART is disabled (UE=0).\n\nNote: In 7-bit data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported."
            },
            {
                "name": "FIFOEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "FIFO mode enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFEIE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TXFIFO empty interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFFIE",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RXFIFO Full interrupt enable\n\nThis bit is set and cleared by software."
            }
        ]
    },
    "1174414340": {
        "name": "LPUART_CR2",
        "address": 1174414340,
        "size": 32,
        "access": "read-write",
        "desc": "LPUART control register 2",
        "fields": [
            {
                "name": "ADDM7",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "7-bit Address Detection/4-bit Address Detection\n\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\n\nThis bit can only be written when the LPUART is disabled (UE=0)\n\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively."
            },
            {
                "name": "STOP",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "STOP bits\n\nThese bits are used for programming the stop bits.\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "SWAP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Swap TX/RX pins\n\nThis bit is set and cleared by software.\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "RXINV",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "RX pin active level inversion\n\nThis bit is set and cleared by software.\n\nThis enables the use of an external inverter on the RX line.\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "TXINV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TX pin active level inversion\n\nThis bit is set and cleared by software.\n\nThis enables the use of an external inverter on the TX line.\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DATAINV",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Binary data inversion\n\nThis bit is set and cleared by software.\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "MSBFIRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Most significant bit first\n\nThis bit is set and cleared by software.\n\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "ADD",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Address of the LPUART node\n\nThese bits give the address of the LPUART node in Mute mode or a character code to be recognized in low-power or Run mode:\n\nIn Mute mode: they are used in multiprocessor communication to wakeup from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.\n\nIn low-power mode: they are used for wake up from low-power mode on character match.\n\nWhen a character, received during low-power mode, corresponds to the character programmed through ADD[7:0] bitfield, the CMF flag is set and wakes up the device from low-power mode if the corresponding interrupt is enabled by setting CMIE bit.\n\nIn Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.\n\nThese bits can only be written when the reception is disabled (RE = 0) or when the USART is disabled (UE = 0)."
            }
        ]
    },
    "1174414344": {
        "name": "LPUART_CR3",
        "address": 1174414344,
        "size": 32,
        "access": "read-write",
        "desc": "LPUART control register 3",
        "fields": [
            {
                "name": "EIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Error interrupt enable\n\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FE=1 or ORE=1 or NE=1 in the LPUART_ISR register)."
            },
            {
                "name": "HDSEL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Half-duplex selection\n\nSelection of Single-wire Half-duplex mode\n\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DMAR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA enable receiver\n\nThis bit is set/reset by software"
            },
            {
                "name": "DMAT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA enable transmitter\n\nThis bit is set/reset by software"
            },
            {
                "name": "RTSE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "RTS enable\n\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "CTSE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS enable\n\nThis bit can only be written when the LPUART is disabled (UE=0)"
            },
            {
                "name": "CTSIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS interrupt enable"
            },
            {
                "name": "OVRDIS",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun Disable\n\nThis bit is used to disable the receive overrun detection.\n\nthe ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register.\n\nThis bit can only be written when the LPUART is disabled (UE=0).\n\nNote: This control bit enables checking the communication flow w/o reading the data."
            },
            {
                "name": "DDRE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DMA Disable on Reception Error\n\nThis bit can only be written when the LPUART is disabled (UE=0).\n\nNote: The reception errors are: parity error, framing error or noise error."
            },
            {
                "name": "DEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Driver enable mode\n\nThis bit enables the user to activate the external transceiver control, through the DE signal.\n\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DEP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Driver enable polarity selection\n\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "TXFTIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO threshold interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFTCFG",
                "bitOffset": 25,
                "bitWidth": 3,
                "desc": "Receive FIFO threshold configuration\n\nRemaining combinations: Reserved."
            },
            {
                "name": "RXFTIE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "RXFIFO threshold interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFTCFG",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "TXFIFO threshold configuration\n\nRemaining combinations: Reserved."
            }
        ]
    },
    "1174414348": {
        "name": "LPUART_BRR",
        "address": 1174414348,
        "size": 32,
        "access": "read-write",
        "desc": "LPUART baud rate register",
        "fields": [
            {
                "name": "BRR",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "LPUART baud rate division (LPUARTDIV)"
            }
        ]
    },
    "1174414360": {
        "name": "LPUART_RQR",
        "address": 1174414360,
        "size": 32,
        "access": "write-only",
        "desc": "LPUART request register",
        "fields": [
            {
                "name": "SBKRQ",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Send break request\n\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\n\nNote: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit."
            },
            {
                "name": "MMRQ",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Mute mode request\n\nWriting 1 to this bit puts the LPUART in Mute mode and resets the RWU flag."
            },
            {
                "name": "RXFRQ",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Receive data flush request\n\nWriting 1 to this bit clears the RXNE flag.\n\nThis enables discarding the received data without reading it, and avoid an overrun condition."
            },
            {
                "name": "TXFRQ",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Transmit data flush request\n\nThis bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register).\n\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register."
            }
        ]
    },
    "1174414364": {
        "name": "LPUART_ISR",
        "address": 1174414364,
        "size": 32,
        "access": "read-only",
        "desc": "LPUART interrupt and status register",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error\n\nThis bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register.\n\nAn interrupt is generated if PEIE = 1 in the LPUART_CR1 register.\n\nNote: This error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "FE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error\n\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register.\n\nWhen transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).\n\nAn interrupt is generated if EIE = 1 in the LPUART_CR1 register.\n\nNote: This error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Start bit noise detection flag\n\nThis bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NFCF bit in the LPUART_ICR register.\n\nNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.\n\nNote: This error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "ORE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error\n\nThis bit is set by hardware when the data currently being received in the shift register is\n\nready to be transferred into the LPUART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register.\n\nAn interrupt is generated if RXFNEIE=1 or EIE = 1 in the LPUART_CR1 register.\n\nNote: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.\n\nNote: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register."
            },
            {
                "name": "IDLE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected\n\nThis bit is set by hardware when an Idle line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register.\n\nNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).\n\nNote: If Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set."
            },
            {
                "name": "RXFNE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty\n\nRXFNE bit is set by hardware when the RXFIFO is not empty, and so data can be read from the LPUART_RDR register. Every read of the LPUART_RDR frees a location in the RXFIFO. It is cleared when the RXFIFO is empty.\n\nThe RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register.\n\nAn interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete\n\nThis bit indicates that the last data written in the LPUART_TDR has been transmitted out of the shift register. The TC flag behaves as follows:\n\nWhen TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXFE is set.\n\nWhen TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached.\n\nWhen TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred.\n\nWhen TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty.\n\nAn interrupt is generated if TCIE=1 in the LPUART_CR1 register.\n\nTC bit is cleared by software by writing 1 to the TCCF in the LPUART_ICR register or by writing to the LPUART_TDR register."
            },
            {
                "name": "TXFNF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full\n\nTXFNF is set by hardware when TXFIFO is not full, and so data can be written in the LPUART_TDR. Every write in the LPUART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the LPUART_TDR.\n\nThe TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time).\n\nAn interrupt is generated if the TXFNFIE bit =1 in the LPUART_CR1 register.\n\nNote: This bit is used during single buffer transmission."
            },
            {
                "name": "CTSIF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS interrupt flag\n\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register.\n\nAn interrupt is generated if CTSIE=1 in the LPUART_CR3 register.\n\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "CTS",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS flag\n\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\n\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "BUSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Busy flag\n\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not)."
            },
            {
                "name": "CMF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match flag\n\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register.\n\nAn interrupt is generated if CMIE=1in the LPUART_CR1 register."
            },
            {
                "name": "SBKF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Send break flag\n\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission."
            },
            {
                "name": "RWU",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Receiver wakeup from Mute mode\n\nThis bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register.\n\nWhen wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register.\n\nNote: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "TEACK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Transmit enable acknowledge flag\n\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART.\n\nIt can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period."
            },
            {
                "name": "REACK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Receive enable acknowledge flag\n\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART.\n\nIt can be used to verify that the LPUART is ready for reception before entering low-power mode.\n\nNote: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "TXFE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO Empty\n\nThis bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the LPUART_RQR register.\n\nAn interrupt is generated if the TXFEIE bit =1 (bit 30) in the LPUART_CR1 register."
            },
            {
                "name": "RXFF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "RXFIFO Full\n\nThis bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the LPUART_RDR register.\n\nAn interrupt is generated if the RXFFIE bit =1 in the LPUART_CR1 register."
            },
            {
                "name": "RXFT",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "RXFIFO threshold flag\n\nThis bit is set by hardware when the RXFIFO reaches the threshold programmed in RXFTCFG in LPUART_CR3 register i.e. the Receive FIFO contains RXFTCFG data. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the LPUART_CR3 register."
            },
            {
                "name": "TXFT",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "TXFIFO threshold flag\n\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG in LPUART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the LPUART_CR3 register."
            }
        ]
    },
    "1174414368": {
        "name": "LPUART_ICR",
        "address": 1174414368,
        "size": 32,
        "access": "write-only",
        "desc": "LPUART interrupt flag clear register",
        "fields": [
            {
                "name": "PECF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error clear flag\n\nWriting 1 to this bit clears the PE flag in the LPUART_ISR register."
            },
            {
                "name": "FECF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error clear flag\n\nWriting 1 to this bit clears the FE flag in the LPUART_ISR register."
            },
            {
                "name": "NECF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detected clear flag\n\nWriting 1 to this bit clears the NE flag in the LPUART_ISR register."
            },
            {
                "name": "ORECF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error clear flag\n\nWriting 1 to this bit clears the ORE flag in the LPUART_ISR register."
            },
            {
                "name": "IDLECF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected clear flag\n\nWriting 1 to this bit clears the IDLE flag in the LPUART_ISR register."
            },
            {
                "name": "TCCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete clear flag\n\nWriting 1 to this bit clears the TC flag in the LPUART_ISR register."
            },
            {
                "name": "CTSCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS clear flag\n\nWriting 1 to this bit clears the CTSIF flag in the LPUART_ISR register."
            },
            {
                "name": "CMCF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match clear flag\n\nWriting 1 to this bit clears the CMF flag in the LPUART_ISR register."
            }
        ]
    },
    "1174414372": {
        "name": "LPUART_RDR",
        "address": 1174414372,
        "size": 32,
        "access": "read-only",
        "desc": "LPUART receive data register",
        "fields": [
            {
                "name": "RDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Receive data value\n\nContains the received data character.\n\nThe RDR register provides the parallel interface between the input shift register and the internal bus (see Figure 952).\n\nWhen receiving with the parity enabled, the value read in the MSB bit is the received parity bit."
            }
        ]
    },
    "1174414376": {
        "name": "LPUART_TDR",
        "address": 1174414376,
        "size": 32,
        "access": "read-write",
        "desc": "LPUART transmit data register",
        "fields": [
            {
                "name": "TDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Transmit data value\n\nContains the data character to be transmitted.\n\nThe TDR register provides the parallel interface between the internal bus and the output shift register (see Figure 952).\n\nWhen transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.\n\nNote: This register must be written only when TXE/TXFNF=1."
            }
        ]
    },
    "1174414380": {
        "name": "LPUART_PRESC",
        "address": 1174414380,
        "size": 32,
        "access": "read-write",
        "desc": "LPUART prescaler register",
        "fields": [
            {
                "name": "PRESCALER",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Clock prescaler\n\nThe LPUART input clock can be divided by a prescaler:\n\nRemaining combinations: Reserved.\n\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256."
            }
        ]
    },
    "1174414384": {
        "name": "LPUART_AUTOCR",
        "address": 1174414384,
        "size": 32,
        "access": "read-write",
        "desc": "LPUART Autonomous mode control register",
        "fields": [
            {
                "name": "TDN",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "TDC transmission data number\n\nThis bitfield enables the programming of the number of data to be transmitted. It can be written only when UE is cleared in LPUART_CR1."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Trigger polarity bit\n\nThis bitfield can be written only when the UE bit is cleared in LPUART_CR1 register."
            },
            {
                "name": "TRIGEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Trigger enable bit\n\nNote: This bitfield can be written only when the UE bit of USART_CR1 register is cleared.\n\nNote: When a trigger is detected, TE is set to 1 in LPUART_CR1 and the data transfer is launched."
            },
            {
                "name": "IDLEDIS",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Idle frame transmission disable bit after enabling the transmitter\n\nNote: This bitfield can be written only when the UE bit of USART_CR1 register is cleared."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 19,
                "bitWidth": 4,
                "desc": "Trigger selection bits\n\nRefer to Section : Description LPUART interconnections.\n\nThis bitfield can be written only when the UE bit is cleared in LPUART_CR1 register.\n\n...\n\nNote: This bitfield can be written only when the UE bit of USART_CR1 register is cleared."
            }
        ]
    },
    "1108090880": {
        "name": "PKA_CR",
        "address": 1108090880,
        "size": 32,
        "access": "",
        "desc": "PKA control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "PKA enable.\nWhen an illegal operation is selected while EN=1 OPERRF bit is set in PKA_SR. See PKA_CR.MODE bitfield for details.\nNote: When EN=0 PKA RAM can still be accessed by the application."
            },
            {
                "name": "START",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "start the operation\nWriting 1 to this bit starts the operation which is selected by MODE[5:0], using the operands and data already written to the PKA RAM. This bit is always read as 0.\nWhen an illegal operation is selected while START bit is set no operation is started, and OPERRF bit is set in PKA_SR.\nNote: START is ignored if PKA is busy."
            },
            {
                "name": "MODE",
                "bitOffset": 8,
                "bitWidth": 6,
                "desc": "PKA operation code\nWhen an operation not listed here is written by the application with EN bit set, OPERRF bit is set in PKA_SR register, and the write to MODE bitfield is ignored. When PKA is configured in limited mode (LMF = 1 in PKA_SR), writing a MODE different from 0x26 with EN bit to 1 triggers OPERRF bit to be set and write to MODE bit is ignored."
            },
            {
                "name": "PROCENDIE",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "End of operation interrupt enable"
            },
            {
                "name": "RAMERRIE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "RAM error interrupt enable"
            },
            {
                "name": "ADDRERRIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Address error interrupt enable"
            },
            {
                "name": "OPERRIE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Operation error interrupt enable"
            }
        ]
    },
    "1108090884": {
        "name": "PKA_SR",
        "address": 1108090884,
        "size": 32,
        "access": "",
        "desc": "PKA status register",
        "fields": [
            {
                "name": "INITOK",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "PKA initialization OK\nThis bit is asserted when PKA initialization is complete. When RNG is not able to output proper random numbers INITOK stays at 0."
            },
            {
                "name": "LMF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Limited mode flag\nThis bit is updated when EN bit in PKA_CR is set"
            },
            {
                "name": "BUSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "PKA operation is in progress\nThis bit is set to 1 whenever START bit in the PKA_CR is set. It is automatically cleared when the computation is complete, meaning that PKA RAM can be safely accessed and a new operation can be started.\nIf PKA is started with a wrong opcode, it is busy for a couple of cycles, then it aborts automatically the operation and go back to ready (BUSY bit is set to 0)."
            },
            {
                "name": "PROCENDF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "PKA End of Operation flag"
            },
            {
                "name": "RAMERRF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "PKA RAM error flag\nThis bit is cleared using RAMERRFC bit in PKA_CLRFR."
            },
            {
                "name": "ADDRERRF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Address error flag\nThis bit is cleared using ADDRERRFC bit in PKA_CLRFR."
            },
            {
                "name": "OPERRF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Operation error flag\nThis bit is cleared using OPERRFC bit in PKA_CLRFR."
            }
        ]
    },
    "1108090888": {
        "name": "PKA_CLRFR",
        "address": 1108090888,
        "size": 32,
        "access": "",
        "desc": "PKA clear flag register",
        "fields": [
            {
                "name": "PROCENDFC",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Clear PKA End of Operation flag"
            },
            {
                "name": "RAMERRFC",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Clear PKA RAM error flag"
            },
            {
                "name": "ADDRERRFC",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Clear address error flag"
            },
            {
                "name": "OPERRFC",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Clear operation error flag"
            }
        ]
    },
    "1174538240": {
        "name": "PWR_CR1",
        "address": 1174538240,
        "size": 32,
        "access": "",
        "desc": "PWR control register 1",
        "fields": [
            {
                "name": "LPMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Low-power mode selection\nThese bits select the low-power mode entered when the CPU enters the SleepDeep mode.\n10x: Standby mode\nothers reserved"
            },
            {
                "name": "R2RSB1",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "SRAM2 retention in Standby mode\nThis bit is used to keep the SRAM2 content in Standby retention mode."
            },
            {
                "name": "ULPMEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "BOR0 ultra-low-power mode.\nThis bit is used to reduce the consumption by configuring the BOR0 in discontinuous mode for Stop 1 and Standby modes. Discontinuous mode is only available when BOR levels 1 to 4 and PVD are disabled.\nNote: This bit must be set to reach the lowest power consumption in the low-power modes.\nNote: This bit must not be set together with autonomous peripherals using HSI16 as kernel clock.\nNote: When BOR level 1 to 4 or PVD is enabled continuous mode applies independent from ULPMEN."
            },
            {
                "name": "RADIORSB",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "2.4 GHz RADIO SRAMs (RXTXRAM and Sequence RAM) and Sleep clock retention in Standby mode.\nThis bit is used to keep the 2.4 GHz RADIO SRAMs content in Standby retention mode and the 2.4 GHz RADIO sleep timer counter operational."
            },
            {
                "name": "R1RSB1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SRAM1 retention in Standby mode\nThis bit is used to keep the SRAM1 content in Standby retention mode."
            }
        ]
    },
    "1174538244": {
        "name": "PWR_CR2",
        "address": 1174538244,
        "size": 32,
        "access": "",
        "desc": "PWR control register 2",
        "fields": [
            {
                "name": "SRAM1PDS1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SRAM1 power-down in Stop modes (Stop 0, 1)\nNote: The SRAM1 retention in Standby mode is controlled by R1RSB1 bit in PWR_CR1."
            },
            {
                "name": "SRAM2PDS1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "SRAM2 power-down in Stop modes (Stop 0, 1)\nNote: The SRAM2 retention in Standby mode is controlled by R2RSB1 bit in PWR_CR1."
            },
            {
                "name": "ICRAMPDS",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "ICACHE SRAM power-down in Stop modes (Stop 0, 1)"
            },
            {
                "name": "FLASHFWU",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Flash memory fast wakeup from Stop modes (Stop 0, 1)\nThis bit is used to obtain the best trade-off between low-power consumption and wakeup time when exiting the Stop 0 or Stop 1 modes.\nWhen this bit is set, the Flash memory remains in normal mode in Stop 0 and Stop 1 modes, which offers a faster startup time with higher consumption."
            }
        ]
    },
    "1174538248": {
        "name": "PWR_CR3",
        "address": 1174538248,
        "size": 32,
        "access": "",
        "desc": "PWR control register 3",
        "fields": [
            {
                "name": "REGSEL",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Regulator selection"
            },
            {
                "name": "FSTEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Fast soft start"
            }
        ]
    },
    "1174538252": {
        "name": "PWR_VOSR",
        "address": 1174538252,
        "size": 32,
        "access": "",
        "desc": "PWR voltage scaling register",
        "fields": [
            {
                "name": "VOSRDY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Ready bit for VsubCORE/sub voltage scaling output selection\nSet and cleared by hardware. When decreasing the voltage scaling range, VOSRDY must be one before increasing the SYSCLK frequency."
            },
            {
                "name": "VOS",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Voltage scaling range selection\nSet a and cleared by software.\nCleared by hardware when entering Stop 1 mode.\nAccess can be secured by RCC SYSCLKSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538256": {
        "name": "PWR_SVMCR",
        "address": 1174538256,
        "size": 32,
        "access": "",
        "desc": "PWR supply voltage monitoring control register",
        "fields": [
            {
                "name": "PVDE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Programmable voltage detector enable"
            },
            {
                "name": "PVDLS",
                "bitOffset": 5,
                "bitWidth": 3,
                "desc": "Programmable voltage detector level selection\nThese bits select the voltage threshold detected by the programmable voltage detector:"
            }
        ]
    },
    "1174538260": {
        "name": "PWR_WUCR1",
        "address": 1174538260,
        "size": 32,
        "access": "",
        "desc": "PWR wakeup control register 1",
        "fields": [
            {
                "name": "WUPEN1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pin WKUP1 enable\nAccess can be secured by PWR WUP1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPEN2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pin WKUP2 enable\nAccess can be secured by PWR WUP2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPEN3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pin WKUP3 enable\nAccess can be secured by PWR WUP3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPEN4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pin WKUP4 enable\nAccess can be secured by PWR WUP4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPEN5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pin WKUP5 enable\nAccess can be secured by PWR WUP5SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPEN6",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pin WKUP6 enable\nAccess can be secured by PWR WUP6SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPEN7",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pin WKUP7 enable\nAccess can be secured by PWR WUP7SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPEN8",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pin WKUP8 enable\nAccess can be secured by PWR WUP8SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538264": {
        "name": "PWR_WUCR2",
        "address": 1174538264,
        "size": 32,
        "access": "",
        "desc": "PWR wakeup control register 2",
        "fields": [
            {
                "name": "WUPP1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP1 polarity.\nThis bit must be configured when WUPEN1 = 0.\nAccess can be secured by PWR WUP1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPP2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP2 polarity\nThis bit must be configured when WUPEN2 = 0.\nAccess can be secured by PWR WUP2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPP3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP3 polarity\nThis bit must be configured when WUPEN3 = 0.\nAccess can be secured by PWR WUP3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPP4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP4 polarity\nThis bit must be configured when WUPEN4 = 0.\nAccess can be secured by PWR WUP4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPP5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP5 polarity\nThis bit must be configured when WUPEN5 = 0.\nAccess can be secured by PWR WUP5SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPP6",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP6 polarity\nThis bit must be configured when WUPEN6 = 0.\nAccess can be secured by PWR WUP6SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPP7",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP7 polarity\nThis bit must be configured when WUPEN7 = 0.\nAccess can be secured by PWR WUP7SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUPP8",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP8 polarity\nThis bit must be configured when WUPEN8 = 0.\nAccess can be secured by PWR WUP8SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538268": {
        "name": "PWR_WUCR3",
        "address": 1174538268,
        "size": 32,
        "access": "",
        "desc": "PWR wakeup control register 3",
        "fields": [
            {
                "name": "WUSEL1",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Wakeup and interrupt pin WKUP1 selection\nThis field must be configured when WUPEN1 = 0.\nAccess can be secured by PWR WUP1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUSEL2",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Wakeup and interrupt pin WKUP2 selection\nThis field must be configured when WUPEN2 = 0.\nAccess can be secured by PWR WUP2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUSEL3",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Wakeup and interrupt pin WKUP3 selection\nThis field must be configured when WUPEN3 = 0.\nAccess can be secured by PWR WUP3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUSEL4",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Wakeup and interrupt pin WKUP4 selection\nThis field must be configured when WUPEN4 = 0.\nAccess can be secured by PWR WUP4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUSEL5",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Wakeup and interrupt pin WKUP5 selection\nThis field must be configured when WUPEN5 = 0.\nAccess can be secured by PWR WUP5SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUSEL6",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Wakeup and interrupt pin WKUP6 selection\nThis field must be configured when WUPEN6 = 0.\nAccess can be secured by PWR WUP6SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUSEL7",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Wakeup and interrupt pin WKUP7 selection\nThis field must be configured when WUPEN7 = 0.\nAccess can be secured by PWR WUP7SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "WUSEL8",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Wakeup and interrupt pin WKUP8 selection\nThis field must be configured when WUPEN8 = 0.\nAccess can be secured by PWR WUP8SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538280": {
        "name": "PWR_DBPR",
        "address": 1174538280,
        "size": 32,
        "access": "",
        "desc": "PWR disable Backup domain register",
        "fields": [
            {
                "name": "DBP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Disable Backup domain write protection\nIn reset state, all registers and SRAM in Backup domain are protected against parasitic write access. This bit must be set to enable the write access to these registers."
            }
        ]
    },
    "1174538288": {
        "name": "PWR_SECCFGR",
        "address": 1174538288,
        "size": 32,
        "access": "",
        "desc": "PWR security configuration register",
        "fields": [
            {
                "name": "WUP1SEC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "WUP1 secure protection"
            },
            {
                "name": "WUP2SEC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "WUP2 secure protection"
            },
            {
                "name": "WUP3SEC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "WUP3 secure protection"
            },
            {
                "name": "WUP4SEC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "WUP4 secure protection"
            },
            {
                "name": "WUP5SEC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "WUP5 secure protection"
            },
            {
                "name": "WUP6SEC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "WUP6 secure protection"
            },
            {
                "name": "WUP7SEC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "WUP7 secure protection"
            },
            {
                "name": "WUP8SEC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "WUP8 secure protection"
            },
            {
                "name": "LPMSEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Low-power modes secure protection"
            },
            {
                "name": "VDMSEC",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Voltage detection secure protection"
            },
            {
                "name": "VBSEC",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Backup domain secure protection"
            }
        ]
    },
    "1174538292": {
        "name": "PWR_PRIVCFGR",
        "address": 1174538292,
        "size": 32,
        "access": "",
        "desc": "PWR privilege control register",
        "fields": [
            {
                "name": "SPRIV",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "PWR secure functions privilege configuration\nThis bit is set and reset by software.\nIt can be written only by a secure privileged access."
            },
            {
                "name": "NSPRIV",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "PWR non-secure functions privilege configuration\nThis bit is set and reset by software.\nIt can be written only by privileged access, secure or non-secure."
            }
        ]
    },
    "1174538296": {
        "name": "PWR_SR",
        "address": 1174538296,
        "size": 32,
        "access": "",
        "desc": "PWR status register",
        "fields": [
            {
                "name": "CSSF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear Stop and Standby flags\nAccess can be secured by PWR LPMSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.\nWriting 1 to this bit clears the STOPF and SBF flags."
            },
            {
                "name": "STOPF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Stop flag\nThis bit is set by hardware when the device enters a Stop or Standby mode at the same time as the sysclk has been set by hardware to select HSI16. It's cleared by software by writing 1 to the CSSF bit and by hardware when SBF is set."
            },
            {
                "name": "SBF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Standby flag\nThis bit is set by hardware when the device enters the Standby mode and the CPU restart from its reset vector. It's cleared by writing 1 to the CSSF bit, or by a power-on reset. It is not cleared by the system reset."
            }
        ]
    },
    "1174538300": {
        "name": "PWR_SVMSR",
        "address": 1174538300,
        "size": 32,
        "access": "",
        "desc": "PWR supply voltage monitoring status register",
        "fields": [
            {
                "name": "REGS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Regulator selection"
            },
            {
                "name": "PVDO",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Programmable voltage detector output"
            },
            {
                "name": "ACTVOSRDY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Voltage level ready for currently used VOS"
            },
            {
                "name": "ACTVOS",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "VOS currently applied to VsubCORE/sub\nThis field provides the last VOS value."
            }
        ]
    },
    "1174538308": {
        "name": "PWR_WUSR",
        "address": 1174538308,
        "size": 32,
        "access": "",
        "desc": "PWR wakeup status register",
        "fields": [
            {
                "name": "WUF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pending flag 1\nThis bit is set when a wakeup event is detected on WKUP1 pin. This bit is cleared by writing 1 in the CWUF1 bit of PWR_WUSCR or by hardware when WUPEN1 = 0."
            },
            {
                "name": "WUF2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pending flag 2\nThis bit is set when a wakeup event is detected on WKUP2 pin. This bit is cleared by writing 1 in the CWUF2 bit of PWR_WUSCR or by hardware when WUPEN2 = 0."
            },
            {
                "name": "WUF3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pending flag 3\nThis bit is set when a wakeup event is detected on WKUP3 pin. This bit is cleared by writing 1 in the CWUF3 bit of PWR_WUSCR or by hardware when WUPEN3 = 0."
            },
            {
                "name": "WUF4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pending flag 4\nThis bit is set when a wakeup event is detected on WKUP4 pin. This bit is cleared by writing 1 in the CWUF4 bit of PWR_WUSCR or by hardware when WUPEN4 = 0."
            },
            {
                "name": "WUF5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pending flag 5\nThis bit is set when a wakeup event is detected on WKUP5 pin. This bit is cleared by writing 1 in the CWUF5 bit of PWR_WUSCR or by hardware when WUPEN5 = 0."
            },
            {
                "name": "WUF6",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pending flag 6\nThis bit is set when a wakeup event is detected on WKUP6 pin. This bit is cleared by writing 1 in the CWUF6 bit of PWR_WUSCR when WUSEL6 different 11, or by hardware when WUPEN6 = 0.\nWhen WUSEL6 = 11, this bit is cleared by hardware when all associated internal wakeup source are cleared.\nWhen WUSEL6 = 11, no WKUP interrupt is generated"
            },
            {
                "name": "WUF7",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pending flag 7\nThis bit is set when a wakeup event is detected on WKUP7 pin. This bit is cleared by writing 1 in the CWUF7 bit of PWR_WUSCR when WUSEL7 different 11, or by hardware when WUPEN7 = 0.\nWhen WUSEL7 = 11, this bit is cleared by hardware when all associated internal wakeup source are cleared.\nWhen WUSEL7 = 11, no WKUP interrupt is generated."
            },
            {
                "name": "WUF8",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Wakeup and interrupt pending flag 8\nThis bit is set when a wakeup event is detected on WKUP8 pin. This bit is cleared by writing 1 in the CWUF8 bit of PWR_WUSCR when WUSEL8 different 11, or by hardware when WUPEN8 = 0.\nWhen WUSEL8 = 11, this bit is cleared by hardware when all associated internal wakeup source are cleared.\nWhen WUSEL8 = 11, no WKUP interrupt is generated"
            }
        ]
    },
    "1174538312": {
        "name": "PWR_WUSCR",
        "address": 1174538312,
        "size": 32,
        "access": "",
        "desc": "PWR wakeup status clear register",
        "fields": [
            {
                "name": "CWUF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 1\nAccess can be secured by PWR WUP1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.\nWriting 1 to this bit clears the WUF1 flag in PWR_WUSR."
            },
            {
                "name": "CWUF2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 2\nAccess can be secured by PWR WUP2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.\nWriting 1 to this bit clears the WUF2 flag in PWR_WUSR."
            },
            {
                "name": "CWUF3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 3\nAccess can be secured by PWR WUP3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.\nWriting 1 to this bit clears the WUF3 flag in PWR_WUSR."
            },
            {
                "name": "CWUF4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 4\nAccess can be secured by PWR WUP4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.\nWriting 1 to this bit clears the WUF4 flag in PWR_WUSR."
            },
            {
                "name": "CWUF5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 5\nAccess can be secured by PWR WUP5SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.\nWriting 1 to this bit clears the WUF5 flag in PWR_WUSR."
            },
            {
                "name": "CWUF6",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 6\nAccess can be secured by PWR WUP6SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.\nWriting 1 to this bit clears the WUF6 flag in PWR_WUSR."
            },
            {
                "name": "CWUF7",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 7\nAccess can be secured by PWR WUP7SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.\nWriting 1 to this bit clears the WUF7 flag in PWR_WUSR."
            },
            {
                "name": "CWUF8",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 8\nAccess can be secured by PWR WUP8SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV.\nWriting 1 to this bit clears the WUF8 flag in PWR_WUSR."
            }
        ]
    },
    "1174538320": {
        "name": "PWR_IORETENRA",
        "address": 1174538320,
        "size": 32,
        "access": "",
        "desc": "PWR port A Standby IO retention enable register",
        "fields": [
            {
                "name": "EN0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.\nWhen set, each bit enables the Standby GPIO retention feature for PAy"
            },
            {
                "name": "EN1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.\nWhen set, each bit enables the Standby GPIO retention feature for PAy"
            },
            {
                "name": "EN2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.\nWhen set, each bit enables the Standby GPIO retention feature for PAy"
            },
            {
                "name": "EN3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV.\nWhen set, each bit enables the Standby GPIO retention feature for PAy"
            },
            {
                "name": "EN5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention enable\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538324": {
        "name": "PWR_IORETRA",
        "address": 1174538324,
        "size": 32,
        "access": "",
        "desc": "PWR port A Standby IO retention status register",
        "fields": [
            {
                "name": "RET0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV."
            },
            {
                "name": "RET1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV."
            },
            {
                "name": "RET2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV."
            },
            {
                "name": "RET3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be protected by GPIOA SECy, privilege protection is controlled by PWR SPRIV or PWR NSPRIV."
            },
            {
                "name": "RET5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port A Standby GPIO retention active\nAccess can be secured by GPIOA SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538328": {
        "name": "PWR_IORETENRB",
        "address": 1174538328,
        "size": 32,
        "access": "",
        "desc": "PWR port B Standby IO retention enable register",
        "fields": [
            {
                "name": "EN0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention enable\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538332": {
        "name": "PWR_IORETRB",
        "address": 1174538332,
        "size": 32,
        "access": "",
        "desc": "PWR port B Standby IO retention status register",
        "fields": [
            {
                "name": "RET0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port B Standby GPIO retention active\nAccess can be secured by GPIOB SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538336": {
        "name": "PWR_IORETENRC",
        "address": 1174538336,
        "size": 32,
        "access": "",
        "desc": "PWR port C Standby IO retention enable register",
        "fields": [
            {
                "name": "EN13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C Standby GPIO retention enable\nAccess can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C Standby GPIO retention enable\nAccess can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "EN15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C Standby GPIO retention enable\nAccess can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538340": {
        "name": "PWR_IORETRC",
        "address": 1174538340,
        "size": 32,
        "access": "",
        "desc": "PWR port C Standby IO retention status register",
        "fields": [
            {
                "name": "RET13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C Standby GPIO retention active\nAccess can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C Standby GPIO retention active\nAccess can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            },
            {
                "name": "RET15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C Standby GPIO retention active\nAccess can be secured by GPIOC SECy. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538376": {
        "name": "PWR_IORETENRH",
        "address": 1174538376,
        "size": 32,
        "access": "",
        "desc": "PWR port H Standby IO retention enable register",
        "fields": [
            {
                "name": "EN3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port H Standby GPIO retention enable\nAccess can be secured by GPIOH SEC3. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538380": {
        "name": "PWR_IORETRH",
        "address": 1174538380,
        "size": 32,
        "access": "",
        "desc": "PWR port H Standby IO retention status register",
        "fields": [
            {
                "name": "RET3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port H Standby GPIO retention active\nAccess can be secured by GPIOH SEC3. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with PWR SPRIV or when non-secure with PWR NSPRIV."
            }
        ]
    },
    "1174538496": {
        "name": "PWR_RADIOSCR",
        "address": 1174538496,
        "size": 32,
        "access": "",
        "desc": "PWR 2.4 GHz RADIO status and control register",
        "fields": [
            {
                "name": "MODE",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "2.4 GHz RADIO operating mode.\n1x: 2.4 GHz RADIO active mode"
            },
            {
                "name": "PHYMODE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "2.4 GHz RADIO PHY operating mode"
            },
            {
                "name": "ENCMODE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "2.4 GHz RADIO encryption function operating mode"
            },
            {
                "name": "RFVDDHPA",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "2.4 GHz RADIO VDDHPA control word.\nBits [3:0] see Table 81: PA output power table format for definition.\nBit [4] rf_event."
            },
            {
                "name": "REGPARDYVDDRFPA",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Ready bit for VsubDDHPA/sub voltage level when selecting VDDRFPA input.\nNote: REGPARDYVDDRFPA does not allow to detect correct VsubDDHPA/sub voltage level when request to lower the level."
            }
        ]
    },
    "1073897472": {
        "name": "RAMCFG_M1CR",
        "address": 1073897472,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM1 control register",
        "fields": [
            {
                "name": "SRAMER",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM1 erase\nThis bit can be set by software only after writing the unlock sequence in the ERASEKEY field of the RAMCFG_M1ERKEYR register. Setting this bit starts the SRAM1 erase. This bit is automatically cleared by hardware at the end of the erase operation."
            },
            {
                "name": "WSC",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "SRAM1 wait state configuration\nThis field is used to program the number of wait states inserted on the AHB when reading the SRAM1, depending on its access time.\n...\nNote: Before entering Stop 1 mode software must set SRAM1 wait states to at least 1."
            }
        ]
    },
    "1073897480": {
        "name": "RAMCFG_M1ISR",
        "address": 1073897480,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM1 interrupt status register",
        "fields": [
            {
                "name": "SRAMBUSY",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM busy with erase operation.\nNote: Depending on the SRAM, the erase operation can be performed due to software request, system reset if the enabled by user option, tamper detection or RDP regression. Refer to Table38."
            }
        ]
    },
    "1073897512": {
        "name": "RAMCFG_M1ERKEYR",
        "address": 1073897512,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM1 erase key register",
        "fields": [
            {
                "name": "ERASEKEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Erase write protection key\nThe following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register.\nWrite 0xCA into ERASEKEY[7:0]\nWrite 0x53 into ERASEKEY[7:0]\nNote: Writing a wrong key reactivates the write protection."
            }
        ]
    },
    "1073897536": {
        "name": "RAMCFG_M2CR",
        "address": 1073897536,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM2 control register",
        "fields": [
            {
                "name": "ALE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "SRAM2 parity fail address latch enable"
            },
            {
                "name": "SRAMER",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM2 erase\nThis bit can be set by software only after writing the unlock sequence in the ERASEKEY field of the RAMCFG_M2ERKEYR register. Setting this bit starts the SRAM2 erase. This bit is automatically cleared by hardware at the end of the erase operation."
            },
            {
                "name": "WSC",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "SRAM2 wait state configuration\nThis field is used to program the number of wait states inserted on the AHB when reading the SRAM2, depending on its access time.\n...\nNote: Before entering Stop 1 mode software must set SRAM2 wait states to at least 1."
            }
        ]
    },
    "1073897540": {
        "name": "RAMCFG_M2IER",
        "address": 1073897540,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM2 interrupt enable register",
        "fields": [
            {
                "name": "PEIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Parity error interrupt enable"
            },
            {
                "name": "PENMI",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Parity error NMI.\nThis bit is set by software and cleared only by a global RAMCFG reset\nNote: When PENMI bit is set, the RAMCFG maskable interrupt is not generated for a parity error whatever PEIE bit value."
            }
        ]
    },
    "1073897544": {
        "name": "RAMCFG_M2ISR",
        "address": 1073897544,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM2 interrupt status register",
        "fields": [
            {
                "name": "PED",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Parity error detected"
            },
            {
                "name": "SRAMBUSY",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM2 busy with erase operation.\nNote: Depending on the SRAM2, the erase operation can be performed due to software request, system reset if the enabled by user option, tamper detection or RDP regression. Refer to Table38."
            }
        ]
    },
    "1073897552": {
        "name": "RAMCFG_M2PEAR",
        "address": 1073897552,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM2 parity error address register",
        "fields": [
            {
                "name": "PEA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Parity error SRAM word aligned address offset.PEA[1:0] read 0b00.\nWhen ALE bit is set in RAMCFG_M2CR register, this field is updated when PED and CPED are zero and a new parity error is detected, with the SRAM word aligned address offset corresponding to the parity error."
            },
            {
                "name": "ID",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Parity error AHB bus master ID.\nWhen ALE bit is set in RAMCFG_M2CR register, this field is updated when PED and CPED are zero and a new parity error is detected, with:\nOthers: reserved"
            },
            {
                "name": "BYTE",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Byte parity error flag.\nWhen ALE bit is set in RAMCFG_M2CR register, this field is updated when PED and CPED are zero and a new parity error is detected, with:\n1xxx: parity error detected on fourth byte in word aligned address\nx1xx: parity error detected on third byte in word aligned address\nxx1x: parity error detected on second byte in word aligned address\nxxx1: parity error detected on first byte in word aligned address"
            }
        ]
    },
    "1073897556": {
        "name": "RAMCFG_M2ICR",
        "address": 1073897556,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM2 interrupt clear register",
        "fields": [
            {
                "name": "CPED",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear parity error detect bit\nWriting 1 to this bit clears the PED bit in RAMCFG_M2ISR.\nReading this bit returns the value of the RAMCFG_M2ISR PED bit."
            }
        ]
    },
    "1073897560": {
        "name": "RAMCFG_M2WPR1",
        "address": 1073897560,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM2 write protection register 1",
        "fields": [
            {
                "name": "P0WP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P1WP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P2WP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P3WP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P4WP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P5WP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P6WP",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P7WP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P8WP",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P9WP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P10WP",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P11WP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P12WP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P13WP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P14WP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P15WP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P16WP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P17WP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P18WP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P19WP",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P20WP",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P21WP",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P22WP",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P23WP",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P24WP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P25WP",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P26WP",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P27WP",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P28WP",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P29WP",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P30WP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P31WP",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            }
        ]
    },
    "1073897564": {
        "name": "RAMCFG_M2WPR2",
        "address": 1073897564,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM2 write protection register 2",
        "fields": [
            {
                "name": "P32WP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P33WP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P34WP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P35WP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P36WP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P37WP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P38WP",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P39WP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P40WP",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P41WP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P42WP",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P43WP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P44WP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P45WP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P46WP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P47WP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P48WP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P49WP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P50WP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P51WP",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P52WP",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P53WP",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P54WP",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P55WP",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P56WP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P57WP",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P58WP",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P59WP",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P60WP",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P61WP",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P62WP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            },
            {
                "name": "P63WP",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "SRAM2 1-Kbyte write protect page y write protection\nThese bits are set by software and cleared only by a system reset."
            }
        ]
    },
    "1073897576": {
        "name": "RAMCFG_M2ERKEYR",
        "address": 1073897576,
        "size": 32,
        "access": "",
        "desc": "RAMCFG SRAM2 erase key register",
        "fields": [
            {
                "name": "ERASEKEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Erase write protection key\nThe following steps are required to unlock the write protection of the SRAMER bit in the RAMCFG_MxCR register.\nWrite 0xCA into ERASEKEY[7:0]\nWrite 0x53 into ERASEKEY[7:0]\nNote: Writing a wrong key reactivates the write protection."
            }
        ]
    },
    "1174539264": {
        "name": "RCC_CR",
        "address": 1174539264,
        "size": 32,
        "access": "",
        "desc": "RCC clock control register",
        "fields": [
            {
                "name": "HSION",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "HSI16 clock enable\nSet and cleared by software.\nCleared by hardware when entering Stop and Standby modes.\nSet by hardware to force the HSI16 oscillator on when exiting Stop and Standby modes.\nSet by hardware to force the HSI16 oscillator on in case of clock security failure of the HSE32 crystal oscillator.\nThis bit is set by hardware if the HSI16 is used directly or indirectly as system clock.\nAccess to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSIKERON",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "HSI16 enable for some peripheral kernels\nSet and cleared by software to force HSI16 oscillator on even in Stop modes.\nKeeping the HSI16 oscillator on in Stop modes allows the communication speed not to be reduced by the HSI16 oscillator startup time. This bit has no effect on register bit HSION value.\nCleared by hardware when entering Standby modes.\nRefer to Peripherals clock gating and autonomous mode for more details.\nAccess to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSIRDY",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "HSI16 clock ready flag\nSet by hardware to indicate that HSI16 oscillator is stable. This bit is set only when HSI16 is enabled by software by setting HSION.\nAccess to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: Once the HSION bit is cleared, HSIRDY goes low after six HSI16 clock cycles."
            },
            {
                "name": "HSEON",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "HSE32 clock enable\nSet and cleared by software.\nCleared by hardware to stop the HSE32 clock for the CPU when entering Stop and Standby modes and on a HSECSS failure.\nWhen the HSE32 is used as 2.4 GHz RADIO kernel clock, enabled by RADIOEN and RADIOSMEN and the 2.4 GHz RADIO is active, HSEON is not be cleared when entering low power mode. In this case only Stop 0 mode is entered as low power mode.\nThis bit cannot be reset if the HSE32 oscillator is used directly or indirectly as the system clock.\nAccess to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSERDY",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "HSE32 clock ready flag\nSet by hardware to indicate that the HSE32 oscillator is stable. This bit is set both when HSE32 is enabled by software by setting HSEON and when requested as kernel clock by the 2.4 GHz RADIO.\nAccess to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSECSSON",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "HSE32 clock security system enable\nSet by software to enable the HSE32 clock security system. When HSECSSON is set, the clock detector is enabled by hardware when the HSE32 oscillator is ready and disabled by hardware if a HSE32 clock failure is detected. This bit is set only and is cleared by reset.\nAccess to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSEPRE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "HSE32 clock for SYSCLK prescaler\nSet and cleared by software to control the division factor of the HSE32 clock for SYSCLK.\nAccess to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "PLL1ON",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "PLL1 enable\nSet and cleared by software to enable the main PLL.\nCleared by hardware when entering Stop or Standby modes and when PLL1 on HSE32 is selected as sysclk, on a HSECSS failure.\nThis bit cannot be reset if the PLL1 clock is used as the system clock.\nAccess to the bit can be secured by RCC PLL1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "PLL1RDY",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "PLL1 clock ready flag\nSet by hardware to indicate that the PLL1 is locked.\nAccess to the bit can be secured by RCC PLL1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539280": {
        "name": "RCC_ICSCR3",
        "address": 1174539280,
        "size": 32,
        "access": "",
        "desc": "RCC internal clock sources calibration register 3",
        "fields": [
            {
                "name": "HSICAL",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "HSI16 clock calibration\nThese bits are initialized at startup with the factory-programmed HSI16 calibration value. When HSITRIM[4:0] is written, HSICAL[11:0] is updated with the sum of HSITRIM[4:0] and the initial factory trim value."
            },
            {
                "name": "HSITRIM",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "HSI16 clock trimming\nThese bits provide an additional user-programmable trimming value that is added to the HSICAL[11:0] bits. It can be programmed to adjust to voltage and temperature variations that influence the frequency of the HSI16."
            }
        ]
    },
    "1174539292": {
        "name": "RCC_CFGR1",
        "address": 1174539292,
        "size": 32,
        "access": "",
        "desc": "RCC clock configuration register 1",
        "fields": [
            {
                "name": "SW",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "system clock switch\nSet and cleared by software to select system clock source (SYSCLK).\nCleared by hardware when entering Stop and Standby modes\nWhen selecting HSE32 directly or indirectly as system clock and HSE32 oscillator clock security fails, cleared by hardware."
            },
            {
                "name": "SWS",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "system clock switch status\nSet and cleared by hardware to indicate which clock source is used as system clock."
            },
            {
                "name": "MCOSEL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "microcontroller clock output\nSet and cleared by software.\nothers: reserved\nNote: This clock output may have some truncated cycles at startup or during MCO clock source switching."
            },
            {
                "name": "MCOPRE",
                "bitOffset": 28,
                "bitWidth": 3,
                "desc": "microcontroller clock output prescaler\nSet and cleared by software.\nIt is highly recommended to change this prescaler before MCO output is enabled.\nothers: not allowed"
            }
        ]
    },
    "1174539296": {
        "name": "RCC_CFGR2",
        "address": 1174539296,
        "size": 32,
        "access": "",
        "desc": "RCC clock configuration register 2",
        "fields": [
            {
                "name": "HPRE",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "AHB1, AHB2 and AHB4 prescaler\nSet and cleared by software to control the division factor of the AHB1, AHB2 and AHB4 clock (hclk1).\nThe software must limit the incremental frequency step by setting these bits correctly to ensure that the hclk1 maximum incremental frequency step does not exceed the maximum allowed incremental frequency step (for more details, refer to Table99: SYSCLK and bus maximum frequency). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value is taken into account.\n0xx: hclk1 = SYSCLK not divided"
            },
            {
                "name": "PPRE1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "APB1 prescaler\nSet and cleared by software to control the division factor of the APB1 clock (pclk1).\n0xx: pclk1 = hclk1 not divided"
            },
            {
                "name": "PPRE2",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "APB2 prescaler\nSet and cleared by software to control the division factor of the APB2 clock (pclk2).\n0xx: pclk2 = hclk1 not divided"
            }
        ]
    },
    "1174539300": {
        "name": "RCC_CFGR3",
        "address": 1174539300,
        "size": 32,
        "access": "",
        "desc": "RCC clock configuration register 3",
        "fields": [
            {
                "name": "PPRE7",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "APB7 prescaler\nSet and cleared by software to control the division factor of the APB7 clock (pclk7).\n0xx: hclk1 not divided"
            }
        ]
    },
    "1174539304": {
        "name": "RCC_PLL1CFGR",
        "address": 1174539304,
        "size": 32,
        "access": "",
        "desc": "RCC PLL1 configuration register",
        "fields": [
            {
                "name": "PLL1SRC",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "PLL1 entry clock source\nSet and cleared by software to select PLL1 clock source. These bits can be written only when the PLL1 is disabled.\nCleared by hardware when entering Stop or Standby modes.\nNote: In order to save power, when no PLL1 clock is used, the value of PLL1SRC must be 0."
            },
            {
                "name": "PLL1RGE",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "PLL1 input frequency range\nSet and reset by software to select the proper reference frequency range used for PLL1.\nThis bit must be written before enabling the PLL1.\n00-01-10: PLL1 input (ref1_ck) clock range frequency between 4 and 8 MHz"
            },
            {
                "name": "PLL1FRACEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "PLL1 fractional latch enable\nSet and reset by software to latch the content of PLL1FRACN into the  modulator.\nIn order to latch the PLL1FRACN value into the  modulator, PLL1FRACEN must be set to 0, then set to 1: the transition 0 to 1 transfers the content of PLL1FRACN into the modulator (see PLL1 initialization phase for details)."
            },
            {
                "name": "PLL1M",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "Prescaler for PLL1\nSet and cleared by software to configure the prescaler of the PLL1. The VCO1 input frequency is PLL1 input clock frequency/PLL1M.\nThis bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).\n..."
            },
            {
                "name": "PLL1PEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "PLL1 DIVP divider output enable\nSet and reset by software to enable the pll1pclk output of the PLL1.\nTo save power, PLL1PEN and PLL1P bits must be set to 0 when the pll1pclk is not used.\nThis bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0)."
            },
            {
                "name": "PLL1QEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "PLL1 DIVQ divider output enable\nSet and reset by software to enable the pll1qclk output of the PLL1.\nTo save power, PLL1QEN and PLL1Q bits must be set to 0 when the pll1qclk is not used.\nThis bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0)."
            },
            {
                "name": "PLL1REN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "PLL1 DIVR divider output enable\nSet and cleared by software to enable the pll1rclk output of the PLL1.\nTo save power, PLL1REN and PLL1R bits must be set to 0 when the pll1rclk is not used.\nThis bit can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0)."
            },
            {
                "name": "PLL1RCLKPRE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "pll1rclk clock for SYSCLK prescaler division enable\nSet and cleared by software to control the division of the pll1rclk clock for SYSCLK."
            },
            {
                "name": "PLL1RCLKPRESTEP",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "pll1rclk clock for SYSCLK prescaler division step selection\nSet and cleared by software to control the division step of the pll1rclk clock for SYSCLK."
            },
            {
                "name": "PLL1RCLKPRERDY",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "pll1rclkpre not divided ready.\nSet by hardware after PLL1RCLKPRE has been set from divided to not divide, to indicate that the pll1rclk not divided is available on sysclkpre."
            }
        ]
    },
    "1174539316": {
        "name": "RCC_PLL1DIVR",
        "address": 1174539316,
        "size": 32,
        "access": "",
        "desc": "RCC PLL1 dividers register",
        "fields": [
            {
                "name": "PLL1N",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Multiplication factor for PLL1 VCO\nSet and reset by software to control the multiplication factor of the VCO.\nThese bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).\n...\n...\nothers: reserved\nVCO output frequency = Fsubref1_ck/sub x multiplication factor for PLL1 VCO, when fractional value 0 has been loaded into PLL1FRACN, with:\nMultiplication factor for PLL1 VCO between 4 and 512\ninput frequency Fsubref1_ck/sub between 4 and 16MHz"
            },
            {
                "name": "PLL1P",
                "bitOffset": 9,
                "bitWidth": 7,
                "desc": "PLL1 DIVP division factor\nSet and reset by software to control the frequency of the pll1pclk clock.\nThese bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).\nNote that odd division factors are not allowed.\n..."
            },
            {
                "name": "PLL1Q",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "PLL1 DIVQ division factor\nSet and reset by software to control the frequency of the PLl1QCLK clock.\nThese bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).\n..."
            },
            {
                "name": "PLL1R",
                "bitOffset": 24,
                "bitWidth": 7,
                "desc": "PLL1 DIVR division factor\nSet and reset by software to control the frequency of the pll1rclk clock.\nThese bits can be written only when the PLL1 is disabled (PLL1ON = 0 and PLL1RDY = 0).\n..."
            }
        ]
    },
    "1174539320": {
        "name": "RCC_PLL1FRACR",
        "address": 1174539320,
        "size": 32,
        "access": "",
        "desc": "RCC PLL1 fractional divider register",
        "fields": [
            {
                "name": "PLL1FRACN",
                "bitOffset": 3,
                "bitWidth": 13,
                "desc": "Fractional part of the multiplication factor for PLL1 VCO\nSet and reset by software to control the fractional part of the multiplication factor of the VCO.\nThese bits can be written at any time, allowing dynamic fine-tuning of the PLL1 VCO.\nVCO output frequency = Fsubref1_ck/sub x [multiplication factor for PLL1 VCO + (PLL1FRACN / 2sup13/sup)], with:\nMultiplication factor for PLL1 VCO must be between 4 and 512.\nPLL1FRACN can be between 0 and 2sup13/sup- 1.\nThe input frequency Fsubref1_ck/sub must be between 4 and 16 MHz.\nTo change the used fractional value on-the-fly even if the PLL1 is enabled, the application must proceed as follows:\nSet the bit PLL1FRACEN to 0.\nWrite the new fractional value into PLL1FRACN.\nSet the bit PLL1FRACEN to 1."
            }
        ]
    },
    "1174539344": {
        "name": "RCC_CIER",
        "address": 1174539344,
        "size": 32,
        "access": "",
        "desc": "RCC clock interrupt enable register",
        "fields": [
            {
                "name": "LSI1RDYIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI1 ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the LSI1 oscillator stabilization.\nAccess to the bit can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSERDYIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization.\nAccess to the bit can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSIRDYIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI16 ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization.\nAccess to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSERDYIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE32 ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by the HSE32 oscillator stabilization.\nAccess to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "PLL1RDYIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "PLL1 ready interrupt enable\nSet and cleared by software to enable/disable interrupt caused by PLL1 lock.\nAccess to the bit can be secured by RCC PLL1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539348": {
        "name": "RCC_CIFR",
        "address": 1174539348,
        "size": 32,
        "access": "",
        "desc": "RCC clock interrupt flag register",
        "fields": [
            {
                "name": "LSI1RDYF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI1 ready interrupt flag\nSet by hardware when the LSI1 clock becomes stable and LSI1RDYIE is set.\nCleared by software setting the LSI1RDYC bit.\nAccess to the bit can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSERDYF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt flag\nSet by hardware when the LSE clock becomes stable and LSERDYIE is set.\nCleared by software setting the LSERDYC bit.\nAccess to the bit can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSIRDYF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI16 ready interrupt flag\nSet by hardware when the HSI16 clock becomes stable and HSIRDYIE is set in a response to setting the HSION (see RCC_CR). When HSION is not set but the HSI16 oscillator is enabled by the peripheral through a clock request, this bit is not set and no interrupt is generated.\nAccess to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nCleared by software setting the HSIRDYC bit."
            },
            {
                "name": "HSERDYF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE32 ready interrupt flag\nSet by hardware when the HSE32 clock becomes stable and HSERDYIE is set.\nCleared by software setting the HSERDYC bit.\nAccess to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "PLL1RDYF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "PLL1 ready interrupt flag\nSet by hardware when the PLL1 locks and PLL1RDYIE is set.\nCleared by software setting the PLL1RDYC bit.\nAccess to the bit can be secured by RCC PLL1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSECSSF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "HSE32 clock security system interrupt flag\nSet by hardware when a clock security failure is detected in the HSE32 oscillator.\nCleared by software setting the HSECSSC bit.\nAccess to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539352": {
        "name": "RCC_CICR",
        "address": 1174539352,
        "size": 32,
        "access": "",
        "desc": "RCC clock interrupt clear register",
        "fields": [
            {
                "name": "LSI1RDYC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI1 ready interrupt clear\nWriting this bit to 1 clears the LSI1RDYF flag. Writing 0 has no effect.\nAccess to the bit can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSERDYC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt clear\nWriting this bit to 1 clears the LSERDYF flag. Writing 0 has no effect.\nAccess to the bit can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSIRDYC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI16 ready interrupt clear\nWriting this bit to 1 clears the HSIRDYF flag. Writing 0 has no effect.\nAccess to the bit can be secured by RCC HSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSERDYC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE32 ready interrupt clear\nWriting this bit to 1 clears the HSERDYF flag. Writing 0 has no effect.\nAccess to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "PLL1RDYC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "PLL1 ready interrupt clear\nWriting this bit to 1 clears the PLL1RDYF flag. Writing 0 has no effect.\nAccess to the bit can be secured by RCC PLL1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSECSSC",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "High speed external clock security system interrupt clear\nWriting this bit to 1 clears the HSECSSF flag. Writing 0 has no effect.\nAccess to the bit can be secured by RCC HSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539360": {
        "name": "RCC_AHB1RSTR",
        "address": 1174539360,
        "size": 32,
        "access": "",
        "desc": "RCC AHB1 peripheral reset register",
        "fields": [
            {
                "name": "GPDMA1RST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPDMA1 reset\nSet and cleared by software.\nAccess can be secured by GPDMA1 SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "CRCRST",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC CRCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TSCRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "TSC reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TSCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539364": {
        "name": "RCC_AHB2RSTR",
        "address": 1174539364,
        "size": 32,
        "access": "",
        "desc": "RCC AHB2 peripheral reset register",
        "fields": [
            {
                "name": "GPIOARST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "IO port A reset\nSet and cleared by software.\nAccess can be secured by GPIOA SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GPIOBRST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "IO port B reset\nSet and cleared by software.\nAccess can be secured by GPIOB SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GPIOCRST",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "IO port C reset\nSet and cleared by software.\nAccess can be secured by GPIOC SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GPIOHRST",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "IO port H reset\nSet and cleared by software.\nAccess can be secured by GPIOH SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "AESRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "AES hardware accelerator reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC AESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HASHRST",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Hash reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC HASHSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "RNGRST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Random number generator reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC RNGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SAESRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "SAES hardware accelerator reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC SAESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSEMRST",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "HSEM hardware accelerator reset\nSet and cleared by software.\nCan only be accessed secure when one or more features in the HSEM is secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "PKARST",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "PKA reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC PKASEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539372": {
        "name": "RCC_AHB4RSTR",
        "address": 1174539372,
        "size": 32,
        "access": "",
        "desc": "RCC AHB4 peripheral reset register",
        "fields": [
            {
                "name": "ADC4RST",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "ADC4 reset\nSet and cleared by software.\nAccess can be secred by GTZC_TZSC ADC4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539376": {
        "name": "RCC_AHB5RSTR",
        "address": 1174539376,
        "size": 32,
        "access": "",
        "desc": "RCC AHB5 peripheral reset register",
        "fields": [
            {
                "name": "RADIORST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "2.4 GHz RADIO reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC RADIOSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539380": {
        "name": "RCC_APB1RSTR1",
        "address": 1174539380,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 peripheral reset register 1",
        "fields": [
            {
                "name": "TIM2RST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TIM3RST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "USART2RST",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC UART2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "I2C1RST",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC I2C1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539384": {
        "name": "RCC_APB1RSTR2",
        "address": 1174539384,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 peripheral reset register 2",
        "fields": [
            {
                "name": "LPTIM2RST",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LPTIM2 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC LPTIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539388": {
        "name": "RCC_APB2RSTR",
        "address": 1174539388,
        "size": 32,
        "access": "",
        "desc": "RCC APB2 peripheral reset register",
        "fields": [
            {
                "name": "TIM1RST",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SPI1RST",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC SPI1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "USART1RST",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC USART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TIM16RST",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM16SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TIM17RST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "TIM17 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM17SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539392": {
        "name": "RCC_APB7RSTR",
        "address": 1174539392,
        "size": 32,
        "access": "",
        "desc": "RCC APB7 peripheral reset register",
        "fields": [
            {
                "name": "SYSCFGRST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SYSCFG reset\nSet and cleared by software.\nAccess can be secured by SYSCFG SYSCFGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SPI3RST",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "SPI3 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC SPI3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LPUART1RST",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LPUART1 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC LPUART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "I2C3RST",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "I2C3 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC I2C3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LPTIM1RST",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "LPTIM1 reset\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC LPTIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539400": {
        "name": "RCC_AHB1ENR",
        "address": 1174539400,
        "size": 32,
        "access": "",
        "desc": "RCC AHB1 peripheral clock enable register",
        "fields": [
            {
                "name": "GPDMA1EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPDMA1 bus clock enable\nSet and cleared by software.\nAccess can be secured by GPDMA1 SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "FLASHEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "FLASH bus clock enable\nSet and cleared by software. This bit can be disabled only when the Flash memory is in power down mode.\nCan only be accessed secured when the Flash security state is secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "CRCEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC bus clock enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC CRCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TSCEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Touch sensing controller bus clock enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TSCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "RAMCFGEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "RAMCFG bus clock enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC RAMCFGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GTZC1EN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "GTZC1 bus clock enable\nSet and reset by software.\nCan only be accessed secure when device is secure (TZEN = 1). When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SRAM1EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "SRAM1 bus clock enable\nSet and reset by software.\nAccess can be secured by GTZC_MPCBB1 SECx, INVSECSTATE. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539404": {
        "name": "RCC_AHB2ENR",
        "address": 1174539404,
        "size": 32,
        "access": "",
        "desc": "RCC AHB2 peripheral clock enable register",
        "fields": [
            {
                "name": "GPIOAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "IO port A bus clock enable\nSet and cleared by software.\nAccess can be secured by GPIOA SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GPIOBEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "IO port B bus clock enable\nSet and cleared by software.\nAccess can be secured by GPIOB SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GPIOCEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "IO port C bus clock enable\nSet and cleared by software.\nAccess can be secured by GPIOC SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GPIOHEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "IO port H bus clock enable\nSet and cleared by software.\nAccess can be secured by GPIOH SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "AESEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "AES bus clock enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC AESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HASHEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "HASH bus clock enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC HASHSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "RNGEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "RNG bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC RNGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SAESEN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "SAES bus clock enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC SAESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HSEMEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "HSEM bus clock enable\nSet and cleared by software.\nCan only be accessed secure when one or more features in the HSEM is secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "PKAEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "PKA bus clock enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC PKASEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SRAM2EN",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "SRAM2 bus clock enable\nSet and cleared by software.\nAccess can be secured by GTZC_MPCBB2 SECx, INVSECSTATE. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539412": {
        "name": "RCC_AHB4ENR",
        "address": 1174539412,
        "size": 32,
        "access": "",
        "desc": "RCC AHB4 peripheral clock enable register",
        "fields": [
            {
                "name": "PWREN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "PWR bus clock enable\nSet and cleared by software.\nCan only be accessed secure when one or more features in the PWR is/are secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "ADC4EN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "ADC4 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC ADC4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539416": {
        "name": "RCC_AHB5ENR",
        "address": 1174539416,
        "size": 32,
        "access": "",
        "desc": "RCC AHB5 peripheral clock enable register",
        "fields": [
            {
                "name": "RADIOEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "2.4 GHz RADIO bus clock enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC RADIOSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nBefore accessing the 2.4 GHz RADIO sleep timers registers the RADIOCLKRDY bit must be checked.\nNote: When RADIOSMEN and STRADIOCLKON are both cleared, RADIOCLKRDY bit must be re-checked when exiting low-power modes (Sleep and Stop)."
            }
        ]
    },
    "1174539420": {
        "name": "RCC_APB1ENR1",
        "address": 1174539420,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 peripheral clock enable register 1",
        "fields": [
            {
                "name": "TIM2EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TIM3EN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "WWDGEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "WWDG bus clock enable\nSet by software to enable the window watchdog bus clock. Reset by hardware system reset.\nThis bit can also be set by hardware if the WWDG_SW option bit is reset.\nAccess can be secured by GTZC_TZSC WWDGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "USART2EN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC USART2SEC When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.."
            },
            {
                "name": "I2C1EN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC I2C1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539424": {
        "name": "RCC_APB1ENR2",
        "address": 1174539424,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 peripheral clock enable register 2",
        "fields": [
            {
                "name": "LPTIM2EN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LPTIM2 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC LPTIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539428": {
        "name": "RCC_APB2ENR",
        "address": 1174539428,
        "size": 32,
        "access": "",
        "desc": "RCC APB2 peripheral clock enable register",
        "fields": [
            {
                "name": "TIM1EN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SPI1EN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC SPI1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "USART1EN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC USART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TIM16EN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM16SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TIM17EN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "TIM17 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM17SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539432": {
        "name": "RCC_APB7ENR",
        "address": 1174539432,
        "size": 32,
        "access": "",
        "desc": "RCC APB7 peripheral clock enable register",
        "fields": [
            {
                "name": "SYSCFGEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SYSCFG bus clock enable\nSet and cleared by software.\nAccess can be secured by SYSCFG SYSCFGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SPI3EN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "SPI3 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC SPI3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LPUART1EN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LPUART1 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC LPUART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "I2C3EN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "I2C3 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC I2C3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LPTIM1EN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "LPTIM1 bus and kernel clocks enable\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC LPTIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "RTCAPBEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "RTC and TAMP bus clock enable\nSet and cleared by software.\nCan only be accessed secure when one or more features in the RTC or TAMP is/are secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539440": {
        "name": "RCC_AHB1SMENR",
        "address": 1174539440,
        "size": 32,
        "access": "",
        "desc": "RCC AHB1 peripheral clocks enable in Sleep and Stop modes register",
        "fields": [
            {
                "name": "GPDMA1SMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPDMA1 bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GPDMA1 SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            },
            {
                "name": "FLASHSMEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "FLASH bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nCan only be accessed secured when the Flash security state is secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "CRCSMEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC CRCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TSCSMEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "TSC bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TSCSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.."
            },
            {
                "name": "RAMCFGSMEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "RAMCFG bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC RAMCFGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GTZC1SMEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "GTZC1 bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nCan only be accessed secure when one device is secure (TZEN = 1). When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "ICACHESMEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "ICACHE bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC ICACHE_REGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.."
            },
            {
                "name": "SRAM1SMEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "SRAM1 bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_MPCBB1 SECx, INVSECSTATE. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539444": {
        "name": "RCC_AHB2SMENR",
        "address": 1174539444,
        "size": 32,
        "access": "",
        "desc": "RCC AHB2 peripheral clocks enable in Sleep and Stop modes register",
        "fields": [
            {
                "name": "GPIOASMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "IO port A bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GPIOA SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GPIOBSMEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "IO port B bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GPIOB SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GPIOCSMEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "IO port C bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GPIOC SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "GPIOHSMEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "IO port H bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GPIOH SECx. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "AESSMEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "AES bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC AESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "HASHSMEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "HASH bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC HASHSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "RNGSMEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Random number generator (RNG) bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC RNGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SAESSMEN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "SAES accelerator bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC SAESSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "PKASMEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "PKA bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC PKASEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SRAM2SMEN",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "SRAM2 bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_MPCBB2 SECx, INVSECSTATE. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539452": {
        "name": "RCC_AHB4SMENR",
        "address": 1174539452,
        "size": 32,
        "access": "",
        "desc": "RCC AHB4 peripheral clocks enable in Sleep and Stop modes register",
        "fields": [
            {
                "name": "PWRSMEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "PWR bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nCan only be accessed secure when one or more features in the PWR is/are secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "ADC4SMEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "ADC4 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC ADC4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            }
        ]
    },
    "1174539456": {
        "name": "RCC_AHB5SMENR",
        "address": 1174539456,
        "size": 32,
        "access": "",
        "desc": "RCC AHB5 peripheral clocks enable in Sleep and Stop modes register",
        "fields": [
            {
                "name": "RADIOSMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "2.4 GHz RADIO bus clock enable during Sleep and Stop modes when the 2.4 GHz RADIO is active.\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC RADIOSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539460": {
        "name": "RCC_APB1SMENR1",
        "address": 1174539460,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 peripheral clocks enable in Sleep and Stop modes\tregister 1",
        "fields": [
            {
                "name": "TIM2SMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TIM3SMEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "WWDGSMEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Window watchdog bus clock enable during Sleep and Stop modes\nSet and cleared by software. This bit is forced to 1 by hardware when the hardware WWDG option is activated.\nAccess can be secured by GTZC_TZSC WWDGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "USART2SMEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC USART2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            },
            {
                "name": "I2C1SMEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC I2C1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            }
        ]
    },
    "1174539464": {
        "name": "RCC_APB1SMENR2",
        "address": 1174539464,
        "size": 32,
        "access": "",
        "desc": "RCC APB1 peripheral clocks enable in Sleep and Stop modes \tregister 2",
        "fields": [
            {
                "name": "LPTIM2SMEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LPTIM2 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC LPTIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            }
        ]
    },
    "1174539468": {
        "name": "RCC_APB2SMENR",
        "address": 1174539468,
        "size": 32,
        "access": "",
        "desc": "RCC APB2 peripheral clocks enable in Sleep and Stop modes register",
        "fields": [
            {
                "name": "TIM1SMEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SPI1SMEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC SPI1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            },
            {
                "name": "USART1SMEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC USART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            },
            {
                "name": "TIM16SMEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM16SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "TIM17SMEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "TIM17 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC TIM17SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539472": {
        "name": "RCC_APB7SMENR",
        "address": 1174539472,
        "size": 32,
        "access": "",
        "desc": "RCC APB7 peripheral clock enable in Sleep and Stop modes register",
        "fields": [
            {
                "name": "SYSCFGSMEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SYSCFG bus clock enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by SYSCFG SYSCFGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "SPI3SMEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "SPI3 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC SPI3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            },
            {
                "name": "LPUART1SMEN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LPUART1 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC LPUART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            },
            {
                "name": "I2C3SMEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "I2C3 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC I2C3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            },
            {
                "name": "LPTIM1SMEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "LPTIM1 bus and kernel clocks enable during Sleep and Stop modes\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC LPTIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            },
            {
                "name": "RTCAPBSMEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "RTC and TAMP APB clock enable during Sleep and Stop modes\nSet and cleared by software.\nCan only be accessed secure when one or more features in the RTC or TAMP is/are secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: This bit must be set to allow the peripheral to wake up from Stop modes."
            }
        ]
    },
    "1174539488": {
        "name": "RCC_CCIPR1",
        "address": 1174539488,
        "size": 32,
        "access": "",
        "desc": "RCC peripherals independent clock configuration register 1",
        "fields": [
            {
                "name": "USART1SEL",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "USART1 kernel clock source selection\nThis bits are used to select the USART1 kernel clock source.\nAccess can be secured by GTZC_TZSC USART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The USART1 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16 or LSE."
            },
            {
                "name": "USART2SEL",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "USART2 kernel clock source selection\nThis bits are used to select the USART2 kernel clock source.\nAccess can be secured by GTZC_TZSC USART2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The USART2 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16 or LSE."
            },
            {
                "name": "I2C1SEL",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "I2C1 kernel clock source selection\nThese bits are used to select the I2C1 kernel clock source.\nAccess can be secured by GTZC_TZSC I2C1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The I2C1 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16."
            },
            {
                "name": "LPTIM2SEL",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Low-power timer 2 kernel clock source selection\nThese bits are used to select the LPTIM2 kernel clock source.\nAccess can be secured by GTZC_TZSC LPTIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The LPTIM2 is functional in Stop 0 and Stop 1 mode only when the kernel clock is LSI, LSE or HSI16 if HSIKERON = 1."
            },
            {
                "name": "SPI1SEL",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "SPI1 kernel clock source selection\nThese bits are used to select the SPI1 kernel clock source.\nAccess can be secured by GTZC_TZSC SPI1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The SPI1 is functional in Stop 0 and Stop 1 mode only when the kernel clock is HSI16."
            },
            {
                "name": "SYSTICKSEL",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "SysTick clock source selection\nThese bits are used to select the SysTick clock source.\nAccess can be secured by RCC SYSCLKSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: When LSE or LSI is selected, the AHB frequency must be at least four times higher than the LSI or LSE frequency. In addition, a jitter up to one hclk1 cycle is introduced, due to the LSE or LSI sampling with hclk1 in the SysTick circuitry."
            },
            {
                "name": "TIMICSEL",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Clocks sources for TIM16,TIM17 and LPTIM2 internal input capture\nWhen the TIMICSEL bit is set, the TIM16, TIM17 and LPTIM2 internal input capture can be connected to HSI16/256.\nWhen TIMICSEL is cleared, the HSI16, clock sources cannot be selected as TIM16, TIM17 or LPTIM2 internal input capture.\nAccess can be secured by GTZC_TZSC TIM16SEC, TIM17SEC, or LPTIM2SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The clock division must be disabled (TIMICSEL configured to 0) before selecting or changing a clock sources division."
            }
        ]
    },
    "1174539492": {
        "name": "RCC_CCIPR2",
        "address": 1174539492,
        "size": 32,
        "access": "",
        "desc": "RCC peripherals independent clock configuration register 2",
        "fields": [
            {
                "name": "RNGSEL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "RNGSEL kernel clock source selection\nThese bits allow to select the RNG kernel clock source.\nAccess can be secured by GTZC_TZSC RNGSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            }
        ]
    },
    "1174539496": {
        "name": "RCC_CCIPR3",
        "address": 1174539496,
        "size": 32,
        "access": "",
        "desc": "RCC peripherals independent clock configuration register 3",
        "fields": [
            {
                "name": "LPUART1SEL",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "LPUART1 kernel clock source selection\nThese bits are used to select the LPUART1 kernel clock source.\nAccess can be secured by GTZC_TZSC LPUART1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The LPUART1 is functional in Stop modes only when the kernel clock is HSI16 or LSE."
            },
            {
                "name": "SPI3SEL",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "SPI3 kernel clock source selection\nThese bits are used to select the SPI3 kernel clock source.\nAccess can be secured by GTZC_TZSC SPI3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The SPI3 is functional in Stop modes only when the kernel clock is HSI16."
            },
            {
                "name": "I2C3SEL",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "I2C3 kernel clock source selection\nThese bits are used to select the I2C3 kernel clock source.\nAccess can be secured by GTZC_TZSC I2C3SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The I2C3 is functional in Stop modes only when the kernel clock is HSI16"
            },
            {
                "name": "LPTIM1SEL",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "LPTIM1 kernel clock source selection\nThese bits are used to select the LPTIM1 kernel clock source.\nAccess can be secured by GTZC_TZSC LPTIM1SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The LPTIM1 is functional in Stop modes only when the kernel clock is LSI, LSE, HSI16 with HSIKERON = 1."
            },
            {
                "name": "ADCSEL",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "ADC4 kernel clock source selection\nThese bits are used to select the ADC4 kernel clock source.\nAccess can be secured by GTZC_TZSC ADC4SEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nothers: reserved\nNote: The ADC4 is functional in Stop modes only when the kernel clock is HSI16."
            }
        ]
    },
    "1174539504": {
        "name": "RCC_BDCR1",
        "address": 1174539504,
        "size": 32,
        "access": "",
        "desc": "RCC backup domain control register",
        "fields": [
            {
                "name": "LSEON",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSE oscillator enable\nSet and cleared by software.\nAccess can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSERDY",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE oscillator ready\nSet and cleared by hardware to indicate when the external 32kHz oscillator is stable. After the LSEON bit is cleared, LSERDY goes low after six external low-speed oscillator clock cycles.\nAccess can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSEBYP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "LSE oscillator bypass\nSet and cleared by software to bypass oscillator in debug mode. This bit can be written only when the external 32kHz oscillator is disabled (LSEON = 0 and LSERDY = 0).\nAccess can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSEDRV",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "LSE oscillator drive capability\nSet by software to modulate the drive capability of the LSE oscillator. LSEDRV must be programmed to a different value than 0 before enabling the LSE oscillator in 'Xtal' mode.\nAccess can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: The oscillator is in 'Xtal mode' when it is not in bypass mode."
            },
            {
                "name": "LSECSSON",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Low speed external clock security enable\nSet by software to enable the LSECSS. LSECSSON must be enabled after the LSE oscillator is enabled (LSEON bit enabled) and ready (LSERDY flag set by hardware) and after the RTCSEL bit is selected.\nOnce enabled, this bit cannot be disabled, except after a LSE failure detection (LSECSSD=1). In that case, the software must disable the LSECSSON bit.\nAccess can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSECSSD",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Low speed external clock security, LSE failure Detection\nSet by hardware to indicate when a failure is detected by the LSECCS on the external 32kHz oscillator.\nReset when LSCSSON bit is cleared.\nAccess can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSESYSEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LSE system clock (LSESYS) enable\nSet by software to enable the LSE system clock generated by RCC. The lsesys clock is used for peripherals (USART, LPUART, LPTIM, RNG, 2.4 GHz RADIO) and functions (LSCO, MCO, TIM triggers, LPTIM trigger) excluding the RTC, TAMP and LSECSS.\nAccess can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "RTCSEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "RTC and TAMP kernel clock source enable and selection\nSet by software to enable and select the clock source for the RTC.\nCan only be accessed secure when one or more features in the RTC or TAMP is/are secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSESYSRDY",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "LSE system clock (LSESYS) ready\nSet and cleared by hardware to indicate when the LSE system clock is stable.When the LSESYSEN bit is set, the LSESYSRDY flag is set after two LSE clock cycles.\nThe LSE clock must be already enabled and stable (LSEON and LSERDY are set).\nWhen the LSEON bit is cleared, LSERDY goes low after six external low-speed oscillator clock cycles.\nAccess can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSEGFON",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "LSE clock glitch filter enable\nSet and cleared by hardware to enable the LSE glitch filter. This bit can be written only when the LSE is disabled (LSEON = 0 and LSERDY = 0).\nAccess can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSETRIM",
                "bitOffset": 13,
                "bitWidth": 2,
                "desc": "LSE trimming\nThese bits are initialized at startup and after OBL_LAUNCH with SBF cleared with the factory-programmed LSE calibration value.\nSet and cleared by software. These bits must be modified only once after a BOR reset or an OBL_LAUNCH and before enabling LSE with LSEON (when both LSEON = 0 and LSERDY= 0).\nAccess can be secured by RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV.\nNote: OBL_LAUNCH of this field occurs only when SBF is cleared and must then only be started by software when LSE oscillator is disabled, LSEON = 0 and LSERDY = 0."
            },
            {
                "name": "BDRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Backup domain software reset\nSet and cleared by software.\nCan only be accessed secure when one or more features in the RTC or TAMP is secure. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "RADIOSTSEL",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "2.4 GHz RADIO sleep timer kernel clock enable and selection\nSet and cleared by software.\nAccess can be secured by GTZC_TZSC RADIOSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSCOEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low-speed clock output (LSCO) enable\nSet and cleared by software.\nAccess can be secured by RCC LSISEC and/or RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSCOSEL",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Low-speed clock output selection\nSet and cleared by software.\nAccess can be secured by RCC LSISEC and/or RCC LSESEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSI1ON",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "LSI1 oscillator enable\nSet and cleared by software.\nAccess can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSI1RDY",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "LSI1 oscillator ready\nSet and cleared by hardware to indicate when the LSI1 oscillator is stable. After the LSI1ON bit is cleared, LSI1RDY goes low after three internal low-speed oscillator clock cycles. This bit is set when the LSI1 is used by IWDG or RTC, even if LSI1ON = 0.\nAccess can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSI1PREDIV",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "LSI1 Low-speed clock divider configuration\nSet and cleared by software to enable the LSI1 division. This bit can be written only when the LSI1 is disabled (LSI1ON = 0 and LSI1RDY = 0). The LSI1PREDIV cannot be changed if the LSI1 is used by the IWDG or by the RTC.\nAccess can be secured by RCC LSISEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "LSI2ON",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "LSI2 oscillator enable"
            },
            {
                "name": "LSI2RDY",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "LSI2 oscillator ready"
            }
        ]
    },
    "1174539508": {
        "name": "RCC_CSR",
        "address": 1174539508,
        "size": 32,
        "access": "",
        "desc": "RCC control/status register",
        "fields": [
            {
                "name": "RMVF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Remove reset flag\nSet by software to clear the reset flags.\nAccess can be secured by RCC RMVFSEC. When secure, a non-secure read/write access is RAZ/WI. It does not generate an illegal access interrupt. This bit can be protected against unprivileged access when secure with RCC SPRIV or when non-secure with RCC NSPRIV."
            },
            {
                "name": "OBLRSTF",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Option byte loader reset flag\nSet by hardware when a reset from the option byte loading occurs.\nCleared by writing to the RMVF bit."
            },
            {
                "name": "PINRSTF",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "NRST pin reset flag\nSet by hardware when a reset from the NRST pin occurs.\nCleared by writing to the RMVF bit."
            },
            {
                "name": "BORRSTF",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "BOR flag\nSet by hardware when a BOR occurs.\nCleared by writing to the RMVF bit."
            },
            {
                "name": "SFTRSTF",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Software reset flag\nSet by hardware when a software reset occurs.\nCleared by writing to the RMVF bit."
            },
            {
                "name": "IWDGRSTF",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Independent watchdog reset flag\nSet by hardware when an independent watchdog reset domain occurs.\nCleared by writing to the RMVF bit."
            },
            {
                "name": "WWDGRSTF",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Window watchdog reset flag\nSet by hardware when a window watchdog reset occurs.\nCleared by writing to the RMVF bit."
            },
            {
                "name": "LPWRRSTF",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Low-power reset flag\nSet by hardware when a reset occurs due to illegal Stop and Standby modes entry.\nCleared by writing to the RMVF bit."
            }
        ]
    },
    "1174539536": {
        "name": "RCC_SECCFGR",
        "address": 1174539536,
        "size": 32,
        "access": "",
        "desc": "RCC secure configuration register",
        "fields": [
            {
                "name": "HSISEC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "HSI16 clock configuration and status bits security\nSet and reset by software."
            },
            {
                "name": "HSESEC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "HSE32 clock configuration bits, status bits and HSECSS security\nSet and reset by software."
            },
            {
                "name": "LSISEC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "LSI clock configuration and status bits security\nSet and reset by software."
            },
            {
                "name": "LSESEC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "LSE clock configuration and status bits security\nSet and reset by software."
            },
            {
                "name": "SYSCLKSEC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "SYSCLK selection, clock output on MCO configuration security\nSet and reset by software."
            },
            {
                "name": "PRESCSEC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "AHBx/APBx prescaler configuration bits security\nSet and reset by software."
            },
            {
                "name": "PLL1SEC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "PLL1 clock configuration and status bits security\nSet and reset by software."
            },
            {
                "name": "RMVFSEC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Remove reset flag security\nSet and reset by software."
            }
        ]
    },
    "1174539540": {
        "name": "RCC_PRIVCFGR",
        "address": 1174539540,
        "size": 32,
        "access": "",
        "desc": "RCC privilege configuration register",
        "fields": [
            {
                "name": "SPRIV",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RCC secure functions privilege configuration\nSet and reset by software.\nThis bit can be written only by a secure privileged access."
            },
            {
                "name": "NSPRIV",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "RCC non-secure functions privilege configuration\nSet and reset by software.\nThis bit can be written only by privileged access, secure or non-secure."
            }
        ]
    },
    "1174539776": {
        "name": "RCC_CFGR4",
        "address": 1174539776,
        "size": 32,
        "access": "",
        "desc": "RCC clock configuration register 2",
        "fields": [
            {
                "name": "HPRE5",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "AHB5 prescaler when SWS select PLL1\nSet and cleared by software to control the division factor of the AHB5 clock (hclk5).\nMust not be changed when SYSCLK source indicated by SWS is PLL1.\nWhen SYSCLK source indicated by SWS is not PLL1: HPRE5 is not taken into account.\nWhen SYSCLK source indicated by SWS is PLL1: HPRE5 is taken into account, from the moment the system clock switch occurs\nDepending on the device voltage range, the software must set these bits correctly to ensure that the AHB5 frequency does not exceed the maximum allowed frequency (for more details, refer to Table99: SYSCLK and bus maximum frequency). After a write operation to these bits and before decreasing the voltage range, this register must be read to be sure that the new value is taken into account.\n0xx: hclk5 = SYSCLK not divided"
            },
            {
                "name": "HDIV5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "AHB5 divider when SWS select HSI16 or HSE32\nSet and reset by software.\nSet to 1 by hardware when entering Stop 1 mode.\nWhen SYSCLK source indicated by SWS is HSI16 or HSE32: HDIV5 is taken into account\nWhen SYSCLK source indicated by SWS is PLL1: HDIV5 is taken not taken into account\nDepending on the device voltage range, the software must set this bit correctly to ensure that the AHB5 frequency does not exceed the maximum allowed frequency (for more details, refer to Table99). After a write operation to this bit and before decreasing the voltage range, this register must be read to be sure that the new value is taken into account."
            }
        ]
    },
    "1174539784": {
        "name": "RCC_RADIOENR",
        "address": 1174539784,
        "size": 32,
        "access": "",
        "desc": "RCC RADIO peripheral clock enable register",
        "fields": [
            {
                "name": "BBCLKEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "2.4 GHz RADIO baseband kernel clock (aclk) enable\nSet and cleared by software.\nNote: The HSE32 oscillator needs to be enabled by either HSEON or STRADIOCLKON."
            },
            {
                "name": "STRADIOCLKON",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "2.4 GHz RADIO bus clock enable and HSE32 oscillator enable by 2.4 GHz RADIO sleep timer wakeup event\nSet by hardware on a 2.4 GHz RADIO sleep timer wakeup event.\nCleared by software writing zero to this bit.\nNote: Before accessing the 2.4 GHz RADIO registers the RADIOCLKRDY bit must be checked."
            },
            {
                "name": "RADIOCLKRDY",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "2.4 GHz RADIO bus clock ready.\nSet and cleared by hardware to indicate that the 2.4 GHz RADIO bus clock is ready and the 2.4 GHz RADIO registers can be accessed.\nNote: Once both RADIOEN and STRADIOCLKON are cleared, RADIOCLKRDY goes low after three hclk5 clock cycles."
            }
        ]
    },
    "1174539792": {
        "name": "RCC_ECSCR1",
        "address": 1174539792,
        "size": 32,
        "access": "",
        "desc": "RCC external clock sources calibration register 1",
        "fields": [
            {
                "name": "HSETRIM",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "HSE32 clock trimming\nThese bits provide user-programmable capacitor trimming value. It can be programmed to adjust the HSE32 oscillator frequency."
            }
        ]
    },
    "1108084736": {
        "name": "RNG_CR",
        "address": 1108084736,
        "size": 32,
        "access": "read-write",
        "desc": "RNG control register",
        "fields": [
            {
                "name": "RNGEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "True random number generator enable"
            },
            {
                "name": "IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Interrupt Enable"
            },
            {
                "name": "CED",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clock error detection\n\nThe clock error detection cannot be enabled nor disabled on-the-fly when the RNG is enabled, that is to enable or disable CED the RNG must be disabled.\n\nWriting this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1."
            },
            {
                "name": "ARDIS",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto reset disable\n\nWhen auto-reset is enabled application still need to clear SEIS bit after a noise source error.\n\nWriting this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1."
            },
            {
                "name": "RNG_CONFIG3",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "RNG configuration 3\n\nReserved to the RNG configuration (bitfield 3). Refer to RNG_CONFIG1 bitfield for details.\n\nIf NISTC bit is cleared in this register RNG_CONFIG3 bitfield values are ignored by RNG."
            },
            {
                "name": "NISTC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Non NIST compliant\n\ntwo conditioning loops are performed and 256 bits of noise source are used.\n\nWriting this bit is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1."
            },
            {
                "name": "RNG_CONFIG2",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "RNG configuration 2\n\nReserved to the RNG configuration (bitfield 2). Refer to RNG_CONFIG1 bitfield for details."
            },
            {
                "name": "CLKDIV",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Clock divider factor\n\nThis value used to configure an internal programmable divider (from 1 to 16) acting on the incoming RNG clock. These bits can be written only when the core is disabled (RNGEN = 0).\n\n...\n\nWriting these bits is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1."
            },
            {
                "name": "RNG_CONFIG1",
                "bitOffset": 20,
                "bitWidth": 6,
                "desc": "RNG configuration 1\n\nReserved to the RNG configuration (bitfield 1). Must be initialized using the recommended value documented in Section 26.6: RNG entropy source validation.\n\nWriting any bit of RNG_CONFIG1 is taken into account only if CONDRST bit is set to 1 in the same access, while CONFIGLOCK remains at 0. Writing to this bit is ignored if CONFIGLOCK = 1."
            },
            {
                "name": "CONDRST",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Conditioning soft reset\n\n\tWrite 1 and then write 0 to reset the conditioning logic, clear all the FIFOs and start a new RNG initialization process, with RNG_SR cleared. Registers RNG_CR and RNG_NSCR are not changed by CONDRST.\n\nThis bit must be set to 1 in the same access that set any configuration bits [29:4]. In other words, when CONDRST bit is set to 1 correct configuration in bits [29:4] must also be written.\n\nWhen CONDRST is set to 0 by software its value goes to 0 when the reset process is done. It takes about 2 AHB clock cycles + 2 RNG clock cycles."
            },
            {
                "name": "CONFIGLOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RNG Config lock\n\nThis bitfield is set once: if this bit is set it can only be reset to 0 if RNG is reset."
            }
        ]
    },
    "1108084740": {
        "name": "RNG_SR",
        "address": 1108084740,
        "size": 32,
        "access": "read-write",
        "desc": "RNG status register",
        "fields": [
            {
                "name": "DRDY",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Data Ready\n\nOnce the output buffer becomes empty (after reading the RNG_DR register), this bit returns to 0 until a new random value is generated.\n\nNote: The DRDY bit can rise when the peripheral is disabled (RNGEN = 0 in the RNG_CR register).\n\nIf IE=1 in the RNG_CR register, an interrupt is generated when DRDY = 1."
            },
            {
                "name": "CECS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clock error current status\n\nNote: CECS bit is valid only if the CED bit in the RNG_CR register is set to 0."
            },
            {
                "name": "SECS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Seed error current status\n\nRun-time repetition count test failed (noise source has provided more than 24 consecutive bits at a constant value 0 or 1, or more than 32 consecutive occurrence of two bits patterns 01 or 10)\n\nStart-up or continuous adaptive proportion test on noise source failed.\n\nStart-up post-processing/conditioning sanity check failed."
            },
            {
                "name": "CEIS",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clock error interrupt status\n\nThis bit is set at the same time as CECS. It is cleared by writing 0. Writing 1 has no effect.\n\nAn interrupt is pending if IE = 1 in the RNG_CR register."
            },
            {
                "name": "SEIS",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Seed error interrupt status\n\nThis bit is set at the same time as SECS. It is cleared by writing 0 (unless CONDRST is used). Writing 1 has no effect.\n\nAn interrupt is pending if IE = 1 in the RNG_CR register."
            }
        ]
    },
    "1108084744": {
        "name": "RNG_DR",
        "address": 1108084744,
        "size": 32,
        "access": "read-only",
        "desc": "RNG data register",
        "fields": [
            {
                "name": "RNDATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Random data\n\n32-bit random data which are valid when DRDY = 1. When DRDY = 0 RNDATA value is zero.\n\nIt is recommended to always verify that RNG_DR is different from zero. Because when it is the case a seed error occurred between RNG_SR polling and RND_DR output reading (rare event)."
            }
        ]
    },
    "1108084752": {
        "name": "RNG_HTCR",
        "address": 1108084752,
        "size": 32,
        "access": "read-write",
        "desc": "RNG health test control register",
        "fields": [
            {
                "name": "HTCFG",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "health test configuration\n\nThis configuration is used by RNG to configure the health tests. See Section 26.6: RNG entropy source validation for the recommended value.\n\nNote: The RNG behavior, including the read to this register, is not guaranteed if a different value from the recommended value is written."
            }
        ]
    },
    "1174435840": {
        "name": "RTC_TR",
        "address": 1174435840,
        "size": 32,
        "access": "",
        "desc": "RTC time register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format"
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            }
        ]
    },
    "1174435844": {
        "name": "RTC_DR",
        "address": 1174435844,
        "size": 32,
        "access": "",
        "desc": "RTC date register",
        "fields": [
            {
                "name": "DU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Date units in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "MU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Month units in BCD format"
            },
            {
                "name": "MT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Month tens in BCD format"
            },
            {
                "name": "WDU",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Week day units\n..."
            },
            {
                "name": "YU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Year units in BCD format"
            },
            {
                "name": "YT",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Year tens in BCD format"
            }
        ]
    },
    "1174435848": {
        "name": "RTC_SSR",
        "address": 1174435848,
        "size": 32,
        "access": "",
        "desc": "RTC subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Synchronous binary counter\nSS[31:16]: Synchronous binary counter MSB values\nWhen Binary or Mixed mode is selected (BIN = 01 or 10 or 11):\nSS[31:16] are the 16 MSB of the SS[31:0] free-running down-counter.\nWhen BCD mode is selected (BIN=00):\nSS[31:16] are forced by hardware to 0x0000.\nSS[15:0]: Subsecond value/synchronous binary counter LSB values\nWhen Binary mode is selected (BIN = 01 or 10 or 11):\nSS[15:0] are the 16 LSB of the SS[31:0] free-running down-counter.\nWhen BCD mode is selected (BIN=00):\nSS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below:\nSecond fraction = (PREDIV_S - SS) / (PREDIV_S + 1)\nSS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR."
            }
        ]
    },
    "1174435852": {
        "name": "RTC_ICSR",
        "address": 1174435852,
        "size": 32,
        "access": "",
        "desc": "RTC initialization control and status register",
        "fields": [
            {
                "name": "WUTWF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer write flag\nThis bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode."
            },
            {
                "name": "SHPF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Shift operation pending\nThis flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect."
            },
            {
                "name": "INITS",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Initialization status flag\nThis bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state)."
            },
            {
                "name": "RSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Registers synchronization flag\nThis bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software.\nIt is cleared either by software or by hardware in initialization mode."
            },
            {
                "name": "INITF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Initialization flag\nWhen this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated."
            },
            {
                "name": "INIT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Initialization mode"
            },
            {
                "name": "BIN",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Binary mode"
            },
            {
                "name": "BCDU",
                "bitOffset": 10,
                "bitWidth": 3,
                "desc": "BCD update (BIN = 10 or 11)\nIn mixed mode when both BCD calendar and binary extended counter are used (BIN = 10 or 11), the calendar second is incremented using the SSR Least Significant Bits."
            },
            {
                "name": "RECALPF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Recalibration pending Flag\nThe RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly."
            }
        ]
    },
    "1174435856": {
        "name": "RTC_PRER",
        "address": 1174435856,
        "size": 32,
        "access": "",
        "desc": "RTC prescaler register",
        "fields": [
            {
                "name": "PREDIV_S",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Synchronous prescaler factor\nThis is the synchronous division factor:\nck_spre frequency = ck_apre frequency/(PREDIV_S+1)"
            },
            {
                "name": "PREDIV_A",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Asynchronous prescaler factor\nThis is the asynchronous division factor:\nck_apre frequency = RTCCLK frequency/(PREDIV_A+1)"
            }
        ]
    },
    "1174435860": {
        "name": "RTC_WUTR",
        "address": 1174435860,
        "size": 32,
        "access": "",
        "desc": "RTC wakeup timer register",
        "fields": [
            {
                "name": "WUT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Wakeup auto-reload value bits\nWhen the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]+1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register.\nWhen WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer.\nThe first assertion of WUTF occurs between WUT and (WUT + 2) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden."
            },
            {
                "name": "WUTOCLR",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Wakeup auto-reload output clear value\nWhen WUTOCLR[15:0] is different from 0x0000, WUTF is set by hardware when the auto-reload down-counter reaches 0 and is cleared by hardware when the auto-reload downcounter reaches WUTOCLR[15:0].\nWhen WUTOCLR[15:0] = 0x0000, WUTF is set by hardware when the WUT down-counter\nreaches 0 and is cleared by software."
            }
        ]
    },
    "1174435864": {
        "name": "RTC_CR",
        "address": 1174435864,
        "size": 32,
        "access": "",
        "desc": "RTC control register",
        "fields": [
            {
                "name": "WUCKSEL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "ck_wut wakeup clock selection\n10x: ck_spre (usually 1Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU.\n11x: ck_spre (usually 1 Hz) clock is selected in BCD mode. In binary or mixed mode, this is the clock selected by BCDU. Furthermore, 2sup16/sup is added to the WUT counter value."
            },
            {
                "name": "TSEDGE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp event active edge\nTSE must be reset when TSEDGE is changed to avoid unwanted TSF setting."
            },
            {
                "name": "REFCKON",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "RTC_REFIN reference clock detection enable (50 or 60Hz)\nNote: BIN must be 0x00 and PREDIV_S must be 0x00FF."
            },
            {
                "name": "BYPSHAD",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Bypass the shadow registers\nNote: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1."
            },
            {
                "name": "FMT",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Hour format"
            },
            {
                "name": "SSRUIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "SSR underflow interrupt enable"
            },
            {
                "name": "ALRAE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Alarm A enable"
            },
            {
                "name": "ALRBE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Alarm B enable"
            },
            {
                "name": "WUTE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Wakeup timer enable\nNote: When the wakeup timer is disabled, wait for WUTWF = 1 before enabling it again."
            },
            {
                "name": "TSE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "timestamp enable"
            },
            {
                "name": "ALRAIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Alarm A interrupt enable"
            },
            {
                "name": "ALRBIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Alarm B interrupt enable"
            },
            {
                "name": "WUTIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Wakeup timer interrupt enable"
            },
            {
                "name": "TSIE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Timestamp interrupt enable"
            },
            {
                "name": "ADD1H",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Add 1 hour (summer time change)\nWhen this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0."
            },
            {
                "name": "SUB1H",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Subtract 1 hour (winter time change)\nWhen this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0.\nSetting this bit has no effect when current hour is 0."
            },
            {
                "name": "BKP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Backup\nThis bit can be written by the user to memorize whether the daylight saving time change has been performed or not."
            },
            {
                "name": "COSEL",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Calibration output selection\nWhen COE = 1, this bit selects which signal is output on CALIB.\nThese frequencies are valid for RTCCLK at 32.768kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to Section74.3.18: Calibration clock output."
            },
            {
                "name": "POL",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Output polarity\nThis bit is used to configure the polarity of TAMPALRM output."
            },
            {
                "name": "OSEL",
                "bitOffset": 21,
                "bitWidth": 2,
                "desc": "Output selection\nThese bits are used to select the flag to be routed to TAMPALRM output."
            },
            {
                "name": "COE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Calibration output enable\nThis bit enables the CALIB output"
            },
            {
                "name": "TAMPTS",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Activate timestamp on tamper detection event\nTAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set up to 3 ck_apre cycles after the tamper flags."
            },
            {
                "name": "TAMPOE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Tamper detection output enable on TAMPALRM"
            },
            {
                "name": "ALRAFCLR",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Alarm A flag automatic clear"
            },
            {
                "name": "ALRBFCLR",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Alarm B flag automatic clear"
            },
            {
                "name": "TAMPALRM_PU",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "TAMPALRM pull-up enable"
            },
            {
                "name": "TAMPALRM_TYPE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TAMPALRM output type"
            },
            {
                "name": "OUT2EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RTC_OUT2 output enable\nWith this bit set, the RTC outputs can be remapped on RTC_OUT2 as follows:\nOUT2EN=0: RTC output 2 disable\nIf OSEL different 00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1\nIf OSEL=00 and TAMPOE=0 and COE=1: CALIB is output on RTC_OUT1\nOUT2EN = 1: RTC output 2 enable\nIf (OSEL different 00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2\nIf OSEL=00 and TAMPOE=0 and COE=1: CALIB is output on RTC_OUT2\nIf (OSEL different 00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1."
            }
        ]
    },
    "1174435868": {
        "name": "RTC_PRIVCFGR",
        "address": 1174435868,
        "size": 32,
        "access": "",
        "desc": "RTC privilege mode control register",
        "fields": [
            {
                "name": "ALRAPRIV",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A and SSR underflow privilege protection"
            },
            {
                "name": "ALRBPRIV",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B privilege protection"
            },
            {
                "name": "WUTPRIV",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer privilege protection"
            },
            {
                "name": "TSPRIV",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp privilege protection"
            },
            {
                "name": "CALPRIV",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Shift register, Delight saving, calibration and reference clock privilege protection"
            },
            {
                "name": "INITPRIV",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Initialization privilege protection"
            },
            {
                "name": "PRIV",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "RTC privilege protection"
            }
        ]
    },
    "1174435872": {
        "name": "RTC_SECCFGR",
        "address": 1174435872,
        "size": 32,
        "access": "",
        "desc": "RTC secure configuration register",
        "fields": [
            {
                "name": "ALRASEC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A and SSR underflow protection"
            },
            {
                "name": "ALRBSEC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B protection"
            },
            {
                "name": "WUTSEC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer protection"
            },
            {
                "name": "TSSEC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp protection"
            },
            {
                "name": "CALSEC",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Shift register, daylight saving, calibration and reference clock protection"
            },
            {
                "name": "INITSEC",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Initialization protection"
            },
            {
                "name": "SEC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "RTC global protection"
            }
        ]
    },
    "1174435876": {
        "name": "RTC_WPR",
        "address": 1174435876,
        "size": 32,
        "access": "",
        "desc": "RTC write protection register",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Write protection key\nThis byte is written by software.\nReading this byte always returns 0x00.\nRefer to RTC register write protection for a description of how to unlock RTC register write protection."
            }
        ]
    },
    "1174435880": {
        "name": "RTC_CALR",
        "address": 1174435880,
        "size": 32,
        "access": "",
        "desc": "RTC calibration register",
        "fields": [
            {
                "name": "CALM",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Calibration minus\nThe frequency of the calendar is reduced by masking CALM out of 2sup20/sup RTCCLK pulses (32seconds if the input frequency is 32768Hz). This decreases the frequency of the calendar with a resolution of 0.9537ppm.\nTo increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section74.3.16: RTC smooth digital calibration on page4278."
            },
            {
                "name": "LPCAL",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "RTC low-power mode"
            },
            {
                "name": "CALW16",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Use a 16-second calibration cycle period\nWhen CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1.\nNote: CALM[0] is stuck at 0 when CALW16 = 1. Refer to Section74.3.16: RTC smooth digital calibration."
            },
            {
                "name": "CALW8",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Use an 8-second calibration cycle period\nWhen CALW8 is set to 1, the 8-second calibration cycle period is selected.\nNote: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to Section74.3.16: RTC smooth digital calibration."
            },
            {
                "name": "CALP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Increase frequency of RTC by 488.5ppm. This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768 Hz, the number of RTCCLK pulses added during a 32 second window is calculated as follows: (512 * CALP)  CALM.\nRefer to Section74.3.16: RTC smooth digital calibration."
            }
        ]
    },
    "1174435884": {
        "name": "RTC_SHIFTR",
        "address": 1174435884,
        "size": 32,
        "access": "",
        "desc": "RTC shift control register",
        "fields": [
            {
                "name": "SUBFS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Subtract a fraction of a second\nThese bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThe value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by:\nDelay (seconds) = SUBFS / (PREDIV_S + 1)\nA fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by:\nAdvance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))).\nIn mixed BCD-binary mode (BIN=10 or 11), the SUBFS[14:BCDU+8] must be written with 0.\nNote: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time."
            },
            {
                "name": "ADD1S",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Add one second\nThis bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThis function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation."
            }
        ]
    },
    "1174435888": {
        "name": "RTC_TSTR",
        "address": 1174435888,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp time register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format."
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format."
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format."
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format."
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format."
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format."
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            }
        ]
    },
    "1174435892": {
        "name": "RTC_TSDR",
        "address": 1174435892,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp date register",
        "fields": [
            {
                "name": "DU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Date units in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "MU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Month units in BCD format"
            },
            {
                "name": "MT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Month tens in BCD format"
            },
            {
                "name": "WDU",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Week day units"
            }
        ]
    },
    "1174435896": {
        "name": "RTC_TSSSR",
        "address": 1174435896,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Subsecond value/synchronous binary counter values\nSS[31:0] is the value of the synchronous prescaler counter when the timestamp event occurred."
            }
        ]
    },
    "1174435904": {
        "name": "RTC_ALRMAR",
        "address": 1174435904,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format."
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format."
            },
            {
                "name": "MSK1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Alarm A seconds mask"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "MSK2",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Alarm A minutes mask"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            },
            {
                "name": "MSK3",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Alarm A hours mask"
            },
            {
                "name": "DU",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Date units or day in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "WDSEL",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Week day selection"
            },
            {
                "name": "MSK4",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Alarm A date mask"
            }
        ]
    },
    "1174435908": {
        "name": "RTC_ALRMASSR",
        "address": 1174435908,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Subseconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.\nThis field is the mirror of SS[14:0] in the RTC_ALRMABINR, and so can also be read or written through RTC_ALRMABINR."
            },
            {
                "name": "MASKSS",
                "bitOffset": 24,
                "bitWidth": 6,
                "desc": "Mask the most-significant bits starting at this bit\n...\nFrom 32 to 63: All 32 SS bits are compared and must match to activate alarm.\nNote: In BCD mode (BIN=00) the overflow bits of the synchronous counter (bits 31:15) are never compared. These bits can be different from 0 only after a shift operation."
            },
            {
                "name": "SSCLR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Clear synchronous counter on alarm (Binary mode only)\nNote: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11)."
            }
        ]
    },
    "1174435912": {
        "name": "RTC_ALRMBR",
        "address": 1174435912,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B register",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format"
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format"
            },
            {
                "name": "MSK1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Alarm B seconds mask"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "MSK2",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Alarm B minutes mask"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            },
            {
                "name": "MSK3",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Alarm B hours mask"
            },
            {
                "name": "DU",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Date units or day in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "WDSEL",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Week day selection"
            },
            {
                "name": "MSK4",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Alarm B date mask"
            }
        ]
    },
    "1174435916": {
        "name": "RTC_ALRMBSSR",
        "address": 1174435916,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B subsecond register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Subseconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.\nThis field is the mirror of SS[14:0] in the RTC_ALRMBBINR, and so can also be read or written through RTC_ALRMBBINR."
            },
            {
                "name": "MASKSS",
                "bitOffset": 24,
                "bitWidth": 6,
                "desc": "Mask the most-significant bits starting at this bit\n...\nFrom 32 to 63: All 32 SS bits are compared and must match to activate alarm.\nNote: In BCD mode (BIN=00)The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation."
            },
            {
                "name": "SSCLR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Clear synchronous counter on alarm (Binary mode only)\nNote: SSCLR must be kept to 0 when BCD or mixed mode is used (BIN = 00, 10 or 11)."
            }
        ]
    },
    "1174435920": {
        "name": "RTC_SR",
        "address": 1174435920,
        "size": 32,
        "access": "",
        "desc": "RTC status register",
        "fields": [
            {
                "name": "ALRAF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR)."
            },
            {
                "name": "ALRBF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR)."
            },
            {
                "name": "WUTF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer flag\nThis flag is set by hardware when the wakeup auto-reload counter reaches 0.\nIf WUTOCLR[15:0] is different from 0x0000, WUTF is cleared by hardware when the wakeup\nauto-reload counter reaches WUTOCLR value.\nIf WUTOCLR[15:0] is 0x0000, WUTF must be cleared by software.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
            },
            {
                "name": "TSF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp flag\nThis flag is set by hardware when a timestamp event occurs.\nNote: TSF is not set if TAMPTS=1 and the tamper flag is read during the 3 ck_apre cycles following tamper event. Refer to Timestamp on tamper event for more details."
            },
            {
                "name": "TSOVF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Timestamp overflow flag\nThis flag is set by hardware when a timestamp event occurs while TSF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "SSRUF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SSR underflow flag\nThis flag is set by hardware when the SSR rolls under 0. SSRUF is not set when SSCLR=1."
            }
        ]
    },
    "1174435924": {
        "name": "RTC_MISR",
        "address": 1174435924,
        "size": 32,
        "access": "",
        "desc": "RTC non-secure masked interrupt status register",
        "fields": [
            {
                "name": "ALRAMF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A masked flag\nThis flag is set by hardware when the alarm A non-secure interrupt occurs."
            },
            {
                "name": "ALRBMF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B non-secure masked flag\nThis flag is set by hardware when the alarm B non-secure interrupt occurs."
            },
            {
                "name": "WUTMF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer non-secure masked flag\nThis flag is set by hardware when the wakeup timer non-secure interrupt occurs.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
            },
            {
                "name": "TSMF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp non-secure masked flag\nThis flag is set by hardware when a timestamp non-secure interrupt occurs."
            },
            {
                "name": "TSOVMF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Timestamp overflow non-secure masked flag\nThis flag is set by hardware when a timestamp interrupt occurs while TSMF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "SSRUMF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SSR underflow non-secure masked flag\nThis flag is set by hardware when the SSR underflow non-secure interrupt occurs."
            }
        ]
    },
    "1174435928": {
        "name": "RTC_SMISR",
        "address": 1174435928,
        "size": 32,
        "access": "",
        "desc": "RTC secure masked interrupt status register",
        "fields": [
            {
                "name": "ALRAMF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A interrupt secure masked flag\nThis flag is set by hardware when the alarm A secure interrupt occurs."
            },
            {
                "name": "ALRBMF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B interrupt secure masked flag\nThis flag is set by hardware when the alarm B secure interrupt occurs."
            },
            {
                "name": "WUTMF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer interrupt secure masked flag\nThis flag is set by hardware when the wakeup timer secure interrupt occurs.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
            },
            {
                "name": "TSMF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp interrupt secure masked flag\nThis flag is set by hardware when a timestamp secure interrupt occurs."
            },
            {
                "name": "TSOVMF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Timestamp overflow interrupt secure masked flag\nThis flag is set by hardware when a timestamp secure interrupt occurs while TSMF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "SSRUMF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SSR underflow secure masked flag\nThis flag is set by hardware when the SSR underflow secure interrupt occurs."
            }
        ]
    },
    "1174435932": {
        "name": "RTC_SCR",
        "address": 1174435932,
        "size": 32,
        "access": "",
        "desc": "RTC status clear register",
        "fields": [
            {
                "name": "CALRAF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear alarm A flag\nWriting 1 in this bit clears the ALRAF bit in the RTC_SR register."
            },
            {
                "name": "CALRBF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear alarm B flag\nWriting 1 in this bit clears the ALRBF bit in the RTC_SR register."
            },
            {
                "name": "CWUTF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear wakeup timer flag\nWriting 1 in this bit clears the WUTF bit in the RTC_SR register."
            },
            {
                "name": "CTSF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear timestamp flag\nWriting 1 in this bit clears the TSF bit in the RTC_SR register."
            },
            {
                "name": "CTSOVF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear timestamp overflow flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "CSSRUF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Clear SSR underflow flag\nWriting '1' in this bit clears the SSRUF in the RTC_SR register."
            }
        ]
    },
    "1174435952": {
        "name": "RTC_ALRABINR",
        "address": 1174435952,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A binary mode register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Synchronous counter alarm value in Binary mode\nThis value is compared with the contents of the synchronous counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.\nSS[14:0] is the mirror of SS[14:0] in the RTC_ALRMASSRR, and so can also be read or written through RTC_ALRMASSR."
            }
        ]
    },
    "1174435956": {
        "name": "RTC_ALRBBINR",
        "address": 1174435956,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B binary mode register",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Synchronous counter alarm value in Binary mode\nThis value is compared with the contents of the synchronous counter to determine if Alarm Bis to be activated. Only bits 0 up MASKSS-1 are compared.\nSS[14:0] is the mirror of SS[14:0] in the RTC_ALRMBSSRR, and so can also be read or written through RTC_ALRMBSSR."
            }
        ]
    },
    "1174413312": {
        "name": "SPI_CR1",
        "address": 1174413312,
        "size": 32,
        "access": "",
        "desc": "SPI control register 1",
        "fields": [
            {
                "name": "SPE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "serial peripheral enable\nThis bit is set by and cleared by software.\nWhen SPE = 1, SPI data transfer is enabled, SPI_CFG1 and SPI_CFG2 configuration registers, CRCPOLY, UDRDR, part of SPI_AUTOCR register and IOLOCK bit in the SPI_CR1 register are write protected. They can be changed only when SPE = 0.\nWhen SPE = 0 any SPI operation is stopped and disabled, all the pending requests of the events with enabled interrupt are blocked except the MODF interrupt request (but their pending still propagates the request of the spi_plck clock), the SS output is deactivated at master, the RDY signal keeps not ready status at slave, the internal state machine is reseted, all the FIFOs content is flushed, CRC calculation initialized, receive data register is read zero.\nSPE is cleared and cannot be set when MODF error flag is active."
            },
            {
                "name": "MASRX",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "master automatic suspension in Receive mode\nThis bit is set and cleared by software to control continuous SPI transfer in master receiver mode and automatic management in order to avoid overrun condition.\nWhen SPI communication is suspended by hardware automatically, it could happen that few bits of next frame are already clocked out due to internal synchronization delay.\nThis is why, the automatic suspension is not quite reliable when size of data drops below 8 bits. In this case, a safe suspension can be achieved by combination with delay inserted between data frames applied when MIDI parameter keeps a non zero value; sum of data size and the interleaved SPI cycles should always produce interval at length of 8 SPI clock periods at minimum. After software clearing of the SUSP bit, the communication resumes and continues by subsequent bits transaction without any next constraint. Prior the SUSP bit is cleared, the user must release the RxFIFO space as much as possible by reading out all the data packets available at RxFIFO based on the RXP flag indication to prevent any subsequent suspension."
            },
            {
                "name": "CSTART",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "master transfer start\nThis bit can be set by software if SPI is enabled only to start an SPI communication. it is cleared by hardware when end of transfer (EOT) flag is set or when a transaction suspend request is accepted.\nIn SPI mode, the bit is taken into account at master mode only. If transmission is enabled, communication starts or continues only if any data is available in the transmission FIFO."
            },
            {
                "name": "CSUSP",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "master suspend request\nThis bit reads as zero.\nIn Master mode, when this bit is set by software, the CSTART bit is reset at the end of the current frame and communication is suspended. The user has to check SUSP flag to check end of the frame transaction.\nThe Master mode communication must be suspended (using this bit or keeping TXDR empty) before going to Low-power mode. Can be used in SPI or I2S mode.\nAfter software suspension, SUSP flag must be cleared and SPI disabled and re-enabled before the next transaction starts."
            },
            {
                "name": "HDDIR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Rx/Tx direction at Half-duplex mode\nIn Half-Duplex configuration the HDDIR bit establishes the Rx/Tx direction of the data transfer. This bit is ignored in Full-Duplex or any Simplex configuration."
            },
            {
                "name": "SSI",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "internal SS signal input level\nThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the peripheral SS input internally and the I/O value of the SS pin is ignored."
            },
            {
                "name": "CRC33_17",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "32-bit CRC polynomial configuration"
            },
            {
                "name": "RCRCINI",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "CRC calculation initialization pattern control for receiver"
            },
            {
                "name": "TCRCINI",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CRC calculation initialization pattern control for transmitter"
            },
            {
                "name": "IOLOCK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "locking the AF configuration of associated I/Os\nThis bit is set by software and cleared by hardware whenever the SPE bit is changed from 1 to 0.\nWhen this bit is set, SPI_CFG2 register content cannot be modified. This bit can be set when SPI is disabled only else it is write protected. It is cleared and cannot be set when MODF bit is set."
            }
        ]
    },
    "1174413316": {
        "name": "SPI_CR2",
        "address": 1174413316,
        "size": 32,
        "access": "",
        "desc": "SPI control register 2",
        "fields": [
            {
                "name": "TSIZE",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "number of data at current transfer\nWhen these bits are changed by software, the SPI must be disabled.\nEndless transaction is initialized when CSTART is set while zero value is stored at TSIZE. TSIZE cannot be set to 0xFFFF respective 0x3FFF value when CRC is enabled.\nNote: TSIZE[15:10] bits are reserved at limited feature set instances and must be kept at reset value."
            }
        ]
    },
    "1174413320": {
        "name": "SPI_CFG1",
        "address": 1174413320,
        "size": 32,
        "access": "",
        "desc": "SPI configuration register 1",
        "fields": [
            {
                "name": "DSIZE",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "number of bits in at single SPI data frame\n.....\nMaximum data size can be limited up to 16-bits at some instances. At instances with limited set of features, DSIZE2:0] bits are reserved and must be kept at reset state. DSIZE[4:3] bits then control next settings of data size:\n00xxx: 8-bits\n01xxx: 16-bits\n10xxx: 24-bits\nNote: 11xxx: 32-bits."
            },
            {
                "name": "FTHLV",
                "bitOffset": 5,
                "bitWidth": 4,
                "desc": "FIFO threshold level\nDefines number of data frames at single data packet. Size of the packet should not exceed 1/2 of FIFO space.\nSPI interface is more efficient if configured packet sizes are aligned with data register access parallelism:\nIf SPI data register is accessed as a 16-bit register and DSIZE less than or equal 8 bit, better to select FTHLV = 2, 4, 6.\nIf SPI data register is accessed as a 32-bit register and DSIZE 8 bit, better to select FTHLV = 2, 4, 6, while if DSIZE less than or equal 8bit, better to select FTHLV = 4, 8, 12.\nNote: FTHLV[3:2] bits are reserved at instances with limited set of features"
            },
            {
                "name": "UDRCFG",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "behavior of slave transmitter at underrun condition\nFor more details see Figure977: Optional configurations of slave detecting underrun condition."
            },
            {
                "name": "RXDMAEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Rx DMA stream enable"
            },
            {
                "name": "TXDMAEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Tx DMA stream enable"
            },
            {
                "name": "CRCSIZE",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "length of CRC frame to be transacted and compared\nMost significant bits are taken into account from polynomial calculation when CRC result is transacted or compared. The length of the polynomial is not affected by this setting.\n.....\nThe value must be set equal or multiply of data size (DSIZE[4:0]). Its maximum size corresponds to DSIZE maximum at the instance.\nNote: The most significant bit at CRCSIZE bit field is reserved at the peripheral instances where data size is limited to 16-bit."
            },
            {
                "name": "CRCEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "hardware CRC computation enable"
            },
            {
                "name": "MBR",
                "bitOffset": 28,
                "bitWidth": 3,
                "desc": "master baud rate prescaler setting\nNote: MBR setting is considered at slave working at TI mode, too (see Section80.5.1: TI mode)."
            },
            {
                "name": "BPASS",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "bypass of the prescaler at master baud rate clock generator"
            }
        ]
    },
    "1174413324": {
        "name": "SPI_CFG2",
        "address": 1174413324,
        "size": 32,
        "access": "",
        "desc": "SPI configuration register 2",
        "fields": [
            {
                "name": "MSSI",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Master SS Idleness\nSpecifies an extra delay, expressed in number of SPI clock cycle periods, inserted additionally between active edge of SS opening a session and the beginning of the first data frame of the session in Master mode when SSOE is enabled.\n...\nThis feature is not supported in TI mode.\nNote: To include the delay, the SPI must be disabled and re-enabled between sessions."
            },
            {
                "name": "MIDI",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "master Inter-Data Idleness\nSpecifies minimum time delay (expressed in SPI clock cycles periods) inserted between two consecutive data frames in Master mode.\n...\nNote: This feature is not supported in TI mode."
            },
            {
                "name": "RDIOM",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "RDY signal input/output management\nNote: When DSIZE at the SPI_CFG1 register is configured shorter than 8-bit, the RDIOM bit must be kept at zero."
            },
            {
                "name": "RDIOP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "RDY signal input/output polarity"
            },
            {
                "name": "IOSWP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "swap functionality of MISO and MOSI pins\nWhen this bit is set, the function of MISO and MOSI pins alternate functions are inverted.\nOriginal MISO pin becomes MOSI and original MOSI pin becomes MISO."
            },
            {
                "name": "COMM",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "SPI Communication Mode"
            },
            {
                "name": "SP",
                "bitOffset": 19,
                "bitWidth": 3,
                "desc": "serial protocol\nothers: reserved, must not be used"
            },
            {
                "name": "MASTER",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "SPI Master"
            },
            {
                "name": "LSBFRST",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "data frame format\nNote: 1: LSB transmitted first"
            },
            {
                "name": "CPHA",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "clock phase"
            },
            {
                "name": "CPOL",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "clock polarity"
            },
            {
                "name": "SSM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "software management of SS signal input\nWhen master uses hardware SS output (SSM = 0 and SSOE = 1) the SS signal input is forced to not active state internally to prevent master mode fault error."
            },
            {
                "name": "SSIOP",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "SS input/output polarity"
            },
            {
                "name": "SSOE",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "SS output enable\nThis bit is taken into account in Master mode only"
            },
            {
                "name": "SSOM",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "SS output management in Master mode\nThis bit is taken into account in Master mode when SSOE is enabled. It allows the SS output to be configured between two consecutive data transfers."
            },
            {
                "name": "AFCNTR",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "alternate function GPIOs control\nThis bit is taken into account when SPE = 0 only\nNote: When SPI must be disabled temporary for a specific configuration reason (e.g. CRC reset, CPHA or HDDIR change) setting this bit prevents any glitches on the associated outputs configured at alternate function mode by keeping them forced at state corresponding the current SPI configuration."
            }
        ]
    },
    "1174413328": {
        "name": "SPI_IER",
        "address": 1174413328,
        "size": 32,
        "access": "",
        "desc": "SPI interrupt enable register",
        "fields": [
            {
                "name": "RXPIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RXP interrupt enable"
            },
            {
                "name": "TXPIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TXP interrupt enable\nTXPIE is set by software and cleared by TXTF flag set event."
            },
            {
                "name": "DXPIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "DXP interrupt enabled\nDXPIE is set by software and cleared by TXTF flag set event."
            },
            {
                "name": "EOTIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "EOT, SUSP and TXC interrupt enable"
            },
            {
                "name": "TXTFIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TXTFIE interrupt enable"
            },
            {
                "name": "UDRIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "UDR interrupt enable"
            },
            {
                "name": "OVRIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "OVR interrupt enable"
            },
            {
                "name": "CRCEIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CRC error interrupt enable"
            },
            {
                "name": "TIFREIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "TIFRE interrupt enable"
            },
            {
                "name": "MODFIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "mode Fault interrupt enable"
            }
        ]
    },
    "1174413332": {
        "name": "SPI_SR",
        "address": 1174413332,
        "size": 32,
        "access": "",
        "desc": "SPI status register",
        "fields": [
            {
                "name": "RXP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rx-Packet available\n     In I2S mode, it must be interpreted as follow: RxFIFO level is lower than FTHLV\n     In I2S mode, it must be interpreted as follow: RxFIFO level is higher or equal to FTHLV\nRXP flag is changed by hardware. It monitors number of overall data currently available at RxFIFO if SPI is enabled. It must be checked once a data packet is completely read out from RxFIFO."
            },
            {
                "name": "TXP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tx-Packet space available\n   In I2S mode, it must be interpreted as follow: there is less than FTHLV free locations in the TxFIFO\n   In I2S mode, it must be interpreted as follow: there is FTHLV or more than FTHLV free locations in the TxFIFO\nTXP flag is changed by hardware. It monitors overall space currently available at TxFIFO no matter if SPI is enabled or not. It must be checked once a complete data packet is stored at TxFIFO."
            },
            {
                "name": "DXP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "duplex packet\nDXP flag is set whenever both TXP and RXP flags are set regardless SPI mode."
            },
            {
                "name": "EOT",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "end of transfer\nEOT is set by hardware as soon as a full transfer is complete, that is when SPI is re-enabled or when TSIZE number of data have been transmitted and/or received on the SPI. EOT is cleared when SPI is re-enabled or by writing 1 to EOTC bit of SPI_IFCR optionally.\nEOT flag triggers an interrupt if EOTIE bit is set.\nIf DXP flag is used until TXTF flag is set and DXPIE is cleared, EOT can be used to download the last packets contained into RxFIFO in one-shot.\nIn master, EOT event terminates the data transaction and handles SS output optionally. When CRC is applied, the EOT event is extended over the CRC frame transaction.\nTo restart the internal state machine properly, SPI is strongly suggested to be disabled and re-enabled before next transaction starts despite its setting is not changed."
            },
            {
                "name": "TXTF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "transmission transfer filled\nTXTF is set by hardware as soon as all of the data packets in a transfer have been submitted for transmission by application software or DMA, that is when TSIZE number of data have been pushed into the TxFIFO.\nThis bit is cleared by software write 1 to TXTFC bit of SPI_IFCR exclusively.\nTXTF flag triggers an interrupt if TXTFIE bit is set.\nTXTF setting clears the TXPIE and DXPIE masks so to off-load application software from calculating when to disable TXP and DXP interrupts."
            },
            {
                "name": "UDR",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "underrun\nThis bit is cleared when SPI is re-enabled or by writing 1 to UDRC bit of SPI_IFCR optionally.\nNote: In SPI mode, the UDR flag applies to Slave mode only. In I2S/PCM mode, (when available) this flag applies to Master and Slave mode"
            },
            {
                "name": "OVR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "overrun\nThis bit is cleared when SPI is re-enabled or by writing 1 to OVRC bit of SPI_IFCR optionally."
            },
            {
                "name": "CRCE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CRC error\nThis bit is cleared when SPI is re-enabled or by writing 1 to CRCEC bit of SPI_IFCR optionally."
            },
            {
                "name": "TIFRE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "TI frame format error\nThis bit is cleared by writing 1 to TIFREC bit of SPI_IFCR exclusively."
            },
            {
                "name": "MODF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "mode fault\nThis bit is cleared by writing 1 to MODFC bit of SPI_IFCR exclusively."
            },
            {
                "name": "SUSP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "suspension status\nIn Master mode, SUSP is set by hardware either as soon as the current frame is completed after CSUSP request is done or at master automatic suspend receive mode (MASRX bit is set at SPI_CR1 register) on RxFIFO full condition.\nSUSP generates an interrupt when EOTIE is set.\nThis bit must be cleared prior SPI is disabled and this is done by writing 1 to SUSPC bit of SPI_IFCR exclusively."
            },
            {
                "name": "TXC",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "TxFIFO transmission complete\nThe flag behavior depends on TSIZE setting.\nWhen TSIZE = 0 the TXC is changed by hardware exclusively and it raises each time the TxFIFO becomes empty and there is no activity on the bus.\nIf TSIZE different 0 there is no specific reason to monitor TXC as it just copies the EOT flag value including its software clearing. The TXC generates an interrupt when EOTIE is set."
            },
            {
                "name": "RXPLVL",
                "bitOffset": 13,
                "bitWidth": 2,
                "desc": "RxFIFO packing level\nWhen RXWNE = 0 and data size is set up to 16-bit, the value gives number of remaining data frames persisting at RxFIFO.\nNote: (*): Optional value when data size is set up to 8-bit only.\nWhen data size is greater than 16-bit, these bits are always read as 00. In that consequence, the single data frame received at the FIFO cannot be detected neither by RWNE nor by RXPLVL bits if data size is set from 17 to 24 bits. The user then must apply other methods like TSIZE  0 or FTHLV = 0."
            },
            {
                "name": "RXWNE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "RxFIFO word not empty\nNote: This bit value does not depend on DSIZE setting and keeps together with RXPLVL[1:0] information about RxFIFO occupancy by residual data."
            },
            {
                "name": "CTSIZE",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "number of data frames remaining in current TSIZE session\nThe value is not quite reliable when traffic is ongoing on bus or during autonomous operation in low-power mode.\nNote: CTSIZE[15:0] bits are not available in instances with limited set of features."
            }
        ]
    },
    "1174413336": {
        "name": "SPI_IFCR",
        "address": 1174413336,
        "size": 32,
        "access": "",
        "desc": "SPI interrupt/status flags clear register",
        "fields": [
            {
                "name": "EOTC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "end of transfer flag clear\nWriting a 1 into this bit clears EOT flag in the SPI_SR register"
            },
            {
                "name": "TXTFC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "transmission transfer filled flag clear\nWriting a 1 into this bit clears TXTF flag in the SPI_SR register"
            },
            {
                "name": "UDRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "underrun flag clear\nWriting a 1 into this bit clears UDR flag in the SPI_SR register"
            },
            {
                "name": "OVRC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "overrun flag clear\nWriting a 1 into this bit clears OVR flag in the SPI_SR register"
            },
            {
                "name": "CRCEC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CRC error flag clear\nWriting a 1 into this bit clears CRCE flag in the SPI_SR register"
            },
            {
                "name": "TIFREC",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "TI frame format error flag clear\nWriting a 1 into this bit clears TIFRE flag in the SPI_SR register"
            },
            {
                "name": "MODFC",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "mode fault flag clear\nWriting a 1 into this bit clears MODF flag in the SPI_SR register"
            },
            {
                "name": "SUSPC",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Suspend flag clear\nWriting a 1 into this bit clears SUSP flag in the SPI_SR register"
            }
        ]
    },
    "1174413340": {
        "name": "SPI_AUTOCR",
        "address": 1174413340,
        "size": 32,
        "access": "",
        "desc": "SPI autonomous mode control register",
        "fields": [
            {
                "name": "TRIGSEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "trigger selection (refer Section: Description of SPI interconnections).\n...\nNote: these bits can be written only when SPE=0."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "trigger polarity\nNote: This bit can be written only when SPE=0."
            },
            {
                "name": "TRIGEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "HW control of CSTART triggering enable\nNote: if user cannot prevent trigger event during write, the TRIGEN must be changed when SPI is disabled"
            }
        ]
    },
    "1174413344": {
        "name": "SPI_TXDR",
        "address": 1174413344,
        "size": 32,
        "access": "",
        "desc": "SPI transmit data register",
        "fields": [
            {
                "name": "TXDR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "transmit data register\nThe register serves as an interface with TxFIFO. A write to it accesses TxFIFO.\nNote: data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read.\nNote: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is written by single access.\nNote: halfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be written by single access.\nNote: word-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data can be written by single access.\nNote: Write access of this register less than the configured data size is forbidden."
            }
        ]
    },
    "1174413360": {
        "name": "SPI_RXDR",
        "address": 1174413360,
        "size": 32,
        "access": "",
        "desc": "SPI receive data register",
        "fields": [
            {
                "name": "RXDR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "receive data register\nThe register serves as an interface with RxFIFO. When it is read, RxFIFO is accessed.\nNote: data is always right-aligned. Unused bits are read as zero when the register is read. Writing to the register is ignored.\nNote: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is read by single access\nNote: halfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be read by single access\nNote: word-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data can be read by single access.\nNote: Read access of this register less than the configured data size is forbidden."
            }
        ]
    },
    "1174413376": {
        "name": "SPI_CRCPOLY",
        "address": 1174413376,
        "size": 32,
        "access": "",
        "desc": "SPI polynomial register",
        "fields": [
            {
                "name": "CRCPOLY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "CRC polynomial register\nThis register contains the polynomial for the CRC calculation.\nThe default 9-bit polynomial setting 0x107 corresponds to default 8-bit setting of DSIZE. It is compatible with setting 0x07 used in other ST products with fixed length of the polynomial string, where the most significant bit of the string is always kept hidden.\nLength of the polynomial is given by the most significant bit of the value stored in this register. It must be set greater than DSIZE. CRC33_17 bit must be set additionally with CRCPOLY register when DSIZE is configured to maximum 32-bit or 16-bit size and CRC is enabled (to keep polynomial length grater than data size).\nNote: CRCPOLY[31:16] bits are reserved at instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored."
            }
        ]
    },
    "1174413380": {
        "name": "SPI_TXCRC",
        "address": 1174413380,
        "size": 32,
        "access": "",
        "desc": "SPI transmitter CRC register",
        "fields": [
            {
                "name": "TXCRC",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "CRC register for transmitter\nWhen CRC calculation is enabled, the TXCRC[31:0] bits contain the computed CRC value of the subsequently transmitted bytes. CRC calculation is initialized when the CRCEN bit of SPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPOLY register.\nThe number of bits considered at calculation depends on SPI_CRCPOLY register and CRCSIZE bits settings at SPI_CFG1 register.\nNote: a read to this register when the communication is ongoing could return an incorrect value.\nNote: TXCRC[31-16] bits are reserved at instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.\nNote: The configuration of CRCSIZE bit field is not taken into account when the content of this register is read by software. No masking is applied for unused bits in this case."
            }
        ]
    },
    "1174413384": {
        "name": "SPI_RXCRC",
        "address": 1174413384,
        "size": 32,
        "access": "",
        "desc": "SPI receiver CRC register",
        "fields": [
            {
                "name": "RXCRC",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "CRC register for receiver\nWhen CRC calculation is enabled, the RXCRC[31:0] bits contain the computed CRC value of the subsequently received bytes. CRC calculation is initialized when the CRCEN bit of SPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPOLY register.\nThe number of bits considered at calculation depends on SPI_CRCPOLY register and CRCSIZE bits settings at SPI_CFG1 register.\nNote: a read to this register when the communication is ongoing could return an incorrect value.\nNote: RXCRC[31-16] bits are reserved at the peripheral instances with data size limited to 16-bit. There is no constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored.\nNote: The configuration of CRCSIZE bit field is not taken into account when the content of this register is read by software. No masking is applied for unused bits in this case."
            }
        ]
    },
    "1174413388": {
        "name": "SPI_UDRDR",
        "address": 1174413388,
        "size": 32,
        "access": "",
        "desc": "SPI underrun data register",
        "fields": [
            {
                "name": "UDRDR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "data at slave underrun condition\nThe register is taken into account in Slave mode and at underrun condition only. The number of bits considered depends on DSIZE bit settings of the SPI_CFG1 register. Underrun condition handling depends on setting UDRCFG bit at SPI_CFG1 register.\nNote: UDRDR[31-16] bits are reserved at the peripheral instances with data size limited to 16-bit. There is no constraint when 32-bit access is applied at these addresses. Reserved bits 31-16 are always read zero while any write to them is ignored."
            }
        ]
    },
    "1174406144": {
        "name": "SYSCFG_SECCFGR",
        "address": 1174406144,
        "size": 32,
        "access": "",
        "desc": "SYSCFG secure configuration register",
        "fields": [
            {
                "name": "SYSCFGSEC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYSCFG clock control, memory erase status and compensation cell registers security"
            },
            {
                "name": "CLASSBSEC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Class B security"
            },
            {
                "name": "FPUSEC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "FPU security"
            }
        ]
    },
    "1174406148": {
        "name": "SYSCFG_CFGR1",
        "address": 1174406148,
        "size": 32,
        "access": "",
        "desc": "SYSCFG configuration register 1",
        "fields": [
            {
                "name": "BOOSTEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "I/O analog switch voltage booster enable\nAccess can be protected by GTZC_TZSC ADC4SEC.\nNote: Refer to Table121 for setting."
            },
            {
                "name": "ANASWVDD",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "GPIO analog switch control voltage selection\nAccess can be protected by GTZC_TZSC ADC4SEC.\nNote: Refer to Table121 for setting."
            },
            {
                "name": "PA6_FMP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Fast-mode Plus drive capability activation on PA6\nThis bit can be read and written only with secure access if PA6 is secure in GPIOA. This bit enables the Fast-mode Plus drive mode for PA6 when PA6 is not used by I2C peripheral. This can be used to dive a LED for instance.\nAccess can be protected by GPIOA SEC6."
            },
            {
                "name": "PA7_FMP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Fast-mode Plus drive capability activation on PA7\nThis bit can be read and written only with secure access if PA7 is secure in GPIOA. This bit enables the Fast-mode Plus drive mode for PA7 when PA7 is not used by I2C peripheral. This can be used to dive a LED for instance.\nAccess can be protected by GPIOA SEC7."
            },
            {
                "name": "PA15_FMP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Fast-mode Plus drive capability activation on PA15\nThis bit can be read and written only with secure access if PA15 is secure in GPIOA. This bit enables the Fast-mode Plus drive mode for PA15 when PA15 is not used by I2C peripheral. This can be used to dive a LED for instance.\nAccess can be protected by GPIOA SEC15."
            },
            {
                "name": "PB3_FMP",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Fast-mode Plus drive capability activation on PB3\nThis bit can be read and written only with secure access if PB3 is secure in GPIOB. This bit enables the Fast-mode Plus drive mode for PB3 when PB3 is not used by I2C peripheral. This can be used to dive a LED for instance.\nAccess can be protected by GPIOB SEC3."
            }
        ]
    },
    "1174406152": {
        "name": "SYSCFG_FPUIMR",
        "address": 1174406152,
        "size": 32,
        "access": "",
        "desc": "SYSCFG FPU interrupt mask register",
        "fields": [
            {
                "name": "FPU_IE",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "Floating point unit interrupts enable bits\nFPU_IE[5]: Inexact interrupt enable (interrupt disable at reset)\nFPU_IE[4]: Input abnormal interrupt enable\nFPU_IE[3]: Overflow interrupt enable\nFPU_IE[2]: Underflow interrupt enable\nFPU_IE[1]: Divide-by-zero interrupt enable\nFPU_IE[0]: Invalid operation Interrupt enable"
            }
        ]
    },
    "1174406156": {
        "name": "SYSCFG_CNSLCKR",
        "address": 1174406156,
        "size": 32,
        "access": "",
        "desc": "SYSCFG CPU non-secure lock register",
        "fields": [
            {
                "name": "LOCKNSVTOR",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "VTOR_NS register lock\nThis bit is set by software and cleared only by a system reset."
            },
            {
                "name": "LOCKNSMPU",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Non-secure MPU registers lock\nThis bit is set by software and cleared only by a system reset. When set, this bit disables write access to non-secure MPU_CTRL_NS, MPU_RNR_NS and MPU_RBAR_NS registers."
            }
        ]
    },
    "1174406160": {
        "name": "SYSCFG_CSLOCKR",
        "address": 1174406160,
        "size": 32,
        "access": "",
        "desc": "SYSCFG CPU secure lock register",
        "fields": [
            {
                "name": "LOCKSVTAIRCR",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "VTOR_S register and AIRCR register bits lock\nThis bit is set by software and cleared only by a system reset. When set, it disables write access to VTOR_S register, PRIS and BFHFNMINS bits in the AIRCR register."
            },
            {
                "name": "LOCKSMPU",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Secure MPU registers lock\nThis bit is set by software and cleared only by a system reset. When set, it disables write access to secure MPU_CTRL, MPU_RNR and MPU_RBAR registers."
            },
            {
                "name": "LOCKSAU",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "SAU registers lock\nThis bit is set by software and cleared only by a system reset. When set, it disables write access to SAU_CTRL, SAU_RNR, SAU_RBAR and SAU_RLAR registers."
            }
        ]
    },
    "1174406164": {
        "name": "SYSCFG_CFGR2",
        "address": 1174406164,
        "size": 32,
        "access": "",
        "desc": "SYSCFG configuration register 2",
        "fields": [
            {
                "name": "CLL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Cortex-M33 LOCKUP (hardfault) output enable\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock the connection of Cortex-M33 LOCKUP (hardfault) output to TIM1/16/17 break input."
            },
            {
                "name": "SPL",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SRAM2 parity lock bit\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock the SRAM2 parity error signal connection to TIM1/16/17 break inputs."
            },
            {
                "name": "PVDL",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "PVD lock enable bit\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock the PVD connection to TIM1/16/17 break input, as well as the PVDE and PVDLS[2:0] in the PWR register."
            },
            {
                "name": "ECCL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "ECC lock\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock the Flash ECC double error signal connection to TIM1/16/17 break input."
            }
        ]
    },
    "1174406168": {
        "name": "SYSCFG_MESR",
        "address": 1174406168,
        "size": 32,
        "access": "",
        "desc": "SYSCFG memory erase status register",
        "fields": [
            {
                "name": "MCLR",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Device memories erase status\nThis bit is set by hardware when SRAM2, ICACHE, PKA SRAM erase is completed after power-on reset or tamper detection (refer to Section75: Tamper and backup registers (TAMP) for more details). This bit is not reset by system reset and is cleared by software by writing 1 to it."
            },
            {
                "name": "IPMEE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "ICACHE and PKA SRAM erase status\nThis bit is set by hardware when ICACHE and PKA SRAM erase is completed after potential tamper detection (refer to Section75: Tamper and backup registers (TAMP) for more details). This bit is cleared by software by writing 1 to it."
            }
        ]
    },
    "1174406172": {
        "name": "SYSCFG_CCCSR",
        "address": 1174406172,
        "size": 32,
        "access": "",
        "desc": "SYSCFG compensation cell control/status register",
        "fields": [
            {
                "name": "EN1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "VDD I/Os compensation cell enable\nThis bit enables the compensation cell of the I/Os supplied by VsubDD/sub."
            },
            {
                "name": "CS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "VDD I/Os code selection\nThis bit selects the code to be applied for the compensation cell of the I/Os supplied by VsubDD/sub."
            },
            {
                "name": "RDY1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "VDD I/Os compensation cell ready flag\nThis bit provides the compensation cell status of the I/Os supplied by VsubDD/sub.\nNote: The HSI16 clock is required for the compensation cell to work properly. The compensation cell ready bit (RDY1) is not set if the HSI16 clock is not enabled (HSION)."
            }
        ]
    },
    "1174406176": {
        "name": "SYSCFG_CCVR",
        "address": 1174406176,
        "size": 32,
        "access": "",
        "desc": "SYSCFG compensation cell value register",
        "fields": [
            {
                "name": "NCV1",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "NMOS compensation value of the I/Os supplied by VsubDD/sub\nThis value is provided by the cell and can be used by the CPU to compute an I/Os compensation cell code for NMOS transistors. This code is applied to the I/Os compensation cell when the CS1 bit of the SYSCFG_CCCSR is reset."
            },
            {
                "name": "PCV1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "PMOS compensation value of the I/Os supplied by VsubDD/sub\nThis value is provided by the cell and can be used by the CPU to compute an I/Os compensation cell code for PMOS transistors. This code is applied to the I/Os compensation cell when the CS1 bit of the SYSCFG_CCCSR is reset."
            }
        ]
    },
    "1174406180": {
        "name": "SYSCFG_CCCR",
        "address": 1174406180,
        "size": 32,
        "access": "",
        "desc": "SYSCFG compensation cell code register",
        "fields": [
            {
                "name": "NCC1",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "NMOS compensation code of the I/Os supplied by VsubDD/sub\nThese bits are written by software to define an I/Os compensation cell code for NMOS transistors. This code is applied to the I/Os compensation cell when the CS1 bit of the SYSCFG_CCCSR is set."
            },
            {
                "name": "PCC1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "PMOS compensation code of the I/Os supplied by VsubDD/sub\nThese bits are written by software to define an I/Os compensation cell code for PMOS transistors. This code is applied to the I/Os compensation cell when the CS1 bit of the SYSCFG_CCCSR is set."
            }
        ]
    },
    "1174406188": {
        "name": "SYSCFG_RSSCMDR",
        "address": 1174406188,
        "size": 32,
        "access": "",
        "desc": "SYSCFG RSS command register",
        "fields": [
            {
                "name": "RSSCMD",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "RSS commands\nThis field defines a command to be executed by the RSS."
            }
        ]
    },
    "1174436864": {
        "name": "TAMP_CR1",
        "address": 1174436864,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 1",
        "fields": [
            {
                "name": "TAMP1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN1 enable"
            },
            {
                "name": "TAMP2E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN2 enable"
            },
            {
                "name": "TAMP3E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN3 enable"
            },
            {
                "name": "TAMP4E",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN4 enable"
            },
            {
                "name": "TAMP5E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN5 enable"
            },
            {
                "name": "TAMP6E",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN6 enable"
            },
            {
                "name": "ITAMP3E",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 enable"
            },
            {
                "name": "ITAMP5E",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 enable"
            },
            {
                "name": "ITAMP6E",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 enable"
            },
            {
                "name": "ITAMP7E",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Internal tamper 7 enable"
            },
            {
                "name": "ITAMP8E",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Internal tamper 8 enable"
            },
            {
                "name": "ITAMP9E",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Internal tamper 9 enable"
            },
            {
                "name": "ITAMP11E",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Internal tamper 11 enable"
            },
            {
                "name": "ITAMP12E",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Internal tamper 12 enable"
            },
            {
                "name": "ITAMP13E",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Internal tamper 13 enable"
            }
        ]
    },
    "1174436868": {
        "name": "TAMP_CR2",
        "address": 1174436868,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 2",
        "fields": [
            {
                "name": "TAMP1NOER",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper 1 no erase"
            },
            {
                "name": "TAMP2NOER",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper 2 no erase"
            },
            {
                "name": "TAMP3NOER",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Tamper 3 no erase"
            },
            {
                "name": "TAMP4NOER",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Tamper 4 no erase"
            },
            {
                "name": "TAMP5NOER",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Tamper 5 no erase"
            },
            {
                "name": "TAMP6NOER",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Tamper 6 no erase"
            },
            {
                "name": "TAMP1MSK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Tamper 1 mask\nThe tamper 1 interrupt must not be enabled when TAMP1MSK is set."
            },
            {
                "name": "TAMP2MSK",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Tamper 2 mask\nThe tamper 2 interrupt must not be enabled when TAMP2MSK is set."
            },
            {
                "name": "TAMP3MSK",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Tamper 3 mask\nThe tamper 3 interrupt must not be enabled when TAMP3MSK is set."
            },
            {
                "name": "BKBLOCK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Backup registers and device secretssup(1)/sup access blocked"
            },
            {
                "name": "BKERASE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Backup registers and device secretssup(1)/sup erase\nWriting '1' to this bit reset the backup registers and device secretssup(1)/sup. Writing 0 has no effect. This bit is always read as 0."
            },
            {
                "name": "TAMP1TRG",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Active level for tamper 1 input\nIf TAMPFLT=00 Tamper 1 input rising edge triggers a tamper detection event.\nIf TAMPFLT=00 Tamper 1 input falling edge triggers a tamper detection event."
            },
            {
                "name": "TAMP2TRG",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Active level for tamper 2 input\nIf TAMPFLT = 00 Tamper 2 input rising edge triggers a tamper detection event.\nIf TAMPFLT=00 Tamper 2 input falling edge triggers a tamper detection event."
            },
            {
                "name": "TAMP3TRG",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Active level for tamper 3 input\nIf TAMPFLT=00 Tamper 3 input rising edge triggers a tamper detection event.\nIf TAMPFLT=00 Tamper 3 input falling edge triggers a tamper detection event."
            },
            {
                "name": "TAMP4TRG",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Active level for tamper 4 input (active mode disabled)\nIf TAMPFLT=00 Tamper 4 input rising edge triggers a tamper detection event.\nIf TAMPFLT=00 Tamper 4 input falling edge triggers a tamper detection event."
            },
            {
                "name": "TAMP5TRG",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Active level for tamper 5 input (active mode disabled)\nIf TAMPFLT=00 Tamper 5 input rising edge triggers a tamper detection event.\nIf TAMPFLT=00 Tamper 5 input falling edge triggers a tamper detection event."
            },
            {
                "name": "TAMP6TRG",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Active level for tamper 6 input (active mode disabled)\nIf TAMPFLT=00 Tamper 6 input rising edge triggers a tamper detection event.\nIf TAMPFLT=00 Tamper 6 input falling edge triggers a tamper detection event."
            }
        ]
    },
    "1174436872": {
        "name": "TAMP_CR3",
        "address": 1174436872,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 3",
        "fields": [
            {
                "name": "ITAMP3NOER",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Internal Tamper 3 no erase"
            },
            {
                "name": "ITAMP5NOER",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Internal Tamper 5 no erase"
            },
            {
                "name": "ITAMP6NOER",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Internal Tamper 6 no erase"
            },
            {
                "name": "ITAMP7NOER",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Internal Tamper 7 no erase"
            },
            {
                "name": "ITAMP8NOER",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Internal Tamper 8 no erase"
            },
            {
                "name": "ITAMP9NOER",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Internal Tamper 9 no erase"
            },
            {
                "name": "ITAMP11NOER",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Internal Tamper 11 no erase"
            },
            {
                "name": "ITAMP12NOER",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Internal Tamper 12 no erase"
            },
            {
                "name": "ITAMP13NOER",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Internal Tamper 13 no erase"
            }
        ]
    },
    "1174436876": {
        "name": "TAMP_FLTCR",
        "address": 1174436876,
        "size": 32,
        "access": "",
        "desc": "TAMP filter control register",
        "fields": [
            {
                "name": "TAMPFREQ",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Tamper sampling frequency\nDetermines the frequency at which each of the TAMP_INx inputs are sampled."
            },
            {
                "name": "TAMPFLT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "TAMP_INx filter count\nThese bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs."
            },
            {
                "name": "TAMPPRCH",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "TAMP_INx precharge duration\nThese bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs."
            },
            {
                "name": "TAMPPUDIS",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TAMP_INx pull-up disable\nThis bit determines if each of the TAMPx pins are precharged before each sample."
            }
        ]
    },
    "1174436880": {
        "name": "TAMP_ATCR1",
        "address": 1174436880,
        "size": 32,
        "access": "",
        "desc": "TAMP active tamper control register 1",
        "fields": [
            {
                "name": "TAMP1AM",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper 1 active mode"
            },
            {
                "name": "TAMP2AM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper 2 active mode"
            },
            {
                "name": "TAMP3AM",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Tamper 3 active mode"
            },
            {
                "name": "TAMP4AM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Tamper 4 active mode"
            },
            {
                "name": "TAMP5AM",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Tamper 5 active mode"
            },
            {
                "name": "TAMP6AM",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Tamper 6 active mode"
            },
            {
                "name": "ATOSEL1",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Active tamper shared output 1 selection\nThe selected output must be available in the package pinout"
            },
            {
                "name": "ATOSEL2",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Active tamper shared output 2 selection\nThe selected output must be available in the package pinout"
            },
            {
                "name": "ATOSEL3",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Active tamper shared output 3 selection\nThe selected output must be available in the package pinout"
            },
            {
                "name": "ATOSEL4",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Active tamper shared output 4 selection\nThe selected output must be available in the package pinout."
            },
            {
                "name": "ATCKSEL",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "Active tamper RTC asynchronous prescaler clock selection\nThese bits selects the RTC asynchronous prescaler stage output. The selected clock is CK_ATPRE.\n...\nNote: These bits can be written only when all active tampers are disabled. The write protection remains for up to 1.5 CK_ATPRE cycles after all the active tampers are disable."
            },
            {
                "name": "ATPER",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "Active tamper output change period\nThe tamper output is changed every CK_ATPER = (2supATPER /supx CK_ATPRE) cycles. Refer to Table713: Minimum ATPER value."
            },
            {
                "name": "ATOSHARE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Active tamper output sharing\nTAMP_IN1 is compared with TAMPOUTSEL1\nTAMP_IN2 is compared with TAMPOUTSEL2\nTAMP_IN3 is compared with TAMPOUTSEL3\nTAMP_IN4 is compared with TAMPOUTSEL4\nTAMP_IN5 is compared with TAMPOUTSEL5\nTAMP_IN6 is compared with TAMPOUTSEL6"
            },
            {
                "name": "FLTEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Active tamper filter enable"
            }
        ]
    },
    "1174436884": {
        "name": "TAMP_ATSEEDR",
        "address": 1174436884,
        "size": 32,
        "access": "",
        "desc": "TAMP active tamper seed register",
        "fields": [
            {
                "name": "SEED",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Pseudo-random generator seed value\nThis register must be written four times with 32-bit values to provide the 128-bit seed to the PRNG. Writing to this register automatically sends the seed value to the PRNG."
            }
        ]
    },
    "1174436888": {
        "name": "TAMP_ATOR",
        "address": 1174436888,
        "size": 32,
        "access": "",
        "desc": "TAMP active tamper output register",
        "fields": [
            {
                "name": "PRNG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Pseudo-random generator value\nThis field provides the values of the PRNG output. Because of potential inconsistencies due to synchronization delays, PRNG must be read at least twice. The read value is correct if it is equal to previous read value.\nThis field can only be read when the APB is in secure mode."
            },
            {
                "name": "SEEDF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Seed running flag\nThis flag is set by hardware when a new seed is written in the TAMP_ATSEEDR. It is cleared by hardware when the PRNG has absorbed this new seed, and by system reset. The TAMP APB cock must not be switched off as long as SEEDF is set."
            },
            {
                "name": "INITS",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Active tamper initialization status\nThis flag is set by hardware when the PRNG has absorbed the first 128-bit seed, meaning that the enabled active tampers are functional. This flag is cleared when the active tampers are disabled."
            }
        ]
    },
    "1174436892": {
        "name": "TAMP_ATCR2",
        "address": 1174436892,
        "size": 32,
        "access": "",
        "desc": "TAMP active tamper control register 2",
        "fields": [
            {
                "name": "ATOSEL1",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "Active tamper shared output 1 selection\nThe selected output must be available in the package pinout.\nBits 9:8 are the mirror of ATOSEL1[1:0] in the TAMP_ATCR1, and so can also be read or\nwritten through TAMP_ATCR1."
            },
            {
                "name": "ATOSEL2",
                "bitOffset": 11,
                "bitWidth": 3,
                "desc": "Active tamper shared output 2 selection\nThe selected output must be available in the package pinout.\nBits 12:11 are the mirror of ATOSEL2[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1."
            },
            {
                "name": "ATOSEL3",
                "bitOffset": 14,
                "bitWidth": 3,
                "desc": "Active tamper shared output 3 selection\nThe selected output must be available in the package pinout.\nBits 15:14 are the mirror of ATOSEL3[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1."
            },
            {
                "name": "ATOSEL4",
                "bitOffset": 17,
                "bitWidth": 3,
                "desc": "Active tamper shared output 4 selection\nThe selected output must be available in the package pinout.\nBits 18:17 are the mirror of ATOSEL2[1:0] in the TAMP_ATCR1, and so can also be read or written through TAMP_ATCR1."
            },
            {
                "name": "ATOSEL5",
                "bitOffset": 20,
                "bitWidth": 3,
                "desc": "Active tamper shared output 5 selection\nThe selected output must be available in the package pinout."
            },
            {
                "name": "ATOSEL6",
                "bitOffset": 23,
                "bitWidth": 3,
                "desc": "Active tamper shared output 6 selection\nThe selected output must be available in the package pinout."
            }
        ]
    },
    "1174436896": {
        "name": "TAMP_SECCFGR",
        "address": 1174436896,
        "size": 32,
        "access": "",
        "desc": "TAMP secure configuration register",
        "fields": [
            {
                "name": "BKPRWSEC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Backup registers read/write protection offset\nBKPRWSEC value must be from 0 to 32.\nProtection zone 1 is defined for backup registers from TAMP_BKP0R to TAMP_BKPxR (x = BKPRWSEC-1, with BKPRWSEC greater than or equal 1).\nif TZEN=1, these backup registers can be read and written only with secure access.\nIf BKPRWSEC = 0: there is no protection zone 1.\nRefer to Figure871: Backup registers protection zones.\nNote: If TZEN=0: the protection zone 1 can be read and written with non-secure access.\nNote: If BKPRWPRIV is set, BKPRWSEC[7:0] can be written only in privileged mode."
            },
            {
                "name": "CNT1SEC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Monotonic counter 1 secure protection"
            },
            {
                "name": "BKPWSEC",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Backup registers write protection offset\nBKPWSEC value must be from 0 to 32.\nProtection zone 2 is defined for backup registers from TAMP_BKPyR (y = BKPRWSEC) to TAMP_BKPzR (z = BKPWSEC-1, with BKPWSECBKPRWSEC):\nif TZEN=1, these backup registers can be written only with secure access.\nThey can be read with secure or non-secure access.\nIf BKPWSEC = 0 or if BKPWSEC less than or equal BKPRWSEC: there is no protection zone 2.\nProtection zone 3 is defined for backup registers from TAMP_BKPtR (t = BKPWSEC if BKPWSEC greater than or equal BKPRWSEC, else t = BKPRWSEC).\nThey can be read or written with secure or non-secure access.\nIf BKPWSEC=32: there is no protection zone 3.\nRefer to Figure871: Backup registers protection zones.\nNote: If TZEN=0: the protection zone 2 can be read and written with non-secure access.\nNote: If BKPWPRIV is set, BKPRWSEC[7:0] can be written only in privileged mode."
            },
            {
                "name": "BHKLOCK",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Boot hardware key lock\nThis bit can be read and can only be written to 1 by software. It is cleared by hardware together with the backup registers following a tamper detection event or when the readout protection (RDP) is disabled."
            },
            {
                "name": "TAMPSEC",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Tamper protection (excluding monotonic counters and backup registers)\nNote: Refer to Section75.3.5: TAMP secure protection modes for details on the read protection."
            }
        ]
    },
    "1174436900": {
        "name": "TAMP_PRIVCFGR",
        "address": 1174436900,
        "size": 32,
        "access": "",
        "desc": "TAMP privilege configuration register",
        "fields": [
            {
                "name": "CNT1PRIV",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Monotonic counter 1 privilege protection"
            },
            {
                "name": "BKPRWPRIV",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Backup registers zone 1 privilege protection"
            },
            {
                "name": "BKPWPRIV",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Backup registers zone 2 privilege protection"
            },
            {
                "name": "TAMPPRIV",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Tamper privilege protection (excluding backup registers)\nNote: Refer to Section75.3.7: TAMP privilege protection modes for details on the read protection."
            }
        ]
    },
    "1174436908": {
        "name": "TAMP_IER",
        "address": 1174436908,
        "size": 32,
        "access": "",
        "desc": "TAMP interrupt enable register",
        "fields": [
            {
                "name": "TAMP1IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper 1 interrupt enable"
            },
            {
                "name": "TAMP2IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper 2 interrupt enable"
            },
            {
                "name": "TAMP3IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Tamper 3 interrupt enable"
            },
            {
                "name": "TAMP4IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Tamper 4 interrupt enable"
            },
            {
                "name": "TAMP5IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Tamper 5 interrupt enable"
            },
            {
                "name": "TAMP6IE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Tamper 6 interrupt enable"
            },
            {
                "name": "ITAMP3IE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 interrupt enable"
            },
            {
                "name": "ITAMP5IE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 interrupt enable"
            },
            {
                "name": "ITAMP6IE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 interrupt enable"
            },
            {
                "name": "ITAMP7IE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Internal tamper 7 interrupt enable"
            },
            {
                "name": "ITAMP8IE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Internal tamper 8 interrupt enable"
            },
            {
                "name": "ITAMP9IE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Internal tamper 9 interrupt enable"
            },
            {
                "name": "ITAMP11IE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Internal tamper 11 interrupt enable"
            },
            {
                "name": "ITAMP12IE",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Internal tamper 12 interrupt enable"
            },
            {
                "name": "ITAMP13IE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Internal tamper 13 interrupt enable"
            }
        ]
    },
    "1174436912": {
        "name": "TAMP_SR",
        "address": 1174436912,
        "size": 32,
        "access": "",
        "desc": "TAMP status register",
        "fields": [
            {
                "name": "TAMP1F",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TAMP1 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP1 input."
            },
            {
                "name": "TAMP2F",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TAMP2 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP2 input."
            },
            {
                "name": "TAMP3F",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TAMP3 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP3 input."
            },
            {
                "name": "TAMP4F",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "TAMP4 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP4 input."
            },
            {
                "name": "TAMP5F",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TAMP5 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP5 input."
            },
            {
                "name": "TAMP6F",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TAMP6 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP6 input."
            },
            {
                "name": "ITAMP3F",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 3."
            },
            {
                "name": "ITAMP5F",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 5."
            },
            {
                "name": "ITAMP6F",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 6."
            },
            {
                "name": "ITAMP7F",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Internal tamper 7 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 7."
            },
            {
                "name": "ITAMP8F",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Internal tamper 8 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 8."
            },
            {
                "name": "ITAMP9F",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Internal tamper 9 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 9."
            },
            {
                "name": "ITAMP11F",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Internal tamper 11 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 11."
            },
            {
                "name": "ITAMP12F",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Internal tamper 12 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 12."
            },
            {
                "name": "ITAMP13F",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Internal tamper 13 flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 13."
            }
        ]
    },
    "1174436916": {
        "name": "TAMP_MISR",
        "address": 1174436916,
        "size": 32,
        "access": "",
        "desc": "TAMP non-secure masked interrupt status register",
        "fields": [
            {
                "name": "TAMP1MF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TAMP1 non-secure interrupt masked flag\nThis flag is set by hardware when the tamper 1 non-secure interrupt is raised."
            },
            {
                "name": "TAMP2MF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TAMP2 non-secure interrupt masked flag\nThis flag is set by hardware when the tamper 2 non-secure interrupt is raised."
            },
            {
                "name": "TAMP3MF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TAMP3 non-secure interrupt masked flag\nThis flag is set by hardware when the tamper 3 non-secure interrupt is raised."
            },
            {
                "name": "TAMP4MF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "TAMP4 non-secure interrupt masked flag\nThis flag is set by hardware when the tamper 4 non-secure interrupt is raised."
            },
            {
                "name": "TAMP5MF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TAMP5 non-secure interrupt masked flag\nThis flag is set by hardware when the tamper 5 non-secure interrupt is raised."
            },
            {
                "name": "TAMP6MF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TAMP6 non-secure interrupt masked flag\nThis flag is set by hardware when the tamper 6 non-secure interrupt is raised."
            },
            {
                "name": "ITAMP3MF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 non-secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 3 non-secure interrupt is raised."
            },
            {
                "name": "ITAMP5MF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 non-secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 5 non-secure interrupt is raised."
            },
            {
                "name": "ITAMP6MF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 non-secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 6 non-secure interrupt is raised."
            },
            {
                "name": "ITAMP7MF",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Internal tamper 7 tamper non-secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 7 non-secure interrupt is raised."
            },
            {
                "name": "ITAMP8MF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Internal tamper 8 non-secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 8 non-secure interrupt is raised."
            },
            {
                "name": "ITAMP9MF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "internal tamper 9 non-secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 9 non-secure interrupt is raised."
            },
            {
                "name": "ITAMP11MF",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "internal tamper 11 non-secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 11 non-secure interrupt is raised."
            },
            {
                "name": "ITAMP12MF",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "internal tamper 12 non-secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 12 non-secure interrupt is raised."
            },
            {
                "name": "ITAMP13MF",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "internal tamper 13 non-secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 13 non-secure interrupt is raised."
            }
        ]
    },
    "1174436920": {
        "name": "TAMP_SMISR",
        "address": 1174436920,
        "size": 32,
        "access": "",
        "desc": "TAMP secure masked interrupt status register",
        "fields": [
            {
                "name": "TAMP1MF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TAMP1 secure interrupt masked flag\nThis flag is set by hardware when the tamper 1 secure interrupt is raised."
            },
            {
                "name": "TAMP2MF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TAMP2 secure interrupt masked flag\nThis flag is set by hardware when the tamper 2 secure interrupt is raised."
            },
            {
                "name": "TAMP3MF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TAMP3 secure interrupt masked flag\nThis flag is set by hardware when the tamper 3 secure interrupt is raised."
            },
            {
                "name": "TAMP4MF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "TAMP4 secure interrupt masked flag\nThis flag is set by hardware when the tamper 4 secure interrupt is raised."
            },
            {
                "name": "TAMP5MF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TAMP5 secure interrupt masked flag\nThis flag is set by hardware when the tamper 5 secure interrupt is raised."
            },
            {
                "name": "TAMP6MF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TAMP6 secure interrupt masked flag\nThis flag is set by hardware when the tamper 6 secure interrupt is raised."
            },
            {
                "name": "ITAMP3MF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 3 secure interrupt is raised."
            },
            {
                "name": "ITAMP5MF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 5 secure interrupt is raised."
            },
            {
                "name": "ITAMP6MF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 6 secure interrupt is raised."
            },
            {
                "name": "ITAMP7MF",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Internal tamper 7 secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 7 secure interrupt is raised."
            },
            {
                "name": "ITAMP8MF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Internal tamper 8 secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 8 secure interrupt is raised."
            },
            {
                "name": "ITAMP9MF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "internal tamper 9 secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 9 secure interrupt is raised."
            },
            {
                "name": "ITAMP11MF",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "internal tamper 11 secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 11 secure interrupt is raised."
            },
            {
                "name": "ITAMP12MF",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "internal tamper 12 secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 12 secure interrupt is raised."
            },
            {
                "name": "ITAMP13MF",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "internal tamper 13 secure interrupt masked flag\nThis flag is set by hardware when the internal tamper 13 secure interrupt is raised."
            }
        ]
    },
    "1174436924": {
        "name": "TAMP_SCR",
        "address": 1174436924,
        "size": 32,
        "access": "",
        "desc": "TAMP status clear register",
        "fields": [
            {
                "name": "CTAMP1F",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear TAMP1 detection flag\nWriting 1 in this bit clears the TAMP1F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP2F",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear TAMP2 detection flag\nWriting 1 in this bit clears the TAMP2F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP3F",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear TAMP3 detection flag\nWriting 1 in this bit clears the TAMP3F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP4F",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear TAMP4 detection flag\nWriting 1 in this bit clears the TAMP4F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP5F",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear TAMP5 detection flag\nWriting 1 in this bit clears the TAMP5F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP6F",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clear TAMP6 detection flag\nWriting 1 in this bit clears the TAMP6F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP3F",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Clear ITAMP3 detection flag\nWriting 1 in this bit clears the ITAMP3F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP5F",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Clear ITAMP5 detection flag\nWriting 1 in this bit clears the ITAMP5F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP6F",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Clear ITAMP6 detection flag\nWriting 1 in this bit clears the ITAMP6F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP7F",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Clear ITAMP7 detection flag\nWriting 1 in this bit clears the ITAMP7F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP8F",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Clear ITAMP8 detection flag\nWriting 1 in this bit clears the ITAMP8F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP9F",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Clear ITAMP9 detection flag\nWriting 1 in this bit clears the ITAMP9F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP11F",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Clear ITAMP11 detection flag\nWriting 1 in this bit clears the ITAMP11F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP12F",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Clear ITAMP12 detection flag\nWriting 1 in this bit clears the ITAMP12F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP13F",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Clear ITAMP13 detection flag\nWriting 1 in this bit clears the ITAMP13F bit in the TAMP_SR register."
            }
        ]
    },
    "1174436928": {
        "name": "TAMP_COUNT1R",
        "address": 1174436928,
        "size": 32,
        "access": "",
        "desc": "TAMP monotonic counter 1 register",
        "fields": [
            {
                "name": "COUNT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "This register is read-only only and is incremented by one when a write access is done to this register. This register cannot roll-over and is frozen when reaching the maximum value."
            }
        ]
    },
    "1174436948": {
        "name": "TAMP_ERCFGR",
        "address": 1174436948,
        "size": 32,
        "access": "",
        "desc": "TAMP erase configuration register",
        "fields": [
            {
                "name": "ERCFG1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Configurable device secrets configuration"
            },
            {
                "name": "ERCFG2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Configurable device secrets configuration"
            },
            {
                "name": "ERCFG3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Configurable device secrets configuration"
            },
            {
                "name": "ERCFG4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Configurable device secrets configuration"
            },
            {
                "name": "ERCFG5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Configurable device secrets configuration"
            }
        ]
    },
    "1174437120": {
        "name": "TAMP_BKP0R",
        "address": 1174437120,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 0 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437124": {
        "name": "TAMP_BKP1R",
        "address": 1174437124,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 1 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437128": {
        "name": "TAMP_BKP2R",
        "address": 1174437128,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 2 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437132": {
        "name": "TAMP_BKP3R",
        "address": 1174437132,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 3 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437136": {
        "name": "TAMP_BKP4R",
        "address": 1174437136,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 4 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437140": {
        "name": "TAMP_BKP5R",
        "address": 1174437140,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 5 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437144": {
        "name": "TAMP_BKP6R",
        "address": 1174437144,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 6 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437148": {
        "name": "TAMP_BKP7R",
        "address": 1174437148,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 7 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437152": {
        "name": "TAMP_BKP8R",
        "address": 1174437152,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 8 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437156": {
        "name": "TAMP_BKP9R",
        "address": 1174437156,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 9 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437160": {
        "name": "TAMP_BKP10R",
        "address": 1174437160,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 10 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437164": {
        "name": "TAMP_BKP11R",
        "address": 1174437164,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 11 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437168": {
        "name": "TAMP_BKP12R",
        "address": 1174437168,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 12 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437172": {
        "name": "TAMP_BKP13R",
        "address": 1174437172,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 13 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437176": {
        "name": "TAMP_BKP14R",
        "address": 1174437176,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 14 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437180": {
        "name": "TAMP_BKP15R",
        "address": 1174437180,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 15 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437184": {
        "name": "TAMP_BKP16R",
        "address": 1174437184,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 16 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437188": {
        "name": "TAMP_BKP17R",
        "address": 1174437188,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 17 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437192": {
        "name": "TAMP_BKP18R",
        "address": 1174437192,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 18 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437196": {
        "name": "TAMP_BKP19R",
        "address": 1174437196,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 19 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437200": {
        "name": "TAMP_BKP20R",
        "address": 1174437200,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 20 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437204": {
        "name": "TAMP_BKP21R",
        "address": 1174437204,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 21 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437208": {
        "name": "TAMP_BKP22R",
        "address": 1174437208,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 22 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437212": {
        "name": "TAMP_BKP23R",
        "address": 1174437212,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 23 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437216": {
        "name": "TAMP_BKP24R",
        "address": 1174437216,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 24 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437220": {
        "name": "TAMP_BKP25R",
        "address": 1174437220,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 25 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437224": {
        "name": "TAMP_BKP26R",
        "address": 1174437224,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 26 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437228": {
        "name": "TAMP_BKP27R",
        "address": 1174437228,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 27 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437232": {
        "name": "TAMP_BKP28R",
        "address": 1174437232,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 28 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437236": {
        "name": "TAMP_BKP29R",
        "address": 1174437236,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 29 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437240": {
        "name": "TAMP_BKP30R",
        "address": 1174437240,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 30 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1174437244": {
        "name": "TAMP_BKP31R",
        "address": 1174437244,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 31 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nIn the default (ERASE) configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073818624": {
        "name": "TIM1_CR1",
        "address": 1073818624,
        "size": 22,
        "access": "read-write",
        "desc": "TIM1 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\n\nNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\n\nThis bit is set and cleared by software to enable/disable UEV event generation.\n\nCounter overflow/underflow\n\nSetting the UG bit\n\nUpdate generation through the slave mode controller\n\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\n\nThis bit is set and cleared by software to select the UEV event sources.\n\nCounter overflow/underflow\n\nSetting the UG bit\n\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction\n\nNote: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode."
            },
            {
                "name": "CMS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Center-aligned mode selection\n\nNote: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\n\nThis bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and the dead-time and sampling clock (tsubDTS/sub)used by the dead-time generators and the digital filters (tim_etr_in, tim_tix),"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            },
            {
                "name": "DITHEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Dithering enable\n\nNote: The DITHEN bit can only be modified when CEN bit is reset."
            }
        ]
    },
    "1073818628": {
        "name": "TIM1_CR2",
        "address": 1073818628,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 control register 2",
        "fields": [
            {
                "name": "CCPC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare preloaded control\n\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCUS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare control update selection\n\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "MMS[2:0]: Master mode selection\n\nThese bits select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:\n\nOther codes reserved\n\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "tim_ti1 selection"
            },
            {
                "name": "OIS1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Output idle state 1 (tim_oc1 output)\n\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OIS1N",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Output idle state 1 (tim_oc1n output)\n\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OIS2",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output idle state 2 (tim_oc2 output)\n\nRefer to OIS1 bit"
            },
            {
                "name": "OIS2N",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output idle state 2 (tim_oc2n output)\n\nRefer to OIS1N bit"
            },
            {
                "name": "OIS3",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Output idle state 3 (tim_oc3n output)\n\nRefer to OIS1 bit"
            },
            {
                "name": "OIS3N",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Output idle state 3 (tim_oc3n output)\n\nRefer to OIS1N bit"
            },
            {
                "name": "OIS4",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Output idle state 4 (tim_oc4 output)\n\nRefer to OIS1 bit"
            },
            {
                "name": "OIS4N",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Output idle state 4 (tim_oc4n output)\n\nRefer to OIS1N bit"
            },
            {
                "name": "OIS5",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output idle state 5 (tim_oc5 output)\n\nRefer to OIS1 bit"
            },
            {
                "name": "OIS6",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Output idle state 6 (tim_oc6 output)\n\nRefer to OIS1 bit"
            },
            {
                "name": "MMS2",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Master mode selection 2\n\nThese bits allow the information to be sent to ADC for synchronization (tim_trgo2) to be selected. The combination is as follows:\n\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "MMS_1",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "MMS[3]"
            }
        ]
    },
    "1073818632": {
        "name": "TIM1_SMCR",
        "address": 1073818632,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 slave mode control register",
        "fields": [
            {
                "name": "SMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "SMS[2:0]: Slave mode selection\n\nWhen external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\n\nNote: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.\n\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo or the tim_trgo2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "OCCS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "OCREF clear selection\n\nThis bit is used to select the OCREF clear source."
            },
            {
                "name": "TS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "TS[2:0]: Trigger selection\n\nThis bitfield is combined with TS[4:3] bits.\n\nThis bit-field selects the trigger input to be used to synchronize the counter.\n\nOthers: Reserved\n\nSee Table 257: TIMx internal trigger connection for more details on tim_itrx meaning for each Timer.\n\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/slave mode"
            },
            {
                "name": "ETF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "External trigger filter\n\nThis bit-field then defines the frequency used to sample tim_etrp signal and the length of the digital filter applied to tim_etrp. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "ETPS",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "External trigger prescaler\n\nExternal trigger signal tim_etrp frequency must be at most 1/4 of TIMxCLK frequency. A prescaler can be enabled to reduce tim_etrp frequency. It is useful when inputting fast external clocks on tim_etr_in."
            },
            {
                "name": "ECE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "External clock enable\n\nThis bit enables External clock mode 2.\n\nNote: Setting the ECE bit has the same effect as selecting external clock mode 1 with tim_trgi connected to tim_etrf (SMS=111 and TS=00111).\n\nIt is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, tim_trgi must not be connected to tim_etrf in this case (TS bits must not be 00111).\n\nNote: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is tim_etrf."
            },
            {
                "name": "ETP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "External trigger polarity\n\nThis bit selects whether tim_etr_in or tim_etr_in is used for trigger operations"
            },
            {
                "name": "SMS_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "SMS[3]"
            },
            {
                "name": "TS_1",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "TS[4:3]"
            },
            {
                "name": "SMSPE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "SMS preload enable\n\nThis bit selects whether the SMS[3:0] bitfield is preloaded"
            },
            {
                "name": "SMSPS",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "SMS preload source\n\nThis bit selects whether the events that triggers the SMS[3:0] bitfield transfer from preload to active"
            }
        ]
    },
    "1073818636": {
        "name": "TIM1_DIER",
        "address": 1073818636,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 DMA/interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 interrupt enable"
            },
            {
                "name": "CC3IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 interrupt enable"
            },
            {
                "name": "CC4IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 interrupt enable"
            },
            {
                "name": "COMIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "BIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 2 DMA request enable"
            },
            {
                "name": "CC3DE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 3 DMA request enable"
            },
            {
                "name": "CC4DE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/compare 4 DMA request enable"
            },
            {
                "name": "COMDE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "COM DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            },
            {
                "name": "IDXIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Index interrupt enable"
            },
            {
                "name": "DIRIE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Direction change interrupt enable"
            },
            {
                "name": "IERRIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Index error interrupt enable"
            },
            {
                "name": "TERRIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transition error interrupt enable"
            }
        ]
    },
    "1073818640": {
        "name": "TIM1_SR",
        "address": 1073818640,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\n\nThis bit is set by hardware on an update event. It is cleared by software.\n\nAt overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.\n\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\n\nWhen CNT is reinitialized by a trigger event (refer to Section 28.6.3: TIM1 slave mode control register (TIM1_SMCR)), if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt flag\n\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\n\nIf channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in downcounting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\n\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 interrupt flag\n\nRefer to CC1IF description"
            },
            {
                "name": "CC3IF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 interrupt flag\n\nRefer to CC1IF description"
            },
            {
                "name": "CC4IF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 interrupt flag\n\nRefer to CC1IF description"
            },
            {
                "name": "COMIF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt flag\n\nThis flag is set by hardware on COM event (when capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software."
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\n\nThis flag is set by hardware on the TRG trigger event (active edge detected on tim_trgi input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software."
            },
            {
                "name": "BIF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt flag\n\nThis flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active."
            },
            {
                "name": "B2IF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Break 2 interrupt flag\n\nThis flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 1 overcapture flag\n\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 2 overcapture flag\n\nRefer to CC1OF description"
            },
            {
                "name": "CC3OF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 3 overcapture flag\n\nRefer to CC1OF description"
            },
            {
                "name": "CC4OF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/compare 4 overcapture flag\n\nRefer to CC1OF description"
            },
            {
                "name": "SBIF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "System break interrupt flag\n\nThis flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active.\n\nThis flag must be reset to re-start PWM operation."
            },
            {
                "name": "CC5IF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Compare 5 interrupt flag\n\nRefer to CC1IF description\n\nNote: Channel 5 can only be configured as output."
            },
            {
                "name": "CC6IF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Compare 6 interrupt flag\n\nRefer to CC1IF description\n\nNote: Channel 6 can only be configured as output."
            },
            {
                "name": "IDXF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Index interrupt flag\n\nThis flag is set by hardware when an index event is detected. It is cleared by software by writing it to '0'."
            },
            {
                "name": "DIRF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Direction change interrupt flag\n\nThis flag is set by hardware when the direction changes in encoder mode (DIR bit value in TIMx_CR is changing). It is cleared by software by writing it to '0'."
            },
            {
                "name": "IERRF",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Index error interrupt flag\n\nThis flag is set by hardware when an index error is detected. It is cleared by software by writing it to '0'."
            },
            {
                "name": "TERRF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transition error interrupt flag\n\nThis flag is set by hardware when a transition error is detected in encoder mode. It is cleared by software by writing it to '0'."
            }
        ]
    },
    "1073818644": {
        "name": "TIM1_EGR",
        "address": 1073818644,
        "size": 22,
        "access": "write-only",
        "desc": "TIM1 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\n\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 generation\n\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\n\nIf channel CC1 is configured as output:\n\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\n\nIf channel CC1 is configured as input:\n\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 generation\n\nRefer to CC1G description"
            },
            {
                "name": "CC3G",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 generation\n\nRefer to CC1G description"
            },
            {
                "name": "CC4G",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 generation\n\nRefer to CC1G description"
            },
            {
                "name": "COMG",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/compare control update generation\n\nThis bit can be set by software, it is automatically cleared by hardware\n\nNote: This bit acts only on channels having a complementary output."
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\n\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            },
            {
                "name": "BG",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break generation\n\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            },
            {
                "name": "B2G",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Break 2 generation\n\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073818648": {
        "name": "TIM1_CCMR1",
        "address": 1073818648,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 capture/compare mode register 1 [alternate]",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/compare 1 Selection\n\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n\nNote: CC1S bits are writable only when the channel is OFF (CC1E = '0' in TIMx_CCER)."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\n\nThis bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1). The prescaler is reset as soon as CC1E='0' (TIMx_CCER register)."
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\n\nThis bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/compare 2 selection\n\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n\nNote: CC2S bits are writable only when the channel is OFF (CC2E = '0' in TIMx_CCER)."
            },
            {
                "name": "IC2PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler"
            },
            {
                "name": "IC2F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 2 filter"
            }
        ]
    },
    "1073818652": {
        "name": "TIM1_CCMR2",
        "address": 1073818652,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 capture/compare mode register 2 [alternate]",
        "fields": [
            {
                "name": "CC3S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/compare 3 selection\n\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n\nNote: CC3S bits are writable only when the channel is OFF (CC3E = '0' in TIMx_CCER)."
            },
            {
                "name": "IC3PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler"
            },
            {
                "name": "IC3F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 3 filter"
            },
            {
                "name": "CC4S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/compare 4 selection\n\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n\nNote: CC4S bits are writable only when the channel is OFF (CC4E = '0' in TIMx_CCER)."
            },
            {
                "name": "IC4PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler"
            },
            {
                "name": "IC4F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 4 filter"
            }
        ]
    },
    "1073818656": {
        "name": "TIM1_CCER",
        "address": 1073818656,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare 1 output enable\n\nWhen CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to Table 272 for details.\n\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 output polarity\n\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\n\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\n\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\n\nCC1NP=1, CC1P=1:\tnon-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\n\nCC1NP=1, CC1P=0:\tthe configuration is reserved, it must not be used.\n\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\n\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 1 complementary output enable\n\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 1 complementary output polarity\n\nCC1 channel configured as output:\n\nCC1 channel configured as input:\n\nThis bit is used in conjunction with CC1P to define the polarity of tim_ti1fp1 and tim_ti2fp1. Refer to CC1P description.\n\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (channel configured as output).\n\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 2 output enable\n\nRefer to CC1E description"
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/compare 2 output polarity\n\nRefer to CC1P description"
            },
            {
                "name": "CC2NE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Capture/compare 2 complementary output enable\n\nRefer to CC1NE description"
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/compare 2 complementary output polarity\n\nRefer to CC1NP description"
            },
            {
                "name": "CC3E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Capture/compare 3 output enable\n\nRefer to CC1E description"
            },
            {
                "name": "CC3P",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/compare 3 output polarity\n\nRefer to CC1P description"
            },
            {
                "name": "CC3NE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 3 complementary output enable\n\nRefer to CC1NE description"
            },
            {
                "name": "CC3NP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/compare 3 complementary output polarity\n\nRefer to CC1NP description"
            },
            {
                "name": "CC4E",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/compare 4 output enable\n\nRefer to CC1E description"
            },
            {
                "name": "CC4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Capture/compare 4 output polarity\n\nRefer to CC1P description"
            },
            {
                "name": "CC4NE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Capture/compare 4 complementary output enable\n\nRefer to CC1NE description"
            },
            {
                "name": "CC4NP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Capture/compare 4 complementary output polarity\n\nRefer to CC1NP description"
            },
            {
                "name": "CC5E",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/compare 5 output enable\n\nRefer to CC1E description"
            },
            {
                "name": "CC5P",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/compare 5 output polarity\n\nRefer to CC1P description"
            },
            {
                "name": "CC6E",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Capture/compare 6 output enable\n\nRefer to CC1E description"
            },
            {
                "name": "CC6P",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Capture/compare 6 output polarity\n\nRefer to CC1P description"
            }
        ]
    },
    "1073818660": {
        "name": "TIM1_CNT",
        "address": 1073818660,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the counter value.\n\nDithering mode (DITHEN = 1)\n\nThe register only holds the non-dithered part in CNT[15:0]. The fractional part is not available."
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF copy\n\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0."
            }
        ]
    },
    "1073818664": {
        "name": "TIM1_PSC",
        "address": 1073818664,
        "size": 22,
        "access": "read-write",
        "desc": "TIM1 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\nThe counter clock frequency (fsubtim_cnt_ck/sub) is equal to fsubtim_psc_ck/sub / (PSC[15:0] + 1).\n\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in 'reset mode')."
            }
        ]
    },
    "1073818668": {
        "name": "TIM1_ARR",
        "address": 1073818668,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Auto-reload value\n\nARR is the value to be loaded in the actual auto-reload register.\n\nRefer to the Section 28.3.3: Time-base unit on page 1112 for more details about ARR update and behavior.\n\nThe counter is blocked while the auto-reload value is null.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the auto-reload value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part."
            }
        ]
    },
    "1073818672": {
        "name": "TIM1_RCR",
        "address": 1073818672,
        "size": 22,
        "access": "read-write",
        "desc": "TIM1 repetition counter register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Repetition counter reload value\n\nThis bitfield defines the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable. It also defines the update interrupt generation rate, if this interrupt is enable.\n\nWhen the repetition down-counter reaches zero, an update event is generated and it restarts counting from REP value. As the repetition counter is reloaded with REP value only at the repetition update event UEV, any write to the TIMx_RCR register is not taken in account until the next repetition update event.\n\nIt means in PWM mode (REP+1) corresponds to:\n\nthe number of PWM periods in edge-aligned mode\n\nthe number of half PWM period in center-aligned mode."
            }
        ]
    },
    "1073818676": {
        "name": "TIM1_CCR1",
        "address": 1073818676,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 1 value\n\nIf channel CC1 is configured as output: CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\n\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value in CCR1[15:0]. The CCR1[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR1[19:4]. The CCR1[3:0] bitfield contains the dithered part.\n\nIf channel CC1 is configured as input: CR1 is the counter value transferred by the last input capture 1 event (tim_ic1). The TIMx_CCR1 register is read-only and cannot be programmed.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the capture value in CCR1[15:0]. The CCR1[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the capture in CCR1[19:4]. The CCR1[3:0] bits are reset."
            }
        ]
    },
    "1073818680": {
        "name": "TIM1_CCR2",
        "address": 1073818680,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 capture/compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 2 value\n\nIf channel CC2 is configured as output: CCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).\n\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc2 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value in CCR2[15:0]. The CCR2[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR2[19:4]. The CCR2[3:0] bitfield contains the dithered part.\n\nIf channel CC2 is configured as input: CCR2 is the counter value transferred by the last input capture 2 event (tim_ic2). The TIMx_CCR2 register is read-only and cannot be programmed.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the capture value in CCR2[15:0]. The CCR2[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the capture in CCR2[19:4]. The CCR2[3:0] bits are reset."
            }
        ]
    },
    "1073818684": {
        "name": "TIM1_CCR3",
        "address": 1073818684,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 capture/compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare value\n\nIf channel CC3 is configured as output: CCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).\n\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc3 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value in CCR3[15:0]. The CCR3[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR3[19:4]. The CCR3[3:0] bitfield contains the dithered part.\n\nIf channel CC3 is configured as input: CCR3 is the counter value transferred by the last input capture 3 event (tim_ic3). The TIMx_CCR3 register is read-only and cannot be programmed.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the capture value in CCR3[15:0]. The CCR3[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the capture in CCR3[19:4]. The CCR3[3:0] bits are reset."
            }
        ]
    },
    "1073818688": {
        "name": "TIM1_CCR4",
        "address": 1073818688,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 capture/compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare value\n\nIf channel CC4 is configured as output: CCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).\n\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on tim_oc4 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value in CCR4[15:0]. The CCR4[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR4[19:4]. The CCR4[3:0] bitfield contains the dithered part.\n\nIf channel CC4 is configured as input: CCR4 is the counter value transferred by the last input capture 4 event (tim_ic4). The TIMx_CCR4 register is read-only and cannot be programmed.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the capture value in CCR4[15:0]. The CCR4[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the capture in CCR4[19:4]. The CCR4[3:0] bits are reset."
            }
        ]
    },
    "1073818692": {
        "name": "TIM1_BDTR",
        "address": 1073818692,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 break and dead-time register",
        "fields": [
            {
                "name": "DTG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time generator setup\n\nThis bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.\n\nDTG[7:5]=0xx = DT=DTG[7:0]x tsubdtg/sub with tsubdtg/sub=tsubDTS/sub.\n\nDTG[7:5]=10x = DT=(64+DTG[5:0])xtsubdtg/sub with Tsubdtg/sub=2xtsubDTS/sub.\n\nDTG[7:5]=110 = DT=(32+DTG[4:0])xtsubdtg/sub with Tsubdtg/sub=8xtsubDTS/sub.\n\nDTG[7:5]=111 = DT=(32+DTG[4:0])xtsubdtg/sub with Tsubdtg/sub=16xtsubDTS/sub.\n\nExample if TsubDTS/sub=125ns (8MHz), dead-time possible values are:\n\n0 to 15875 ns by 125 ns steps,\n\n16 us to 31750 ns by 250 ns steps,\n\n32 us to 63us by 1 us steps,\n\n64 us to 126 us by 2 us steps\n\nNote: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "LOCK",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Lock configuration\n\nThese bits offer a write protection against software errors.\n\nNote: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset."
            },
            {
                "name": "OSSI",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Off-state selection for idle mode\n\nThis bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs.\n\nSee OC/OCN enable description for more details (Section 28.6.11: TIM1 capture/compare enable register (TIM1_CCER)).\n\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OSSR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Off-state selection for Run mode\n\nThis bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.\n\nSee OC/OCN enable description for more details (Section 28.6.11: TIM1 capture/compare enable register (TIM1_CCER)).\n\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Break enable\n\nThis bit enables the complete break protection (including all sources connected to bk_acth and BKIN sources, as per Figure 316: Break and Break2 circuitry overview).\n\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Break polarity\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "AOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Automatic output enable\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "MOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Main output enable\n\nThis bit is cleared asynchronously by hardware as soon as one of the break inputs is active (tim_brk or tim_brk2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.\n\nIn response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.\n\nSee OC/OCN enable description for more details (Section 28.6.11: TIM1 capture/compare enable register (TIM1_CCER))."
            },
            {
                "name": "BKF",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Break filter\n\nThis bit-field defines the frequency used to sample tim_brk input and the length of the digital filter applied to tim_brk. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\n\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2F",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Break 2 filter\n\nThis bit-field defines the frequency used to sample tim_brk2 input and the length of the digital filter applied to tim_brk2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\n\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2E",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Break 2 enable\n\nThis bit enables the complete break 2 protection (including all sources connected to bk_acth and BKIN sources, as per Figure 316: Break and Break2 circuitry overview).\n\nNote: The BRKIN2 must only be used with OSSR = OSSI = 1.\n\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2P",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Break 2 polarity\n\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKDSRM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Break disarm\n\nThis bit is cleared by hardware when no break source is active.\n\nThe BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.\n\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2DSRM",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Break2 disarm\n\nRefer to BKDSRM description"
            },
            {
                "name": "BKBID",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Break bidirectional\n\nIn the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.\n\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2BID",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Break2 bidirectional\n\nRefer to BKBID description"
            }
        ]
    },
    "1073818696": {
        "name": "TIM1_CCR5",
        "address": 1073818696,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 capture/compare register 5",
        "fields": [
            {
                "name": "CCR5",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 5 value\n\nCCR5 is the value to be loaded in the actual capture/compare 5 register (preload value).\n\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc5 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value in CCR5[15:0]. The CCR5[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR5[19:4]. The CCR5[3:0] bitfield contains the dithered part."
            },
            {
                "name": "GC5C1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Group channel 5 and channel 1\n\nDistortion on channel 1 output:\n\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).\n\nNote: it is also possible to apply this distortion on combined PWM signals."
            },
            {
                "name": "GC5C2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Group channel 5 and channel 2\n\nDistortion on channel 2 output:\n\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).\n\nNote: it is also possible to apply this distortion on combined PWM signals."
            },
            {
                "name": "GC5C3",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Group channel 5 and channel 3\n\nDistortion on channel 3 output:\n\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2).\n\nNote: it is also possible to apply this distortion on combined PWM signals."
            }
        ]
    },
    "1073818700": {
        "name": "TIM1_CCR6",
        "address": 1073818700,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 capture/compare register 6",
        "fields": [
            {
                "name": "CCR6",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/compare 6 value\n\nCCR6 is the value to be loaded in the actual capture/compare 6 register (preload value).\n\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC6PE). Else the preload value is copied in the active capture/compare 6 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc6 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value in CCR6[15:0]. The CCR6[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR6[19:4]. The CCR6[3:0] bitfield contains the dithered part."
            }
        ]
    },
    "1073818704": {
        "name": "TIM1_CCMR3",
        "address": 1073818704,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 capture/compare mode register 3",
        "fields": [
            {
                "name": "OC5FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output compare 5 fast enable"
            },
            {
                "name": "OC5PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output compare 5 preload enable"
            },
            {
                "name": "OC5M",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "OC5M[2:0]: Output compare 5 mode"
            },
            {
                "name": "OC5CE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Output compare 5 clear enable"
            },
            {
                "name": "OC6FE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output compare 6 fast enable"
            },
            {
                "name": "OC6PE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output compare 6 preload enable"
            },
            {
                "name": "OC6M",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "OC6M[2:0]: Output compare 6 mode"
            },
            {
                "name": "OC6CE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Output compare 6 clear enable"
            },
            {
                "name": "OC5M_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "OC5M[3]"
            },
            {
                "name": "OC6M_1",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "OC6M[3]"
            }
        ]
    },
    "1073818708": {
        "name": "TIM1_DTR2",
        "address": 1073818708,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 timer deadtime register 2",
        "fields": [
            {
                "name": "DTGF",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time falling edge generator setup\n\nThis bit-field defines the duration of the dead-time inserted between the complementary outputs, on the falling edge.\n\nDTGF[7:5]=0xx = DTF=DTGF[7:0]x tsubdtg/sub with tsubdtg/sub=tsubDTS/sub.\n\nDTGF[7:5]=10x = DTF=(64+DTGF[5:0])xtsubdtg/sub with Tsubdtg/sub=2xtsubDTS/sub.\n\nDTGF[7:5]=110 = DTF=(32+DTGF[4:0])xtsubdtg/sub with Tsubdtg/sub=8xtsubDTS/sub.\n\nDTGF[7:5]=111 = DTF=(32+DTGF[4:0])xtsubdtg/sub with Tsubdtg/sub=16xtsubDTS/sub.\n\nExample if TsubDTS/sub=125ns (8MHz), dead-time possible values are:\n\n0 to 15875 ns by 125 ns steps,\n\n16 us to 31750 ns by 250 ns steps,\n\n32 us to 63us by 1 us steps,\n\n64 us to 126 us by 2 us steps\n\nNote: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "DTAE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Deadtime asymmetric enable\n\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "DTPE",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Deadtime preload enable\n\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073818712": {
        "name": "TIM1_ECR",
        "address": 1073818712,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 timer encoder control register",
        "fields": [
            {
                "name": "IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Index enable\n\nThis bit indicates if the Index event resets the counter."
            },
            {
                "name": "IDIR",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Index direction\n\nThis bit indicates in which direction the Index event resets the counter.\n\nNote: The IDR[1:0] bitfield must be written when IE bit is reset (index disabled)."
            },
            {
                "name": "IBLK",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Index blanking\n\nThis bit indicates if the Index event is conditioned by the tim_ti3 or tim_ti4 input"
            },
            {
                "name": "FIDX",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "First index\n\nThis bit indicates if the first index only is taken into account"
            },
            {
                "name": "IPOS",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Index positioning\n\nIn quadrature encoder mode (SMS[3:0] = 0001, 0010, 0011, 1110, 1111), this bit indicates in which AB input configuration the Index event resets the counter.\n\nIn directional clock mode or clock plus direction mode (SMS[3:0] = 1010, 1011, 1100, 1101), these bits indicates on which level the Index event resets the counter. In bidirectional clock mode, this applies for both clock inputs.\n\nx0: Index resets the counter when clock is 0\n\nx1: Index resets the counter when clock is 1\n\nNote: IPOS[1] bit is not significant"
            },
            {
                "name": "PW",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Pulse width\n\nThis bitfield defines the pulse duration, as following:\n\ntsubPW/sub = PW[7:0] x tsubPWG/sub"
            },
            {
                "name": "PWPRSC",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "Pulse width prescaler\n\nThis bitfield sets the clock prescaler for the pulse generator, as following:\n\ntsubPWG/sub = (2sup(PWPRSC[2:0])/sup) x tsubtim_ker_ck/sub"
            }
        ]
    },
    "1073818716": {
        "name": "TIM1_TISEL",
        "address": 1073818716,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 timer input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Selects tim_ti1[15:0] input\n\n...\n\nRefer to Section 28.3.2: TIM1 pins and internal signals for interconnects list."
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Selects tim_ti2[15:0] input\n\n...\n\nRefer to Section 28.3.2: TIM1 pins and internal signals for interconnects list."
            },
            {
                "name": "TI3SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Selects tim_ti3[15:0] input\n\n...\n\nRefer to Section 28.3.2: TIM1 pins and internal signals for interconnects list."
            },
            {
                "name": "TI4SEL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Selects tim_ti4[15:0] input\n\n...\n\nRefer to Section 28.3.2: TIM1 pins and internal signals for interconnects list."
            }
        ]
    },
    "1073818720": {
        "name": "TIM1_AF1",
        "address": 1073818720,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 alternate function option register 1",
        "fields": [
            {
                "name": "BKINE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIMx_BKIN input enable\n\nThis bit enables the TIMx_BKIN alternate function input for the timer's tim_brk input. TIMx_BKIN input is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "tim_brk_cmp1 enable\n\nThis bit enables the tim_brk_cmp1 for the timer's tim_brk input. tim_brk_cmp1 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "tim_brk_cmp2 enable\n\nThis bit enables the tim_brk_cmp2 for the timer's tim_brk input. tim_brk_cmp2 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP3E",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "tim_brk_cmp3 enable\n\nThis bit enables the tim_brk_cmp3 for the timer's tim_brk input. tim_brk_cmp3 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP4E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "tim_brk_cmp4 enable\n\nThis bit enables the tim_brk_cmp4 for the timer's tim_brk input. tim_brk_cmp4 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP5E",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "tim_brk_cmp5 enable\n\nThis bit enables the tim_brk_cmp5 for the timer's tim_brk input. tim_brk_cmp5 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP6E",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "tim_brk_cmp6 enable\n\nThis bit enables the tim_brk_cmp6 for the timer's tim_brk input. tim_brk_cmp6 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP7E",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "tim_brk_cmp7 enable\n\nThis bit enables the tim_brk_cmp7 for the timer's tim_brk input. tim_brk_cmp7 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP8E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "tim_brk_cmp8 enable\n\nThis bit enables the tim_brk_cmp8 for the timer's tim_brk input. tim_brk_cmp8 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKINP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "TIMx_BKIN input polarity\n\nThis bit selects the TIMx_BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "tim_brk_cmp1 input polarity\n\nThis bit selects the tim_brk_cmp1 input sensitivity. It must be programmed together with the BKP polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "tim_brk_cmp2 input polarity\n\nThis bit selects the tim_brk_cmp2 input sensitivity. It must be programmed together with the BKP polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP3P",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "tim_brk_cmp3 input polarity\n\nThis bit selects the tim_brk_cmp3 input sensitivity. It must be programmed together with the BKP polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "tim_brk_cmp4 input polarity\n\nThis bit selects the tim_brk_cmp4 input sensitivity. It must be programmed together with the BKP polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "ETRSEL",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "etr_in source selection\n\nThese bits select the etr_in input source.\n\n...\n\nRefer to Section 28.3.2: TIM1 pins and internal signals for product specific implementation.\n\nNote: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073818724": {
        "name": "TIM1_AF2",
        "address": 1073818724,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 alternate function register 2",
        "fields": [
            {
                "name": "BK2INE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIMx_BKIN2 input enable\n\nThis bit enables the TIMx_BKIN2 alternate function input for the timer's tim_brk2 input. TIMx_BKIN2 input is 'ORed' with the other tim_brk2 sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp1 enable\n\nThis bit enables the tim_brk2_cmp1 for the timer's tim_brk2 input. tim_brk2_cmp1 output is 'ORed' with the other tim_brk2 sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp2 enable\n\nThis bit enables the tim_brk2_cmp2 for the timer's tim_brk2 input. tim_brk2_cmp2 output is 'ORed' with the other tim_brk2 sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP3E",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp3 enable\n\nThis bit enables the tim_brk2_cmp3 for the timer's tim_brk2 input. tim_brk2_cmp3 output is 'ORed' with the other tim_brk2 sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP4E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp4 enable\n\nThis bit enables the tim_brk2_cmp4 for the timer's tim_brk2 input. tim_brk2_cmp4 output is 'ORed' with the other tim_brk2 sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP5E",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp5 enable\n\nThis bit enables the tim_brk2_cmp5 for the timer's tim_brk2 input. tim_brk2_cmp5 output is 'ORed' with the other tim_brk2 sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP6E",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp6 enable\n\nThis bit enables the tim_brk2_cmp6 for the timer's tim_brk2 input. tim_brk2_cmp6 output is 'ORed' with the other tim_brk2 sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP7E",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp7 enable\n\nThis bit enables the tim_brk2_cmp7 for the timer's tim_brk2 input. tim_brk2_cmp7 output is 'ORed' with the other tim_brk2 sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP8E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp8 enable\n\nThis bit enables the tim_brk2_cmp8 for the timer's tim_brk2 input. tim_brk2_cmp8 output is 'ORed' with the other tim_brk2 sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2INP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "TIMx_BKIN2 input polarity\n\nThis bit selects the TIMx_BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp1 input polarity\n\nThis bit selects the tim_brk2_cmp1 input sensitivity. It must be programmed together with the BK2P polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp2 input polarity\n\nThis bit selects the tim_brk2_cmp2 input sensitivity. It must be programmed together with the BK2P polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP3P",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp3 input polarity\n\nThis bit selects the tim_brk2_cmp3 input sensitivity. It must be programmed together with the BK2P polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "tim_brk2_cmp4 input polarity\n\nThis bit selects the tim_brk2_cmp4 input sensitivity. It must be programmed together with the BK2P polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OCRSEL",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "ocref_clr source selection\n\nThese bits select the ocref_clr input source.\n\n...\n\nRefer to Section 28.3.2: TIM1 pins and internal signals for product specific information.\n\nNote: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073819612": {
        "name": "TIM1_DCR",
        "address": 1073819612,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\n\nThis 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\n\nExample:\n\n..."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\n\nThis 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).\n\n...\n\nExample: Let us consider the following transfer: DBL = 7 bytes & DBA = TIM2_CR1.\n\nIf DBL = 7 bytes and DBA = TIM2_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:\n\n(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL\n\nIn this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data are copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA\n\nAccording to the configuration of the DMA Data Size, several cases may occur:\n\nIf the DMA Data Size is configured in half-words, 16-bit data are transferred to each of the 7 registers.\n\nIf the DMA Data Size is configured in bytes, the data are also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA."
            },
            {
                "name": "DBSS",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "DMA burst source selection\n\nThis bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).\n\nOthers: reserved"
            }
        ]
    },
    "1073819616": {
        "name": "TIM1_DMAR",
        "address": 1073819616,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "DMA register for burst accesses\n\nA read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4\n\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR)."
            }
        ]
    },
    "1073741824": {
        "name": "TIM2_CR1",
        "address": 1073741824,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\n\nNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\n\nCEN is cleared automatically in one-pulse mode, when an update event occurs."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\n\nThis bit is set and cleared by software to enable/disable UEV event generation.\n\nCounter overflow/underflow\n\nSetting the UG bit\n\nUpdate generation through the slave mode controller\n\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\n\nThis bit is set and cleared by software to select the UEV event sources.\n\nCounter overflow/underflow\n\nSetting the UG bit\n\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction\n\nNote: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode."
            },
            {
                "name": "CMS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Center-aligned mode selection\n\nNote: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\n\nThis bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and sampling clock used by the digital filters (tim_etr_in, tim_tix),"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            },
            {
                "name": "DITHEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Dithering Enable\n\nNote: The DITHEN bit can only be modified when CEN bit is reset."
            }
        ]
    },
    "1073741828": {
        "name": "TIM2_CR2",
        "address": 1073741828,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 control register 2",
        "fields": [
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "MMS[0]: Master mode selection\n\nThese bits allow to select the information to be sent in master mode to slave timers for synchronization (tim_trgo). The combination is as follows:\n\nWhen the Counter Enable signal is controlled by the trigger input, there is a delay on tim_trgo, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).\n\nOthers: Reserved\n\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "tim_ti1 selection"
            },
            {
                "name": "MMS_1",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "MMS[3]"
            }
        ]
    },
    "1073741832": {
        "name": "TIM2_SMCR",
        "address": 1073741832,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 slave mode control register",
        "fields": [
            {
                "name": "SMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "SMS[0]: Slave mode selection\n\nWhen external signals are selected the active edge of the trigger signal (tim_trgi) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\n\nNote: The gated mode must not be used if tim_ti1f_ed is selected as the trigger input (TS=00100). Indeed, tim_ti1f_ed outputs 1 pulse for each transition on tim_ti1f, whereas the gated mode checks the level of the trigger signal.\n\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the tim_trgo signal must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "OCCS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "OCREF clear selection\n\nThis bit is used to select the OCREF clear source\n\nNote: If the OCREF clear selection feature is not supported, this bit is reserved and forced by hardware to '0'. Section 29.3: TIM2/TIM3 implementation."
            },
            {
                "name": "TS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "TS[0]: Trigger selection\n\nThis bit-field selects the trigger input to be used to synchronize the counter.\n\nOthers: Reserved\n\nSee Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation details.\n\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/Slave mode"
            },
            {
                "name": "ETF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "External trigger filter\n\nThis bit-field then defines the frequency used to sample tim_etrp signal and the length of the digital filter applied to tim_etrp. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "ETPS",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "External trigger prescaler\n\nExternal trigger signal tim_etrp frequency must be at most 1/4 of tim_ker_ck frequency. A prescaler can be enabled to reduce tim_etrp frequency. It is useful when inputting fast external clocks on tim_etr_in."
            },
            {
                "name": "ECE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "External clock enable\n\nThis bit enables External clock mode 2.\n\nSetting the ECE bit has the same effect as selecting external clock mode 1 with tim_trgi connected to tim_etrf (SMS=111 and TS=00111).\n\nIt is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, tim_trgi must not be connected to tim_etrf in this case (TS bits must not be 00111).\n\nNote: If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is tim_etrf."
            },
            {
                "name": "ETP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "External trigger polarity\n\nThis bit selects whether tim_etr_in or tim_etr_in is used for trigger operations"
            },
            {
                "name": "SMS_1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "SMS[3]"
            },
            {
                "name": "TS_1",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "TS[4:3]"
            },
            {
                "name": "SMSPE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "SMS preload enable\n\nThis bit selects whether the SMS[3:0] bitfield is preloaded"
            },
            {
                "name": "SMSPS",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "SMS preload source\n\nThis bit selects whether the events that triggers the SMS[3:0] bitfield transfer from preload to active"
            }
        ]
    },
    "1073741836": {
        "name": "TIM2_DIER",
        "address": 1073741836,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt enable"
            },
            {
                "name": "CC3IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt enable"
            },
            {
                "name": "CC4IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 DMA request enable"
            },
            {
                "name": "CC3DE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 DMA request enable"
            },
            {
                "name": "CC4DE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            },
            {
                "name": "IDXIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Index interrupt enable"
            },
            {
                "name": "DIRIE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Direction change interrupt enable"
            },
            {
                "name": "IERRIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Index error interrupt enable"
            },
            {
                "name": "TERRIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transition error interrupt enable"
            }
        ]
    },
    "1073741840": {
        "name": "TIM2_SR",
        "address": 1073741840,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\n\nThis bit is set by hardware on an update event. It is cleared by software.\n\nAt overflow or underflow and if UDIS=0 in the TIMx_CR1 register.\n\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\n\nWhen CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt flag\n\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\n\nIf channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in downcounting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\n\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt flag\n\nRefer to CC1IF description"
            },
            {
                "name": "CC3IF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt flag\n\nRefer to CC1IF description"
            },
            {
                "name": "CC4IF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt flag\n\nRefer to CC1IF description"
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\n\nThis flag is set by hardware on the TRG trigger event (active edge detected on tim_trgi input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\n\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 2 overcapture flag\n\nrefer to CC1OF description"
            },
            {
                "name": "CC3OF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 overcapture flag\n\nrefer to CC1OF description"
            },
            {
                "name": "CC4OF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 overcapture flag\n\nrefer to CC1OF description"
            },
            {
                "name": "IDXF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Index interrupt flag\n\nThis flag is set by hardware when an index event is detected. It is cleared by software by\n\nwriting it to '0'."
            },
            {
                "name": "DIRF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Direction change interrupt flag\n\nThis flag is set by hardware when the direction changes in encoder mode (DIR bit value in\n\nTIMx_CR is changing). It is cleared by software by writing it to '0'."
            },
            {
                "name": "IERRF",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Index error interrupt flag\n\nThis flag is set by hardware when an index error is detected. It is cleared by software by\n\nwriting it to '0'."
            },
            {
                "name": "TERRF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transition error interrupt flag\n\nThis flag is set by hardware when a transition error is detected in encoder mode. It is cleared\n\nby software by writing it to '0'."
            }
        ]
    },
    "1073741844": {
        "name": "TIM2_EGR",
        "address": 1073741844,
        "size": 22,
        "access": "write-only",
        "desc": "TIM2 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\n\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 generation\n\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\n\nIf channel CC1 is configured as output:\n\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\n\nIf channel CC1 is configured as input:\n\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 generation\n\nRefer to CC1G description"
            },
            {
                "name": "CC3G",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 generation\n\nRefer to CC1G description"
            },
            {
                "name": "CC4G",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 generation\n\nRefer to CC1G description"
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\n\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073741848": {
        "name": "TIM2_CCMR1",
        "address": 1073741848,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare mode register 1 [alternate]",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\n\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n\nNote: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\n\nThis bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1). The prescaler is reset as soon as CC1E=0 (TIMx_CCER register)."
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\n\nThis bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/compare 2 selection\n\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n\nNote: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC2PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 2 prescaler"
            },
            {
                "name": "IC2F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 2 filter"
            }
        ]
    },
    "1073741852": {
        "name": "TIM2_CCMR2",
        "address": 1073741852,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare mode register 2 [alternate]",
        "fields": [
            {
                "name": "CC3S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 3 selection\n\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n\nNote: CC3S bits are writable only when the channel is OFF (CC3E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC3PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 3 prescaler"
            },
            {
                "name": "IC3F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 3 filter"
            },
            {
                "name": "CC4S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 4 selection\n\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n\nNote: CC4S bits are writable only when the channel is OFF (CC4E = 0 in TIMx_CCER)."
            },
            {
                "name": "IC4PSC",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Input capture 4 prescaler"
            },
            {
                "name": "IC4F",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Input capture 4 filter"
            }
        ]
    },
    "1073741856": {
        "name": "TIM2_CCER",
        "address": 1073741856,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity.\n\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\n\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\n\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\n\nCC1NP=1, CC1P=1:\tnon-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\n\nCC1NP=1, CC1P=0:\tthis configuration is reserved, it must not be used."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity.\n\nCC1 channel configured as output: CC1NP must be kept cleared in this case.\n\nCC1 channel configured as input: This bit is used in conjunction with CC1P to define tim_ti1fp1/tim_ti2fp1 polarity. refer to CC1P description."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output enable.\n\nRefer to CC1E description"
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity.\n\nrefer to CC1P description"
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity.\n\nRefer to CC1NP description"
            },
            {
                "name": "CC3E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output enable.\n\nRefer to CC1E description"
            },
            {
                "name": "CC3P",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity.\n\nRefer to CC1P description"
            },
            {
                "name": "CC3NP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity.\n\nRefer to CC1NP description"
            },
            {
                "name": "CC4E",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output enable.\n\nrefer to CC1E description"
            },
            {
                "name": "CC4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity.\n\nRefer to CC1P description"
            },
            {
                "name": "CC4NP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity.\n\nRefer to CC1NP description"
            }
        ]
    },
    "1073741860": {
        "name": "TIM2_CNT",
        "address": 1073741860,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 31,
                "desc": "Least significant part of counter value\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the counter value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the non-dithered part in CNT[30:0]. The fractional part is not available."
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF copy or CNT bit 31\n\nIf TIMx_CR1.UIFREMAP = 0, thisbit means CNT[31], the most significant bit of counter value\n\nIf TIMx_CRT1.UIFREMAP = 1, this bit means UIF Copy, and is a read-only copy of the UIF bit of the TIMx_ISR register"
            }
        ]
    },
    "1073741864": {
        "name": "TIM2_PSC",
        "address": 1073741864,
        "size": 22,
        "access": "read-write",
        "desc": "TIM2 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\nThe counter clock frequency tim_cnt_ck is equal to fsubtim_psc_ck/sub / (PSC[15:0] + 1).\n\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in 'reset mode')."
            }
        ]
    },
    "1073741868": {
        "name": "TIM2_ARR",
        "address": 1073741868,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Auto-reload value\n\nARR is the value to be loaded in the actual auto-reload register.\n\nRefer to the Section 29.4.3: Time-base unit on page 1245 for more details about ARR update and behavior.\n\nThe counter is blocked while the auto-reload value is null.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the auto-reload value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in ARR[31:4]. The ARR[3:0] bitfield contains the dithered part."
            }
        ]
    },
    "1073741876": {
        "name": "TIM2_CCR1",
        "address": 1073741876,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Capture/compare 1 value\n\nIf channel CC1 is configured as output:\n\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR1[31:4]. The CCR1[3:0] bitfield contains the dithered part.\n\nIf channel CC1 is configured as input:\n\nCCR1 is the counter value transferred by the last input capture 1 event (tim_ic1). The TIMx_CCR1 register is read-only and cannot be programmed.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the capture value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the capture in CCR1[31:0]. The CCR1[3:0] bits are reset."
            }
        ]
    },
    "1073741880": {
        "name": "TIM2_CCR2",
        "address": 1073741880,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Capture/compare 2 value\n\nIf channel CC2 is configured as output:\n\nCCR2 is the value to be loaded in the actual capture/compare 2 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc2 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR2[31:4]. The CCR2[3:0] bitfield contains the dithered part.\n\nIf channel CC2 is configured as input:\n\nCCR2 is the counter value transferred by the last input capture 2 event (tim_ic2). The TIMx_CCR2 register is read-only and cannot be programmed.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the capture value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the capture in CCR2[31:0]. The CCR2[3:0] bits are reset."
            }
        ]
    },
    "1073741884": {
        "name": "TIM2_CCR3",
        "address": 1073741884,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Capture/compare 3 value\n\nIf channel CC3 is configured as output:\n\nCCR3 is the value to be loaded in the actual capture/compare 3 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc3 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR3[31:4]. The CCR3[3:0] bitfield contains the dithered part.\n\nIf channel CC3 is configured as input:\n\nCCR3 is the counter value transferred by the last input capture 3 event (tim_ic3). The TIMx_CCR3 register is read-only and cannot be programmed.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the capture value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the capture in CCR3[31:0]. The CCR3[3:0] bits are reset."
            }
        ]
    },
    "1073741888": {
        "name": "TIM2_CCR4",
        "address": 1073741888,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 capture/compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Capture/compare 4 value\n\nIf channel CC4 is configured as output:\n\nCCR4 is the value to be loaded in the actual capture/compare 4 register (preload value). It is loaded permanently if the preload feature is not selected in the TIMx_CCMR4 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc4 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR4[31:4]. The CCR4[3:0] bitfield contains the dithered part.\n\nIf channel CC4 is configured as input:\n\nCCR4 is the counter value transferred by the last input capture 4 event (tim_ic4). The TIMx_CCR4 register is read-only and cannot be programmed.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the capture value.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the capture in CCR4[31:0]. The CCR4[3:0] bits are reset."
            }
        ]
    },
    "1073741912": {
        "name": "TIM2_ECR",
        "address": 1073741912,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 timer encoder control register",
        "fields": [
            {
                "name": "IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Index enable\n\nThis bit indicates if the Index event resets the counter."
            },
            {
                "name": "IDIR",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Index direction\n\nThis bit indicates in which direction the Index event resets the counter.\n\nNote: The IDR[1:0] bitfield must be written when IE bit is reset (index disabled)."
            },
            {
                "name": "IBLK",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Index blanking\n\nThis bit indicates if the Index event is conditioned by the tim_ti3 input"
            },
            {
                "name": "FIDX",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "First index\n\nThis bit indicates if the first index only is taken into account"
            },
            {
                "name": "IPOS",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Index positioning\n\nIn quadrature encoder mode (SMS[3:0] = 0001, 0010, 0011, 1110, 1111), this bit indicates in which AB input configuration the Index event resets the counter.\n\nIn directional clock mode or clock plus direction mode (SMS[3:0] = 1010, 1011, 1100, 1101), these bits indicates on which level the Index event resets the counter. In bidirectional clock mode, this applies for both clock inputs.\n\nx0: Index resets the counter when clock is 0\n\nx1: Index resets the counter when clock is 1\n\nNote: IPOS[1] bit is not significant"
            },
            {
                "name": "PW",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Pulse width\n\nThis bitfield defines the pulse duration, as following:\n\ntsubPW/sub = PW[7:0] x tsubPWG/sub"
            },
            {
                "name": "PWPRSC",
                "bitOffset": 24,
                "bitWidth": 3,
                "desc": "Pulse width prescaler\n\nThis bitfield sets the clock prescaler for the pulse generator, as following:\n\ntsubPWG/sub = (2sup(PWPRSC[2:0])/sup) x tsubtim_ker_ck/sub"
            }
        ]
    },
    "1073741916": {
        "name": "TIM2_TISEL",
        "address": 1073741916,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 timer input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Selects tim_ti1[15:0] input\n\n...\n\nRefer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation."
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Selects tim_ti2[15:0] input\n\n...\n\nRefer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation."
            },
            {
                "name": "TI3SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Selects tim_ti3[15:0] input\n\n...\n\nRefer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation."
            },
            {
                "name": "TI4SEL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Selects tim_ti4[15:0] input\n\n...\n\nRefer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation."
            }
        ]
    },
    "1073741920": {
        "name": "TIM2_AF1",
        "address": 1073741920,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 alternate function register 1",
        "fields": [
            {
                "name": "ETRSEL",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "etr_in source selection\n\nThese bits select the etr_in input source.\n\n...\n\nRefer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation."
            }
        ]
    },
    "1073741924": {
        "name": "TIM2_AF2",
        "address": 1073741924,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 alternate function register 2",
        "fields": [
            {
                "name": "OCRSEL",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "ocref_clr source selection\n\nThese bits select the ocref_clr input source.\n\n...\n\nRefer to Section 29.4.2: TIM2/TIM3 pins and internal signals for product specific implementation."
            }
        ]
    },
    "1073742812": {
        "name": "TIM2_DCR",
        "address": 1073742812,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\n\nThis 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\n\nExample:\n\n..."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\n\nThis 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).\n\n...\n\nExample: Let us consider the following transfer: DBL = 7 bytes & DBA = TIM2_CR1.\n\nIf DBL = 7 bytes and DBA = TIM2_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:\n\n(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL\n\nIn this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data are copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA\n\nAccording to the configuration of the DMA Data Size, several cases may occur:\n\nIf the DMA Data Size is configured in half-words, 16-bit data are transferred to each of the 7 registers.\n\nIf the DMA Data Size is configured in bytes, the data are also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA."
            },
            {
                "name": "DBSS",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "DMA burst source selection\n\nThis bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).\n\nOthers: reserved"
            }
        ]
    },
    "1073742816": {
        "name": "TIM2_DMAR",
        "address": 1073742816,
        "size": 32,
        "access": "read-write",
        "desc": "TIM2 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "DMA register for burst accesses\n\nA read or write operation to the DMAR register accesses the register located at the address\n\n(TIMx_CR1 address) + (DBA + DMA index) x 4\n\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR)."
            }
        ]
    },
    "1073824768": {
        "name": "TIM16_CR1",
        "address": 1073824768,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\n\nNote: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\n\nThis bit is set and cleared by software to enable/disable UEV event generation.\n\nCounter overflow/underflow\n\nSetting the UG bit\n\nUpdate generation through the slave mode controller\n\n\tBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\n\nThis bit is set and cleared by software to select the UEV event sources.\n\nCounter overflow/underflow\n\nSetting the UG bit\n\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\n\nThis bit-field indicates the division ratio between the timer clock (tim_ker_ck) frequency and the dead-time and sampling clock (tsubDTS/sub)used by the dead-time generators and the digital filters (tim_tix),"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            },
            {
                "name": "DITHEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Dithering enable\n\nNote: The DITHEN bit can only be modified when CEN bit is reset."
            }
        ]
    },
    "1073824772": {
        "name": "TIM16_CR2",
        "address": 1073824772,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 control register 2",
        "fields": [
            {
                "name": "CCPC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare preloaded control\n\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCUS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare control update selection\n\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "OIS1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (tim_oc1 output)\n\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BKR register)."
            },
            {
                "name": "OIS1N",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (tim_oc1n output)\n\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BKR register)."
            }
        ]
    },
    "1073824780": {
        "name": "TIM16_DIER",
        "address": 1073824780,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 DMA/interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "COMIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt enable"
            },
            {
                "name": "BIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            }
        ]
    },
    "1073824784": {
        "name": "TIM16_SR",
        "address": 1073824784,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\n\nThis bit is set by hardware on an update event. It is cleared by software.\n\nAt overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.\n\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt flag\n\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\n\nIf channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\n\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "COMIF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt flag\nThis flag is set by hardware on a COM event (once the capture compare control bits CCxE, CCxNE, OCxM have been updated). It is cleared by software."
            },
            {
                "name": "BIF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt flag\n\nThis flag is set by hardware as soon as the tim_brk input goes active. It can be cleared by software if the break input is not active."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\n\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            }
        ]
    },
    "1073824788": {
        "name": "TIM16_EGR",
        "address": 1073824788,
        "size": 22,
        "access": "write-only",
        "desc": "TIM16 event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\n\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 generation\n\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\n\nIf channel CC1 is configured as output:\n\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\n\nIf channel CC1 is configured as input:\n\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "COMG",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare control update generation\n\nThis bit can be set by software, it is automatically cleared by hardware.\n\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "BG",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break generation\n\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073824792": {
        "name": "TIM16_CCMR1",
        "address": 1073824792,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 capture/compare mode register 1 [alternate]",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\n\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\n\nOthers: Reserved\n\nNote: CC1S bits are writable only when the channel is OFF (CC1E = '0' in TIMx_CCER)."
            },
            {
                "name": "IC1PSC",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Input capture 1 prescaler\n\nThis bit-field defines the ratio of the prescaler acting on CC1 input (tim_ic1).\n\nThe prescaler is reset as soon as CC1E='0' (TIMx_CCER register)."
            },
            {
                "name": "IC1F",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Input capture 1 filter\n\nThis bit-field defines the frequency used to sample tim_ti1 input and the length of the digital filter applied to tim_ti1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            }
        ]
    },
    "1073824800": {
        "name": "TIM16_CCER",
        "address": 1073824800,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 capture/compare enable register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable\n\nWhen CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to Table 305 for details."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output polarity\n\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\n\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\n\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\n\nCC1NP=1, CC1P=1:\tnon-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\n\nCC1NP=1, CC1P=0:\tthis configuration is reserved, it must not be used.\n\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\n\nNote: On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output enable"
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output polarity\n\nCC1 channel configured as output:\n\nCC1 channel configured as input:\n\nThis bit is used in conjunction with CC1P to define the polarity of tim_ti1fp1. Refer to the description of CC1P.\n\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\n\nNote: On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a commutation event is generated."
            }
        ]
    },
    "1073824804": {
        "name": "TIM16_CNT",
        "address": 1073824804,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the counter value.\n\nDithering mode (DITHEN = 1)\n\nThe register only holds the non-dithered part in CNT[15:0]. The fractional part is not available."
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF Copy\n\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved."
            }
        ]
    },
    "1073824808": {
        "name": "TIM16_PSC",
        "address": 1073824808,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\n\nThe counter clock frequency (tim_cnt_ck) is equal to fsubtim_psc_ck/sub / (PSC[15:0] + 1).\n\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in 'reset mode')."
            }
        ]
    },
    "1073824812": {
        "name": "TIM16_ARR",
        "address": 1073824812,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Auto-reload value\n\nARR is the value to be loaded in the actual auto-reload register.\n\nRefer to the Section 30.3.3: Time-base unit on page 1362 for more details about ARR update and behavior.\n\nThe counter is blocked while the auto-reload value is null.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the auto-reload value in ARR[15:0]. The ARR[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in ARR[19:4]. The ARR[3:0] bitfield contains the dithered part."
            }
        ]
    },
    "1073824816": {
        "name": "TIM16_RCR",
        "address": 1073824816,
        "size": 22,
        "access": "read-write",
        "desc": "TIM16 repetition counter register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Repetition counter reload value\n\nThis bitfield defines the update rate of the compare registers (i.e. periodic transfers from preload to active registers) when preload registers are enable. It also defines the update interrupt generation rate, if this interrupt is enable.\n\nWhen the repetition down-counter reaches zero, an update event is generated and it restarts counting from REP value. As the repetition counter is reloaded with REP value only at the repetition update event UEV, any write to the TIMx_RCR register is not taken in account until the next repetition update event.\n\nIt means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode:\n\nthe number of PWM periods in edge-aligned mode\n\nthe number of half PWM period in center-aligned mode"
            }
        ]
    },
    "1073824820": {
        "name": "TIM16_CCR1",
        "address": 1073824820,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Capture/Compare 1 value\n\nIf channel CC1 is configured as output:\n\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\n\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.\n\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on tim_oc1 output.\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the compare value in CCR1[15:0]. The CCR1[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the integer part in CCR1[19:4]. The CCR1[3:0] bitfield contains the dithered part.\n\nIf channel CC1 is configured as input:\n\nCCR1 is the counter value transferred by the last input capture 1 event (tim_ic1).\n\nNon-dithering mode (DITHEN = 0)\n\nThe register holds the capture value in CCR1[15:0]. The CCR1[19:16] bits are reset.\n\nDithering mode (DITHEN = 1)\n\nThe register holds the capture in CCR1[19:4]. The CCR1[3:0] bits are reset."
            }
        ]
    },
    "1073824836": {
        "name": "TIM16_BDTR",
        "address": 1073824836,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 break and dead-time register",
        "fields": [
            {
                "name": "DTG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time generator setup\n\nThis bit-field defines the duration of the dead-time inserted between the complementary outputs. DT correspond to this duration.\n\nDTG[7:5]=0xx = DT=DTG[7:0]x tsubdtg/sub with tsubdtg/sub=tsubDTS/sub\n\nDTG[7:5]=10x = DT=(64+DTG[5:0])xtsubdtg/sub with Tsubdtg/sub=2xtsubDTS/sub\n\nDTG[7:5]=110 = DT=(32+DTG[4:0])xtsubdtg/sub with Tsubdtg/sub=8xtsubDTS/sub\n\nDTG[7:5]=111 = DT=(32+DTG[4:0])xtsubdtg/sub with Tsubdtg/sub=16xtsubDTS/sub\n\nExample if TsubDTS/sub=125ns (8MHz), dead-time possible values are:\n\n0 to 15875 ns by 125 ns steps,\n\n16 s to 31750 ns by 250 ns steps,\n\n32 s to 63 s by 1 s steps,\n\n64 s to 126 s by 2 s steps\n\nNote: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "LOCK",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Lock configuration\n\nThese bits offer a write protection against software errors.\n\nNote: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset."
            },
            {
                "name": "OSSI",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Off-state selection for Idle mode\n\nThis bit is used when MOE=0 on channels configured as outputs.\n\nSee tim_oc1/tim_oc1n enable description for more details (Section 30.6.8: TIMx capture/compare enable register (TIMx_CCER)(x = 16 to 17) on page 1404).\n\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OSSR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Off-state selection for Run mode\n\nThis bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.\n\nSee tim_oc1/tim_oc1n enable description for more details (Section 30.6.8: TIMx capture/compare enable register (TIMx_CCER)(x = 16 to 17) on page 1404).\n\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Break enable\n\n1; Break inputs (tim_brk and tim_sys_brk event) enabled\n\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Break polarity\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "AOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Automatic output enable\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "MOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Main output enable\n\nThis bit is cleared asynchronously by hardware as soon as the tim_brk input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.\n\nSee tim_oc1/tim_oc1n enable description for more details (Section 30.6.8: TIMx capture/compare enable register (TIMx_CCER)(x = 16 to 17) on page 1404)."
            },
            {
                "name": "BKF",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Break filter\n\nThis bit-field defines the frequency used to sample tim_brk input and the length of the digital filter applied to tim_brk. The digital filter is made of an event counter in which N events are needed to validate a transition on the output:\n\nThis bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKDSRM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Break Disarm\n\nThis bit is cleared by hardware when no break source is active.\n\nThe BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.\n\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKBID",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Break Bidirectional\n\nIn the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.\n\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\n\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            }
        ]
    },
    "1073824852": {
        "name": "TIM16_DTR2",
        "address": 1073824852,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 timer deadtime register 2",
        "fields": [
            {
                "name": "DTGF",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time falling edge generator setup\n\nThis bit-field defines the duration of the dead-time inserted between the complementary outputs, on the falling edge.\n\nDTGF[7:5]=0xx = DTF=DTGF[7:0]x tsubdtg/sub with tsubdtg/sub=tsubDTS/sub.\n\nDTGF[7:5]=10x = DTF=(64+DTGF[5:0])xtsubdtg/sub with Tsubdtg/sub=2xtsubDTS/sub.\n\nDTGF[7:5]=110 = DTF=(32+DTGF[4:0])xtsubdtg/sub with Tsubdtg/sub=8xtsubDTS/sub.\n\nDTGF[7:5]=111 = DTF=(32+DTGF[4:0])xtsubdtg/sub with Tsubdtg/sub=16xtsubDTS/sub.\n\nExample if TsubDTS/sub=125ns (8MHz), dead-time possible values are:\n\n0 to 15875 ns by 125 ns steps,\n\n16 us to 31750 ns by 250 ns steps,\n\n32 us to 63us by 1 us steps,\n\n64 us to 126 us by 2 us steps\n\nNote: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "DTAE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Deadtime asymmetric enable\n\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "DTPE",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Deadtime preload enable\n\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073824860": {
        "name": "TIM16_TISEL",
        "address": 1073824860,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "selects tim_ti1_in[15:0] input\n\n...\n\nRefer to Section 30.3.2: TIM16/TIM17 pins and internal signals for interconnects list."
            }
        ]
    },
    "1073824864": {
        "name": "TIM16_AF1",
        "address": 1073824864,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 alternate function register 1",
        "fields": [
            {
                "name": "BKINE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIMx_BKIN input enable\n\nThis bit enables the TIMx_BKIN alternate function input for the timer's tim_brk input. TIMx_BKIN input is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "tim_brk_cmp1 enable\n\nThis bit enables the tim_brk_cmp1 for the timer's tim_brk input. tim_brk_cmp1 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "tim_brk_cmp2 enable\n\nThis bit enables the tim_brk_cmp2 for the timer's tim_brk input. tim_brk_cmp2 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP3E",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "tim_brk_cmp3 enable\n\nThis bit enables the tim_brk_cmp3 for the timer's tim_brk input. tim_brk_cmp3 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP4E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "tim_brk_cmp4 enable\n\nThis bit enables the tim_brk_cmp4 for the timer's tim_brk input. tim_brk_cmp4 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP5E",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "tim_brk_cmp5 enable\n\nThis bit enables the tim_brk_cmp5 for the timer's tim_brk input. tim_brk_cmp5 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP6E",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "tim_brk_cmp6 enable\n\nThis bit enables the tim_brk_cmp6 for the timer's tim_brk input. tim_brk_cmp6 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP7E",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "tim_brk_cmp7 enable\n\nThis bit enables the tim_brk_cmp7 for the timer's tim_brk input. tim_brk_cmp7 output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP8E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "tim_brk_cmp8 enable\n\nThis bit enables the tim_brk_cmp8 for the timer's tim_brk input. mdf_brkx output is 'ORed' with the other tim_brk sources.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKINP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "TIMx_BKIN input polarity\n\nThis bit selects the TIMx_BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "tim_brk_cmp1 input polarity\n\nThis bit selects the tim_brk_cmp1 input sensitivity. It must be programmed together with the BKP polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "tim_brk_cmp2 input polarity\n\nThis bit selects the tim_brk_cmp2 input sensitivity. It must be programmed together with the BKP polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP3P",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "tim_brk_cmp3 input polarity\n\nThis bit selects the tim_brk_cmp3 input sensitivity. It must be programmed together with the BKP polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "tim_brk_cmp4 input polarity\n\nThis bit selects the tim_brk_cmp4 input sensitivity. It must be programmed together with the BKP polarity bit.\n\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073824868": {
        "name": "TIM16_AF2",
        "address": 1073824868,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 alternate function register 2",
        "fields": [
            {
                "name": "OCRSEL",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "tim_ocref_clr source selection\n\nThese bits select the tim_ocref_clr input source.\n\nRefer to Section 30.3.2: TIM16/TIM17 pins and internal signals for product specific implementation.\n\nNote: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073824872": {
        "name": "TIM16_OR1",
        "address": 1073824872,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 option register 1",
        "fields": [
            {
                "name": "HSE32EN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "HSE Divided by 32 enable\n\nThis bit enables the HSE divider by 32 for the tim_ti1_in3. See Table 296: Interconnect to the tim_ti1 input multiplexer for details."
            }
        ]
    },
    "1073825756": {
        "name": "TIM16_DCR",
        "address": 1073825756,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16 DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\n\nThis 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\n\nExample:\n\n...\n\nExample: Let us consider the following transfer: DBL = 7 transfers and DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\n\nThis 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).\n\n..."
            },
            {
                "name": "DBSS",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "DMA burst source selection\n\nThis bitfield defines the interrupt source that triggers the DMA burst transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).\n\nOther: reserved"
            }
        ]
    },
    "1073825760": {
        "name": "TIM16_DMAR",
        "address": 1073825760,
        "size": 32,
        "access": "read-write",
        "desc": "TIM16/TIM17 DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "DMA register for burst accesses\n\nA read or write operation to the DMAR register accesses the register located at the address\n\n(TIMx_CR1 address) + (DBA + DMA index) x 4\n\nwhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR)."
            }
        ]
    },
    "1073889280": {
        "name": "TSC_CR",
        "address": 1073889280,
        "size": 32,
        "access": "",
        "desc": "TSC control register",
        "fields": [
            {
                "name": "TSCE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Touch sensing controller enable\nThis bit is set and cleared by software to enable/disable the touch sensing controller.\nNote: When the touch sensing controller is disabled, TSC registers settings have no effect."
            },
            {
                "name": "START",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Start a new acquisition\nThis bit is set by software to start a new acquisition. It is cleared by hardware as soon as the acquisition is complete or by software to cancel the ongoing acquisition."
            },
            {
                "name": "AM",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Acquisition mode\nThis bit is set and cleared by software to select the acquisition mode.\nNote: This bit must not be modified when an acquisition is ongoing."
            },
            {
                "name": "SYNCPOL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Synchronization pin polarity\nThis bit is set and cleared by software to select the polarity of the synchronization input pin."
            },
            {
                "name": "IODEF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "I/O Default mode\nThis bit is set and cleared by software. It defines the configuration of all the TSC I/Os when there is no ongoing acquisition. When there is an ongoing acquisition, it defines the configuration of all unused I/Os (not defined as sampling capacitor I/O or as channel I/O).\nNote: This bit must not be modified when an acquisition is ongoing."
            },
            {
                "name": "MCV",
                "bitOffset": 5,
                "bitWidth": 3,
                "desc": "Max count value\nThese bits are set and cleared by software. They define the maximum number of charge transfer pulses that can be generated before a max count error is generated.\nNote: These bits must not be modified when an acquisition is ongoing."
            },
            {
                "name": "PGPSC",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Pulse generator prescaler\nThese bits are set and cleared by software.They select the AHB clock divider used to generate the pulse generator clock (PGCLK).\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: Some configurations are forbidden. Refer to the Section21.3.4: Charge transfer acquisition sequence for details."
            },
            {
                "name": "SSPSC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Spread spectrum prescaler\nThis bit is set and cleared by software. It selects the AHB clock divider used to generate the spread spectrum clock (SSCLK).\nNote: This bit must not be modified when an acquisition is ongoing."
            },
            {
                "name": "SSE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Spread spectrum enable\nThis bit is set and cleared by software to enable/disable the spread spectrum feature.\nNote: This bit must not be modified when an acquisition is ongoing."
            },
            {
                "name": "SSD",
                "bitOffset": 17,
                "bitWidth": 7,
                "desc": "Spread spectrum deviation\nThese bits are set and cleared by software. They define the spread spectrum deviation which consists in adding a variable number of periods of the SSCLK clock to the charge transfer pulse high state.\n...\nNote: These bits must not be modified when an acquisition is ongoing."
            },
            {
                "name": "CTPL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Charge transfer pulse low\nThese bits are set and cleared by software. They define the duration of the low state of the charge transfer pulse (transfer of charge from CsubX/sub to CsubS/sub).\n...\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: Some configurations are forbidden. Refer to the Section21.3.4: Charge transfer acquisition sequence for details."
            },
            {
                "name": "CTPH",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Charge transfer pulse high\nThese bits are set and cleared by software. They define the duration of the high state of the charge transfer pulse (charge of CsubX/sub).\n...\nNote: These bits must not be modified when an acquisition is ongoing."
            }
        ]
    },
    "1073889284": {
        "name": "TSC_IER",
        "address": 1073889284,
        "size": 32,
        "access": "",
        "desc": "TSC interrupt enable register",
        "fields": [
            {
                "name": "EOAIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "End of acquisition interrupt enable\nThis bit is set and cleared by software to enable/disable the end of acquisition interrupt."
            },
            {
                "name": "MCEIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Max count error interrupt enable\nThis bit is set and cleared by software to enable/disable the max count error interrupt."
            }
        ]
    },
    "1073889288": {
        "name": "TSC_ICR",
        "address": 1073889288,
        "size": 32,
        "access": "",
        "desc": "TSC interrupt clear register",
        "fields": [
            {
                "name": "EOAIC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "End of acquisition interrupt clear\nThis bit is set by software to clear the end of acquisition flag and it is cleared by hardware when the flag is reset. Writing a '0' has no effect."
            },
            {
                "name": "MCEIC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Max count error interrupt clear\nThis bit is set by software to clear the max count error flag and it is cleared by hardware when the flag is reset. Writing a '0' has no effect."
            }
        ]
    },
    "1073889292": {
        "name": "TSC_ISR",
        "address": 1073889292,
        "size": 32,
        "access": "",
        "desc": "TSC interrupt status register",
        "fields": [
            {
                "name": "EOAF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "End of acquisition flag\nThis bit is set by hardware when the acquisition of all enabled group is complete (all GxS bits of all enabled analog I/O groups are set or when a max count error is detected). It is cleared by software writing 1 to the bit EOAIC of the TSC_ICR register."
            },
            {
                "name": "MCEF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Max count error flag\nThis bit is set by hardware as soon as an analog I/O group counter reaches the max count value specified. It is cleared by software writing 1 to the bit MCEIC of the TSC_ICR register."
            }
        ]
    },
    "1073889296": {
        "name": "TSC_IOHCR",
        "address": 1073889296,
        "size": 32,
        "access": "",
        "desc": "TSC I/O hysteresis control register",
        "fields": [
            {
                "name": "G1_IO1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO3",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO4",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO2",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO4",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO2",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO3",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO2",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO3",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO4",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO1",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO2",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO3",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO4",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Gx_IOy Schmitt trigger hysteresis mode, x = 8 to 1, y = 4 to 1.\nThese bits are set and cleared by software to enable/disable the Gx_IOy Schmitt trigger hysteresis.\nNote: These bits control the I/O Schmitt trigger hysteresis whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            }
        ]
    },
    "1073889304": {
        "name": "TSC_IOASCR",
        "address": 1073889304,
        "size": 32,
        "access": "",
        "desc": "TSC I/O analog switch control register",
        "fields": [
            {
                "name": "G1_IO1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G1_IO4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO3",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G2_IO4",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO2",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G3_IO4",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO2",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO3",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G4_IO4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO2",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO3",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G5_IO4",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO1",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO2",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO3",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            },
            {
                "name": "G6_IO4",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Gx_IOy analog switch enable\nThese bits are set and cleared by software to enable/disable the Gx_IOy analog switch.\nNote: These bits control the I/O analog switch whatever the I/O control mode is (even if controlled by standard GPIO registers)."
            }
        ]
    },
    "1073889312": {
        "name": "TSC_IOSCR",
        "address": 1073889312,
        "size": 32,
        "access": "",
        "desc": "TSC I/O sampling control register",
        "fields": [
            {
                "name": "G1_IO1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO3",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO4",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO2",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO4",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO2",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO3",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO2",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO3",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO4",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO1",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO2",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO3",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO4",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Gx_IOy sampling mode\nThese bits are set and cleared by software to configure the Gx_IOy as a sampling capacitor I/O. Only one I/O per analog I/O group must be defined as sampling capacitor.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOSCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            }
        ]
    },
    "1073889320": {
        "name": "TSC_IOCCR",
        "address": 1073889320,
        "size": 32,
        "access": "",
        "desc": "TSC I/O channel control register",
        "fields": [
            {
                "name": "G1_IO1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G1_IO4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO1",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO3",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G2_IO4",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO2",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G3_IO4",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO2",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO3",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G4_IO4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO1",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO2",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO3",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G5_IO4",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO1",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO2",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO3",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            },
            {
                "name": "G6_IO4",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Gx_IOy channel mode\nThese bits are set and cleared by software to configure the Gx_IOy as a channel I/O.\nNote: These bits must not be modified when an acquisition is ongoing.\nNote: During the acquisition phase and even if the TSC peripheral alternate function is not enabled, as soon as the TSC_IOCCR bit is set, the corresponding GPIO analog switch is automatically controlled by the touch sensing controller."
            }
        ]
    },
    "1073889328": {
        "name": "TSC_IOGCSR",
        "address": 1073889328,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group control status register",
        "fields": [
            {
                "name": "G1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G2E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G3E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G4E",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G5E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G6E",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Analog I/O group x enable\nThese bits are set and cleared by software to enable/disable the acquisition (counter is counting) on the corresponding analog I/O group x."
            },
            {
                "name": "G1S",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G2S",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G3S",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G4S",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G5S",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            },
            {
                "name": "G6S",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Analog I/O group x status\nThese bits are set by hardware when the acquisition on the corresponding enabled analog I/O group x is complete. They are cleared by hardware when a new acquisition is started.\nNote: When a max count error is detected the remaining GxS bits of the enabled analog I/O groups are not set."
            }
        ]
    },
    "1073889332": {
        "name": "TSC_IOG1CR",
        "address": 1073889332,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 1 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold)."
            }
        ]
    },
    "1073889336": {
        "name": "TSC_IOG2CR",
        "address": 1073889336,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 2 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold)."
            }
        ]
    },
    "1073889340": {
        "name": "TSC_IOG3CR",
        "address": 1073889340,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 3 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold)."
            }
        ]
    },
    "1073889344": {
        "name": "TSC_IOG4CR",
        "address": 1073889344,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 4 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold)."
            }
        ]
    },
    "1073889348": {
        "name": "TSC_IOG5CR",
        "address": 1073889348,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 5 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold)."
            }
        ]
    },
    "1073889352": {
        "name": "TSC_IOG6CR",
        "address": 1073889352,
        "size": 32,
        "access": "",
        "desc": "TSC I/O group 6 counter register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 14,
                "desc": "Counter value\nThese bits represent the number of charge transfer cycles generated on the analog I/O group x to complete its acquisition (voltage across CsubS/sub has reached the threshold)."
            }
        ]
    },
    "1073821696": {
        "name": "USART_CR1",
        "address": 1073821696,
        "size": 32,
        "access": "read-write",
        "desc": "USART control register 1 [alternate]",
        "fields": [
            {
                "name": "UE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART enable\n\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.\n\nNote: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.\n\nNote: The DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.\n\nNote: In Smartcard mode, (SCEN = 1), the CK is always available when CLKEN = 1, regardless of the UE bit value."
            },
            {
                "name": "UESM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "USART enable in low-power mode\n\nWhen this bit is cleared, the USART cannot request its kernel clock and is not functional in low-power mode.\n\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\n\nThis bit is set and cleared by software.\n\nNote: The UESM bit must be set at the initialization phase.\n\nNote: If the USART does not support the wakeup from low-power mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "RE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receiver enable\n\nThis bit enables the receiver. It is set and cleared by software."
            },
            {
                "name": "TE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transmitter enable\n\nThis bit enables the transmitter. When the Autonomous mode is not used, TE bit is set and cleared by software. When the Autonomous mode is used, TE bit becomes a status bit, which is set and cleared by hardware.\n\nNote: During transmission, a low pulse on the TE bit (0 followed by 1) sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to 1. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.\n\nNote: In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts."
            },
            {
                "name": "IDLEIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "IDLE interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFNEIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFNFIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "PEIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "PE interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "PS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Parity selection\n\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\n\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "PCE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Parity control enable\n\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).\n\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "WAKE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver wakeup method\n\nThis bit determines the USART wakeup method from Mute mode. It is set or cleared by software.\n\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "M0",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Word length\n\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).\n\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "MME",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Mute mode enable\n\nThis bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software."
            },
            {
                "name": "CMIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Character match interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "OVER8",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Oversampling mode\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: In LIN, IrDA and Smartcard modes, this bit must be kept cleared."
            },
            {
                "name": "DEDT",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Driver Enable deassertion time\n\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\n\nIf the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.\n\nThis bitfield can only be written when the USART is disabled (UE=0).\n\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "DEAT",
                "bitOffset": 21,
                "bitWidth": 5,
                "desc": "Driver Enable assertion time\n\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\n\nThis bitfield can only be written when the USART is disabled (UE=0).\n\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "RTOIE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receiver timeout interrupt enable\n\nThis bit is set and cleared by software.\n\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "EOBIE",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "End of Block interrupt enable\n\nThis bit is set and cleared by software.\n\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "M1",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Word length\n\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\n\nM[1:0] = 00: 1 start bit, 8 Data bits, n Stop bit\n\nM[1:0] = 01: 1 start bit, 9 Data bits, n Stop bit\n\nM[1:0] = 10: 1 start bit, 7 Data bits, n Stop bit\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: In 7-bits data length mode, the Smartcard mode, LIN master mode and auto baud rate (0x7F and 0x55 frames detection) are not supported."
            },
            {
                "name": "FIFOEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "FIFO mode enable\n\nThis bit is set and cleared by software.\n\nThis bitfield can only be written when the USART is disabled (UE=0).\n\nNote: FIFO mode can be used on standard UART communication, in SPI Master/Slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes."
            },
            {
                "name": "TXFEIE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TXFIFO empty interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFFIE",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RXFIFO Full interrupt enable\n\nThis bit is set and cleared by software."
            }
        ]
    },
    "1073821700": {
        "name": "USART_CR2",
        "address": 1073821700,
        "size": 32,
        "access": "read-write",
        "desc": "USART control register 2",
        "fields": [
            {
                "name": "SLVEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Synchronous Slave mode enable\n\nWhen the SLVEN bit is set, the Synchronous slave mode is enabled.\n\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "DIS_NSS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "When the DIS_NSS bit is set, the NSS pin input is ignored.\n\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "ADDM7",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "7-bit Address Detection/4-bit Address Detection\n\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\n\nThis bit can only be written when the USART is disabled (UE=0)\n\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively."
            },
            {
                "name": "LBDL",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LIN break detection length\n\nThis bit is for selection between 11 bit or 10 bit break detection.\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "LBDIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LIN break detection interrupt enable\n\nBreak interrupt mask (break detection using break delimiter).\n\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "LBCL",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Last bit clock pulse\n\nThis bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the CK pin in Synchronous mode.\n\nThe last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register.\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "CPHA",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Clock phase\n\nThis bit is used to select the phase of the clock output on the CK pin in Synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see Figure 933 and Figure 934)\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "CPOL",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Clock polarity\n\nThis bit enables the user to select the polarity of the clock output on the CK pin in Synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: If Synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "CLKEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Clock enable\n\nThis bit enables the user to enable the CK pin.\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: If neither Synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565.\n\nIn Smartcard mode, in order to provide correctly the CK clock to the smartcard, the steps below must be respected:\n\nUE = 0\n\nSCEN = 1\n\nGTPR configuration\n\nCLKEN= 1\n\nNote: UE = 1"
            },
            {
                "name": "STOP",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "stop bits\n\nThese bits are used for programming the stop bits.\n\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "LINEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "LIN mode enable\n\nThis bit is set and cleared by software.\n\nThe LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.\n\nThis bitfield can only be written when the USART is disabled (UE=0).\n\nNote: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "SWAP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Swap TX/RX pins\n\nThis bit is set and cleared by software.\n\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "RXINV",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "RX pin active level inversion\n\nThis bit is set and cleared by software.\n\nThis enables the use of an external inverter on the RX line.\n\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "TXINV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TX pin active level inversion\n\nThis bit is set and cleared by software.\n\nThis enables the use of an external inverter on the TX line.\n\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "DATAINV",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Binary data inversion\n\nThis bit is set and cleared by software.\n\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "MSBFIRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Most significant bit first\n\nThis bit is set and cleared by software.\n\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "ABREN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Auto baud rate enable\n\nThis bit is set and cleared by software.\n\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "ABRMOD",
                "bitOffset": 21,
                "bitWidth": 2,
                "desc": "Auto baud rate mode\n\nThese bits are set and cleared by software.\n\nThis bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0).\n\nNote: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example 0xAA for MSBFIRST)\n\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "RTOEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Receiver timeout enable\n\nThis bit is set and cleared by software.\n\nWhen this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register).\n\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "ADD",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Address of the USART node\n\nThese bits give the address of the USART node in Mute mode or a character code to be recognized in low-power or Run mode:\n\nIn Mute mode: they are used in multiprocessor communication to wakeup from Mute mode with 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter should be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.\n\nIn low-power mode: they are used for wake up from low-power mode on character match.\n\nWhen a character, received during low-power mode, corresponds to the character programmed through ADD[7:0] bitfield, the CMF flag is set and wakes up the device from low-power mode if the corresponding interrupt is enabled by setting CMIE bit.\n\nIn Run mode with Mute mode inactive (for example, end-of-block detection in ModBus protocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF flag is set on match. An interrupt is generated if the CMIE bit is set.\n\nThese bits can only be written when the reception is disabled (RE = 0) or when the USART is disabled (UE = 0)."
            }
        ]
    },
    "1073821704": {
        "name": "USART_CR3",
        "address": 1073821704,
        "size": 32,
        "access": "read-write",
        "desc": "USART control register 3",
        "fields": [
            {
                "name": "EIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Error interrupt enable\n\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1or UDR = 1 in the USART_ISR register)."
            },
            {
                "name": "IREN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "IrDA mode enable\n\nThis bit is set and cleared by software.\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "IRLP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "IrDA low-power\n\nThis bit is used for selecting between normal and low-power IrDA modes\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "HDSEL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Half-duplex selection\n\nSelection of Single-wire Half-duplex mode\n\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "NACK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Smartcard NACK enable\n\nThis bitfield can only be written when the USART is disabled (UE=0).\n\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "SCEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Smartcard mode enable\n\nThis bit is used for enabling Smartcard mode.\n\nThis bitfield can only be written when the USART is disabled (UE=0).\n\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "DMAR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA enable receiver\n\nThis bit is set/reset by software"
            },
            {
                "name": "DMAT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA enable transmitter\n\nThis bit is set/reset by software"
            },
            {
                "name": "RTSE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "RTS enable\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "CTSE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS enable\n\nThis bit can only be written when the USART is disabled (UE=0)\n\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "CTSIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS interrupt enable\n\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "ONEBIT",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "One sample bit method enable\n\nThis bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.\n\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "OVRDIS",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun Disable\n\nThis bit is used to disable the receive overrun detection.\n\nthe ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data are written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used.\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: This control bit enables checking the communication flow w/o reading the data"
            },
            {
                "name": "DDRE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DMA Disable on Reception Error\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: The reception errors are: parity error, framing error or noise error."
            },
            {
                "name": "DEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Driver enable mode\n\nThis bit enables the user to activate the external transceiver control, through the DE signal.\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "DEP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Driver enable polarity selection\n\nThis bit can only be written when the USART is disabled (UE=0).\n\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "SCARCNT",
                "bitOffset": 17,
                "bitWidth": 3,
                "desc": "Smartcard auto-retry count\n\nThis bitfield specifies the number of retries for transmission and reception in Smartcard mode.\n\nIn Transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set).\n\nIn Reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set).\n\nThis bitfield must be programmed only when the USART is disabled (UE=0).\n\nWhen the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to stop retransmission.\n\n0x1 to 0x7: number of automatic retransmission attempts (before signaling error)\n\nNote: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "TXFTIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO threshold interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "TCBGTIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Transmission Complete before guard time, interrupt enable\n\nThis bit is set and cleared by software.\n\nNote: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "RXFTCFG",
                "bitOffset": 25,
                "bitWidth": 3,
                "desc": "Receive FIFO threshold configuration\n\nRemaining combinations: Reserved"
            },
            {
                "name": "RXFTIE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "RXFIFO threshold interrupt enable\n\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFTCFG",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "TXFIFO threshold configuration\n\nRemaining combinations: Reserved"
            }
        ]
    },
    "1073821708": {
        "name": "USART_BRR",
        "address": 1073821708,
        "size": 32,
        "access": "read-write",
        "desc": "USART baud rate register",
        "fields": [
            {
                "name": "BRR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "USART baud rate\n\nBRR[15:4]\n\nBRR[15:4] correspond to USARTDIV[15:4]\n\nBRR[3:0]\n\nWhen OVER8 = 0, BRR[3:0] = USARTDIV[3:0].\n\nWhen OVER8 = 1:\n\nBRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.\n\nBRR[3] must be kept cleared."
            }
        ]
    },
    "1073821712": {
        "name": "USART_GTPR",
        "address": 1073821712,
        "size": 32,
        "access": "read-write",
        "desc": "USART guard time and prescaler register",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Prescaler value\n\nPSC[7:0] = IrDA Normal and Low-power baud rate\n\nThis bitfield is used for programming the prescaler for dividing the USART source clock to achieve the low-power frequency:\n\nThe source clock is divided by the value given in the register (8 significant bits):\n\n...\n\nPSC[4:0]: Prescaler value\n\nThis bitfield is used for programming the prescaler for dividing the USART source clock to provide the Smartcard clock.\n\nThe value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency:\n\n...\n\nThis bitfield can only be written when the USART is disabled (UE=0).\n\nNote: Bits [7:5] must be kept cleared if Smartcard mode is used.\n\nNote: This bitfield is reserved and forced by hardware to 0 when the Smartcard and IrDA modes are not supported. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "GT",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "Guard time value\n\nThis bitfield is used to program the Guard time value in terms of number of baud clock periods.\n\nThis is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.\n\nThis bitfield can only be written when the USART is disabled (UE=0).\n\nNote: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            }
        ]
    },
    "1073821716": {
        "name": "USART_RTOR",
        "address": 1073821716,
        "size": 32,
        "access": "read-write",
        "desc": "USART receiver timeout register",
        "fields": [
            {
                "name": "RTO",
                "bitOffset": 0,
                "bitWidth": 24,
                "desc": "Receiver timeout value\n\nThis bitfield gives the Receiver timeout value in terms of number of bit duration.\n\nIn Standard mode, the RTOF flag is set if, after the last received character, no new start bit is detected for more than the RTO value.\n\nIn Smartcard mode, this value is used to implement the CWT and BWT. See Smartcard chapter for more details. In the standard, the CWT/BWT measurement is done starting from the start bit of the last received character.\n\nNote: This value must only be programmed once per received character."
            },
            {
                "name": "BLEN",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Block Length\n\nThis bitfield gives the Block length in Smartcard T=1 Reception. Its value equals the number of information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1.\n\nExamples:\n\nBLEN = 0 - 0 information characters + LEC\n\nBLEN = 1 - 0 information characters + CRC\n\nBLEN = 255 - 254 information characters + CRC (total 256 characters))\n\nIn Smartcard mode, the Block length counter is reset when TXE=0 (TXFE = 0 in case FIFO mode is enabled).\n\nThis bitfield can be used also in other modes. In this case, the Block length counter is reset when RE=0 (receiver disabled) and/or when the EOBCF bit is written to 1.\n\nNote: This value can be programmed after the start of the block reception (using the data from the LEN character in the Prologue Field). It must be programmed only once per received block."
            }
        ]
    },
    "1073821720": {
        "name": "USART_RQR",
        "address": 1073821720,
        "size": 32,
        "access": "write-only",
        "desc": "USART request register",
        "fields": [
            {
                "name": "ABRRQ",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Auto baud rate request\n\nWriting 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an automatic baud rate measurement on the next received data frame.\n\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "SBKRQ",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Send break request\n\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\n\nNote: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit."
            },
            {
                "name": "MMRQ",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Mute mode request\n\nWriting 1 to this bit puts the USART in Mute mode and resets the RWU flag."
            },
            {
                "name": "RXFRQ",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Receive data flush request\n\nWriting 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.\n\nThis enables to discard the received data without reading them, and avoid an overrun condition."
            },
            {
                "name": "TXFRQ",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Transmit data flush request\n\nWhen FIFO mode is disabled, writing 1 to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value.\n\nWhen FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes.\n\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register."
            }
        ]
    },
    "1073821724": {
        "name": "USART_ISR",
        "address": 1073821724,
        "size": 32,
        "access": "read-only",
        "desc": "USART interrupt and status register [alternate]",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error\n\nThis bit is set by hardware when a parity error occurs in Reception mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.\n\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\n\nNote: This error is associated with the character in the USART_RDR."
            },
            {
                "name": "FE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error\n\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\n\nWhen transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).\n\nAn interrupt is generated if EIE = 1 in the USART_CR1 register.\n\nNote: This error is associated with the character in the USART_RDR."
            },
            {
                "name": "NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detection flag\n\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NFCF bit in the USART_ICR register.\n\nNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.\n\nNote: When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Section 78.5.9: Tolerance of the USART receiver to clock deviation on page 4584).\n\nNote: This error is associated with the character in the USART_RDR."
            },
            {
                "name": "ORE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error\n\nThis bit is set by hardware when the data currently being received in the shift register is\n\nready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.\n\nAn interrupt is generated if RXFNEIE=1 or EIE = 1 in the USART_CR1 register.\n\nNote: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.\n\nNote: This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register."
            },
            {
                "name": "IDLE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected\n\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.\n\nNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).\n\nNote: If Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set."
            },
            {
                "name": "RXFNE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty\n\nRXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO.\n\nRXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.\n\nAn interrupt is generated if RXFNEIE=1 in the USART_CR1 register."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete\n\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register. The TC flag behaves as follows:\n\nWhen TDN = 0, the TC flag is set when the transmission of a frame containing data is complete and when TXE/TXFE is set.\n\nWhen TDN is equal to the number of data in the TXFIFO, the TC flag is set when TXFIFO is empty and TDN is reached.\n\nWhen TDN is greater than the number of data in the TXFIFO, TC remains cleared until the TXFIFO is filled again to reach the programmed number of data to be transferred.\n\nWhen TDN is less than the number of data in the TXFIFO, TC is set when TDN is reached even if the TXFIFO is not empty.\n\nAn interrupt is generated if TCIE=1 in the USART_CR1 register.\n\nTC bit is cleared by software by writing 1 to the TCCF in the USART_ICR register or by writing to the USART_TDR register."
            },
            {
                "name": "TXFNF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full\n\nTXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR.\n\nAn interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register.\n\nNote: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE is set at the same time).\n\nNote: This bit is used during single buffer transmission."
            },
            {
                "name": "LBDF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "LIN break detection flag\n\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.\n\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\n\nNote: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "CTSIF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS interrupt flag\n\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.\n\nAn interrupt is generated if CTSIE=1 in the USART_CR3 register.\n\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "CTS",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS flag\n\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\n\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "RTOF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver timeout\n\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.\n\nAn interrupt is generated if RTOIE=1 in the USART_CR2 register.\n\nIn Smartcard mode, the timeout corresponds to the CWT or BWT timings.\n\nNote: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.\n\nNote: The counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.\n\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "EOBF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "End of block flag\n\nThis bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.\n\nAn interrupt is generated if EOBIE = 1 in the USART_CR1 register.\n\nIt is cleared by software, writing 1 to EOBCF in the USART_ICR register.\n\nNote: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "UDR",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SPI slave underrun error flag\n\nIn Slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.\n\nNote: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "ABRE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Auto baud rate error\n\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)\n\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\n\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "ABRF",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Auto baud rate flag\n\nThis bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case)\n\nIt is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.\n\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "BUSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Busy flag\n\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not)."
            },
            {
                "name": "CMF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match flag\n\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.\n\nAn interrupt is generated if CMIE=1in the USART_CR1 register."
            },
            {
                "name": "SBKF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Send break flag\n\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission."
            },
            {
                "name": "RWU",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Receiver wakeup from Mute mode\n\nThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.\n\nWhen wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.\n\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "TEACK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Transmit enable acknowledge flag\n\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.\n\nIt can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period."
            },
            {
                "name": "REACK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Receive enable acknowledge flag\n\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.\n\nIt can be used to verify that the USART is ready for reception before entering low-power mode.\n\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "TXFE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO Empty\n\nThis bit is set by hardware when TXFIFO is Empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.\n\nAn interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register."
            },
            {
                "name": "RXFF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "RXFIFO Full\n\nThis bit is set by hardware when the number of received data corresponds to RXFIFO size + 1 (RXFIFO full + 1 data in the USART_RDR register.\n\nAn interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register."
            },
            {
                "name": "TCBGT",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmission complete before guard time flag\n\nThis bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.\n\nIt is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register.\n\nThis bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.\n\nNote: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is 1. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "RXFT",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "RXFIFO threshold flag\n\nThis bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the USART_CR3 register.\n\nNote: When the RXFTCFG threshold is configured to 101, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data."
            },
            {
                "name": "TXFT",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "TXFIFO threshold flag\n\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register."
            }
        ]
    },
    "1073821728": {
        "name": "USART_ICR",
        "address": 1073821728,
        "size": 32,
        "access": "write-only",
        "desc": "USART interrupt flag clear register",
        "fields": [
            {
                "name": "PECF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error clear flag\n\nWriting 1 to this bit clears the PE flag in the USART_ISR register."
            },
            {
                "name": "FECF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error clear flag\n\nWriting 1 to this bit clears the FE flag in the USART_ISR register."
            },
            {
                "name": "NECF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detected clear flag\n\nWriting 1 to this bit clears the NE flag in the USART_ISR register."
            },
            {
                "name": "ORECF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error clear flag\n\nWriting 1 to this bit clears the ORE flag in the USART_ISR register."
            },
            {
                "name": "IDLECF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected clear flag\n\nWriting 1 to this bit clears the IDLE flag in the USART_ISR register."
            },
            {
                "name": "TXFECF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TXFIFO empty clear flag\n\nWriting 1 to this bit clears the TXFE flag in the USART_ISR register."
            },
            {
                "name": "TCCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete clear flag\n\nWriting 1 to this bit clears the TC flag in the USART_ISR register."
            },
            {
                "name": "TCBGTCF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transmission complete before Guard time clear flag\n\nWriting 1 to this bit clears the TCBGT flag in the USART_ISR register."
            },
            {
                "name": "LBDCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "LIN break detection clear flag\n\nWriting 1 to this bit clears the LBDF flag in the USART_ISR register.\n\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "CTSCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS clear flag\n\nWriting 1 to this bit clears the CTSIF flag in the USART_ISR register.\n\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "RTOCF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver timeout clear flag\n\nWriting 1 to this bit clears the RTOF flag in the USART_ISR register.\n\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "EOBCF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "End of block clear flag\n\nWriting 1 to this bit clears the EOBF flag in the USART_ISR register.\n\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565."
            },
            {
                "name": "UDRCF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SPI slave underrun clear flag\n\nWriting 1 to this bit clears the UDRF flag in the USART_ISR register.\n\nNote: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to Section 78.4: USART implementation on page 4565"
            },
            {
                "name": "CMCF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match clear flag\n\nWriting 1 to this bit clears the CMF flag in the USART_ISR register."
            }
        ]
    },
    "1073821732": {
        "name": "USART_RDR",
        "address": 1073821732,
        "size": 32,
        "access": "read-only",
        "desc": "USART receive data register",
        "fields": [
            {
                "name": "RDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Receive data value\n\nContains the received data character.\n\nThe RDR register provides the parallel interface between the input shift register and the internal bus (see Figure 927).\n\nWhen receiving with the parity enabled, the value read in the MSB bit is the received parity bit."
            }
        ]
    },
    "1073821736": {
        "name": "USART_TDR",
        "address": 1073821736,
        "size": 32,
        "access": "read-write",
        "desc": "USART transmit data register",
        "fields": [
            {
                "name": "TDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Transmit data value\n\nContains the data character to be transmitted.\n\nThe USART_TDR register provides the parallel interface between the internal bus and the output shift register (see Figure 927).\n\nWhen transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.\n\nNote: This register must be written only when TXE/TXFNF=1."
            }
        ]
    },
    "1073821740": {
        "name": "USART_PRESC",
        "address": 1073821740,
        "size": 32,
        "access": "read-write",
        "desc": "USART prescaler register",
        "fields": [
            {
                "name": "PRESCALER",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Clock prescaler\n\nThe USART input clock can be divided by a prescaler factor:\n\nRemaining combinations: Reserved\n\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is equal to 1011 i.e. input clock divided by 256."
            }
        ]
    },
    "1073821744": {
        "name": "USART_AUTOCR",
        "address": 1073821744,
        "size": 32,
        "access": "read-write",
        "desc": "USART Autonomous mode control register",
        "fields": [
            {
                "name": "TDN",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "TDN transmission data number\n\nThis bitfield enables the programming of the number of data to be transmitted. It can be written only when UE is cleared in USART_CR1."
            },
            {
                "name": "TRIGPOL",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Trigger polarity bit\n\nThis bitfield can be written only when the UE bit is cleared in USART_CR1 register."
            },
            {
                "name": "TRIGEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Trigger enable bit\n\nNote: This bitfield can be written only when the UE bit of USART_CR1 register is cleared.\n\nNote: When a trigger is detected, TE is set to 1 in USART_CR1 and the data transfer is launched."
            },
            {
                "name": "IDLEDIS",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Idle frame transmission disable bit after enabling the transmitter\n\nNote: This bitfield can be written only when the UE bit of USART_CR1 register is cleared."
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 19,
                "bitWidth": 4,
                "desc": "Trigger selection bits\n\nRefer to Description of USART interconnections.\n\nThis bitfield can be written only when the UE bit is cleared in USART_CR1 register.\n\n...\n\nNote: This bitfield can be written only when the UE bit of USART_CR1 register is cleared."
            }
        ]
    },
    "1073753088": {
        "name": "WWDG_CR",
        "address": 1073753088,
        "size": 32,
        "access": "",
        "desc": "WWDG control register",
        "fields": [
            {
                "name": "T",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "7-bit counter (MSB to LSB)\nThese bits contain the value of the watchdog counter, decremented every\n(4096 x 2supWDGTB[2:0]/sup) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared)."
            },
            {
                "name": "WDGA",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Activation bit\nThis bit is set by software and only cleared by hardware after a reset. When WDGA = 1, the watchdog can generate a reset."
            }
        ]
    },
    "1073753092": {
        "name": "WWDG_CFR",
        "address": 1073753092,
        "size": 32,
        "access": "",
        "desc": "WWDG configuration register",
        "fields": [
            {
                "name": "W",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "7-bit window value\nThese bits contain the window value to be compared with the down-counter."
            },
            {
                "name": "EWI",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Early wakeup interrupt\nWhen set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset."
            },
            {
                "name": "WDGTB",
                "bitOffset": 11,
                "bitWidth": 3,
                "desc": "Timer base\nThe timebase of the prescaler can be modified as follows:"
            }
        ]
    },
    "1073753096": {
        "name": "WWDG_SR",
        "address": 1073753096,
        "size": 32,
        "access": "",
        "desc": "WWDG status register",
        "fields": [
            {
                "name": "EWIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Early wakeup interrupt flag\nThis bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. Writing 1 has no effect. This bit is also set if the interrupt is not enabled."
            }
        ]
    }
}