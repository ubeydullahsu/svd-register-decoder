{
    "1073897472": {
        "name": "AES_CR",
        "address": 1073897472,
        "size": 32,
        "access": "",
        "desc": "AES control register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "AES enable\nThis bit enables/disables the AES peripheral:\nAt any moment, clearing then setting the bit re-initializes the AES peripheral.\nThis bit is automatically cleared by hardware upon the completion of the key preparation (Mode 2) and upon the completion of GCM/GMAC/CCM initial phase."
            },
            {
                "name": "DATATYPE",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Data type selection\nThis bitfield defines the format of data written in the AES_DINR register or read from the AES_DOUTR register, through selecting the mode of data swapping:\nFor more details, refer to .\nAttempts to write the bitfield are ignored when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "MODE",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "AES operating mode\nThis bitfield selects the AES operating mode:\nAttempts to write the bitfield are ignored when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access. Any attempt to selecting Mode 4 while either ECB or CBC chaining mode is not selected, defaults to effective selection of Mode 3. It is not possible to select a Mode 3 following a Mode 4."
            },
            {
                "name": "CHMOD1",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Chaining mode selection, bit [2]\nRefer to the bits [5:6] of the register for the description of the CHMOD[2:0] bitfield\nCHMOD[1:0]: Chaining mode selection, bits [1:0]\nThis bitfield, together with the bit CHMOD[2] forming CHMOD[2:0], selects the AES chaining mode:\nothers: Reserved\nAttempts to write the bitfield are ignored when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "CCFC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Computation complete flag clear\nUpon written to 1, this bit clears the computation complete flag (CCF) in the AES_SR register:\nReading the flag always returns zero."
            },
            {
                "name": "ERRC",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Error flag clear\nUpon written to 1, this bit clears the RDERR and WRERR error flags in the AES_SR register:\nReading the flag always returns zero."
            },
            {
                "name": "CCFIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CCF interrupt enable\nThis bit enables or disables (masks) the AES interrupt generation when CCF (computation complete flag) is set:"
            },
            {
                "name": "ERRIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Error interrupt enable\nThis bit enables or disables (masks) the AES interrupt generation when RDERR and/or WRERR is set:"
            },
            {
                "name": "DMAINEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "DMA input enable\nThis bit enables/disables data transferring with DMA, in the input phase:\nWhen the bit is set, DMA requests are automatically generated by AES during the input data phase. This feature is only effective when Mode 1 or Mode 3 is selected through the MODE[1:0] bitfield. It is not effective for Mode 2 (key derivation).\nUsage of DMA with Mode 4 (single decryption) is not recommended."
            },
            {
                "name": "DMAOUTEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "DMA output enable\nThis bit enables/disables data transferring with DMA, in the output phase:\nWhen the bit is set, DMA requests are automatically generated by AES during the output data phase. This feature is only effective when Mode 1 or Mode 3 is selected through the MODE[1:0] bitfield. It is not effective for Mode 2 (key derivation).\nUsage of DMA with Mode 4 (single decryption) is not recommended."
            },
            {
                "name": "GCMPH",
                "bitOffset": 13,
                "bitWidth": 2,
                "desc": "GCM or CCM phase selection\nThis bitfield selects the phase of GCM, GMAC or CCM algorithm:\nThe bitfield has no effect if other than GCM, GMAC or CCM algorithms are selected (through the ALGOMODE bitfield)."
            },
            {
                "name": "CHMOD2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Chaining mode selection, bit [2]\nRefer to the bits [5:6] of the register for the description of the CHMOD[2:0] bitfield\nCHMOD[1:0]: Chaining mode selection, bits [1:0]\nThis bitfield, together with the bit CHMOD[2] forming CHMOD[2:0], selects the AES chaining mode:\nothers: Reserved\nAttempts to write the bitfield are ignored when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "KEYSIZE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Key size selection\nThis bitfield defines the length of the key used in the AES cryptographic core, in bits:\nAttempts to write the bit are ignored when the EN bit of the AES_CR register is set before the write access and it is not cleared by that write access."
            },
            {
                "name": "NPBLB",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Number of padding bytes in last block\nThe bitfield sets the number of padding bytes in last block of payload:\n..."
            }
        ]
    },
    "1073897476": {
        "name": "AES_SR",
        "address": 1073897476,
        "size": 32,
        "access": "",
        "desc": "AES status register",
        "fields": [
            {
                "name": "CCF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Computation completed flag\nThis flag indicates whether the computation is completed:\nThe flag is set by hardware upon the completion of the computation. It is cleared by software, upon setting the CCFC bit of the AES_CR register.\nUpon the flag setting, an interrupt is generated if enabled through the CCFIE bit of the AES_CR register.\nThe flag is significant only when the DMAOUTEN bit is 0. It may stay high when DMA_EN is 1."
            },
            {
                "name": "RDERR",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Read error flag\nThis flag indicates the detection of an unexpected read operation from the AES_DOUTR register (during computation or data input phase):\nThe flag is set by hardware. It is cleared by software upon setting the ERRC bit of the AES_CR register.\nUpon the flag setting, an interrupt is generated if enabled through the ERRIE bit of the AES_CR register.\nThe flag setting has no impact on the AES operation. Unexpected read returns zero."
            },
            {
                "name": "WRERR",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Write error\nThis flag indicates the detection of an unexpected write operation to the AES_DINR register (during computation or data output phase):\nThe flag is set by hardware. It is cleared by software upon setting the ERRC bit of the AES_CR register.\nUpon the flag setting, an interrupt is generated if enabled through the ERRIE bit of the AES_CR register.\nThe flag setting has no impact on the AES operation. Unexpected write is ignored."
            },
            {
                "name": "BUSY",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Busy"
            }
        ]
    },
    "1073897480": {
        "name": "AES_DINR",
        "address": 1073897480,
        "size": 32,
        "access": "",
        "desc": "AES data input register ",
        "fields": [
            {
                "name": "DIN",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Input data word\nA four-fold sequential write to this bitfield during the input phase results in writing a complete 128-bit block of input data to the AES peripheral. From the first to the fourth write, the corresponding data weights are [127:96], [95:64], [63:32], and [31:0]. Upon each write, the data from the 32-bit input buffer are handled by the data swap block according to the DATATYPE[1:0] bitfield, then written into the AES core 128-bit input buffer.\nThe data signification of the input data block depends on the AES operating mode:\n- Mode 1 (encryption): plaintext\n- Mode 2 (key derivation): the bitfield is not used (AES_KEYRx registers used for input)\n- Mode 3 (decryption) and Mode 4 (key derivation then single decryption): ciphertext\nThe data swap operation is described in page499."
            }
        ]
    },
    "1073897484": {
        "name": "AES_DOUTR",
        "address": 1073897484,
        "size": 32,
        "access": "",
        "desc": "AES data output register ",
        "fields": [
            {
                "name": "DOUT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Output data word\nThis read-only bitfield fetches a 32-bit output buffer. A four-fold sequential read of this bitfield, upon the computation completion (CCF set), virtually reads a complete 128-bit block of output data from the AES peripheral. Before reaching the output buffer, the data produced by the AES core are handled by the data swap block according to the DATATYPE[1:0] bitfield.\nData weights from the first to the fourth read operation are: [127:96], [95:64], [63:32], and [31:0].\nThe data signification of the output data block depends on the AES operating mode:\n- Mode 1 (encryption): ciphertext\n- Mode 2 (key derivation): the bitfield is not used (AES_KEYRx registers used for output)\n- Mode 3 (decryption) and Mode 4 (key derivation then single decryption): plaintext\nThe data swap operation is described in page499."
            }
        ]
    },
    "1073897488": {
        "name": "AES_KEYR0",
        "address": 1073897488,
        "size": 32,
        "access": "",
        "desc": "AES key register 0",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [31:0]\nThis bitfield contains the bits [31:0] of the AES encryption or decryption key, depending on the operating mode:\n- In Mode 1 (encryption), Mode 2 (key derivation) and Mode 4 (key derivation then single decryption): the value to write into the bitfield is the encryption key.\n- In Mode 3 (decryption): the value to write into the bitfield is the encryption key to be derived before being used for decryption. After writing the encryption key into the bitfield, its reading before enabling AES returns the same value. Its reading after enabling AES and after the CCF flag is set returns the decryption key derived from the encryption key.\nNote: In mode 4 (key derivation then single decryption) the bitfield always contains the encryption key.\nThe AES_KEYRx registers may be written only when KEYSIZE value is correct and when the AES peripheral is disabled (EN bit of the AES_CR register cleared).  Note that, if, the key is directly loaded to AES_KEYRx registers (hence writes to key register is ignored and KEIF is set).\nRefer to  for more details."
            }
        ]
    },
    "1073897492": {
        "name": "AES_KEYR1",
        "address": 1073897492,
        "size": 32,
        "access": "",
        "desc": "AES key register 1",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [63:32]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield."
            }
        ]
    },
    "1073897496": {
        "name": "AES_KEYR2",
        "address": 1073897496,
        "size": 32,
        "access": "",
        "desc": "AES key register 2",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [95:64]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield."
            }
        ]
    },
    "1073897500": {
        "name": "AES_KEYR3",
        "address": 1073897500,
        "size": 32,
        "access": "",
        "desc": "AES key register 3",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [127:96]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield."
            }
        ]
    },
    "1073897504": {
        "name": "AES_IVR0",
        "address": 1073897504,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 0",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [31:0]\nRefer to  for description of the IVI[127:0] bitfield.\nThe initialization vector is only used in chaining modes other than ECB.\nThe AES_IVRx registers may be written only when the AES peripheral is disabled"
            }
        ]
    },
    "1073897508": {
        "name": "AES_IVR1",
        "address": 1073897508,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 1",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [63:32]\nRefer to the AES_IVR0 register for description of the IVI[128:0] bitfield."
            }
        ]
    },
    "1073897512": {
        "name": "AES_IVR2",
        "address": 1073897512,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 2",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [95:64]\nRefer to the AES_IVR0 register for description of the IVI[128:0] bitfield."
            }
        ]
    },
    "1073897516": {
        "name": "AES_IVR3",
        "address": 1073897516,
        "size": 32,
        "access": "",
        "desc": "AES initialization vector register 3",
        "fields": [
            {
                "name": "IVI",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Initialization vector input, bits [127:96]\nRefer to the AES_IVR0 register for description of the IVI[128:0] bitfield."
            }
        ]
    },
    "1073897520": {
        "name": "AES_KEYR4",
        "address": 1073897520,
        "size": 32,
        "access": "",
        "desc": "AES key register 4",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [159:128]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield."
            }
        ]
    },
    "1073897524": {
        "name": "AES_KEYR5",
        "address": 1073897524,
        "size": 32,
        "access": "",
        "desc": "AES key register 5",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [191:160]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield."
            }
        ]
    },
    "1073897528": {
        "name": "AES_KEYR6",
        "address": 1073897528,
        "size": 32,
        "access": "",
        "desc": "AES key register 6",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [223:192]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield."
            }
        ]
    },
    "1073897532": {
        "name": "AES_KEYR7",
        "address": 1073897532,
        "size": 32,
        "access": "",
        "desc": "AES key register 7",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Cryptographic key, bits [255:224]\nRefer to the AES_KEYR0 register for description of the KEY[255:0] bitfield."
            }
        ]
    },
    "1073897536": {
        "name": "AES_SUSP0R",
        "address": 1073897536,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers ",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "AES suspend\nUpon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers."
            }
        ]
    },
    "1073897540": {
        "name": "AES_SUSP1R",
        "address": 1073897540,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers ",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "AES suspend\nUpon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers."
            }
        ]
    },
    "1073897544": {
        "name": "AES_SUSP2R",
        "address": 1073897544,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers ",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "AES suspend\nUpon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers."
            }
        ]
    },
    "1073897548": {
        "name": "AES_SUSP3R",
        "address": 1073897548,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers ",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "AES suspend\nUpon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers."
            }
        ]
    },
    "1073897552": {
        "name": "AES_SUSP4R",
        "address": 1073897552,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers ",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "AES suspend\nUpon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers."
            }
        ]
    },
    "1073897556": {
        "name": "AES_SUSP5R",
        "address": 1073897556,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers ",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "AES suspend\nUpon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers."
            }
        ]
    },
    "1073897560": {
        "name": "AES_SUSP6R",
        "address": 1073897560,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers ",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "AES suspend\nUpon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers."
            }
        ]
    },
    "1073897564": {
        "name": "AES_SUSP7R",
        "address": 1073897564,
        "size": 32,
        "access": "",
        "desc": "AES suspend registers ",
        "fields": [
            {
                "name": "SUSP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "AES suspend\nUpon suspend operation, this bitfield of every AES_SUSPxR register takes the value of one of internal AES registers."
            }
        ]
    },
    "1073816576": {
        "name": "ADC_ISR",
        "address": 1073816576,
        "size": 32,
        "access": "",
        "desc": "ADC interrupt and status register ",
        "fields": [
            {
                "name": "ADRDY",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC ready\nThis bit is set by hardware after the ADC has been enabled (ADEN=1) and when the ADC reaches a state where it is ready to accept conversion requests.\nIt is cleared by software writing 1 to it."
            },
            {
                "name": "EOSMP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "End of sampling flag\nThis bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to '1'."
            },
            {
                "name": "EOC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "End of conversion flag\nThis bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register."
            },
            {
                "name": "EOS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "End of sequence flag\nThis bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it."
            },
            {
                "name": "OVR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "ADC overrun\nThis bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it."
            },
            {
                "name": "AWD1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog 1 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1."
            },
            {
                "name": "AWD2",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog 2 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it."
            },
            {
                "name": "AWD3",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog 3 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1."
            },
            {
                "name": "EOCAL",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "End Of Calibration flag\nThis bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it."
            },
            {
                "name": "CCRDY",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Channel Configuration Ready flag\nThis flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it.\nNote: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration."
            }
        ]
    },
    "1073816580": {
        "name": "ADC_IER",
        "address": 1073816580,
        "size": 32,
        "access": "",
        "desc": "ADC interrupt enable register ",
        "fields": [
            {
                "name": "ADRDYIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC ready interrupt enable\nThis bit is set and cleared by software to enable/disable the ADC Ready interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOSMPIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "End of sampling flag interrupt enable\nThis bit is set and cleared by software to enable/disable the end of the sampling phase interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOCIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "End of conversion interrupt enable\nThis bit is set and cleared by software to enable/disable the end of conversion interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOSIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "End of conversion sequence interrupt enable\nThis bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "OVRIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Overrun interrupt enable\nThis bit is set and cleared by software to enable/disable the overrun interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD1IE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog 1 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2IE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog 2 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3IE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog 3 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EOCALIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "End of calibration interrupt enable\nThis bit is set and cleared by software to enable/disable the end of calibration interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "CCRDYIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Channel Configuration Ready Interrupt enable\nThis bit is set and cleared by software to enable/disable the channel configuration ready interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            }
        ]
    },
    "1073816584": {
        "name": "ADC_CR",
        "address": 1073816584,
        "size": 32,
        "access": "",
        "desc": "ADC control register ",
        "fields": [
            {
                "name": "ADEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC enable command\nThis bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set.\nIt is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.\nNote: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL=0, ADSTP=0, ADSTART=0, ADDIS=0 and ADEN=0)"
            },
            {
                "name": "ADDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "ADC disable command\nThis bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state).\nIt is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time).\nNote: Setting ADDIS to '1' is only effective when ADEN=1 and ADSTART=0 (which ensures that no conversion is ongoing)"
            },
            {
                "name": "ADSTART",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "ADC start conversion command\nThis bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware trigger configuration).\nIt is cleared by hardware:\nIn single conversion mode (CONT=0, DISCEN=0), when software trigger is selected (EXTEN=00): at the assertion of the end of Conversion Sequence (EOS) flag.\nIn discontinuous conversion mode(CONT=0, DISCEN=1), when the software trigger is selected (EXTEN=00): at the assertion of the end of Conversion (EOC) flag.\nIn all other cases: after the execution of the ADSTP command, at the same time as the ADSTP bit is cleared by hardware.\nNote: The software is allowed to set ADSTART only when ADEN=1 and ADDIS=0 (ADC is enabled and there is no pending request to disable the ADC).\nAfter writing to ADC_CHSELR register or changing CHSELRMOD or SCANDIRW, it is mandatory to wait until CCRDY flag is asserted before setting ADSTART, otherwise, the value written to ADSTART is ignored."
            },
            {
                "name": "ADSTP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "ADC stop conversion command\nThis bit is set by software to stop and discard an ongoing conversion (ADSTP Command).\nIt is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command.\nNote: Setting ADSTP to '1' is only effective when ADSTART=1 and ADDIS=0 (ADC is enabled and may be converting and there is no pending request to disable the ADC)"
            },
            {
                "name": "ADVREGEN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "ADC Voltage Regulator Enable\nThis bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tADCVREG_SETUP.\nIt is cleared by software to disable the voltage regulator. It can be cleared only if ADEN is et to 0.\nNote: The software is allowed to program this bit field only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0)."
            },
            {
                "name": "ADCAL",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "ADC calibration\nThis bit is set by software to start the calibration of the ADC.\nIt is cleared by hardware after calibration is complete.\nNote: The software is allowed to set ADCAL only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\nThe software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN=1 and ADSTART=0 (ADC enabled and no conversion is ongoing)."
            }
        ]
    },
    "1073816588": {
        "name": "ADC_CFGR1",
        "address": 1073816588,
        "size": 32,
        "access": "",
        "desc": "ADC configuration register 1 ",
        "fields": [
            {
                "name": "DMAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Direct memory access enable\nThis bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to .\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "DMACFG",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Direct memory access configuration\nThis bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN=1.\nFor more details, refer to page403\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "SCANDIR",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Scan sequence direction\nThis bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared to 0.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "RES",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Data resolution\nThese bits are written by software to select the resolution of the conversion.\nNote: The software is allowed to write these bits only when ADEN=0."
            },
            {
                "name": "ALIGN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Data alignment\nThis bit is set and cleared by software to select right or left alignment. Refer to Data alignment and resolution (oversampling disabled: OVSE = 0) on page401\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EXTSEL",
                "bitOffset": 6,
                "bitWidth": 3,
                "desc": "External trigger selection\nThese bits select the external event used to trigger the start of conversion (refer to External triggers for details):\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "EXTEN",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "External trigger enable and polarity selection\nThese bits are set and cleared by software to select the external trigger polarity and enable the trigger.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "OVRMOD",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun management mode\nThis bit is set and cleared by software and configure the way data overruns are managed.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "CONT",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Single / continuous conversion mode\nThis bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared.\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN=1 and CONT=1.\nThe software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "WAIT",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Wait conversion mode\nThis bit is set and cleared by software to enable/disable wait conversion mode..\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AUTOFF",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Auto-off mode\nThis bit is set and cleared by software to enable/disable auto-off mode..\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "DISCEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Discontinuous mode\nThis bit is set and cleared by software to enable/disable discontinuous mode.\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN=1 and CONT=1.\nThe software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "CHSELRMOD",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Mode selection of the ADC_CHSELR register\nThis bit is set and cleared by software to control the ADC_CHSELR feature:\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "AWD1SGL",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Enable the watchdog on a single channel or on all channels\nThis bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD1EN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Analog watchdog enable\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD1CH",
                "bitOffset": 26,
                "bitWidth": 5,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.\n.....\nOthers: Reserved\nNote: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR register.\nThe software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            }
        ]
    },
    "1073816592": {
        "name": "ADC_CFGR2",
        "address": 1073816592,
        "size": 32,
        "access": "",
        "desc": "ADC configuration register 2 ",
        "fields": [
            {
                "name": "OVSE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Oversampler Enable\nThis bit is set and cleared by software.\nNote: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "OVSR",
                "bitOffset": 2,
                "bitWidth": 3,
                "desc": "Oversampling ratio\nThis bit filed defines the number of oversampling ratio.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "OVSS",
                "bitOffset": 5,
                "bitWidth": 4,
                "desc": "Oversampling shift\nThis bit is set and cleared by software.\nOthers: Reserved\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "TOVS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Triggered Oversampling\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "LFTRIG",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Low frequency trigger mode enable\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing)."
            },
            {
                "name": "CKMODE",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "ADC clock mode\nThese bits are set and cleared by software to define how the analog ADC is clocked:\nIn all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion.\nNote: The software is allowed to write these bits only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0)."
            }
        ]
    },
    "1073816596": {
        "name": "ADC_SMPR",
        "address": 1073816596,
        "size": 32,
        "access": "",
        "desc": "ADC sampling time register ",
        "fields": [
            {
                "name": "SMP1",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Sampling time selection 1\nThese bits are written by software to select the sampling time that applies to all channels.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMP2",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Sampling time selection 2\nThese bits are written by software to select the sampling time that applies to all channels.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL0",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL1",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL2",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL3",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL4",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL5",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL6",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL7",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL8",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL9",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL10",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL11",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL12",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL13",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL14",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL15",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL16",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL17",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "SMPSEL18",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1073816608": {
        "name": "ADC_AWD1TR",
        "address": 1073816608,
        "size": 32,
        "access": "",
        "desc": "ADC watchdog threshold register ",
        "fields": [
            {
                "name": "LT1",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Analog watchdog 1 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page407."
            },
            {
                "name": "HT1",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Analog watchdog 1 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page407."
            }
        ]
    },
    "1073816612": {
        "name": "ADC_AWD2TR",
        "address": 1073816612,
        "size": 32,
        "access": "",
        "desc": "ADC watchdog threshold register ",
        "fields": [
            {
                "name": "LT2",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Analog watchdog 2 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page407."
            },
            {
                "name": "HT2",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Analog watchdog 2 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page407."
            }
        ]
    },
    "1073816616": {
        "name": "ADC_CHSELR",
        "address": 1073816616,
        "size": 32,
        "access": "",
        "desc": "ADC channel selection register [alternate] ",
        "fields": [
            {
                "name": "CHSEL0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            },
            {
                "name": "CHSEL18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).\nIf CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored."
            }
        ]
    },
    "1073816620": {
        "name": "ADC_AWD3TR",
        "address": 1073816620,
        "size": 32,
        "access": "",
        "desc": "ADC watchdog threshold register ",
        "fields": [
            {
                "name": "LT3",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Analog watchdog 3lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page407."
            },
            {
                "name": "HT3",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Analog watchdog 3 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page407."
            }
        ]
    },
    "1073816640": {
        "name": "ADC_DR",
        "address": 1073816640,
        "size": 32,
        "access": "",
        "desc": "ADC data register ",
        "fields": [
            {
                "name": "DATA",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Converted data\nThese bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in OVSE = 0) on page401.\nJust after a calibration is complete, DATA[6:0] contains the calibration factor."
            }
        ]
    },
    "1073816736": {
        "name": "ADC_AWD2CR",
        "address": 1073816736,
        "size": 32,
        "access": "",
        "desc": "ADC Analog Watchdog 2 Configuration register ",
        "fields": [
            {
                "name": "AWD2CH0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD2CH18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1073816740": {
        "name": "ADC_AWD3CR",
        "address": 1073816740,
        "size": 32,
        "access": "",
        "desc": "ADC Analog Watchdog 3 Configuration register ",
        "fields": [
            {
                "name": "AWD3CH0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "AWD3CH18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            }
        ]
    },
    "1073816756": {
        "name": "ADC_CALFACT",
        "address": 1073816756,
        "size": 32,
        "access": "",
        "desc": "ADC Calibration factor ",
        "fields": [
            {
                "name": "CALFACT",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Calibration factor\nThese bits are written by hardware or by software.\nOnce a calibration is complete,they are updated by hardware with the calibration factors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different from the current one stored into the analog ADC, it is then applied once a new calibration is launched.\nJust after a calibration is complete, DATA[6:0] contains the calibration factor.\nNote: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing). Refer to SQ8[3:0] for a definition of channel selection."
            }
        ]
    },
    "1073817352": {
        "name": "ADC_CCR",
        "address": 1073817352,
        "size": 32,
        "access": "",
        "desc": "ADC common configuration register ",
        "fields": [
            {
                "name": "PRESC",
                "bitOffset": 18,
                "bitWidth": 4,
                "desc": "ADC prescaler\nSet and cleared by software to select the frequency of the clock to the ADC.\nOther: Reserved\nNote: Software is allowed to write these bits only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0)."
            },
            {
                "name": "VREFEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "VREFINT enable\nThis bit is set and cleared by software to enable/disable the VREFINT.\nNote: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "TSEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Temperature sensor enable\nThis bit is set and cleared by software to enable/disable the temperature sensor.\nNote: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)."
            },
            {
                "name": "VBATEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "VBAT enable\nThis bit is set and cleared by software to enable/disable the VBAT channel.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)"
            }
        ]
    },
    "1073807872": {
        "name": "COMP1_CSR",
        "address": 1073807872,
        "size": 32,
        "access": "",
        "desc": "Comparator 1 control and status register ",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Comparator 1 enable bit\nThis bit is controlled by software (if not locked). It enables the comparator 1:"
            },
            {
                "name": "INMSEL",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Comparator 1 signal selector for inverting input INM\nThis bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP1_INM of the comparator 1:\n> 1000: 1/4 VREFINT"
            },
            {
                "name": "INPSEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Comparator 1 signal selector for non-inverting input\nThis bitfield is controlled by software (if not locked). It selects the signal for the non-inverting input COMP1_INP of the comparator 1 (also see the WINMODE bit):"
            },
            {
                "name": "WINMODE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Comparator 1 non-inverting input selector for window mode\nThis bit is controlled by software (if not locked). It selects the signal for COMP1_INP input of the comparator 1:"
            },
            {
                "name": "WINOUT",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Comparator 1 output selector\nThis bit is controlled by software (if not locked). It selects the comparator 1 output:"
            },
            {
                "name": "POLARITY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Comparator 1 polarity selector\nThis bit is controlled by software (if not locked). It selects the comparator 1 output polarity:"
            },
            {
                "name": "HYST",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Comparator 1 hysteresis selector\nThis bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 1:"
            },
            {
                "name": "PWRMODE",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Comparator 1 power mode selector\nThis bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 1:\nothers: Reserved"
            },
            {
                "name": "BLANKSEL",
                "bitOffset": 20,
                "bitWidth": 5,
                "desc": "Comparator 1 blanking source selector\nThis bitfield is controlled by software (if not locked). It selects the blanking source:\nxxxx1: TIM1 OC4\nxxx1x: TIM1 OC5\nxx1xx: TIM2 OC3\nx1xxx: TIM3 OC3\n1xxxx: TIM15 OC2"
            },
            {
                "name": "VALUE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Comparator 1 output status\nThis bit is read-only. It reflects the level of the comparator 1 output after the polarity selector and blanking, as indicated in ."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "COMP1_CSR register lock\nThis bit is set by software and cleared by a system reset. It locks the whole content of the comparator 1 control register COMP1_CSR[31:0]:"
            }
        ]
    },
    "1073807876": {
        "name": "COMP2_CSR",
        "address": 1073807876,
        "size": 32,
        "access": "",
        "desc": "Comparator 2 control and status register ",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Comparator 2 enable bit\nThis bit is controlled by software (if not locked). It enables the comparator 2:"
            },
            {
                "name": "INMSEL",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Comparator 2 signal selector for inverting input INM\nThis bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP2_INM of the comparator 2:\n> 1000: 1/4 VREFINT"
            },
            {
                "name": "INPSEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Comparator 2 signal selector for non-inverting input\nThis bitfield is controlled by software (if not locked). It selects the signal for the non-inverting input COMP2_INP of the comparator 2 (also see the WINMODE bit):"
            },
            {
                "name": "WINMODE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Comparator 2 non-inverting input selector for window mode\nThis bit is controlled by software (if not locked). It selects the signal for COMP2_INP input of the comparator 2:"
            },
            {
                "name": "WINOUT",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Comparator 2 output selector\nThis bit is controlled by software (if not locked). It selects the comparator 2 output:"
            },
            {
                "name": "POLARITY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Comparator 2 polarity selector\nThis bit is controlled by software (if not locked). It selects the comparator 2 output polarity:"
            },
            {
                "name": "HYST",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Comparator 2 hysteresis selector\nThis bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 2:"
            },
            {
                "name": "PWRMODE",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Comparator 2 power mode selector\nThis bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 2:\nothers: Reserved"
            },
            {
                "name": "BLANKSEL",
                "bitOffset": 20,
                "bitWidth": 5,
                "desc": "Comparator 2 blanking source selector\nThis bitfield is controlled by software (if not locked). It selects the blanking source:\nxxxx1: TIM1 OC4\nxxx1x: TIM1 OC5\nxx1xx: TIM2 OC3\nx1xxx: TIM3 OC3\n1xxxx: TIM15 OC2"
            },
            {
                "name": "VALUE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Comparator 2 output status\nThis bit is read-only. It reflects the level of the comparator 2 output after the polarity selector and blanking, as indicated in ."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "COMP2_CSR register lock\nThis bit is set by software and cleared by a system reset. It locks the whole content of the comparator 2 control register COMP2_CSR[31:0]:"
            }
        ]
    },
    "1073807880": {
        "name": "COMP3_CSR",
        "address": 1073807880,
        "size": 32,
        "access": "",
        "desc": "Comparator 2 control and status register ",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Comparator 3 enable bit\nThis bit is controlled by software (if not locked). It enables the comparator 3:"
            },
            {
                "name": "INMSEL",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Comparator 3 signal selector for inverting input INM\nThis bitfield is controlled by software (if not locked). It selects the signal for the inverting input COMP3_INM of the comparator 3:\n> 1000: 1/4 VREFINT"
            },
            {
                "name": "INPSEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Comparator 3 signal selector for non-inverting input\nThis bitfield is controlled by software (if not locked). It selects the signal for the non-inverting input COMP3_INP of the comparator 3 (also see the WINMODE bit):"
            },
            {
                "name": "WINMODE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Comparator 3 non-inverting input selector for window mode\nThis bit is controlled by software (if not locked). It selects the signal for COMP3_INP input of the comparator 3:"
            },
            {
                "name": "WINOUT",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Comparator 3 output selector\nThis bit is controlled by software (if not locked). It selects the comparator 3 output:"
            },
            {
                "name": "POLARITY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Comparator 2 polarity selector\nThis bit is controlled by software (if not locked). It selects the comparator 3 output polarity:"
            },
            {
                "name": "HYST",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Comparator 3 hysteresis selector\nThis bitfield is controlled by software (if not locked). It selects the hysteresis of the comparator 3:"
            },
            {
                "name": "PWRMODE",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Comparator 3 power mode selector\nThis bitfield is controlled by software (if not locked). It selects the power consumption and as a consequence the speed of the comparator 3:\nothers: Reserved"
            },
            {
                "name": "BLANKSEL",
                "bitOffset": 20,
                "bitWidth": 5,
                "desc": "Comparator 3 blanking source selector\nThis bitfield is controlled by software (if not locked). It selects the blanking source:\nxxxx1: TIM1 OC4\nxxx1x: TIM1 OC5\nxx1xx: TIM2 OC3\nx1xxx: TIM3 OC3\n1xxxx: TIM15 OC2"
            },
            {
                "name": "VALUE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Comparator 3 output status\nThis bit is read-only. It reflects the level of the comparator 2 output after the polarity selector and blanking, as indicated in ."
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "COMP3_CSR register lock\nThis bit is set by software and cleared by a system reset. It locks the whole content of the comparator 3 control register COMP3_CSR[31:0]:"
            }
        ]
    },
    "1073885184": {
        "name": "CRC_DR",
        "address": 1073885184,
        "size": 32,
        "access": "read-write",
        "desc": "Data register",
        "fields": [
            {
                "name": "DR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Data register bits"
            }
        ]
    },
    "1073885188": {
        "name": "CRC_IDR",
        "address": 1073885188,
        "size": 32,
        "access": "read-write",
        "desc": "Independent data register",
        "fields": [
            {
                "name": "IDR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "General-purpose 32-bit data register\n              bits"
            }
        ]
    },
    "1073885192": {
        "name": "CRC_CR",
        "address": 1073885192,
        "size": 32,
        "access": "",
        "desc": "Control register",
        "fields": [
            {
                "name": "REV_OUT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Reverse output data\nThis bit controls the reversal of the bit order of the output data."
            },
            {
                "name": "REV_IN",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Reverse input data\nThese bits control the reversal of the bit order of the input data"
            },
            {
                "name": "POLYSIZE",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Polynomial size\nThese bits control the size of the polynomial."
            },
            {
                "name": "RESET",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RESET bit"
            }
        ]
    },
    "1073885200": {
        "name": "CRC_INIT",
        "address": 1073885200,
        "size": 32,
        "access": "read-write",
        "desc": "Initial CRC value",
        "fields": [
            {
                "name": "CRC_INIT",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Programmable initial CRC\n              value"
            }
        ]
    },
    "1073885204": {
        "name": "CRC_POL",
        "address": 1073885204,
        "size": 32,
        "access": "read-write",
        "desc": "polynomial",
        "fields": [
            {
                "name": "POL",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Programmable polynomial"
            }
        ]
    },
    "1073771520": {
        "name": "DAC_CR",
        "address": 1073771520,
        "size": 32,
        "access": "read-write",
        "desc": "DAC control register",
        "fields": [
            {
                "name": "EN1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DAC channel1 enable\nThis bit is set and cleared by software to enable/disable DAC channel1."
            },
            {
                "name": "TEN1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DAC channel1 trigger enable\nThis bit is set and cleared by software to enable/disable DAC channel1 trigger.\nNote: When software trigger is selected, the transfer from the DAC_DHR1 register to the DAC_DOR1 register takes only one dac_pclk clock cycle."
            },
            {
                "name": "TSEL1",
                "bitOffset": 2,
                "bitWidth": 4,
                "desc": "DAC channel1 trigger selection\nThese bits select the external event used to trigger DAC channel1\n...\nRefer to the trigger selection tables in  for details on trigger configuration and mapping.\nNote: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled)."
            },
            {
                "name": "WAVE1",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "DAC channel1 noise/triangle wave generation enable\nThese bits are set and cleared by software.\n1x: Triangle wave generation enabled\nOnly used if bit TEN1 = 1 (DAC channel1 trigger enabled)."
            },
            {
                "name": "MAMP1",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "DAC channel1 mask/amplitude selector\nThese bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.\nbigger or equal to 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095"
            },
            {
                "name": "DMAEN1",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "DAC channel1 DMA enable\nThis bit is set and cleared by software."
            },
            {
                "name": "DMAUDRIE1",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DAC channel1 DMA Underrun Interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "CEN1",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "DAC channel1 calibration enable\nThis bit is set and cleared by software to enable/disable DAC channel1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored."
            },
            {
                "name": "EN2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "DAC channel2 enable\nThis bit is set and cleared by software to enable/disable DAC channel2.\nNote: These bits are available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "TEN2",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "DAC channel2 trigger enable\nThis bit is set and cleared by software to enable/disable DAC channel2 trigger\nNote: When software trigger is selected, the transfer from the DAC_DHR2 register to the DAC_DOR2 register takes only one dac_pclk clock cycle.\nThese bits are available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "TSEL2",
                "bitOffset": 18,
                "bitWidth": 4,
                "desc": "DAC channel2 trigger selection\nThese bits select the external event used to trigger DAC channel2\n...\nRefer to the trigger selection tables in  for details on trigger configuration and mapping.\nNote: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).\nThese bits are available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "WAVE2",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "DAC channel2 noise/triangle wave generation enable\nThese bits are set/reset by software.\n1x: Triangle wave generation enabled\nNote: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)\nThese bits are available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "MAMP2",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "DAC channel2 mask/amplitude selector\nThese bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode.\nbigger or equal to 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095\nNote: These bits are available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "DMAEN2",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "DAC channel2 DMA enable\nThis bit is set and cleared by software.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "DMAUDRIE2",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "DAC channel2 DMA underrun interrupt enable\nThis bit is set and cleared by software.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "CEN2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "DAC channel2 calibration enable\nThis bit is set and cleared by software to enable/disable DAC channel2 calibration, it can be written only if EN2 bit is set to 0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1073771524": {
        "name": "DAC_SWTRGR",
        "address": 1073771524,
        "size": 32,
        "access": "write-only",
        "desc": "DAC software trigger register",
        "fields": [
            {
                "name": "SWTRIG1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DAC channel1 software trigger\nThis bit is set by software to trigger the DAC in software trigger mode.\nNote: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register."
            },
            {
                "name": "SWTRIG2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DAC channel2 software trigger\nThis bit is set by software to trigger the DAC in software trigger mode.\nNote: This bit is cleared by hardware (one dac_pclk clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.\nThis bit is available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1073771528": {
        "name": "DAC_DHR12R1",
        "address": 1073771528,
        "size": 32,
        "access": "read-write",
        "desc": "DAC channel1 12-bit right-aligned data\n          holding register",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit right-aligned data\nThese bits are written by software. They specify 12-bit data for DAC channel1."
            }
        ]
    },
    "1073771532": {
        "name": "DAC_DHR12L1",
        "address": 1073771532,
        "size": 32,
        "access": "read-write",
        "desc": "DAC channel1 12-bit left aligned data\n          holding register",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 4,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit left-aligned data\nThese bits are written by software.\nThey specify 12-bit data for DAC channel1."
            }
        ]
    },
    "1073771536": {
        "name": "DAC_DHR8R1",
        "address": 1073771536,
        "size": 32,
        "access": "read-write",
        "desc": "DAC channel1 8-bit right aligned data\n          holding register",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "DAC channel1 8-bit right-aligned data\nThese bits are written by software. They specify 8-bit data for DAC channel1."
            }
        ]
    },
    "1073771540": {
        "name": "DAC_DHR12R2",
        "address": 1073771540,
        "size": 32,
        "access": "read-write",
        "desc": "DAC channel2 12-bit right aligned data\n          holding register",
        "fields": [
            {
                "name": "DACC2DHR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel2 12-bit right-aligned data\nThese bits are written by software. They specify 12-bit data for DAC channel2."
            }
        ]
    },
    "1073771544": {
        "name": "DAC_DHR12L2",
        "address": 1073771544,
        "size": 32,
        "access": "read-write",
        "desc": "DAC channel2 12-bit left aligned data\n          holding register",
        "fields": [
            {
                "name": "DACC2DHR",
                "bitOffset": 4,
                "bitWidth": 12,
                "desc": "DAC channel2 12-bit left-aligned data\nThese bits are written by software which specify 12-bit data for DAC channel2."
            }
        ]
    },
    "1073771548": {
        "name": "DAC_DHR8R2",
        "address": 1073771548,
        "size": 32,
        "access": "read-write",
        "desc": "DAC channel2 8-bit right-aligned data\n          holding register",
        "fields": [
            {
                "name": "DACC2DHR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "DAC channel2 8-bit right-aligned data\nThese bits are written by software which specifies 8-bit data for DAC channel2."
            }
        ]
    },
    "1073771552": {
        "name": "DAC_DHR12RD",
        "address": 1073771552,
        "size": 32,
        "access": "read-write",
        "desc": "Dual DAC 12-bit right-aligned data holding\n          register",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit right-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel1."
            },
            {
                "name": "DACC2DHR",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "DAC channel2 12-bit right-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel2."
            }
        ]
    },
    "1073771556": {
        "name": "DAC_DHR12LD",
        "address": 1073771556,
        "size": 32,
        "access": "read-write",
        "desc": "DUAL DAC 12-bit left aligned data holding\n          register",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 4,
                "bitWidth": 12,
                "desc": "DAC channel1 12-bit left-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel1."
            },
            {
                "name": "DACC2DHR",
                "bitOffset": 20,
                "bitWidth": 12,
                "desc": "DAC channel2 12-bit left-aligned data\nThese bits are written by software which specifies 12-bit data for DAC channel2."
            }
        ]
    },
    "1073771560": {
        "name": "DAC_DHR8RD",
        "address": 1073771560,
        "size": 32,
        "access": "read-write",
        "desc": "DUAL DAC 8-bit right aligned data holding\n          register",
        "fields": [
            {
                "name": "DACC1DHR",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "DAC channel1 8-bit right-aligned data\nThese bits are written by software which specifies 8-bit data for DAC channel1."
            },
            {
                "name": "DACC2DHR",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "DAC channel2 8-bit right-aligned data\nThese bits are written by software which specifies 8-bit data for DAC channel2."
            }
        ]
    },
    "1073771564": {
        "name": "DAC_DOR1",
        "address": 1073771564,
        "size": 32,
        "access": "read-only",
        "desc": "DAC channel1 data output\n          register",
        "fields": [
            {
                "name": "DACC1DOR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel1 data output\nThese bits are read-only, they contain data output for DAC channel1."
            }
        ]
    },
    "1073771568": {
        "name": "DAC_DOR2",
        "address": 1073771568,
        "size": 32,
        "access": "read-only",
        "desc": "DAC channel2 data output\n          register",
        "fields": [
            {
                "name": "DACC2DOR",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "DAC channel2 data output\nThese bits are read-only, they contain data output for DAC channel2."
            }
        ]
    },
    "1073771572": {
        "name": "DAC_SR",
        "address": 1073771572,
        "size": 32,
        "access": "",
        "desc": "DAC status register",
        "fields": [
            {
                "name": "DMAUDR1",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DAC channel1 DMA underrun flag\nThis bit is set by hardware and cleared by software (by writing it to 1)."
            },
            {
                "name": "CAL_FLAG1",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "DAC channel1 calibration offset status\nThis bit is set and cleared by hardware"
            },
            {
                "name": "BWST1",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DAC channel1 busy writing sample time flag\nThis bit is systematically set just after Sample and hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3 LSI periods of synchronization)."
            },
            {
                "name": "DMAUDR2",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "DAC channel2 DMA underrun flag\nThis bit is set by hardware and cleared by software (by writing it to 1).\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "CAL_FLAG2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "DAC channel2 calibration offset status\nThis bit is set and cleared by hardware\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            },
            {
                "name": "BWST2",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "DAC channel2 busy writing sample time flag\nThis bit is systematically set just after Sample and hold mode enable. It is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).\nNote: This bit is available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1073771576": {
        "name": "DAC_CCR",
        "address": 1073771576,
        "size": 32,
        "access": "read-write",
        "desc": "DAC calibration control\n          register",
        "fields": [
            {
                "name": "OTRIM1",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DAC channel1 offset trimming value"
            },
            {
                "name": "OTRIM2",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "DAC channel2 offset trimming value\nThese bits are available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1073771580": {
        "name": "DAC_MCR",
        "address": 1073771580,
        "size": 32,
        "access": "read-write",
        "desc": "DAC mode control register",
        "fields": [
            {
                "name": "MODE1",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "DAC channel1 mode\nThese bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored.\nThey can be set and cleared by software to select the DAC channel1 mode:\nDAC channel1 in Normal mode\nDAC channel1 in sample & hold mode\nNote: This register can be modified only when EN1=0."
            },
            {
                "name": "MODE2",
                "bitOffset": 16,
                "bitWidth": 3,
                "desc": "DAC channel2 mode\nThese bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored.\nThey can be set and cleared by software to select the DAC channel2 mode:\nDAC channel2 in Normal mode\nDAC channel2 in Sample and hold mode\nNote: This register can be modified only when EN2=0.\nRefer to  for the availability of DAC channel2."
            }
        ]
    },
    "1073771584": {
        "name": "DAC_SHSR1",
        "address": 1073771584,
        "size": 32,
        "access": "read-write",
        "desc": "DAC Sample and Hold sample time register\n          1",
        "fields": [
            {
                "name": "TSAMPLE1",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "DAC channel1 sample time (only valid in Sample and hold mode)\nThese bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWST1 of DAC_SR register is low, If BWST1=1, the write operation is ignored."
            }
        ]
    },
    "1073771588": {
        "name": "DAC_SHSR2",
        "address": 1073771588,
        "size": 32,
        "access": "read-write",
        "desc": "DAC Sample and Hold sample time register\n          2",
        "fields": [
            {
                "name": "TSAMPLE2",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "DAC channel2 sample time (only valid in Sample and hold mode)\nThese bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWST2 of DAC_SR register is low, if BWST2=1, the write operation is ignored."
            }
        ]
    },
    "1073771592": {
        "name": "DAC_SHHR",
        "address": 1073771592,
        "size": 32,
        "access": "read-write",
        "desc": "DAC Sample and Hold hold time\n          register",
        "fields": [
            {
                "name": "THOLD1",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "DAC channel1 hold time (only valid in Sample and hold mode)\nHold time= (THOLD[9:0]) x LSI clock period\nNote: This register can be modified only when EN1=0."
            },
            {
                "name": "THOLD2",
                "bitOffset": 16,
                "bitWidth": 10,
                "desc": "DAC channel2 hold time (only valid in Sample and hold mode).\nHold time= (THOLD[9:0]) x LSI clock period\nNote: This register can be modified only when EN2=0.\nThese bits are available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1073771596": {
        "name": "DAC_SHRR",
        "address": 1073771596,
        "size": 32,
        "access": "read-write",
        "desc": "DAC Sample and Hold refresh time\n          register",
        "fields": [
            {
                "name": "TREFRESH1",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "DAC channel1 refresh time (only valid in Sample and hold mode)\nRefresh time= (TREFRESH[7:0]) x LSI clock period\nNote: This register can be modified only when EN1=0."
            },
            {
                "name": "TREFRESH2",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "DAC channel2 refresh time (only valid in Sample and hold mode)\nRefresh time= (TREFRESH[7:0]) x LSI clock period\nNote: This register can be modified only when EN2=0.\nThese bits are available only on dual-channel DACs. Refer to implementation."
            }
        ]
    },
    "1073829888": {
        "name": "IDCODE",
        "address": 1073829888,
        "size": 32,
        "access": "read-only",
        "desc": "MCU Device ID Code Register",
        "fields": [
            {
                "name": "DEV_ID",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Device Identifier"
            },
            {
                "name": "REV_ID",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Revision Identifier"
            }
        ]
    },
    "1073829892": {
        "name": "DBG_CR",
        "address": 1073829892,
        "size": 32,
        "access": "read-write",
        "desc": "DBG configuration register ",
        "fields": [
            {
                "name": "DBG_STOP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Debug Stop mode\nDebug options in Stop mode.\nUpon Stop mode exit, the software must re-establish the desired clock configuration."
            },
            {
                "name": "DBG_STANDBY",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Debug Standby and Shutdown modes\nDebug options in Standby or Shutdown mode."
            }
        ]
    },
    "1073829896": {
        "name": "DBG_APB_FZ1",
        "address": 1073829896,
        "size": 32,
        "access": "read-write",
        "desc": "DBG APB freeze register 1 ",
        "fields": [
            {
                "name": "DBG_TIM2_STOP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clocking of TIM2 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM2 when the core is halted:"
            },
            {
                "name": "DBG_TIM3_STOP",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clocking of TIM3 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM3 when the core is halted:"
            },
            {
                "name": "DBG_TIM6_STOP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clocking of TIM6 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM6 when the core is halted:"
            },
            {
                "name": "DBG_TIM7_STOP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clocking of TIM7 counter when the core is halted.\nThis bit enables/disables the clock to the counter of ITIM7 when the core is halted:"
            },
            {
                "name": "DBG_RTC_STOP",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Clocking of RTC counter when the core is halted\nThis bit enables/disables the clock to the counter of RTC when the core is halted:"
            },
            {
                "name": "DBG_WWDG_STOP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Clocking of WWDG counter when the core is halted\nThis bit enables/disables the clock to the counter of WWDG when the core is halted:"
            },
            {
                "name": "DBG_IWDG_STOP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Clocking of IWDG counter when the core is halted\nThis bit enables/disables the clock to the counter of IWDG when the core is halted:"
            },
            {
                "name": "DBG_I2C1_SMBUS_TIMEOUT",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "SMBUS timeout when core is halted"
            },
            {
                "name": "DBG_LPTIM2_STOP",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Clocking of LPTIMER2 counter when the core is halted\nThis bit enables/disables the clock to the counter of LPTIMER2 when the core is halted:"
            },
            {
                "name": "DBG_LPTIM1_STOP",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Clocking of LPTIMER1 counter when the core is halted\nThis bit enables/disables the clock to the counter of LPTIMER1 when the core is halted:"
            }
        ]
    },
    "1073829900": {
        "name": "DBG_APB_FZ2",
        "address": 1073829900,
        "size": 32,
        "access": "read-write",
        "desc": "DBG APB freeze register 2 ",
        "fields": [
            {
                "name": "DBG_TIM1_STOP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Clocking of TIM1 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM1 when the core is halted:"
            },
            {
                "name": "DBG_TIM14_STOP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Clocking of TIM14 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM14 when the core is halted:"
            },
            {
                "name": "DBG_TIM15_STOP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Clocking of TIM15 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM15 when the core is halted:\nOnly available on STM32G071xx and STM32G081xx, reserved on STM32G031xx and STM32G041xx."
            },
            {
                "name": "DBG_TIM16_STOP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Clocking of TIM16 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM16 when the core is halted:"
            },
            {
                "name": "DBG_TIM17_STOP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Clocking of TIM17 counter when the core is halted\nThis bit enables/disables the clock to the counter of TIM17 when the core is halted:"
            }
        ]
    },
    "1073874944": {
        "name": "DMAMUX_C0CR",
        "address": 1073874944,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request line multiplexer channel x configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "DMA request identification\n\tSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\n\tDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\n\tDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\n\tThis field shall only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\n\tSelects the synchronization input (see inputs to resources STM32G0)."
            }
        ]
    },
    "1073874948": {
        "name": "DMAMUX_C1CR",
        "address": 1073874948,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request line multiplexer channel x configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "DMA request identification\n\tSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\n\tDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\n\tDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\n\tThis field shall only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\n\tSelects the synchronization input (see inputs to resources STM32G0)."
            }
        ]
    },
    "1073874952": {
        "name": "DMAMUX_C2CR",
        "address": 1073874952,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request line multiplexer channel x configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "DMA request identification\n\tSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\n\tDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\n\tDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\n\tThis field shall only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\n\tSelects the synchronization input (see inputs to resources STM32G0)."
            }
        ]
    },
    "1073874956": {
        "name": "DMAMUX_C3CR",
        "address": 1073874956,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request line multiplexer channel x configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "DMA request identification\n\tSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\n\tDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\n\tDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\n\tThis field shall only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\n\tSelects the synchronization input (see inputs to resources STM32G0)."
            }
        ]
    },
    "1073874960": {
        "name": "DMAMUX_C4CR",
        "address": 1073874960,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request line multiplexer channel x configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "DMA request identification\n\tSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\n\tDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\n\tDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\n\tThis field shall only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\n\tSelects the synchronization input (see inputs to resources STM32G0)."
            }
        ]
    },
    "1073874964": {
        "name": "DMAMUX_C5CR",
        "address": 1073874964,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request line multiplexer channel x configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "DMA request identification\n\tSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\n\tDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\n\tDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\n\tThis field shall only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\n\tSelects the synchronization input (see inputs to resources STM32G0)."
            }
        ]
    },
    "1073874968": {
        "name": "DMAMUX_C6CR",
        "address": 1073874968,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request line multiplexer channel x configuration register",
        "fields": [
            {
                "name": "DMAREQ_ID",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "DMA request identification\n\tSelects the input DMA request. See the DMAMUX table about assignments of multiplexer inputs to resources."
            },
            {
                "name": "SOIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Synchronization overrun interrupt enable"
            },
            {
                "name": "EGE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Event generation enable"
            },
            {
                "name": "SE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Synchronization enable"
            },
            {
                "name": "SPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Synchronization polarity\n\tDefines the edge polarity of the selected synchronization input:"
            },
            {
                "name": "NBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests minus 1 to forward\n\tDefines the number of DMA requests to forward to the DMA controller after a synchronization event, and/or the number of DMA requests before an output event is generated.\n\tThis field shall only be written when both SE and EGE bits are low."
            },
            {
                "name": "SYNC_ID",
                "bitOffset": 24,
                "bitWidth": 5,
                "desc": "Synchronization identification\n\tSelects the synchronization input (see inputs to resources STM32G0)."
            }
        ]
    },
    "1073875072": {
        "name": "DMAMUX_CSR",
        "address": 1073875072,
        "size": 32,
        "access": "read-only",
        "desc": "DMAMUX request line multiplexer interrupt channel status register",
        "fields": [
            {
                "name": "SOF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\n\tThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\n\tThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\n\tThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\n\tThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\n\tThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\n\tThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\n\tThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\n\tThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\n\tThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\n\tThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\n\tThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\n\tThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            },
            {
                "name": "SOF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Synchronization overrun event flag\n\tThe flag is set when a synchronization event occurs on a DMA request line multiplexer channel x, while the DMA request counter value is lower than NBREQ.\n\tThe flag is cleared by writing 1 to the corresponding CSOFx bit in DMAMUX_CFR register."
            }
        ]
    },
    "1073875076": {
        "name": "DMAMUX_CFR",
        "address": 1073875076,
        "size": 32,
        "access": "write-only",
        "desc": "DMAMUX request line multiplexer interrupt clear flag register",
        "fields": [
            {
                "name": "CSOF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            },
            {
                "name": "CSOF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Clear synchronization overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag SOFx in the DMAMUX_CSR register."
            }
        ]
    },
    "1073875200": {
        "name": "DMAMUX_RG0CR",
        "address": 1073875200,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request generator channel x configuration register",
        "fields": [
            {
                "name": "SIG_ID",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator"
            },
            {
                "name": "OIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Trigger overrun interrupt enable"
            },
            {
                "name": "GE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "DMA request generator channel x enable"
            },
            {
                "name": "GPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input"
            },
            {
                "name": "GNBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field shall only be written when GE bit is disabled."
            }
        ]
    },
    "1073875204": {
        "name": "DMAMUX_RG1CR",
        "address": 1073875204,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request generator channel x configuration register",
        "fields": [
            {
                "name": "SIG_ID",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator"
            },
            {
                "name": "OIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Trigger overrun interrupt enable"
            },
            {
                "name": "GE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "DMA request generator channel x enable"
            },
            {
                "name": "GPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input"
            },
            {
                "name": "GNBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field shall only be written when GE bit is disabled."
            }
        ]
    },
    "1073875208": {
        "name": "DMAMUX_RG2CR",
        "address": 1073875208,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request generator channel x configuration register",
        "fields": [
            {
                "name": "SIG_ID",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator"
            },
            {
                "name": "OIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Trigger overrun interrupt enable"
            },
            {
                "name": "GE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "DMA request generator channel x enable"
            },
            {
                "name": "GPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input"
            },
            {
                "name": "GNBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field shall only be written when GE bit is disabled."
            }
        ]
    },
    "1073875212": {
        "name": "DMAMUX_RG3CR",
        "address": 1073875212,
        "size": 32,
        "access": "read-write",
        "desc": "DMAMUX request generator channel x configuration register",
        "fields": [
            {
                "name": "SIG_ID",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "Signal identification\nSelects the DMA request trigger input used for the channel x of the DMA request generator"
            },
            {
                "name": "OIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Trigger overrun interrupt enable"
            },
            {
                "name": "GE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "DMA request generator channel x enable"
            },
            {
                "name": "GPOL",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "DMA request generator trigger polarity\nDefines the edge polarity of the selected trigger input"
            },
            {
                "name": "GNBREQ",
                "bitOffset": 19,
                "bitWidth": 5,
                "desc": "Number of DMA requests to be generated (minus 1)\nDefines the number of DMA requests to be generated after a trigger event. The actual number of generated DMA requests is GNBREQ +1.\nNote: This field shall only be written when GE bit is disabled."
            }
        ]
    },
    "1073875264": {
        "name": "DMAMUX_RGSR",
        "address": 1073875264,
        "size": 32,
        "access": "read-only",
        "desc": "DMAMUX request generator interrupt status register",
        "fields": [
            {
                "name": "OF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register."
            },
            {
                "name": "OF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register."
            },
            {
                "name": "OF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register."
            },
            {
                "name": "OF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Trigger overrun event flag\nThe flag is set when a new trigger event occurs on DMA request generator channel x, before the request counter underrun (the internal request counter programmed via the GNBREQ field of the DMAMUX_RGxCR register).\nThe flag is cleared by writing 1 to the corresponding COFx bit in the DMAMUX_RGCFR register."
            }
        ]
    },
    "1073875268": {
        "name": "DMAMUX_RGCFR",
        "address": 1073875268,
        "size": 32,
        "access": "write-only",
        "desc": "DMAMUX request generator interrupt clear flag register",
        "fields": [
            {
                "name": "COF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register."
            },
            {
                "name": "COF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register."
            },
            {
                "name": "COF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register."
            },
            {
                "name": "COF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear trigger overrun event flag\nWriting 1 in each bit clears the corresponding overrun flag OFx in the DMAMUX_RGSR register."
            }
        ]
    },
    "1073872896": {
        "name": "DMA_ISR",
        "address": 1073872896,
        "size": 32,
        "access": "",
        "desc": "DMA interrupt status register ",
        "fields": [
            {
                "name": "GIF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "global interrupt flag for channel 1"
            },
            {
                "name": "TCIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "transfer complete (TC) flag for channel 1"
            },
            {
                "name": "HTIF1",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "half transfer (HT) flag for channel 1"
            },
            {
                "name": "TEIF1",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "transfer error (TE) flag for channel 1"
            },
            {
                "name": "GIF2",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "global interrupt flag for channel 2"
            },
            {
                "name": "TCIF2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "transfer complete (TC) flag for channel 2"
            },
            {
                "name": "HTIF2",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "half transfer (HT) flag for channel 2"
            },
            {
                "name": "TEIF2",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "transfer error (TE) flag for channel 2"
            },
            {
                "name": "GIF3",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "global interrupt flag for channel 3"
            },
            {
                "name": "TCIF3",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "transfer complete (TC) flag for channel 3"
            },
            {
                "name": "HTIF3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "half transfer (HT) flag for channel 3"
            },
            {
                "name": "TEIF3",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "transfer error (TE) flag for channel 3"
            },
            {
                "name": "GIF4",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "global interrupt flag for channel 4"
            },
            {
                "name": "TCIF4",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "transfer complete (TC) flag for channel 4"
            },
            {
                "name": "HTIF4",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "half transfer (HT) flag for channel 4"
            },
            {
                "name": "TEIF4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "transfer error (TE) flag for channel 4"
            },
            {
                "name": "GIF5",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "global interrupt flag for channel 5"
            },
            {
                "name": "TCIF5",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "transfer complete (TC) flag for channel 5"
            },
            {
                "name": "HTIF5",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "half transfer (HT) flag for channel 5"
            },
            {
                "name": "TEIF5",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "transfer error (TE) flag for channel 5"
            },
            {
                "name": "GIF6",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "global interrupt flag for channel 6"
            },
            {
                "name": "TCIF6",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "transfer complete (TC) flag for channel 6"
            },
            {
                "name": "HTIF6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "half transfer (HT) flag for channel 6"
            },
            {
                "name": "TEIF6",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "transfer error (TE) flag for channel 6"
            },
            {
                "name": "GIF7",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "global interrupt flag for channel 7"
            },
            {
                "name": "TCIF7",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "transfer complete (TC) flag for channel 7"
            },
            {
                "name": "HTIF7",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "half transfer (HT) flag for channel 7"
            },
            {
                "name": "TEIF7",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "transfer error (TE) flag for channel 7"
            }
        ]
    },
    "1073872900": {
        "name": "DMA_IFCR",
        "address": 1073872900,
        "size": 32,
        "access": "",
        "desc": "DMA interrupt flag clear register ",
        "fields": [
            {
                "name": "CGIF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "global interrupt flag clear for channel 1"
            },
            {
                "name": "CTCIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "transfer complete flag clear for channel 1"
            },
            {
                "name": "CHTIF1",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "half transfer flag clear for channel 1"
            },
            {
                "name": "CTEIF1",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "transfer error flag clear for channel 1"
            },
            {
                "name": "CGIF2",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "global interrupt flag clear for channel 2"
            },
            {
                "name": "CTCIF2",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "transfer complete flag clear for channel 2"
            },
            {
                "name": "CHTIF2",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "half transfer flag clear for channel 2"
            },
            {
                "name": "CTEIF2",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "transfer error flag clear for channel 2"
            },
            {
                "name": "CGIF3",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "global interrupt flag clear for channel 3"
            },
            {
                "name": "CTCIF3",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "transfer complete flag clear for channel 3"
            },
            {
                "name": "CHTIF3",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "half transfer flag clear for channel 3"
            },
            {
                "name": "CTEIF3",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "transfer error flag clear for channel 3"
            },
            {
                "name": "CGIF4",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "global interrupt flag clear for channel 4"
            },
            {
                "name": "CTCIF4",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "transfer complete flag clear for channel 4"
            },
            {
                "name": "CHTIF4",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "half transfer flag clear for channel 4"
            },
            {
                "name": "CTEIF4",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "transfer error flag clear for channel 4"
            },
            {
                "name": "CGIF5",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "global interrupt flag clear for channel 5"
            },
            {
                "name": "CTCIF5",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "transfer complete flag clear for channel 5"
            },
            {
                "name": "CHTIF5",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "half transfer flag clear for channel 5"
            },
            {
                "name": "CTEIF5",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "transfer error flag clear for channel 5"
            },
            {
                "name": "CGIF6",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "global interrupt flag clear for channel 6"
            },
            {
                "name": "CTCIF6",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "transfer complete flag clear for channel 6"
            },
            {
                "name": "CHTIF6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "half transfer flag clear for channel 6"
            },
            {
                "name": "CTEIF6",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "transfer error flag clear for channel 6"
            },
            {
                "name": "CGIF7",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "global interrupt flag clear for channel 7"
            },
            {
                "name": "CTCIF7",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "transfer complete flag clear for channel 7"
            },
            {
                "name": "CHTIF7",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "half transfer flag clear for channel 7"
            },
            {
                "name": "CTEIF7",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "transfer error flag clear for channel 7"
            }
        ]
    },
    "1073872904": {
        "name": "DMA_CCR1",
        "address": 1073872904,
        "size": 32,
        "access": "",
        "desc": "DMA channel 1 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872908": {
        "name": "DMA_CNDTR1",
        "address": 1073872908,
        "size": 32,
        "access": "",
        "desc": "DMA channel 1 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872912": {
        "name": "DMA_CPAR1",
        "address": 1073872912,
        "size": 32,
        "access": "",
        "desc": "DMA channel 1 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872916": {
        "name": "DMA_CMAR1",
        "address": 1073872916,
        "size": 32,
        "access": "",
        "desc": "DMA channel 1 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872924": {
        "name": "DMA_CCR2",
        "address": 1073872924,
        "size": 32,
        "access": "",
        "desc": "DMA channel 2 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872928": {
        "name": "DMA_CNDTR2",
        "address": 1073872928,
        "size": 32,
        "access": "",
        "desc": "DMA channel 2 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872932": {
        "name": "DMA_CPAR2",
        "address": 1073872932,
        "size": 32,
        "access": "",
        "desc": "DMA channel 2 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872936": {
        "name": "DMA_CMAR2",
        "address": 1073872936,
        "size": 32,
        "access": "",
        "desc": "DMA channel 2 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872944": {
        "name": "DMA_CCR3",
        "address": 1073872944,
        "size": 32,
        "access": "",
        "desc": "DMA channel 3 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872948": {
        "name": "DMA_CNDTR3",
        "address": 1073872948,
        "size": 32,
        "access": "",
        "desc": "DMA channel 3 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872952": {
        "name": "DMA_CPAR3",
        "address": 1073872952,
        "size": 32,
        "access": "",
        "desc": "DMA channel 3 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872956": {
        "name": "DMA_CMAR3",
        "address": 1073872956,
        "size": 32,
        "access": "",
        "desc": "DMA channel 3 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872964": {
        "name": "DMA_CCR4",
        "address": 1073872964,
        "size": 32,
        "access": "",
        "desc": "DMA channel 4 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872968": {
        "name": "DMA_CNDTR4",
        "address": 1073872968,
        "size": 32,
        "access": "",
        "desc": "DMA channel 4 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872972": {
        "name": "DMA_CPAR4",
        "address": 1073872972,
        "size": 32,
        "access": "",
        "desc": "DMA channel 4 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872976": {
        "name": "DMA_CMAR4",
        "address": 1073872976,
        "size": 32,
        "access": "",
        "desc": "DMA channel 4 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872984": {
        "name": "DMA_CCR5",
        "address": 1073872984,
        "size": 32,
        "access": "",
        "desc": "DMA channel 5 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872988": {
        "name": "DMA_CNDTR5",
        "address": 1073872988,
        "size": 32,
        "access": "",
        "desc": "DMA channel 5 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872992": {
        "name": "DMA_CPAR5",
        "address": 1073872992,
        "size": 32,
        "access": "",
        "desc": "DMA channel 5 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073872996": {
        "name": "DMA_CMAR5",
        "address": 1073872996,
        "size": 32,
        "access": "",
        "desc": "DMA channel 5 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073873004": {
        "name": "DMA_CCR6",
        "address": 1073873004,
        "size": 32,
        "access": "",
        "desc": "DMA channel 6 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073873008": {
        "name": "DMA_CNDTR6",
        "address": 1073873008,
        "size": 32,
        "access": "",
        "desc": "DMA channel 6 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073873012": {
        "name": "DMA_CPAR6",
        "address": 1073873012,
        "size": 32,
        "access": "",
        "desc": "DMA channel 6 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073873016": {
        "name": "DMA_CMAR6",
        "address": 1073873016,
        "size": 32,
        "access": "",
        "desc": "DMA channel 6 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073873024": {
        "name": "DMA_CCR7",
        "address": 1073873024,
        "size": 32,
        "access": "",
        "desc": "DMA channel 7 configuration register",
        "fields": [
            {
                "name": "EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).\nNote: this bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "HTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "TEIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nDestination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nSource attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "CIRC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PINC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MINC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PSIZE",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR=1 and the peripheral source if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MSIZE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the peripheral source if DIR=1 and the peripheral destination if DIR=0.\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "PL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            },
            {
                "name": "MEM2MEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073873028": {
        "name": "DMA_CNDTR7",
        "address": 1073873028,
        "size": 32,
        "access": "",
        "desc": "DMA channel 7 number of data to transfer register",
        "fields": [
            {
                "name": "NDT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC=0 in the DMA_CCRx register).\nIt is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC=1).\nIf this field is zero, no transfer can be served whatever the channel status (enabled or not).\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073873032": {
        "name": "DMA_CPAR7",
        "address": 1073873032,
        "size": 32,
        "access": "",
        "desc": "DMA channel 7 peripheral address register",
        "fields": [
            {
                "name": "PA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory destination address if DIR=1 and the memory source address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR=1 and the peripheral source address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073873036": {
        "name": "DMA_CMAR7",
        "address": 1073873036,
        "size": 32,
        "access": "",
        "desc": "DMA channel 7 memory address register",
        "fields": [
            {
                "name": "MA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.\nIn memory-to-memory mode, this register identifies the memory source address if DIR=1 and the memory destination address if DIR=0.\nIn peripheral-to-peripheral mode, this register identifies the peripheral source address DIR=1 and the peripheral destination address if DIR=0.\nNote: this register is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1)."
            }
        ]
    },
    "1073879040": {
        "name": "RTSR1",
        "address": 1073879040,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI rising trigger selection\n          register",
        "fields": [
            {
                "name": "RT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            },
            {
                "name": "RT20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event line"
            }
        ]
    },
    "1073879044": {
        "name": "FTSR1",
        "address": 1073879044,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI falling trigger selection\n          register",
        "fields": [
            {
                "name": "FT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line"
            },
            {
                "name": "FT20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit\n              of Configurable Event input"
            }
        ]
    },
    "1073879048": {
        "name": "SWIER1",
        "address": 1073879048,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI software interrupt event\n          register",
        "fields": [
            {
                "name": "SWI0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            },
            {
                "name": "SWI20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line"
            }
        ]
    },
    "1073879052": {
        "name": "RPR1",
        "address": 1073879052,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI rising edge pending\n          register",
        "fields": [
            {
                "name": "RPIF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "configurable event inputs x rising edge\n              Pending bit"
            },
            {
                "name": "RPIF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            },
            {
                "name": "RPIF20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line"
            }
        ]
    },
    "1073879056": {
        "name": "FPR1",
        "address": 1073879056,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI falling edge pending\n          register",
        "fields": [
            {
                "name": "FPIF0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            },
            {
                "name": "FPIF20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line"
            }
        ]
    },
    "1073879080": {
        "name": "RTSR2",
        "address": 1073879080,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI rising trigger selection register 2",
        "fields": [
            {
                "name": "RT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rising trigger event configuration bit of configurable line 34"
            }
        ]
    },
    "1073879084": {
        "name": "FTSR2",
        "address": 1073879084,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI falling trigger selection register 2",
        "fields": [
            {
                "name": "FT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Falling trigger event configuration bit of configurable line 34"
            }
        ]
    },
    "1073879088": {
        "name": "SWIER2",
        "address": 1073879088,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI software interrupt event register 2",
        "fields": [
            {
                "name": "SWI2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Software rising edge event trigger on line 34"
            }
        ]
    },
    "1073879092": {
        "name": "RPR2",
        "address": 1073879092,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI rising edge pending register 2",
        "fields": [
            {
                "name": "RPIF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rising edge event pending for configurable line 34"
            }
        ]
    },
    "1073879096": {
        "name": "FPR2",
        "address": 1073879096,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI falling edge pending register 2",
        "fields": [
            {
                "name": "FPIF2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Falling edge event pending for configurable line 34"
            }
        ]
    },
    "1073879136": {
        "name": "EXTICR1",
        "address": 1073879136,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI external interrupt selection\n          register",
        "fields": [
            {
                "name": "EXTI0_7",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI8_15",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI16_23",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI24_31",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            }
        ]
    },
    "1073879140": {
        "name": "EXTICR2",
        "address": 1073879140,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI external interrupt selection\n          register",
        "fields": [
            {
                "name": "EXTI0_7",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI8_15",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI16_23",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI24_31",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            }
        ]
    },
    "1073879144": {
        "name": "EXTICR3",
        "address": 1073879144,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI external interrupt selection\n          register",
        "fields": [
            {
                "name": "EXTI0_7",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI8_15",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI16_23",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI24_31",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            }
        ]
    },
    "1073879148": {
        "name": "EXTICR4",
        "address": 1073879148,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI external interrupt selection\n          register",
        "fields": [
            {
                "name": "EXTI0_7",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI8_15",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI16_23",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            },
            {
                "name": "EXTI24_31",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "GPIO port selection"
            }
        ]
    },
    "1073879168": {
        "name": "IMR1",
        "address": 1073879168,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI CPU wakeup with interrupt mask\n          register",
        "fields": [
            {
                "name": "IM0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM20",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM22",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM24",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            }
        ]
    },
    "1073879172": {
        "name": "EMR1",
        "address": 1073879172,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI CPU wakeup with event mask\n          register",
        "fields": [
            {
                "name": "EM0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM16",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM17",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM18",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM19",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM21",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM23",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM25",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM26",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM27",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM28",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM29",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM30",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM31",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            }
        ]
    },
    "1073879184": {
        "name": "IMR2",
        "address": 1073879184,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI CPU wakeup with interrupt mask\n          register",
        "fields": [
            {
                "name": "IM32",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM33",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM34",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            },
            {
                "name": "IM35",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wakeup with interrupt mask on event\n              input"
            }
        ]
    },
    "1073879188": {
        "name": "EMR2",
        "address": 1073879188,
        "size": 32,
        "access": "read-write",
        "desc": "EXTI CPU wakeup with event mask\n          register",
        "fields": [
            {
                "name": "EM32",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM33",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM34",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            },
            {
                "name": "EM35",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "CPU wakeup with event mask on event\n              input"
            }
        ]
    },
    "1073767424": {
        "name": "FDCAN_CREL",
        "address": 1073767424,
        "size": 32,
        "access": "",
        "desc": "FDCAN core release register ",
        "fields": [
            {
                "name": "DAY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "18"
            },
            {
                "name": "MON",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "12"
            },
            {
                "name": "YEAR",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "4"
            },
            {
                "name": "SUBSTEP",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "1"
            },
            {
                "name": "STEP",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "2"
            },
            {
                "name": "REL",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "3"
            }
        ]
    },
    "1073767428": {
        "name": "FDCAN_ENDN",
        "address": 1073767428,
        "size": 32,
        "access": "",
        "desc": "FDCAN endian register ",
        "fields": [
            {
                "name": "ETV",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Endianness test value\nThe endianness test value is 0x8765 4321."
            }
        ]
    },
    "1073767436": {
        "name": "FDCAN_DBTP",
        "address": 1073767436,
        "size": 32,
        "access": "",
        "desc": "FDCAN data bit timing and prescaler register ",
        "fields": [
            {
                "name": "DSJW",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Synchronization jump width\nMust always be smaller than DTSEG2, valid values are 0 to 15. The value used by the hardware is the one programmed, incremented by 1: tSJW = (DSJW + 1) x tq."
            },
            {
                "name": "DTSEG2",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Data time segment after sample point\nValid values are 0 to 15. The value used by the hardware is the one programmed, incremented by 1, i.e. tBS2 = (DTSEG2 + 1) x tq."
            },
            {
                "name": "DTSEG1",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "Data time segment before sample point\nValid values are 0 to 31. The value used by the hardware is the one programmed, incremented by 1, i.e. tBS1 = (DTSEG1 + 1) x tq."
            },
            {
                "name": "DBRP",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Data bit rate prescaler\nThe value by which the oscillator frequency is divided to generate the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Baud Rate Prescaler are 0 to 31. The hardware interpreters this value as the value programmed plus 1."
            },
            {
                "name": "TDC",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Transceiver delay compensation"
            }
        ]
    },
    "1073767440": {
        "name": "FDCAN_TEST",
        "address": 1073767440,
        "size": 32,
        "access": "",
        "desc": "FDCAN test register ",
        "fields": [
            {
                "name": "LBCK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Loop back mode"
            },
            {
                "name": "TX",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Control of transmit pin"
            },
            {
                "name": "RX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Receive pin\nMonitors the actual value of pin FDCANx_RX"
            }
        ]
    },
    "1073767444": {
        "name": "FDCAN_RWD",
        "address": 1073767444,
        "size": 32,
        "access": "",
        "desc": "FDCAN RAM watchdog register ",
        "fields": [
            {
                "name": "WDC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Watchdog configuration\nStart value of the message RAM watchdog counter. With the reset value of 00, the counter is disabled.\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of FDCAN_CCCR register are set to 1."
            },
            {
                "name": "WDV",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "Watchdog value\nActual message RAM watchdog counter value."
            }
        ]
    },
    "1073767448": {
        "name": "FDCAN_CCCR",
        "address": 1073767448,
        "size": 32,
        "access": "",
        "desc": "FDCAN CC control register ",
        "fields": [
            {
                "name": "INIT",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Initialization"
            },
            {
                "name": "CCE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Configuration change enable"
            },
            {
                "name": "ASM",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "ASM restricted operation mode\nThe restricted operation mode is intended for applications that adapt themselves to different CAN bit rates. The application tests different bit rates and leaves the Restricted Operation Mode after it has received a valid frame. In the optional Restricted Operation Mode the node is able to transmit and receive data and remote frames and it gives acknowledge to valid frames, but it does not send active error frames or overload frames. In case of an error condition or overload condition, it does not send dominant bits, instead it waits for the occurrence of bus idle condition to resynchronize itself to the CAN communication. The error counters are not incremented. Bit ASM can only be set by software when both CCE and INIT are set to 1. The bit can be reset by the software at any time."
            },
            {
                "name": "CSA",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clock stop acknowledge"
            },
            {
                "name": "CSR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clock stop request"
            },
            {
                "name": "MON",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Bus monitoring mode\nBit MON can only be set by software when both CCE and INIT are set to 1. The bit can be reset by the Host at any time."
            },
            {
                "name": "DAR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Disable automatic retransmission"
            },
            {
                "name": "TEST",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Test mode enable"
            },
            {
                "name": "FDOE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "FD operation enable"
            },
            {
                "name": "BRSE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "FDCAN bit rate switching"
            },
            {
                "name": "PXHD",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Protocol exception handling disable"
            },
            {
                "name": "EFBI",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Edge filtering during bus integration"
            },
            {
                "name": "TXP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "If this bit is set, the FDCAN pauses for two CAN bit times before starting the next transmission after successfully transmitting a frame."
            },
            {
                "name": "NISO",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Non ISO operation\nIf this bit is set, the FDCAN uses the CAN FD frame format as specified by the Bosch CAN FD Specification V1.0."
            }
        ]
    },
    "1073767452": {
        "name": "FDCAN_NBTP",
        "address": 1073767452,
        "size": 32,
        "access": "",
        "desc": "FDCAN nominal bit timing and prescaler register ",
        "fields": [
            {
                "name": "NTSEG2",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Nominal time segment after sample point\nValid values are 0 to 127. The actual interpretation by the hardware of this value is such that one more than the programmed value is used."
            },
            {
                "name": "NTSEG1",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "Nominal time segment before sample point\nValid values are 0 to 255. The actual interpretation by the hardware of this value is such that one more than the programmed value is used.\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "NBRP",
                "bitOffset": 16,
                "bitWidth": 9,
                "desc": "Bit rate prescaler\nValue by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values are 0 to 511. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "NSJW",
                "bitOffset": 25,
                "bitWidth": 7,
                "desc": "Nominal (re)synchronization jump width\nValid values are 0 to 127. The actual interpretation by the hardware of this value is such that the used value is the one programmed incremented by one.\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073767456": {
        "name": "FDCAN_TSCC",
        "address": 1073767456,
        "size": 32,
        "access": "",
        "desc": "FDCAN timestamp counter configuration register ",
        "fields": [
            {
                "name": "TSS",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Timestamp select\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "TCP",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Timestamp counter prescaler\nConfigures the timestamp and timeout counters time unit in multiples of CAN bit times\n[1 : 16].\nThe actual interpretation by the hardware of this value is such that one more than the value programmed here is used.\nIn CAN FD mode the internal timestamp counter TCP does not provide a constant time base due to the different CAN bit times between arbitration phase and data phase. Thus CAN FD requires an external counter for timestamp generation (TSS = 10).\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073767460": {
        "name": "FDCAN_TSCV",
        "address": 1073767460,
        "size": 32,
        "access": "",
        "desc": "FDCAN timestamp counter value register ",
        "fields": [
            {
                "name": "TSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Timestamp counter\nThe internal/external timestamp counter value is captured on start of frame (both Rx and Tx). When TSCC[TSS] = 01, the timestamp counter is incremented in multiples of CAN bit times [1 : 16] depending on the configuration of TSCC[TCP]. A wrap around sets interrupt flag IR[TSW]. Write access resets the counter to 0.\nWhen TSCC.TSS = 10, TSC reflects the external timestamp counter value. A write access has no impact."
            }
        ]
    },
    "1073767464": {
        "name": "FDCAN_TOCC",
        "address": 1073767464,
        "size": 32,
        "access": "",
        "desc": "FDCAN timeout counter configuration register ",
        "fields": [
            {
                "name": "ETOC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Timeout counter enable\nThis is a protected write (P) bit, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "TOS",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Timeout select\nWhen operating in Continuous mode, a write to TOCV presets the counter to the value configured by TOCC[TOP] and continues down-counting. When the timeout counter is controlled by one of the FIFOs, an empty FIFO presets the counter to the value configured by TOCC[TOP]. Down-counting is started when the first FIFO element is stored.\nThese are protected write (P) bits, write access is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "TOP",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "Timeout period\nStart value of the timeout counter (down-counter). Configures the timeout period."
            }
        ]
    },
    "1073767468": {
        "name": "FDCAN_TOCV",
        "address": 1073767468,
        "size": 32,
        "access": "",
        "desc": "FDCAN timeout counter value register ",
        "fields": [
            {
                "name": "TOC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Timeout counter\nThe timeout counter is decremented in multiples of CAN bit times [1 : 16] depending on the configuration of TSCC.TCP. When decremented to 0, interrupt flag IR.TOO is set and the Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS."
            }
        ]
    },
    "1073767488": {
        "name": "FDCAN_ECR",
        "address": 1073767488,
        "size": 32,
        "access": "",
        "desc": "FDCAN error counter register ",
        "fields": [
            {
                "name": "TEC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Transmit error counter\nActual state of the transmit error counter, values between 0 and 255.\nWhen CCCR.ASM is set, the CAN protocol controller does not increment TEC and REC when a CAN protocol error is detected, but CEL is still incremented."
            },
            {
                "name": "REC",
                "bitOffset": 8,
                "bitWidth": 7,
                "desc": "Receive error counter\nActual state of the receive error counter, values between 0 and 127."
            },
            {
                "name": "RP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Receive error passive"
            },
            {
                "name": "CEL",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "CAN error logging\nThe counter is incremented each time when a CAN protocol error causes the transmit error counter or the receive error counter to be incremented. It is reset by read access to CEL. The counter stops at 0xFF; the next increment of TEC or REC sets interrupt flag IR[ELO].\nAccess type is RX: reset on read."
            }
        ]
    },
    "1073767492": {
        "name": "FDCAN_PSR",
        "address": 1073767492,
        "size": 32,
        "access": "",
        "desc": "FDCAN protocol status register ",
        "fields": [
            {
                "name": "LEC",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Last error code\nThe LEC indicates the type of the last error to occur on the CAN bus. This field is cleared to 0 when a message has been transferred (reception or transmission) without error.\nAccess type is RS: set on read."
            },
            {
                "name": "ACT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Activity\nMonitors the module's CAN communication state."
            },
            {
                "name": "EP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Error passive"
            },
            {
                "name": "EW",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Warning Sstatus"
            },
            {
                "name": "BO",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Bus_Off status"
            },
            {
                "name": "DLEC",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "Data last error code\nType of last error that occurred in the data phase of a FDCAN format frame with its BRS flag set. Coding is the same as for LEC. This field is cleared to 0 when a FDCAN format frame with its BRS flag set has been transferred (reception or transmission) without error.\nAccess type is RS: set on read."
            },
            {
                "name": "RESI",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "ESI flag of last received FDCAN message\nThis bit is set together with REDL, independent of acceptance filtering.\nAccess type is RX: reset on read."
            },
            {
                "name": "RBRS",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "BRS flag of last received FDCAN message\nThis bit is set together with REDL, independent of acceptance filtering.\nAccess type is RX: reset on read."
            },
            {
                "name": "REDL",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Received FDCAN message\nThis bit is set independent of acceptance filtering.\nAccess type is RX: reset on read."
            },
            {
                "name": "PXE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Protocol exception event"
            },
            {
                "name": "TDCV",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Transmitter delay compensation value\nPosition of the secondary sample point, defined by the sum of the measured delay from FDCAN_TX to FDCAN_RX and TDCR.TDCO. The SSP position is, in the data phase, the number of minimum time quanta (mtq) between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq."
            }
        ]
    },
    "1073767496": {
        "name": "FDCAN_TDCR",
        "address": 1073767496,
        "size": 32,
        "access": "",
        "desc": "FDCAN transmitter delay compensation register ",
        "fields": [
            {
                "name": "TDCF",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Transmitter delay compensation filter window length\nDefines the minimum value for the SSP position, dominant edges on FDCAN_RX that would result in an earlier SSP position are ignored for transmitter delay measurements.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "TDCO",
                "bitOffset": 8,
                "bitWidth": 7,
                "desc": "Transmitter delay compensation offset\nOffset value defining the distance between the measured delay from FDCAN_TX to FDCAN_RX and the secondary sample point. Valid values are 0 to 127 mtq.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073767504": {
        "name": "FDCAN_IR",
        "address": 1073767504,
        "size": 32,
        "access": "",
        "desc": "FDCAN interrupt register ",
        "fields": [
            {
                "name": "RF0N",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 new message"
            },
            {
                "name": "RF0F",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 full"
            },
            {
                "name": "RF0L",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 message lost"
            },
            {
                "name": "RF1N",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 new message"
            },
            {
                "name": "RF1F",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 full"
            },
            {
                "name": "RF1L",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 message lost"
            },
            {
                "name": "HPM",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "High-priority message"
            },
            {
                "name": "TC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transmission completed"
            },
            {
                "name": "TCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Transmission cancellation finished"
            },
            {
                "name": "TFE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Tx FIFO empty"
            },
            {
                "name": "TEFN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Tx event FIFO New Entry"
            },
            {
                "name": "TEFF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Tx event FIFO full"
            },
            {
                "name": "TEFL",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Tx event FIFO element lost"
            },
            {
                "name": "TSW",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Timestamp wraparound"
            },
            {
                "name": "MRAF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Message RAM access failure\nThe flag is set when the Rx handler:\nhas not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message storage is aborted and the Rx Handler starts processing of the following message.\nwas unable to write a message to the message RAM. In this case message storage is aborted.\nIn both cases the FIFO put index is not updated. The partly stored message is overwritten when the next message is stored to this location.\nThe flag is also set when the Tx Handler was not able to read a message from the Message RAM in time. In this case message transmission is aborted. In case of a Tx Handler access failure the FDCAN is switched into Restricted Operation Mode (see mode). To leave Restricted Operation Mode, the Host CPU has to reset CCCR.ASM."
            },
            {
                "name": "TOO",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Timeout occurred"
            },
            {
                "name": "ELO",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Error logging overflow"
            },
            {
                "name": "EP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Error passive"
            },
            {
                "name": "EW",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Warning status"
            },
            {
                "name": "BO",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Bus_Off status"
            },
            {
                "name": "WDI",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Watchdog interrupt"
            },
            {
                "name": "PEA",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Protocol error in arbitration phase (nominal bit time is used)"
            },
            {
                "name": "PED",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Protocol error in data phase (data bit time is used)"
            },
            {
                "name": "ARA",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Access to reserved address"
            }
        ]
    },
    "1073767508": {
        "name": "FDCAN_IE",
        "address": 1073767508,
        "size": 32,
        "access": "",
        "desc": "FDCAN interrupt enable register ",
        "fields": [
            {
                "name": "RF0NE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 new message interrupt enable"
            },
            {
                "name": "RF0FE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 full interrupt enable"
            },
            {
                "name": "RF0LE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 message lost interrupt enable"
            },
            {
                "name": "RF1NE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 new message interrupt enable"
            },
            {
                "name": "RF1FE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 full interrupt enable"
            },
            {
                "name": "RF1LE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 message lost interrupt enable"
            },
            {
                "name": "HPME",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "High-priority message interrupt enable"
            },
            {
                "name": "TCE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transmission completed interrupt enable"
            },
            {
                "name": "TCFE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Transmission cancellation finished interrupt enable"
            },
            {
                "name": "TFEE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Tx FIFO empty interrupt enable"
            },
            {
                "name": "TEFNE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Tx event FIFO new entry interrupt enable"
            },
            {
                "name": "TEFFE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Tx event FIFO full interrupt enable"
            },
            {
                "name": "TEFLE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Tx event FIFO element lost interrupt enable"
            },
            {
                "name": "TSWE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Timestamp wraparound interrupt enable"
            },
            {
                "name": "MRAFE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Message RAM access failure interrupt enable"
            },
            {
                "name": "TOOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Timeout occurred interrupt enable"
            },
            {
                "name": "ELOE",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Error logging overflow interrupt enable"
            },
            {
                "name": "EPE",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Error passive interrupt enable"
            },
            {
                "name": "EWE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Warning status interrupt enable"
            },
            {
                "name": "BOE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Bus_Off status"
            },
            {
                "name": "WDIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Watchdog interrupt enable"
            },
            {
                "name": "PEAE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Protocol error in arbitration phase enable"
            },
            {
                "name": "PEDE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Protocol error in data phase enable"
            },
            {
                "name": "ARAE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Access to reserved address enable"
            }
        ]
    },
    "1073767512": {
        "name": "FDCAN_ILS",
        "address": 1073767512,
        "size": 32,
        "access": "",
        "desc": "FDCAN interrupt line select register ",
        "fields": [
            {
                "name": "RxFIFO0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RX FIFO bit grouping the following interruption\nRF0LL: Rx FIFO 0 message lost interrupt line\nRF0FL: Rx FIFO 0 full interrupt line\nRF0NL: Rx FIFO 0 new message interrupt line"
            },
            {
                "name": "RxFIFO1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "RX FIFO bit grouping the following interruption\nRF1LL: Rx FIFO 1 message lost interrupt line\nRF1FL: Rx FIFO 1 full Interrupt line\nRF1NL: Rx FIFO 1 new message interrupt line"
            },
            {
                "name": "SMSG",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Status message bit grouping the following interruption\nTCFL: Transmission cancellation finished interrupt line\nTCL: Transmission completed interrupt line\nHPML: High-priority message interrupt line"
            },
            {
                "name": "TFERR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Tx FIFO ERROR grouping the following interruption\nTEFLL: Tx event FIFO element lost interrupt line\nTEFFL: Tx event FIFO full interrupt line\nTEFNL: Tx event FIFO new entry interrupt line\nTFEL: Tx FIFO empty interrupt line"
            },
            {
                "name": "MISC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Interrupt regrouping the following interruption\nTOOL: Timeout occurred interrupt line\nMRAFL: Message RAM access failure interrupt line\nTSWL: Timestamp wraparound interrupt line"
            },
            {
                "name": "BERR",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "BERR"
            },
            {
                "name": "PERR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Protocol error grouping the following interruption\nARAL: Access to reserved address line\nPEDL: Protocol error in data phase line\nPEAL: Protocol error in arbitration phase line\nWDIL: Watchdog interrupt line\nBOL: Bus_Off status\nEWL: Warning status interrupt line"
            }
        ]
    },
    "1073767516": {
        "name": "FDCAN_ILE",
        "address": 1073767516,
        "size": 32,
        "access": "",
        "desc": "FDCAN interrupt line enable register ",
        "fields": [
            {
                "name": "EINT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Enable interrupt line 0"
            },
            {
                "name": "EINT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Enable interrupt line 1"
            }
        ]
    },
    "1073767552": {
        "name": "FDCAN_RXGFC",
        "address": 1073767552,
        "size": 32,
        "access": "",
        "desc": "FDCAN global filter configuration register ",
        "fields": [
            {
                "name": "RRFE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Reject remote frames extended\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "RRFS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Reject remote frames standard\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "ANFE",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Accept non-matching frames extended\nDefines how received messages with 29-bit IDs that do not match any element of the filter list are treated.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "ANFS",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Accept Non-matching frames standard\nDefines how received messages with 11-bit IDs that do not match any element of the filter list are treated.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "F1OM",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "FIFO 1 operation mode (overwrite or blocking)\nThis is a protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "F0OM",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "FIFO 0 operation mode (overwrite or blocking)\nThis is protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "LSS",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "List size standard\n>28: Values greater than 28 are interpreted as 28.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            },
            {
                "name": "LSE",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "List size extended\n>8: Values greater than 8 are interpreted as 8.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073767556": {
        "name": "FDCAN_XIDAM",
        "address": 1073767556,
        "size": 32,
        "access": "",
        "desc": "FDCAN extended ID and mask register ",
        "fields": [
            {
                "name": "EIDM",
                "bitOffset": 0,
                "bitWidth": 29,
                "desc": "Extended ID mask\nFor acceptance filtering of extended frames the Extended ID AND Mask is AND-ed with the Message ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all bits set to 1 the mask is not active.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073767560": {
        "name": "FDCAN_HPMS",
        "address": 1073767560,
        "size": 32,
        "access": "",
        "desc": "FDCAN high-priority message status register ",
        "fields": [
            {
                "name": "BIDX",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Buffer index\nIndex of Rx FIFO element to which the message was stored. Only valid when MSI[1] = 1."
            },
            {
                "name": "MSI",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Message storage indicator"
            },
            {
                "name": "FIDX",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "Filter index\nIndex of matching filter element. Range is 0 to RXGFC[LSS] - 1 or RXGFC[LSE] - 1."
            },
            {
                "name": "FLST",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Filter list\nIndicates the filter list of the matching filter element."
            }
        ]
    },
    "1073767568": {
        "name": "FDCAN_RXF0S",
        "address": 1073767568,
        "size": 32,
        "access": "",
        "desc": "FDCAN Rx FIFO 0 status register ",
        "fields": [
            {
                "name": "F0FL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Rx FIFO 0 fill level\nNumber of elements stored in Rx FIFO 0, range 0 to 3."
            },
            {
                "name": "F0GI",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Rx FIFO 0 get index\nRx FIFO 0 read index pointer, range 0 to 2."
            },
            {
                "name": "F0PI",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Rx FIFO 0 put index\nRx FIFO 0 write index pointer, range 0 to 2."
            },
            {
                "name": "F0F",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 full"
            },
            {
                "name": "RF0L",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Rx FIFO 0 message lost\nThis bit is a copy of interrupt flag IR[RF0L]. When IR[RF0L] is reset, this bit is also reset."
            }
        ]
    },
    "1073767572": {
        "name": "FDCAN_RXF0A",
        "address": 1073767572,
        "size": 32,
        "access": "",
        "desc": "CAN Rx FIFO 0 acknowledge register ",
        "fields": [
            {
                "name": "F0AI",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Rx FIFO 0 acknowledge index\nAfter the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the buffer index of the last element read from Rx FIFO 0 to F0AI. This sets the Rx FIFO0 get index RXF0S[F0GI] to F0AI + 1 and update the FIFO 0 fill level RXF0S[F0FL]."
            }
        ]
    },
    "1073767576": {
        "name": "FDCAN_RXF1S",
        "address": 1073767576,
        "size": 32,
        "access": "",
        "desc": "FDCAN Rx FIFO 1 status register ",
        "fields": [
            {
                "name": "F1FL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Rx FIFO 1 fill level\nNumber of elements stored in Rx FIFO 1, range 0 to 3."
            },
            {
                "name": "F1GI",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Rx FIFO 1 get index\nRx FIFO 1 read index pointer, range 0 to 2."
            },
            {
                "name": "F1PI",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Rx FIFO 1 put index\nRx FIFO 1 write index pointer, range 0 to 2."
            },
            {
                "name": "F1F",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 full"
            },
            {
                "name": "RF1L",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Rx FIFO 1 message lost\nThis bit is a copy of interrupt flag IR[RF1L]. When IR[RF1L] is reset, this bit is also reset."
            }
        ]
    },
    "1073767580": {
        "name": "FDCAN_RXF1A",
        "address": 1073767580,
        "size": 32,
        "access": "",
        "desc": "FDCAN Rx FIFO 1 acknowledge register ",
        "fields": [
            {
                "name": "F1AI",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Rx FIFO 1 acknowledge index\nAfter the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the buffer index of the last element read from Rx FIFO 1 to F1AI. This sets the Rx FIFO1 get index RXF1S[F1GI] to F1AI + 1 and update the FIFO 1 Fill Level RXF1S[F1FL]."
            }
        ]
    },
    "1073767616": {
        "name": "FDCAN_TXBC",
        "address": 1073767616,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer configuration register ",
        "fields": [
            {
                "name": "TFQM",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Tx FIFO/queue mode\nThis is a protected write (P) bit, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073767620": {
        "name": "FDCAN_TXFQS",
        "address": 1073767620,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx FIFO/queue status register ",
        "fields": [
            {
                "name": "TFFL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Tx FIFO free level\nNumber of consecutive free Tx FIFO elements starting from TFGI, range 0 to 3. Read as 0 when Tx queue operation is configured (TXBC[TFQM] = 1)."
            },
            {
                "name": "TFGI",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Tx FIFO get index\nTx FIFO read index pointer, range 0 to 3. Read as 0 when Tx queue operation is configured (TXBC.TFQM = 1)"
            },
            {
                "name": "TFQPI",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Tx FIFO/queue put index\nTx FIFO/queue write index pointer, range 0 to 3"
            },
            {
                "name": "TFQF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Tx FIFO/queue full"
            }
        ]
    },
    "1073767624": {
        "name": "FDCAN_TXBRP",
        "address": 1073767624,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer request pending register ",
        "fields": [
            {
                "name": "TRP",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Transmission request pending\nEach Tx Buffer has its own transmission request pending bit. The bits are set via register TXBAR. The bits are reset after a requested transmission has completed or has been canceled via register TXBCR.\nAfter a TXBRP bit has been set, a Tx scan is started to check for the pending Tx request with the highest priority (Tx Buffer with lowest Message ID).\nA cancellation request resets the corresponding transmission request pending bit of register TXBRP. In case a transmission has already been started when a cancellation is requested, this is done at the end of the transmission, regardless whether the transmission was successful or not. The cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.\nAfter a cancellation has been requested, a finished cancellation is signaled via TXBCF\nafter successful transmission together with the corresponding TXBTO bit\nwhen the transmission has not yet been started at the point of cancellation\nwhen the transmission has been aborted due to lost arbitration\nwhen an error occurred during frame transmission\nIn DAR mode all transmissions are automatically canceled if they are not successful. The corresponding TXBCF bit is set for all unsuccessful transmissions."
            }
        ]
    },
    "1073767628": {
        "name": "FDCAN_TXBAR",
        "address": 1073767628,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer add request register ",
        "fields": [
            {
                "name": "AR",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Add request\nEach Tx buffer has its own add request bit. Writing a 1 sets the corresponding add request bit; writing a 0 has no impact. This enables the Host to set transmission requests for multiple Tx buffers with one write to TXBAR. When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan process has completed."
            }
        ]
    },
    "1073767632": {
        "name": "FDCAN_TXBCR",
        "address": 1073767632,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer cancellation request register ",
        "fields": [
            {
                "name": "CR",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Cancellation request\nEach Tx buffer has its own cancellation request bit. Writing a 1 sets the corresponding CR bit; writing a 0 has no impact.\nThis enables the Host to set cancellation requests for multiple Tx buffers with one write to TXBCR. The bits remain set until the corresponding TXBRP bit is reset."
            }
        ]
    },
    "1073767636": {
        "name": "FDCAN_TXBTO",
        "address": 1073767636,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer transmission occurred register ",
        "fields": [
            {
                "name": "TO",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Transmission occurred.\nEach Tx buffer has its own TO bit. The bits are set when the corresponding TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission is requested by writing a 1 to the corresponding bit of register TXBAR."
            }
        ]
    },
    "1073767640": {
        "name": "FDCAN_TXBCF",
        "address": 1073767640,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer cancellation finished register ",
        "fields": [
            {
                "name": "CF",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Cancellation finished\nEach Tx buffer has its own CF bit. The bits are set when the corresponding TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a new transmission is requested by writing a 1 to the corresponding bit of register TXBAR."
            }
        ]
    },
    "1073767644": {
        "name": "FDCAN_TXBTIE",
        "address": 1073767644,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer transmission interrupt enable register\t",
        "fields": [
            {
                "name": "TIE",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Transmission interrupt enable\nEach Tx buffer has its own TIE bit."
            }
        ]
    },
    "1073767648": {
        "name": "FDCAN_TXBCIE",
        "address": 1073767648,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx buffer cancellation finished interrupt enable register\t",
        "fields": [
            {
                "name": "CFIE",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Cancellation finished interrupt enable.\nEach Tx buffer has its own CFIE bit."
            }
        ]
    },
    "1073767652": {
        "name": "FDCAN_TXEFS",
        "address": 1073767652,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx event FIFO status register ",
        "fields": [
            {
                "name": "EFFL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Event FIFO fill level\nNumber of elements stored in Tx event FIFO, range 0 to 3."
            },
            {
                "name": "EFGI",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Event FIFO get index\nTx Event FIFO read index pointer, range 0 to 3."
            },
            {
                "name": "EFPI",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Event FIFO put index\nTx Event FIFO write index pointer, range 0 to 3."
            },
            {
                "name": "EFF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Event FIFO full"
            },
            {
                "name": "TEFL",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Tx Event FIFO element lost\nThis bit is a copy of interrupt flag IR[TEFL]. When IR[TEFL] is reset, this bit is also reset.\n0 No Tx event FIFO element lost\n1 Tx event FIFO element lost, also set after write attempt to Tx Event FIFO of size 0."
            }
        ]
    },
    "1073767656": {
        "name": "FDCAN_TXEFA",
        "address": 1073767656,
        "size": 32,
        "access": "",
        "desc": "FDCAN Tx event FIFO acknowledge register ",
        "fields": [
            {
                "name": "EFAI",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Event FIFO acknowledge index\nAfter the Host has read an element or a sequence of elements from the Tx event FIFO, it has to write the index of the last element read from Tx event FIFO to EFAI. This sets the Tx event FIFO get index TXEFS[EFGI] to EFAI + 1 and updates the FIFO 0 fill level TXEFS[EFFL]."
            }
        ]
    },
    "1073767680": {
        "name": "FDCAN_CKDIV",
        "address": 1073767680,
        "size": 32,
        "access": "",
        "desc": "FDCAN CFG clock divider register ",
        "fields": [
            {
                "name": "PDIV",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "input clock divider\nThe APB clock could be divided prior to be used by the CAN sub system. The rate must be computed using the divider output clock.\nThese are protected write (P) bits, which means that write access by the bits is possible only when the bit 1 [CCE] and bit 0 [INIT] of CCCR register are set to 1."
            }
        ]
    },
    "1073881088": {
        "name": "ACR",
        "address": 1073881088,
        "size": 32,
        "access": "read-write",
        "desc": "Access control register",
        "fields": [
            {
                "name": "LATENCY",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Latency"
            },
            {
                "name": "PRFTEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Prefetch enable"
            },
            {
                "name": "ICEN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Instruction cache enable"
            },
            {
                "name": "ICRST",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Instruction cache reset"
            },
            {
                "name": "EMPTY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Flash User area empty"
            },
            {
                "name": "DBG_SWEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Debug access software\n              enable"
            }
        ]
    },
    "1073881096": {
        "name": "KEYR",
        "address": 1073881096,
        "size": 32,
        "access": "write-only",
        "desc": "Flash key register",
        "fields": [
            {
                "name": "KEYR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "KEYR"
            }
        ]
    },
    "1073881100": {
        "name": "OPTKEYR",
        "address": 1073881100,
        "size": 32,
        "access": "write-only",
        "desc": "Option byte key register",
        "fields": [
            {
                "name": "OPTKEYR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Option byte key"
            }
        ]
    },
    "1073881104": {
        "name": "SR",
        "address": 1073881104,
        "size": 32,
        "access": "read-write",
        "desc": "Status register",
        "fields": [
            {
                "name": "EOP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "End of operation"
            },
            {
                "name": "OPERR",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Operation error"
            },
            {
                "name": "PROGERR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Programming error"
            },
            {
                "name": "WRPERR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Write protected error"
            },
            {
                "name": "PGAERR",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Programming alignment\n              error"
            },
            {
                "name": "SIZERR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Size error"
            },
            {
                "name": "PGSERR",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Programming sequence error"
            },
            {
                "name": "MISERR",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Fast programming data miss\n              error"
            },
            {
                "name": "FASTERR",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Fast programming error"
            },
            {
                "name": "RDERR",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "PCROP read error"
            },
            {
                "name": "OPTVERR",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Option and Engineering bits loading\n              validity error"
            },
            {
                "name": "BSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Busy"
            },
            {
                "name": "CFGBSY",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Programming or erase configuration\n              busy."
            }
        ]
    },
    "1073881108": {
        "name": "CR",
        "address": 1073881108,
        "size": 32,
        "access": "read-write",
        "desc": "Flash control register",
        "fields": [
            {
                "name": "PG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Programming"
            },
            {
                "name": "PER",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Page erase"
            },
            {
                "name": "MER1",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Mass erase"
            },
            {
                "name": "PNB",
                "bitOffset": 3,
                "bitWidth": 10,
                "desc": "Page number"
            },
            {
                "name": "STRT",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Start"
            },
            {
                "name": "BKER",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Bank selection for erase operation"
            },
            {
                "name": "MER2",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Mass erase, Bank 2"
            },
            {
                "name": "OPTSTRT",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Options modification start"
            },
            {
                "name": "FSTPG",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Fast programming"
            },
            {
                "name": "EOPIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "End of operation interrupt\n              enable"
            },
            {
                "name": "ERRIE",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Error interrupt enable"
            },
            {
                "name": "RDERRIE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "PCROP read error interrupt\n              enable"
            },
            {
                "name": "OBL_LAUNCH",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Force the option byte\n              loading"
            },
            {
                "name": "SEC_PROT",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Securable memory area protection\n              enable"
            },
            {
                "name": "SEC_PROT2",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Securable memory area protection enable, Bank 2"
            },
            {
                "name": "OPTLOCK",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Options Lock"
            },
            {
                "name": "LOCK",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "FLASH_CR Lock"
            }
        ]
    },
    "1073881112": {
        "name": "ECCR",
        "address": 1073881112,
        "size": 32,
        "access": "",
        "desc": "Flash ECC register",
        "fields": [
            {
                "name": "ADDR_ECC",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "ECC fail address"
            },
            {
                "name": "SYSF_ECC",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "ECC fail for Corrected ECC Error or\n              Double ECC Error in info block"
            },
            {
                "name": "ECCIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "ECC correction interrupt\n              enable"
            },
            {
                "name": "ECCC",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "ECC correction"
            },
            {
                "name": "ECCD",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "ECC detection"
            }
        ]
    },
    "1073881116": {
        "name": "ECCR2",
        "address": 1073881116,
        "size": 32,
        "access": "",
        "desc": "Flash ECC register 2",
        "fields": [
            {
                "name": "ADDR_ECC",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "ECC fail address"
            },
            {
                "name": "SYSF_ECC",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "ECC fail for Corrected ECC Error or\n              Double ECC Error in info block"
            },
            {
                "name": "ECCIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "ECC correction interrupt\n              enable"
            },
            {
                "name": "ECCC",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "ECC correction"
            },
            {
                "name": "ECCD",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "ECC detection"
            }
        ]
    },
    "1073881120": {
        "name": "OPTR",
        "address": 1073881120,
        "size": 32,
        "access": "read-write",
        "desc": "Flash option register",
        "fields": [
            {
                "name": "RDP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Read protection level"
            },
            {
                "name": "BOREN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "BOR reset Level"
            },
            {
                "name": "BORF_LEV",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "These bits contain the VDD supply level\n              threshold that activates the reset"
            },
            {
                "name": "BORR_LEV",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "These bits contain the VDD supply level\n              threshold that releases the reset."
            },
            {
                "name": "nRST_STOP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "nRST_STOP"
            },
            {
                "name": "nRST_STDBY",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "nRST_STDBY"
            },
            {
                "name": "nRSTS_HDW",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "nRSTS_HDW"
            },
            {
                "name": "IDWG_SW",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Independent watchdog\n              selection"
            },
            {
                "name": "IWDG_STOP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Independent watchdog counter freeze in\n              Stop mode"
            },
            {
                "name": "IWDG_STDBY",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Independent watchdog counter freeze in\n              Standby mode"
            },
            {
                "name": "WWDG_SW",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Window watchdog selection"
            },
            {
                "name": "RAM_PARITY_CHECK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "SRAM parity check control"
            },
            {
                "name": "nBOOT_SEL",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "nBOOT_SEL"
            },
            {
                "name": "nBOOT1",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Boot configuration"
            },
            {
                "name": "nBOOT0",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "nBOOT0 option bit"
            },
            {
                "name": "NRST_MODE",
                "bitOffset": 27,
                "bitWidth": 2,
                "desc": "NRST_MODE"
            },
            {
                "name": "IRHEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Internal reset holder enable\n              bit"
            }
        ]
    },
    "1073881124": {
        "name": "PCROP1ASR",
        "address": 1073881124,
        "size": 32,
        "access": "read-only",
        "desc": "Flash PCROP zone A Start address\n          register",
        "fields": [
            {
                "name": "PCROP1A_STRT",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "PCROP1A area start offset"
            }
        ]
    },
    "1073881128": {
        "name": "PCROP1AER",
        "address": 1073881128,
        "size": 32,
        "access": "read-only",
        "desc": "Flash PCROP zone A End address\n          register",
        "fields": [
            {
                "name": "PCROP1A_END",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "PCROP1A area end offset"
            },
            {
                "name": "PCROP_RDP",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "PCROP area preserved when RDP level\n              decreased"
            }
        ]
    },
    "1073881132": {
        "name": "WRP1AR",
        "address": 1073881132,
        "size": 32,
        "access": "read-only",
        "desc": "Flash WRP area A address\n          register",
        "fields": [
            {
                "name": "WRP1A_STRT",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "WRP area A start offset"
            },
            {
                "name": "WRP1A_END",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "WRP area A end offset"
            }
        ]
    },
    "1073881136": {
        "name": "WRP1BR",
        "address": 1073881136,
        "size": 32,
        "access": "read-only",
        "desc": "Flash WRP area B address\n          register",
        "fields": [
            {
                "name": "WRP1B_STRT",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "WRP area B start offset"
            },
            {
                "name": "WRP1B_END",
                "bitOffset": 16,
                "bitWidth": 6,
                "desc": "WRP area B end offset"
            }
        ]
    },
    "1073881140": {
        "name": "PCROP1BSR",
        "address": 1073881140,
        "size": 32,
        "access": "read-only",
        "desc": "Flash PCROP zone B Start address\n          register",
        "fields": [
            {
                "name": "PCROP1B_STRT",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "PCROP1B area start offset"
            }
        ]
    },
    "1073881144": {
        "name": "PCROP1BER",
        "address": 1073881144,
        "size": 32,
        "access": "read-write",
        "desc": "Flash PCROP area B End address\n          register",
        "fields": [
            {
                "name": "PCROP1B_END",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "PCROP1B area end offset"
            }
        ]
    },
    "1073881156": {
        "name": "PCROP2ASR",
        "address": 1073881156,
        "size": 32,
        "access": "read-write",
        "desc": "Flash PCROP2 area A start address register",
        "fields": [
            {
                "name": "PCROP2A_STRT",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "PCROP2A area start offset, bank2"
            }
        ]
    },
    "1073881160": {
        "name": "PCROP2AER",
        "address": 1073881160,
        "size": 32,
        "access": "read-write",
        "desc": "Flash PCROP2 area A end address register",
        "fields": [
            {
                "name": "PCROP2A_END",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "PCROP2A area end offset, bank2"
            }
        ]
    },
    "1073881164": {
        "name": "WRP2AR",
        "address": 1073881164,
        "size": 32,
        "access": "read-write",
        "desc": "Flash WRP2 area A address register",
        "fields": [
            {
                "name": "WRP2A_STRT",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "WRP area A start offset, Bank 2"
            },
            {
                "name": "WRP2A_END",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "WRP area A end offset, Bank 2"
            }
        ]
    },
    "1073881168": {
        "name": "WRP2BR",
        "address": 1073881168,
        "size": 32,
        "access": "read-write",
        "desc": "Flash WRP2 area B address register",
        "fields": [
            {
                "name": "WRP2B_STRT",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "WRP area B start offset, Bank 2"
            },
            {
                "name": "WRP2B_END",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "WRP area B end offset, Bank 2"
            }
        ]
    },
    "1073881172": {
        "name": "PCROP2BSR",
        "address": 1073881172,
        "size": 32,
        "access": "read-write",
        "desc": "FLASH PCROP2 area B start address register",
        "fields": [
            {
                "name": "PCROP2B_STRT",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "PCROP2B area start offset, Bank 2"
            }
        ]
    },
    "1073881176": {
        "name": "PCROP2BER",
        "address": 1073881176,
        "size": 32,
        "access": "read-write",
        "desc": "FLASH PCROP2 area B end address register",
        "fields": [
            {
                "name": "PCROP2B_END",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "PCROP2B area end offset, Bank 2"
            }
        ]
    },
    "1073881216": {
        "name": "SECR",
        "address": 1073881216,
        "size": 32,
        "access": "read-write",
        "desc": "Flash Security register",
        "fields": [
            {
                "name": "SEC_SIZE",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Securable memory area size"
            },
            {
                "name": "BOOT_LOCK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "used to force boot from user\n              area"
            },
            {
                "name": "SEC_SIZE2",
                "bitOffset": 20,
                "bitWidth": 8,
                "desc": "Securable memory area size"
            }
        ]
    },
    "1342177280": {
        "name": "MODER",
        "address": 1342177280,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODER15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            }
        ]
    },
    "1342177284": {
        "name": "OTYPER",
        "address": 1342177284,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            }
        ]
    },
    "1342177288": {
        "name": "OSPEEDR",
        "address": 1342177288,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port output speed\n          register",
        "fields": [
            {
                "name": "OSPEEDR15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            }
        ]
    },
    "1342177292": {
        "name": "PUPDR",
        "address": 1342177292,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port pull-up/pull-down\n          register",
        "fields": [
            {
                "name": "PUPDR15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            }
        ]
    },
    "1342177296": {
        "name": "IDR",
        "address": 1342177296,
        "size": 32,
        "access": "read-only",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "IDR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            }
        ]
    },
    "1342177300": {
        "name": "ODR",
        "address": 1342177300,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "ODR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            }
        ]
    },
    "1342177304": {
        "name": "BSRR",
        "address": 1342177304,
        "size": 32,
        "access": "write-only",
        "desc": "GPIO port bit set/reset\n          register",
        "fields": [
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            }
        ]
    },
    "1342177308": {
        "name": "LCKR",
        "address": 1342177308,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port configuration lock\n          register",
        "fields": [
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            }
        ]
    },
    "1342177312": {
        "name": "AFRL",
        "address": 1342177312,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO alternate function low\n          register",
        "fields": [
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            }
        ]
    },
    "1342177316": {
        "name": "AFRH",
        "address": 1342177316,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO alternate function high\n          register",
        "fields": [
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            }
        ]
    },
    "1342177320": {
        "name": "BRR",
        "address": 1342177320,
        "size": 32,
        "access": "write-only",
        "desc": "port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            }
        ]
    },
    "1342178304": {
        "name": "MODER",
        "address": 1342178304,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port mode register",
        "fields": [
            {
                "name": "MODER15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "MODER0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            }
        ]
    },
    "1342178308": {
        "name": "OTYPER",
        "address": 1342178308,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port output type register",
        "fields": [
            {
                "name": "OT15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OT0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x configuration bits (y =\n              0..15)"
            }
        ]
    },
    "1342178312": {
        "name": "OSPEEDR",
        "address": 1342178312,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port output speed\n          register",
        "fields": [
            {
                "name": "OSPEEDR15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "OSPEEDR0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            }
        ]
    },
    "1342178316": {
        "name": "PUPDR",
        "address": 1342178316,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port pull-up/pull-down\n          register",
        "fields": [
            {
                "name": "PUPDR15",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR14",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR13",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR12",
                "bitOffset": 24,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR11",
                "bitOffset": 22,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR10",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR9",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR8",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR7",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR6",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR5",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR4",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR3",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR2",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR1",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            },
            {
                "name": "PUPDR0",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Port x configuration bits (y =\n              0..15)"
            }
        ]
    },
    "1342178320": {
        "name": "IDR",
        "address": 1342178320,
        "size": 32,
        "access": "read-only",
        "desc": "GPIO port input data register",
        "fields": [
            {
                "name": "IDR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            },
            {
                "name": "IDR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port input data (y =\n              0..15)"
            }
        ]
    },
    "1342178324": {
        "name": "ODR",
        "address": 1342178324,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port output data register",
        "fields": [
            {
                "name": "ODR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            },
            {
                "name": "ODR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port output data (y =\n              0..15)"
            }
        ]
    },
    "1342178328": {
        "name": "BSRR",
        "address": 1342178328,
        "size": 32,
        "access": "write-only",
        "desc": "GPIO port bit set/reset\n          register",
        "fields": [
            {
                "name": "BR15",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR14",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR13",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR12",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR11",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR10",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR9",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR8",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR7",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR6",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR5",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR4",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR3",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR2",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR1",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Port x reset bit y (y =\n              0..15)"
            },
            {
                "name": "BR0",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            },
            {
                "name": "BS0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x set bit y (y=\n              0..15)"
            }
        ]
    },
    "1342178332": {
        "name": "LCKR",
        "address": 1342178332,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO port configuration lock\n          register",
        "fields": [
            {
                "name": "LCKK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            },
            {
                "name": "LCK0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port x lock bit y (y=\n              0..15)"
            }
        ]
    },
    "1342178336": {
        "name": "AFRL",
        "address": 1342178336,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO alternate function low\n          register",
        "fields": [
            {
                "name": "AFSEL7",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL6",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL5",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL4",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL3",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL2",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL1",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            },
            {
                "name": "AFSEL0",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 0..7)"
            }
        ]
    },
    "1342178340": {
        "name": "AFRH",
        "address": 1342178340,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO alternate function high\n          register",
        "fields": [
            {
                "name": "AFSEL15",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL14",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL13",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL12",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL11",
                "bitOffset": 12,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL10",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL9",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            },
            {
                "name": "AFSEL8",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Alternate function selection for port x\n              bit y (y = 8..15)"
            }
        ]
    },
    "1342178344": {
        "name": "BRR",
        "address": 1342178344,
        "size": 32,
        "access": "write-only",
        "desc": "port bit reset register",
        "fields": [
            {
                "name": "BR0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            },
            {
                "name": "BR15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port Reset bit"
            }
        ]
    },
    "1073772544": {
        "name": "CEC_CR",
        "address": 1073772544,
        "size": 32,
        "access": "read-write",
        "desc": "CEC control register",
        "fields": [
            {
                "name": "CECEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CEC enable\nThe CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission."
            },
            {
                "name": "TXSOM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tx start of message\nTXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM.\nStart-bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission starts after the end of reception.\nTXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1).\nTXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit.\nNote: TXSOM must be set when CECEN=1.\nTXSOM must be set when transmission data is available into TXDR.\nHEADER first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR that is used only for reception."
            },
            {
                "name": "TXEOM",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Tx end of message\nThe TXEOM bit is set by software to command transmission of the last byte of a CEC message.\nTXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM.\nNote: TXEOM must be set when CECEN=1.\nTXEOM must be set before writing transmission data to TXDR.\nIf TXEOM is set when TXSOM=0, transmitted message consists of 1 byte (HEADER) only (PING message)."
            }
        ]
    },
    "1073772548": {
        "name": "CEC_CFGR",
        "address": 1073772548,
        "size": 32,
        "access": "read-write",
        "desc": "This register is used to configure the\n          HDMI-CEC controller. It is mandatory to write CEC_CFGR\n          only when CECEN=0.",
        "fields": [
            {
                "name": "SFT",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Signal free time\nSFT bits are set by software. In the SFT=0x0 configuration, the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software.\n0x0\n2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE=1)\n4 data-bit periods if CEC is the new bus initiator\n6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1)"
            },
            {
                "name": "RXTOL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rx-tolerance"
            },
            {
                "name": "BRESTP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rx-stop on bit rising error\nThe BRESTP bit is set and cleared by software."
            },
            {
                "name": "BREGEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Generate error-bit on bit rising error\nThe BREGEN bit is set and cleared by software.\nNote: If BRDNOGEN=0, an error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0."
            },
            {
                "name": "LBPEGEN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Generate error-bit on long bit period error\nThe LBPEGEN bit is set and cleared by software.\nNote: If BRDNOGEN=0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0."
            },
            {
                "name": "BRDNOGEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Avoid error-bit generation in broadcast\nThe BRDNOGEN bit is set and cleared by software.\nerror-bit on the CEC line. LBPE detection with LBPEGEN=0 on a broadcast message generates an error-bit on the CEC line."
            },
            {
                "name": "SFTOP",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SFT option bit\nThe SFTOPT bit is set and cleared by software."
            },
            {
                "name": "OAR",
                "bitOffset": 16,
                "bitWidth": 15,
                "desc": "Own addresses configuration\nThe OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position.\nAt the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received.\nExample:\nOAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received."
            },
            {
                "name": "LSTN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Listen mode\nLSTN bit is set and cleared by software."
            }
        ]
    },
    "1073772552": {
        "name": "CEC_TXDR",
        "address": 1073772552,
        "size": 32,
        "access": "write-only",
        "desc": "CEC Tx data register",
        "fields": [
            {
                "name": "TXD",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Tx Data register. TXD is a write-only\n              register containing the data byte to be transmitted.\n              Note: TXD must be written when\n              TXSTART=1"
            }
        ]
    },
    "1073772556": {
        "name": "CEC_RXDR",
        "address": 1073772556,
        "size": 32,
        "access": "read-only",
        "desc": "CEC Rx Data Register",
        "fields": [
            {
                "name": "RXD",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Rx Data register. RXD is read-only and\n              contains the last data byte which has been received\n              from the CEC line."
            }
        ]
    },
    "1073772560": {
        "name": "CEC_ISR",
        "address": 1073772560,
        "size": 32,
        "access": "read-write",
        "desc": "CEC Interrupt and Status\n          Register",
        "fields": [
            {
                "name": "RXBR",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rx-Byte Received The RXBR bit is set by\n              hardware to inform application that a new byte has\n              been received from the CEC line and stored into the\n              RXD buffer. RXBR is cleared by software write at\n              1."
            },
            {
                "name": "RXEND",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "End Of Reception RXEND is set by\n              hardware to inform application that the last byte of\n              a CEC message is received from the CEC line and\n              stored into the RXD buffer. RXEND is set at the same\n              time of RXBR. RXEND is cleared by software write at\n              1."
            },
            {
                "name": "RXOVR",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rx-Overrun RXOVR is set by hardware if\n              RXBR is not yet cleared at the time a new byte is\n              received on the CEC line and stored into RXD. RXOVR\n              assertion stops message reception so that no\n              acknowledge is sent. In case of broadcast, a negative\n              acknowledge is sent. RXOVR is cleared by software\n              write at 1."
            },
            {
                "name": "BRE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Rx-Bit Rising Error BRE is set by\n              hardware in case a Data-Bit waveform is detected with\n              Bit Rising Error. BRE is set either at the time the\n              misplaced rising edge occurs, or at the end of the\n              maximum BRE tolerance allowed by RXTOL, in case\n              rising edge is still longing. BRE stops message\n              reception if BRESTP=1. BRE generates an Error-Bit on\n              the CEC line if BREGEN=1. BRE is cleared by software\n              write at 1."
            },
            {
                "name": "SBPE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Rx-Short Bit Period Error SBPE is set by\n              hardware in case a Data-Bit waveform is detected with\n              Short Bit Period Error. SBPE is set at the time the\n              anticipated falling edge occurs. SBPE generates an\n              Error-Bit on the CEC line. SBPE is cleared by\n              software write at 1."
            },
            {
                "name": "LBPE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Rx-Long Bit Period Error LBPE is set by\n              hardware in case a Data-Bit waveform is detected with\n              Long Bit Period Error. LBPE is set at the end of the\n              maximum bit-extension tolerance allowed by RXTOL, in\n              case falling edge is still longing. LBPE always stops\n              reception of the CEC message. LBPE generates an\n              Error-Bit on the CEC line if LBPEGEN=1. In case of\n              broadcast, Error-Bit is generated even in case of\n              LBPEGEN=0. LBPE is cleared by software write at\n              1."
            },
            {
                "name": "RXACKE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Rx-Missing Acknowledge In receive mode,\n              RXACKE is set by hardware to inform application that\n              no acknowledge was seen on the CEC line. RXACKE\n              applies only for broadcast messages and in listen\n              mode also for not directly addressed messages\n              (destination address not enabled in OAR). RXACKE\n              aborts message reception. RXACKE is cleared by\n              software write at 1."
            },
            {
                "name": "ARBLST",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Arbitration Lost ARBLST is set by\n              hardware to inform application that CEC device is\n              switching to reception due to arbitration lost event\n              following the TXSOM command. ARBLST can be due either\n              to a contending CEC device starting earlier or\n              starting at the same time but with higher HEADER\n              priority. After ARBLST assertion TXSOM bit keeps\n              pending for next transmission attempt. ARBLST is\n              cleared by software write at 1."
            },
            {
                "name": "TXBR",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Tx-Byte Request TXBR is set by hardware\n              to inform application that the next transmission data\n              has to be written to TXDR. TXBR is set when the 4th\n              bit of currently transmitted byte is sent.\n              Application must write the next byte to TXDR within 6\n              nominal data-bit periods before transmission underrun\n              error occurs (TXUDR). TXBR is cleared by software\n              write at 1."
            },
            {
                "name": "TXEND",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "End of Transmission TXEND is set by\n              hardware to inform application that the last byte of\n              the CEC message has been successfully transmitted.\n              TXEND clears the TXSOM and TXEOM control bits. TXEND\n              is cleared by software write at 1."
            },
            {
                "name": "TXUDR",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Tx-Buffer Underrun In transmission mode,\n              TXUDR is set by hardware if application was not in\n              time to load TXDR before of next byte transmission.\n              TXUDR aborts message transmission and clears TXSOM\n              and TXEOM control bits. TXUDR is cleared by software\n              write at 1"
            },
            {
                "name": "TXERR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Tx-Error In transmission mode, TXERR is\n              set by hardware if the CEC initiator detects low\n              impedance on the CEC line while it is released. TXERR\n              aborts message transmission and clears TXSOM and\n              TXEOM controls. TXERR is cleared by software write at\n              1."
            },
            {
                "name": "TXACKE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Tx-Missing Acknowledge Error In\n              transmission mode, TXACKE is set by hardware to\n              inform application that no acknowledge was received.\n              In case of broadcast transmission, TXACKE informs\n              application that a negative acknowledge was received.\n              TXACKE aborts message transmission and clears TXSOM\n              and TXEOM controls. TXACKE is cleared by software\n              write at 1."
            }
        ]
    },
    "1073772564": {
        "name": "CEC_IER",
        "address": 1073772564,
        "size": 32,
        "access": "read-write",
        "desc": "CEC interrupt enable register",
        "fields": [
            {
                "name": "RXBRIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rx-byte received interrupt enable\nThe RXBRIE bit is set and cleared by software."
            },
            {
                "name": "RXENDIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "End of reception interrupt enable\nThe RXENDIE bit is set and cleared by software."
            },
            {
                "name": "RXOVRIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Rx-buffer overrun interrupt enable\nThe RXOVRIE bit is set and cleared by software."
            },
            {
                "name": "BREIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Bit rising error interrupt enable\nThe BREIE bit is set and cleared by software."
            },
            {
                "name": "SBPEIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Short bit period error interrupt enable\nThe SBPEIE bit is set and cleared by software."
            },
            {
                "name": "LBPEIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Long bit period error interrupt enable\nThe LBPEIE bit is set and cleared by software."
            },
            {
                "name": "RXACKIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Rx-missing acknowledge error interrupt enable\nThe RXACKIE bit is set and cleared by software."
            },
            {
                "name": "ARBLSTIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Arbitration lost interrupt enable\nThe ARBLSTIE bit is set and cleared by software."
            },
            {
                "name": "TXBRIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Tx-byte request interrupt enable\nThe TXBRIE bit is set and cleared by software."
            },
            {
                "name": "TXENDIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Tx-end of message interrupt enable\nThe TXENDIE bit is set and cleared by software."
            },
            {
                "name": "TXUDRIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Tx-underrun interrupt enable\nThe TXUDRIE bit is set and cleared by software."
            },
            {
                "name": "TXERRIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Tx-error interrupt enable\nThe TXERRIE bit is set and cleared by software."
            },
            {
                "name": "TXACKIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Tx-missing acknowledge error interrupt enable\nThe TXACKEIE bit is set and cleared by software."
            }
        ]
    },
    "1073763328": {
        "name": "I2C_CR1",
        "address": 1073763328,
        "size": 32,
        "access": "read-write",
        "desc": "Control register 1",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Peripheral enable\nNote: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles."
            },
            {
                "name": "TXIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TX Interrupt enable"
            },
            {
                "name": "RXIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "RX Interrupt enable"
            },
            {
                "name": "ADDRIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address match Interrupt enable (slave only)"
            },
            {
                "name": "NACKIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not acknowledge received Interrupt enable"
            },
            {
                "name": "STOPIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Stop detection Interrupt enable"
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transfer Complete interrupt enable\nNote: Any of these events generate an interrupt:\nTransfer Complete (TC)\nTransfer Complete Reload (TCR)"
            },
            {
                "name": "ERRIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Error interrupts enable\nNote: Any of these errors generate an interrupt:\nArbitration Loss (ARLO)\nBus Error detection (BERR)\nOverrun/Underrun (OVR)\nTimeout detection (TIMEOUT)\nPEC error detection (PECERR)\nAlert pin event detection (ALERT)"
            },
            {
                "name": "DNF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Digital noise filter\nThese bits are used to configure the digital noise filter on SDA and SCL input. The digital filter, filters spikes with a length of up to DNF[3:0] * tI2CCLK\n...\nNote: If the analog filter is also enabled, the digital filter is added to the analog filter.\nThis filter can only be programmed when the I2C is disabled (PE = 0)."
            },
            {
                "name": "ANFOFF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Analog noise filter OFF\nNote: This bit can only be programmed when the I2C is disabled (PE = 0)."
            },
            {
                "name": "TXDMAEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "DMA transmission requests enable"
            },
            {
                "name": "RXDMAEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DMA reception requests enable"
            },
            {
                "name": "SBC",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Slave byte control\nThis bit is used to enable hardware byte control in slave mode."
            },
            {
                "name": "NOSTRETCH",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Clock stretching disable\nThis bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode.\nNote: This bit can only be programmed when the I2C is disabled (PE = 0)."
            },
            {
                "name": "WUPEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Wakeup from Stop mode enable\nNote: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to .\nNote: WUPEN can be set only when DNF = '0000'"
            },
            {
                "name": "GCEN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "General call enable"
            },
            {
                "name": "SMBHEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "SMBus Host Address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "SMBDEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "SMBus Device Default Address enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "ALERTEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "SMBus alert enable\nNote: When ALERTEN=0, the SMBA pin can be used as a standard GPIO.\nIf the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            },
            {
                "name": "PECEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "PEC enable\nNote: If the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            }
        ]
    },
    "1073763332": {
        "name": "I2C_CR2",
        "address": 1073763332,
        "size": 32,
        "access": "read-write",
        "desc": "Control register 2",
        "fields": [
            {
                "name": "SADD",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Slave address (master mode)\nIn 7-bit addressing mode (ADD10 = 0):\nSADD[7:1] should be written with the 7-bit slave address to be sent. The bits SADD[9], SADD[8] and SADD[0] are don't care.\nIn 10-bit addressing mode (ADD10 = 1):\nSADD[9:0] should be written with the 10-bit slave address to be sent.\nNote: Changing these bits when the START bit is set is not allowed."
            },
            {
                "name": "RD_WRN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Transfer direction (master mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "ADD10",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "10-bit addressing mode (master mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "HEAD10R",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "10-bit address header only read direction (master receiver mode)\nNote: Changing this bit when the START bit is set is not allowed."
            },
            {
                "name": "START",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Start generation\nThis bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing '1' to the ADDRCF bit in the I2C_ICR register.\nIf the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer.\nOtherwise setting this bit generates a START condition once the bus is free.\nNote: Writing '0' to this bit has no effect.\nThe START bit can be set even if the bus is BUSY or I2C is in slave mode.\nThis bit has no effect when RELOAD is set."
            },
            {
                "name": "STOP",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Stop generation (master mode)\nThe bit is set by software, cleared by hardware when a STOP condition is detected, or when PE = 0.\nIn Master Mode:\nNote: Writing '0' to this bit has no effect."
            },
            {
                "name": "NACK",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "NACK generation (slave mode)\nThe bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0.\nNote: Writing '0' to this bit has no effect.\nThis bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value.\nWhen an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value.\nWhen hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value."
            },
            {
                "name": "NBYTES",
                "bitOffset": 16,
                "bitWidth": 8,
                "desc": "Number of bytes\nThe number of bytes to be transmitted/received is programmed there. This field is don't care in slave mode with SBC=0.\nNote: Changing these bits when the START bit is set is not allowed."
            },
            {
                "name": "RELOAD",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "NBYTES reload mode\nThis bit is set and cleared by software."
            },
            {
                "name": "AUTOEND",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Automatic end mode (master mode)\nThis bit is set and cleared by software.\nNote: This bit has no effect in slave mode or when the RELOAD bit is set."
            },
            {
                "name": "PECBYTE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Packet error checking byte\nThis bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0.\nNote: Writing '0' to this bit has no effect.\nThis bit has no effect when RELOAD is set.\nThis bit has no effect is slave mode when SBC=0.\nIf the SMBus feature is not supported, this bit is reserved and forced by hardware to '0'. Refer to ."
            }
        ]
    },
    "1073763336": {
        "name": "I2C_OAR1",
        "address": 1073763336,
        "size": 32,
        "access": "read-write",
        "desc": "Own address register 1",
        "fields": [
            {
                "name": "OA1",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Interface own slave address\n7-bit addressing mode: OA1[7:1] contains the 7-bit own slave address. The bits OA1[9], OA1[8] and OA1[0] are don't care.\n10-bit addressing mode: OA1[9:0] contains the 10-bit own slave address.\nNote: These bits can be written only when OA1EN=0."
            },
            {
                "name": "OA1MODE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Own Address 1 10-bit mode\nNote: This bit can be written only when OA1EN=0."
            },
            {
                "name": "OA1EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Own Address 1 enable"
            }
        ]
    },
    "1073763340": {
        "name": "I2C_OAR2",
        "address": 1073763340,
        "size": 32,
        "access": "read-write",
        "desc": "Own address register 2",
        "fields": [
            {
                "name": "OA2",
                "bitOffset": 1,
                "bitWidth": 7,
                "desc": "Interface address\n7-bit addressing mode: 7-bit address\nNote: These bits can be written only when OA2EN=0."
            },
            {
                "name": "OA2MSK",
                "bitOffset": 8,
                "bitWidth": 3,
                "desc": "Own Address 2 masks\nNote: These bits can be written only when OA2EN=0.\nAs soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches."
            },
            {
                "name": "OA2EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Own Address 2 enable"
            }
        ]
    },
    "1073763344": {
        "name": "I2C_TIMINGR",
        "address": 1073763344,
        "size": 32,
        "access": "read-write",
        "desc": "Timing register",
        "fields": [
            {
                "name": "SCLL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "SCL low period (master\n              mode)"
            },
            {
                "name": "SCLH",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "SCL high period (master\n              mode)"
            },
            {
                "name": "SDADEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Data hold time"
            },
            {
                "name": "SCLDEL",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Data setup time"
            },
            {
                "name": "PRESC",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Timing prescaler"
            }
        ]
    },
    "1073763348": {
        "name": "I2C_TIMEOUTR",
        "address": 1073763348,
        "size": 32,
        "access": "read-write",
        "desc": "Status register 1",
        "fields": [
            {
                "name": "TIMEOUTA",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Bus Timeout A\nThis field is used to configure:\nThe SCL low timeout condition tTIMEOUT when TIDLE=0\ntTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK\nThe bus idle condition (both SCL and SDA high) when TIDLE=1\ntIDLE= (TIMEOUTA+1) x 4 x tI2CCLK\nNote: These bits can be written only when TIMOUTEN=0."
            },
            {
                "name": "TIDLE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Idle clock timeout detection\nNote: This bit can be written only when TIMOUTEN=0."
            },
            {
                "name": "TIMOUTEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Clock timeout enable"
            },
            {
                "name": "TIMEOUTB",
                "bitOffset": 16,
                "bitWidth": 12,
                "desc": "Bus timeout B\nThis field is used to configure the cumulative clock extension timeout:\nIn master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected\nIn slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected\ntLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK\nNote: These bits can be written only when TEXTEN=0."
            },
            {
                "name": "TEXTEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Extended clock timeout enable"
            }
        ]
    },
    "1073763352": {
        "name": "I2C_ISR",
        "address": 1073763352,
        "size": 32,
        "access": "",
        "desc": "Interrupt and Status register",
        "fields": [
            {
                "name": "ADDCODE",
                "bitOffset": 17,
                "bitWidth": 7,
                "desc": "Address match code (Slave\n              mode)"
            },
            {
                "name": "DIR",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Transfer direction (Slave mode)\nThis flag is updated when an address match event occurs (ADDR=1)."
            },
            {
                "name": "BUSY",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Bus busy"
            },
            {
                "name": "ALERT",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SMBus alert"
            },
            {
                "name": "TIMEOUT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Timeout or t_low detection\n              flag"
            },
            {
                "name": "PECERR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "PEC Error in reception"
            },
            {
                "name": "OVR",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Overrun/Underrun (slave\n              mode)"
            },
            {
                "name": "ARLO",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Arbitration lost"
            },
            {
                "name": "BERR",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Bus error"
            },
            {
                "name": "TCR",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transfer Complete Reload"
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transfer Complete (master\n              mode)"
            },
            {
                "name": "STOPF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Stop detection flag"
            },
            {
                "name": "NACKF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not acknowledge received\n              flag"
            },
            {
                "name": "ADDR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address matched (slave\n              mode)"
            },
            {
                "name": "RXNE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receive data register not empty\n              (receivers)"
            },
            {
                "name": "TXIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transmit interrupt status\n              (transmitters)"
            },
            {
                "name": "TXE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Transmit data register empty\n              (transmitters)"
            }
        ]
    },
    "1073763356": {
        "name": "I2C_ICR",
        "address": 1073763356,
        "size": 32,
        "access": "write-only",
        "desc": "Interrupt clear register",
        "fields": [
            {
                "name": "ALERTCF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Alert flag clear"
            },
            {
                "name": "TIMOUTCF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Timeout detection flag\n              clear"
            },
            {
                "name": "PECCF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "PEC Error flag clear"
            },
            {
                "name": "OVRCF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Overrun/Underrun flag\n              clear"
            },
            {
                "name": "ARLOCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Arbitration lost flag\n              clear"
            },
            {
                "name": "BERRCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Bus error flag clear"
            },
            {
                "name": "STOPCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Stop detection flag clear"
            },
            {
                "name": "NACKCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Not Acknowledge flag clear"
            },
            {
                "name": "ADDRCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Address Matched flag clear"
            }
        ]
    },
    "1073763360": {
        "name": "I2C_PECR",
        "address": 1073763360,
        "size": 32,
        "access": "read-only",
        "desc": "PEC register",
        "fields": [
            {
                "name": "PEC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Packet error checking\n              register"
            }
        ]
    },
    "1073763364": {
        "name": "I2C_RXDR",
        "address": 1073763364,
        "size": 32,
        "access": "read-only",
        "desc": "Receive data register",
        "fields": [
            {
                "name": "RXDATA",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit receive data"
            }
        ]
    },
    "1073763368": {
        "name": "I2C_TXDR",
        "address": 1073763368,
        "size": 32,
        "access": "read-write",
        "desc": "Transmit data register",
        "fields": [
            {
                "name": "TXDATA",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "8-bit transmit data"
            }
        ]
    },
    "1073754112": {
        "name": "IWDG_KR",
        "address": 1073754112,
        "size": 32,
        "access": "write-only",
        "desc": "Key register",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Key value (write only, read\n              0x0000)"
            }
        ]
    },
    "1073754116": {
        "name": "IWDG_PR",
        "address": 1073754116,
        "size": 32,
        "access": "read-write",
        "desc": "Prescaler register",
        "fields": [
            {
                "name": "PR",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Prescaler divider\nThese bits are write access protected see . They are written by software to select the prescaler divider feeding the counter clock. PVU bit of the  must be reset in order to be able to change the prescaler divider.\nNote: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the status register (IWDG_SR) is reset."
            }
        ]
    },
    "1073754120": {
        "name": "IWDG_RLR",
        "address": 1073754120,
        "size": 32,
        "access": "read-write",
        "desc": "Reload register",
        "fields": [
            {
                "name": "RL",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter reload\n              value"
            }
        ]
    },
    "1073754124": {
        "name": "IWDG_SR",
        "address": 1073754124,
        "size": 32,
        "access": "read-only",
        "desc": "Status register",
        "fields": [
            {
                "name": "PVU",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Watchdog prescaler value update\nThis bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to five LSI cycles).\nPrescaler value can be updated only when PVU bit is reset."
            },
            {
                "name": "RVU",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Watchdog counter reload value update\nThis bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles).\nReload value can be updated only when RVU bit is reset."
            },
            {
                "name": "WVU",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Watchdog counter window value update\nThis bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to five LSI cycles).\nWindow value can be updated only when WVU bit is reset."
            }
        ]
    },
    "1073754128": {
        "name": "IWDG_WINR",
        "address": 1073754128,
        "size": 32,
        "access": "read-write",
        "desc": "Window register",
        "fields": [
            {
                "name": "WIN",
                "bitOffset": 0,
                "bitWidth": 12,
                "desc": "Watchdog counter window\n              value"
            }
        ]
    },
    "1073773568": {
        "name": "LPTIM_ISR",
        "address": 1073773568,
        "size": 32,
        "access": "read-only",
        "desc": "Interrupt and Status Register",
        "fields": [
            {
                "name": "CMPM",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Compare match\nThe CMPM bit is set by hardware to inform application that LPTIM_CNT register value reached the LPTIM_CMP register's value."
            },
            {
                "name": "ARRM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match\nARRM is set by hardware to inform application that LPTIM_CNT register's value reached the LPTIM_ARR register's value. ARRM flag can be cleared by writing 1 to the ARRMCF bit in the LPTIM_ICR register."
            },
            {
                "name": "EXTTRIG",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger edge event\nEXTTRIG is set by hardware to inform application that a valid edge on the selected external trigger input has occurred. If the trigger is ignored because the timer has already started, then this flag is not set. EXTTRIG flag can be cleared by writing 1 to the EXTTRIGCF bit in the LPTIM_ICR register."
            },
            {
                "name": "CMPOK",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register update OK\nCMPOK is set by hardware to inform application that the APB bus write operation to the LPTIM_CMP register has been successfully completed."
            },
            {
                "name": "ARROK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK\nARROK is set by hardware to inform application that the APB bus write operation to the LPTIM_ARR register has been successfully completed. ARROK flag can be cleared by writing 1 to the ARROKCF bit in the LPTIM_ICR register."
            },
            {
                "name": "UP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Counter direction change down to up\nIn Encoder mode, UP bit is set by hardware to inform application that the counter direction has changed from down to up. UP flag can be cleared by writing 1 to the UPCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            },
            {
                "name": "DOWN",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Counter direction change up to down\nIn Encoder mode, DOWN bit is set by hardware to inform application that the counter direction has changed from up to down. DOWN flag can be cleared by writing 1 to the DOWNCF bit in the LPTIM_ICR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            }
        ]
    },
    "1073773572": {
        "name": "LPTIM_ICR",
        "address": 1073773572,
        "size": 32,
        "access": "write-only",
        "desc": "Interrupt Clear Register",
        "fields": [
            {
                "name": "CMPMCF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Compare match clear flag\nWriting 1 to this bit clears the CMP flag in the LPTIM_ISR register"
            },
            {
                "name": "ARRMCF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match clear flag\nWriting 1 to this bit clears the ARRM flag in the LPTIM_ISR register"
            },
            {
                "name": "EXTTRIGCF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge clear flag\nWriting 1 to this bit clears the EXTTRIG flag in the LPTIM_ISR register"
            },
            {
                "name": "CMPOKCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register update OK clear flag\nWriting 1 to this bit clears the CMPOK flag in the LPTIM_ISR register"
            },
            {
                "name": "ARROKCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK clear flag\nWriting 1 to this bit clears the ARROK flag in the LPTIM_ISR register"
            },
            {
                "name": "UPCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP clear flag\nWriting 1 to this bit clear the UP flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            },
            {
                "name": "DOWNCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down clear flag\nWriting 1 to this bit clear the DOWN flag in the LPTIM_ISR register.\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            }
        ]
    },
    "1073773576": {
        "name": "LPTIM_IER",
        "address": 1073773576,
        "size": 32,
        "access": "read-write",
        "desc": "Interrupt Enable Register",
        "fields": [
            {
                "name": "CMPMIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Compare match Interrupt Enable"
            },
            {
                "name": "ARRMIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Autoreload match Interrupt Enable"
            },
            {
                "name": "EXTTRIGIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "External trigger valid edge Interrupt Enable"
            },
            {
                "name": "CMPOKIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Compare register update OK Interrupt Enable"
            },
            {
                "name": "ARROKIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Autoreload register update OK Interrupt Enable"
            },
            {
                "name": "UPIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Direction change to UP Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            },
            {
                "name": "DOWNIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Direction change to down Interrupt Enable\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            }
        ]
    },
    "1073773580": {
        "name": "LPTIM_CFGR",
        "address": 1073773580,
        "size": 32,
        "access": "read-write",
        "desc": "Configuration Register",
        "fields": [
            {
                "name": "CKSEL",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clock selector\nThe CKSEL bit selects which clock source the LPTIM will use:"
            },
            {
                "name": "CKPOL",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Clock Polarity\nIf LPTIM is clocked by an external clock source:\nWhen the LPTIM is clocked by an external clock source, CKPOL bits is used to configure the active edge or edges used by the counter:\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 1 is active.\nIf the LPTIM is configured in Encoder mode (ENC bit is set), the encoder sub-mode 2 is active.\nRefer to  for more details about Encoder mode sub-modes."
            },
            {
                "name": "CKFLT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "Configurable digital filter for external clock\nThe CKFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an external clock signal before it is considered as a valid level transition. An internal clock source must be present to use this feature"
            },
            {
                "name": "TRGFLT",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "Configurable digital filter for trigger\nThe TRGFLT value sets the number of consecutive equal samples that should be detected when a level change occurs on an internal trigger before it is considered as a valid level transition. An internal clock source must be present to use this feature"
            },
            {
                "name": "PRESC",
                "bitOffset": 9,
                "bitWidth": 3,
                "desc": "Clock prescaler\nThe PRESC bits configure the prescaler division factor. It can be one among the following division factors:"
            },
            {
                "name": "TRIGSEL",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Trigger selector\nThe TRIGSEL bits select the trigger source that will serve as a trigger event for the LPTIM among the below 8 available sources:\nSee  for details."
            },
            {
                "name": "TRIGEN",
                "bitOffset": 17,
                "bitWidth": 2,
                "desc": "Trigger enable and polarity\nThe TRIGEN bits controls whether the LPTIM counter is started by an external trigger or not. If the external trigger option is selected, three configurations are possible for the trigger active edge:"
            },
            {
                "name": "TIMOUT",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Timeout enable\nThe TIMOUT bit controls the Timeout feature"
            },
            {
                "name": "WAVE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Waveform shape\nThe WAVE bit controls the output shape"
            },
            {
                "name": "WAVPOL",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Waveform shape polarity\nThe WAVEPOL bit controls the output polarity"
            },
            {
                "name": "PRELOAD",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Registers update mode\nThe PRELOAD bit controls the LPTIM_ARR and the LPTIM_CMP registers update modality"
            },
            {
                "name": "COUNTMODE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "counter mode enabled\nThe COUNTMODE bit selects which clock source is used by the LPTIM to clock the counter:"
            },
            {
                "name": "ENC",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Encoder mode enable\nThe ENC bit controls the Encoder mode\nNote: If the LPTIM does not support encoder mode feature, this bit is reserved. Please refer to ."
            }
        ]
    },
    "1073773584": {
        "name": "LPTIM_CR",
        "address": 1073773584,
        "size": 32,
        "access": "read-write",
        "desc": "Control Register",
        "fields": [
            {
                "name": "ENABLE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPTIM enable\nThe ENABLE bit is set and cleared by software."
            },
            {
                "name": "SNGSTRT",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPTIM start in Single mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = '00'), setting this bit starts the LPTIM in single pulse mode.\nIf the software start is disabled (TRIGEN[1:0] different than '00'), setting this bit starts the LPTIM in single pulse mode as soon as an external trigger is detected.\nIf this bit is set when the LPTIM is in continuous counting mode, then the LPTIM will stop at the following match between LPTIM_ARR and LPTIM_CNT registers.\nThis bit can only be set when the LPTIM is enabled. It will be automatically reset by hardware."
            },
            {
                "name": "CNTSTRT",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Timer start in Continuous mode\nThis bit is set by software and cleared by hardware.\nIn case of software start (TRIGEN[1:0] = '00'), setting this bit starts the LPTIM in Continuous mode.\nIf the software start is disabled (TRIGEN[1:0] different than '00'), setting this bit starts the timer in Continuous mode as soon as an external trigger is detected.\nIf this bit is set when a single pulse mode counting is ongoing, then the timer will not stop at the next match between the LPTIM_ARR and LPTIM_CNT registers and the LPTIM counter keeps counting in Continuous mode.\nThis bit can be set only when the LPTIM is enabled. It will be automatically reset by hardware."
            },
            {
                "name": "COUNTRST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Counter reset\nThis bit is set by software and cleared by hardware. When set to '1' this bit will trigger a synchronous reset of the LPTIM_CNT counter register. Due to the synchronous nature of this reset, it only takes place after a synchronization delay of 3 LPTimer core clock cycles (LPTimer core clock may be different from APB clock).\nCOUNTRST must never be set to '1' by software before it is already cleared to '0' by hardware. Software should consequently check that COUNTRST bit is already cleared to '0' before attempting to set it to '1'."
            },
            {
                "name": "RSTARE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Reset after read enable\nThis bit is set and cleared by software. When RSTARE is set to '1', any read access to LPTIM_CNT register will asynchronously reset LPTIM_CNT register content."
            }
        ]
    },
    "1073773588": {
        "name": "LPTIM_CMP",
        "address": 1073773588,
        "size": 32,
        "access": "read-write",
        "desc": "Compare Register",
        "fields": [
            {
                "name": "CMP",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Compare value"
            }
        ]
    },
    "1073773592": {
        "name": "LPTIM_ARR",
        "address": 1073773592,
        "size": 32,
        "access": "read-write",
        "desc": "Autoreload Register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto reload value"
            }
        ]
    },
    "1073773596": {
        "name": "LPTIM_CNT",
        "address": 1073773596,
        "size": 32,
        "access": "read-only",
        "desc": "Counter Register",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value"
            }
        ]
    },
    "1073773604": {
        "name": "LPTIM_CFGR2",
        "address": 1073773604,
        "size": 32,
        "access": "read-write",
        "desc": "LPTIM configuration register 2",
        "fields": [
            {
                "name": "IN1SEL",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "LPTIM input 1 selection\nThe IN1SEL bits control the LPTIM Input 1 multiplexer, which connects LPTIM Input 1 to one of the available inputs.\nFor connection details refer to ."
            },
            {
                "name": "IN2SEL",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "LPTIM input 2 selection\nThe IN2SEL bits control the LPTIM Input 2 multiplexer, which connect LPTIM Input 2 to one of the available inputs.\nFor connection details refer to .\nNote: If the LPTIM does not support encoder mode feature, these bits are reserved. Please refer to ."
            }
        ]
    },
    "1073774592": {
        "name": "LPUART_CR1_enabled",
        "address": 1073774592,
        "size": 32,
        "access": "",
        "desc": "LPUART control register 1 [alternate] ",
        "fields": [
            {
                "name": "UE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPUART enable\nWhen this bit is cleared, the LPUART prescalers and outputs are stopped immediately, and current operations are discarded. The configuration of the LPUART is kept, but all the status flags, in the LPUART_ISR are reset. This bit is set and cleared by software.\nNote: To enter low-power mode without generating errors on the line, the TE bit must be reset before and the software must wait for the TC bit in the LPUART_ISR to be set before resetting the UE bit.\nThe DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit."
            },
            {
                "name": "UESM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPUART enable in Stop mode\nWhen this bit is cleared, the LPUART is not able to wake up the MCU from low-power mode.\nWhen this bit is set, the LPUART is able to wake up the MCU from low-power mode, provided that the LPUART clock selection is HSI or LSE in the RCC.\nThis bit is set and cleared by software.\nNote: It is recommended to set the UESM bit just before entering low-power mode and clear it on exit from low-power mode."
            },
            {
                "name": "RE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software."
            },
            {
                "name": "TE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit ('0' followed by '1') sends a preamble (idle line) after the current word. In order to generate an idle character, the TE must not be immediately written to 1. In order to ensure the required duration, the software can poll the TEACK bit in the LPUART_ISR register.\nWhen TE is set there is a 1 bit-time delay before the transmission starts."
            },
            {
                "name": "IDLEIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "IDLE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFNEIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFNFIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PEIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "PE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "PCE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "WAKE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver wakeup method\nThis bit determines the LPUART wakeup method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "M0",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1) description).\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "MME",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Mute mode enable\nThis bit activates the Mute mode function of the LPUART. When set, the LPUART can switch between the active and Mute modes, as defined by the WAKE bit. It is set and cleared by software."
            },
            {
                "name": "CMIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Character match interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "DEDT",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Driver Enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal.It is expressed in lpuart_ker_ck clock cycles. For more details, refer control and RS485 Driver Enable.\nIf the LPUART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DEAT",
                "bitOffset": 21,
                "bitWidth": 5,
                "desc": "Driver Enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in lpuart_ker_ck clock cycles. For more details, refer .\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "M1",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] = '00': 1 Start bit, 8 Data bits, n Stop bit\nM[1:0] = '01': 1 Start bit, 9 Data bits, n Stop bit\nM[1:0] = '10': 1 Start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the LPUART is disabled (UE=0).\nNote: In 7-bit data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported."
            },
            {
                "name": "FIFOEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "FIFO mode enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFEIE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TXFIFO empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFFIE",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RXFIFO Full interrupt enable\nThis bit is set and cleared by software."
            }
        ]
    },
    "1073774596": {
        "name": "LPUART_CR2",
        "address": 1073774596,
        "size": 32,
        "access": "",
        "desc": "LPUART control register 2 ",
        "fields": [
            {
                "name": "ADDM7",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "7-bit Address Detection/4-bit Address Detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\nThis bit can only be written when the LPUART is disabled (UE=0)\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively."
            },
            {
                "name": "STOP",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "STOP bits\nThese bits are used for programming the stop bits.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "SWAP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Swap TX/RX pins\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "RXINV",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "RX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "TXINV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DATAINV",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Binary data inversion\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "MSBFIRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Most significant bit first\nThis bit is set and cleared by software.\nThis bitfield can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "ADD",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Address of the LPUART node\nADD[7:4]:\nThese bits give the address of the LPUART node or a character code to be recognized.\nThey are used to wake up the MCU with 7-bit address mark detection in multiprocessor communication during Mute mode or Stop mode. The MSB of the character sent by the transmitter should be equal to 1. They can also be used for character detection during normal reception, Mute mode inactive (for example, end of block detection in ModBus protocol). In this case, the whole received character (8-bit) is compared to the ADD[7:0] value and CMF flag is set on match.\nThese bits can only be written when reception is disabled (RE = 0) or the LPUART is disabled (UE=0)\nADD[3:0]:\nThese bits give the address of the LPUART node or a character code to be recognized.\nThey are used for wakeup with address mark detection in multiprocessor communication during Mute mode or low-power mode.\nThese bits can only be written when reception is disabled (RE = 0) or the LPUART is disabled (UE=0)"
            }
        ]
    },
    "1073774600": {
        "name": "LPUART_CR3",
        "address": 1073774600,
        "size": 32,
        "access": "",
        "desc": "LPUART control register 3 ",
        "fields": [
            {
                "name": "EIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error or noise flag (FE=1 or ORE=1 or NE=1 in the LPUART_ISR register)."
            },
            {
                "name": "HDSEL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Half-duplex selection\nSelection of Single-wire Half-duplex mode\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DMAR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA enable receiver\nThis bit is set/reset by software"
            },
            {
                "name": "DMAT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA enable transmitter\nThis bit is set/reset by software"
            },
            {
                "name": "RTSE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "RTS enable\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "CTSE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS enable\nThis bit can only be written when the LPUART is disabled (UE=0)"
            },
            {
                "name": "CTSIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS interrupt enable"
            },
            {
                "name": "OVRDIS",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun Disable\nThis bit is used to disable the receive overrun detection.\nthe ORE flag is not set and the new received data overwrites the previous content of the LPUART_RDR register.\nThis bit can only be written when the LPUART is disabled (UE=0).\nNote: This control bit enables checking the communication flow w/o reading the data."
            },
            {
                "name": "DDRE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DMA Disable on Reception Error\nThis bit can only be written when the LPUART is disabled (UE=0).\nNote: The reception errors are: parity error, framing error or noise error."
            },
            {
                "name": "DEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "DEP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Driver enable polarity selection\nThis bit can only be written when the LPUART is disabled (UE=0)."
            },
            {
                "name": "WUS",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Wakeup from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).\nThis bitfield can only be written when the LPUART is disabled (UE=0).\nNote: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "WUFIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode interrupt enable\nThis bit is set and cleared by software.\nNote: WUFIE must be set before entering in low-power mode.\nIf the LPUART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "TXFTIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFTCFG",
                "bitOffset": 25,
                "bitWidth": 3,
                "desc": "Receive FIFO threshold configuration\nRemaining combinations: Reserved."
            },
            {
                "name": "RXFTIE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "RXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFTCFG",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "TXFIFO threshold configuration\nRemaining combinations: Reserved."
            }
        ]
    },
    "1073774604": {
        "name": "LPUART_BRR",
        "address": 1073774604,
        "size": 32,
        "access": "",
        "desc": "LPUART baud rate register ",
        "fields": [
            {
                "name": "BRR",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "LPUART baud rate"
            }
        ]
    },
    "1073774616": {
        "name": "LPUART_RQR",
        "address": 1073774616,
        "size": 32,
        "access": "",
        "desc": "LPUART request register ",
        "fields": [
            {
                "name": "SBKRQ",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\nNote: If the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit."
            },
            {
                "name": "MMRQ",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Mute mode request\nWriting 1 to this bit puts the LPUART in Mute mode and resets the RWU flag."
            },
            {
                "name": "RXFRQ",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Receive data flush request\nWriting 1 to this bit clears the RXNE flag.\nThis enables discarding the received data without reading it, and avoid an overrun condition."
            },
            {
                "name": "TXFRQ",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Transmit data flush request\nThis bit is used when FIFO mode is enabled. TXFRQ bit is set to flush the whole FIFO. This sets the flag TXFE (TXFIFO empty, bit 23 in the LPUART_ISR register).\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register."
            }
        ]
    },
    "1073774620": {
        "name": "LPUART_ISR_enabled",
        "address": 1073774620,
        "size": 32,
        "access": "",
        "desc": "LPUART interrupt and status register [alternate] ",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the LPUART_ICR register.\nAn interrupt is generated if PEIE = 1 in the LPUART_CR1 register.\nNote: This error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "FE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the LPUART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE=1 in the LPUART_CR1 register.\nNote: This error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Start bit noise detection flag\nThis bit is set by hardware when noise is detected on the start bit of a received frame. It is cleared by software, writing 1 to the NECF bit in the LPUART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.\nThis error is associated with the character in the LPUART_RDR."
            },
            {
                "name": "ORE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the LPUART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the LPUART_ICR register.\nAn interrupt is generated if RXFNEIE=1 or EIE = 1 in the LPUART_CR1 register.\nNote: When this bit is set, the LPUART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.\nThis bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the LPUART_CR3 register."
            },
            {
                "name": "IDLE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected\nThis bit is set by hardware when an Idle line is detected. An interrupt is generated if IDLEIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the LPUART_ICR register.\nNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).\nIf Mute mode is enabled (MME=1), IDLE is set if the LPUART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set."
            },
            {
                "name": "RXFNE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty\nRXFNE bit is set by hardware when the RXFIFO is not empty, and so data can be read from the LPUART_RDR register. Every read of the LPUART_RDR frees a location in the RXFIFO. It is cleared when the RXFIFO is empty.\nThe RXFNE flag can also be cleared by writing 1 to the RXFRQ in the LPUART_RQR register.\nAn interrupt is generated if RXFNEIE=1 in the LPUART_CR1 register."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete\nThis bit is set by hardware if the transmission of a frame containing data is complete and if TXFF is set. An interrupt is generated if TCIE=1 in the LPUART_CR1 register. It is cleared by software, writing 1 to the TCCF in the LPUART_ICR register or by a write to the LPUART_TDR register.\nAn interrupt is generated if TCIE=1 in the LPUART_CR1 register.\nNote: If TE bit is reset and no transmission is on going, the TC bit is set immediately."
            },
            {
                "name": "TXFNF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full\nTXFNF is set by hardware when TXFIFO is not full, and so data can be written in the LPUART_TDR. Every write in the LPUART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the LPUART_TDR.\nThe TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time).\nAn interrupt is generated if the TXFNFIE bit =1 in the LPUART_CR1 register.\nNote: This bit is used during single buffer transmission."
            },
            {
                "name": "CTSIF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS interrupt flag\nThis bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the LPUART_ICR register.\nAn interrupt is generated if CTSIE=1 in the LPUART_CR3 register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "CTS",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "BUSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not)."
            },
            {
                "name": "CMF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the LPUART_ICR register.\nAn interrupt is generated if CMIE=1in the LPUART_CR1 register."
            },
            {
                "name": "SBKF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the LPUART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission."
            },
            {
                "name": "RWU",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Receiver wakeup from Mute mode\nThis bit indicates if the LPUART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the LPUART_CR1 register.\nWhen wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the LPUART_RQR register.\nNote: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "WUF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode flag\nThis bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the LPUART_ICR register.\nAn interrupt is generated if WUFIE=1 in the LPUART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nIf the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value"
            },
            {
                "name": "TEACK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the LPUART.\nIt can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the LPUART_CR1 register, in order to respect the TE=0 minimum period."
            },
            {
                "name": "REACK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the LPUART.\nIt can be used to verify that the LPUART is ready for reception before entering low-power mode.\nNote: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "TXFE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO empty\nThis bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the LPUART_RQR register.\nAn interrupt is generated if the TXFEIE bit =1 (bit 30) in the LPUART_CR1 register."
            },
            {
                "name": "RXFF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "RXFIFO full\nThis bit is set by hardware when the number of received data corresponds to RXFIFOsize+1 (RXFIFO full + 1 data in the LPUART_RDR register.\nAn interrupt is generated if the RXFFIE bit =1 in the LPUART_CR1 register."
            },
            {
                "name": "RXFT",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "RXFIFO threshold flag\nThis bit is set by hardware when the RXFIFO reaches the threshold programmed in RXFTCFG in LPUART_CR3 register i.e. the Receive FIFO contains RXFTCFG data. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the LPUART_CR3 register."
            },
            {
                "name": "TXFT",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "TXFIFO threshold flag\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG in LPUART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the LPUART_CR3 register."
            }
        ]
    },
    "1073774624": {
        "name": "LPUART_ICR",
        "address": 1073774624,
        "size": 32,
        "access": "",
        "desc": "LPUART interrupt flag clear register ",
        "fields": [
            {
                "name": "PECF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error clear flag\nWriting 1 to this bit clears the PE flag in the LPUART_ISR register."
            },
            {
                "name": "FECF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error clear flag\nWriting 1 to this bit clears the FE flag in the LPUART_ISR register."
            },
            {
                "name": "NECF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the LPUART_ISR register."
            },
            {
                "name": "ORECF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the LPUART_ISR register."
            },
            {
                "name": "IDLECF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the LPUART_ISR register."
            },
            {
                "name": "TCCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the LPUART_ISR register."
            },
            {
                "name": "CTSCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the LPUART_ISR register."
            },
            {
                "name": "CMCF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match clear flag\nWriting 1 to this bit clears the CMF flag in the LPUART_ISR register."
            },
            {
                "name": "WUCF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the LPUART_ISR register.\nNote: If the LPUART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
            }
        ]
    },
    "1073774628": {
        "name": "LPUART_RDR",
        "address": 1073774628,
        "size": 32,
        "access": "",
        "desc": "LPUART receive data register ",
        "fields": [
            {
                "name": "RDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Receive data value\nContains the received data character.\nThe RDR register provides the parallel interface between the input shift register and the internal bus (see ).\nWhen receiving with the parity enabled, the value read in the MSB bit is the received parity bit."
            }
        ]
    },
    "1073774632": {
        "name": "LPUART_TDR",
        "address": 1073774632,
        "size": 32,
        "access": "",
        "desc": "LPUART transmit data register ",
        "fields": [
            {
                "name": "TDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Transmit data value\nContains the data character to be transmitted.\nThe TDR register provides the parallel interface between the internal bus and the output shift register (see ).\nWhen transmitting with the parity enabled (PCE bit set to 1 in the LPUART_CR1 register), the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect because it is replaced by the parity.\nNote: This register must be written only when TXE/TXFNF=1."
            }
        ]
    },
    "1073774636": {
        "name": "LPUART_PRESC",
        "address": 1073774636,
        "size": 32,
        "access": "",
        "desc": "LPUART prescaler register ",
        "fields": [
            {
                "name": "PRESCALER",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Clock prescaler\nThe LPUART input clock can be divided by a prescaler:\nRemaining combinations: Reserved.\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256."
            }
        ]
    },
    "1073770496": {
        "name": "CR1",
        "address": 1073770496,
        "size": 32,
        "access": "read-write",
        "desc": "Power control register 1",
        "fields": [
            {
                "name": "LPR",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Low-power run"
            },
            {
                "name": "VOS",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "Voltage scaling range\n              selection"
            },
            {
                "name": "DBP",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Disable backup domain write\n              protection"
            },
            {
                "name": "FPD_LPSLP",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Flash memory powered down during\n              Low-power sleep mode"
            },
            {
                "name": "FPD_LPRUN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Flash memory powered down during\n              Low-power run mode"
            },
            {
                "name": "FPD_STOP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Flash memory powered down during Stop\n              mode"
            },
            {
                "name": "LPMS",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Low-power mode selection"
            }
        ]
    },
    "1073770500": {
        "name": "CR2",
        "address": 1073770500,
        "size": 32,
        "access": "read-write",
        "desc": "Power control register 2",
        "fields": [
            {
                "name": "PVDE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Power voltage detector\n              enable"
            },
            {
                "name": "PVDFT",
                "bitOffset": 1,
                "bitWidth": 3,
                "desc": "Power voltage detector falling threshold selection"
            },
            {
                "name": "PVDRT",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Power voltage detector rising threshold selection"
            },
            {
                "name": "PVMENDAC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "PVMENDAC"
            },
            {
                "name": "PVMENUSB",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "PVMENUSB"
            },
            {
                "name": "IOSV",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "IOSV"
            },
            {
                "name": "USV",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "USV"
            }
        ]
    },
    "1073770504": {
        "name": "CR3",
        "address": 1073770504,
        "size": 32,
        "access": "read-write",
        "desc": "Power control register 3",
        "fields": [
            {
                "name": "EWUP1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Enable Wakeup pin WKUP1"
            },
            {
                "name": "EWUP2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Enable Wakeup pin WKUP2"
            },
            {
                "name": "EWUP3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Enable Wakeup pin WKUP3"
            },
            {
                "name": "EWUP4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Enable Wakeup pin WKUP4"
            },
            {
                "name": "EWUP5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Enable WKUP5 wakeup pin"
            },
            {
                "name": "EWUP6",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Enable WKUP6 wakeup pin"
            },
            {
                "name": "RRS",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM retention in Standby\n              mode"
            },
            {
                "name": "ENB_ULP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Ultra-low-power enable"
            },
            {
                "name": "APC",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Apply pull-up and pull-down\n              configuration"
            },
            {
                "name": "EIWUL",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Enable internal wakeup\n              line"
            }
        ]
    },
    "1073770508": {
        "name": "CR4",
        "address": 1073770508,
        "size": 32,
        "access": "read-write",
        "desc": "Power control register 4",
        "fields": [
            {
                "name": "WP1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP1 polarity"
            },
            {
                "name": "WP2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP2 polarity"
            },
            {
                "name": "WP3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP3 polarity"
            },
            {
                "name": "WP4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP4 polarity"
            },
            {
                "name": "WP5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Wakeup pin WKUP5 polarity"
            },
            {
                "name": "WP6",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "WKUP6 wakeup pin polarity"
            },
            {
                "name": "VBE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "VBAT battery charging\n              enable"
            },
            {
                "name": "VBRS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "VBAT battery charging resistor\n              selection"
            }
        ]
    },
    "1073770512": {
        "name": "SR1",
        "address": 1073770512,
        "size": 32,
        "access": "read-only",
        "desc": "Power status register 1",
        "fields": [
            {
                "name": "WUF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Wakeup flag 1"
            },
            {
                "name": "WUF2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Wakeup flag 2"
            },
            {
                "name": "WUF3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup flag 3"
            },
            {
                "name": "WUF4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Wakeup flag 4"
            },
            {
                "name": "WUF5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Wakeup flag 5"
            },
            {
                "name": "WUF6",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Wakeup flag 6"
            },
            {
                "name": "SBF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Standby flag"
            },
            {
                "name": "WUFI",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Wakeup flag internal"
            }
        ]
    },
    "1073770516": {
        "name": "SR2",
        "address": 1073770516,
        "size": 32,
        "access": "read-only",
        "desc": "Power status register 2",
        "fields": [
            {
                "name": "PVMODAC",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "VDDA monitoring output flag"
            },
            {
                "name": "PVMOUSB",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "USB supply voltage monitoring output flag"
            },
            {
                "name": "PVDO",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Power voltage detector\n              output"
            },
            {
                "name": "VOSF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Voltage scaling flag"
            },
            {
                "name": "REGLPF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Low-power regulator flag"
            },
            {
                "name": "REGLPS",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Low-power regulator\n              started"
            },
            {
                "name": "FLASH_RDY",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Flash ready flag"
            }
        ]
    },
    "1073770520": {
        "name": "SCR",
        "address": 1073770520,
        "size": 32,
        "access": "write-only",
        "desc": "Power status clear register",
        "fields": [
            {
                "name": "CSBF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Clear standby flag"
            },
            {
                "name": "CWUF6",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 6"
            },
            {
                "name": "CWUF5",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 5"
            },
            {
                "name": "CWUF4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 4"
            },
            {
                "name": "CWUF3",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 3"
            },
            {
                "name": "CWUF2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 2"
            },
            {
                "name": "CWUF1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear wakeup flag 1"
            }
        ]
    },
    "1073770528": {
        "name": "PUCRA",
        "address": 1073770528,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port A pull-up control\n          register",
        "fields": [
            {
                "name": "PU15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port A pull-up bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770532": {
        "name": "PDCRA",
        "address": 1073770532,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port A pull-down control\n          register",
        "fields": [
            {
                "name": "PD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port A pull-down bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770536": {
        "name": "PUCRB",
        "address": 1073770536,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port B pull-up control\n          register",
        "fields": [
            {
                "name": "PU15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port B pull-up bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770540": {
        "name": "PDCRB",
        "address": 1073770540,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port B pull-down control\n          register",
        "fields": [
            {
                "name": "PD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port B pull-down bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770544": {
        "name": "PUCRC",
        "address": 1073770544,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port C pull-up control\n          register",
        "fields": [
            {
                "name": "PU15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port C pull-up bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770548": {
        "name": "PDCRC",
        "address": 1073770548,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port C pull-down control\n          register",
        "fields": [
            {
                "name": "PD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port C pull-down bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770552": {
        "name": "PUCRD",
        "address": 1073770552,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port D pull-up control\n          register",
        "fields": [
            {
                "name": "PU15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port D pull-up bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770556": {
        "name": "PDCRD",
        "address": 1073770556,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port D pull-down control\n          register",
        "fields": [
            {
                "name": "PD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port D pull-down bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770560": {
        "name": "PUCRE",
        "address": 1073770560,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port E pull-UP control\n          register",
        "fields": [
            {
                "name": "PU15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port E pull-up bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770564": {
        "name": "PDCRE",
        "address": 1073770564,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port E pull-down control\n          register",
        "fields": [
            {
                "name": "PD15",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD14",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port E pull-down bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770568": {
        "name": "PUCRF",
        "address": 1073770568,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port F pull-up control\n          register",
        "fields": [
            {
                "name": "PU13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            },
            {
                "name": "PU0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port F pull-up bit y\n              (y=0..15)"
            }
        ]
    },
    "1073770572": {
        "name": "PDCRF",
        "address": 1073770572,
        "size": 32,
        "access": "read-write",
        "desc": "Power Port F pull-down control\n          register",
        "fields": [
            {
                "name": "PD13",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD12",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD11",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD10",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD9",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD8",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD7",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD6",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD5",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD4",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            },
            {
                "name": "PD0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Port F pull-down bit y\n              (y=0..15)"
            }
        ]
    },
    "1073876992": {
        "name": "CR",
        "address": 1073876992,
        "size": 32,
        "access": "read-write",
        "desc": "Clock control register",
        "fields": [
            {
                "name": "HSION",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "HSI16 clock enable"
            },
            {
                "name": "HSIKERON",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "HSI16 always enable for peripheral\n              kernels"
            },
            {
                "name": "HSIRDY",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "HSI16 clock ready flag"
            },
            {
                "name": "HSIDIV",
                "bitOffset": 11,
                "bitWidth": 3,
                "desc": "HSI16 clock division\n              factor"
            },
            {
                "name": "HSEON",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "HSE clock enable"
            },
            {
                "name": "HSERDY",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "HSE clock ready flag"
            },
            {
                "name": "HSEBYP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "HSE crystal oscillator\n              bypass"
            },
            {
                "name": "CSSON",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Clock security system\n              enable"
            },
            {
                "name": "HSI48ON",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "HSI48ON"
            },
            {
                "name": "HSI48RDY",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "HSI48RDY"
            },
            {
                "name": "PLLON",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "PLL enable"
            },
            {
                "name": "PLLRDY",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "PLL clock ready flag"
            }
        ]
    },
    "1073876996": {
        "name": "ICSCR",
        "address": 1073876996,
        "size": 32,
        "access": "",
        "desc": "Internal clock sources calibration\n          register",
        "fields": [
            {
                "name": "HSICAL",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "HSI16 clock calibration"
            },
            {
                "name": "HSITRIM",
                "bitOffset": 8,
                "bitWidth": 7,
                "desc": "HSI16 clock trimming"
            }
        ]
    },
    "1073877000": {
        "name": "CFGR",
        "address": 1073877000,
        "size": 32,
        "access": "",
        "desc": "Clock configuration register",
        "fields": [
            {
                "name": "MCOPRE",
                "bitOffset": 28,
                "bitWidth": 4,
                "desc": "Microcontroller clock output\n              prescaler"
            },
            {
                "name": "MCOSEL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Microcontroller clock\n              output"
            },
            {
                "name": "MCO2PRE",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "MCO2PRE"
            },
            {
                "name": "MCO2SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "MCO2SEL"
            },
            {
                "name": "PPRE",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "APB prescaler"
            },
            {
                "name": "HPRE",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "AHB prescaler"
            },
            {
                "name": "SWS",
                "bitOffset": 3,
                "bitWidth": 3,
                "desc": "System clock switch status"
            },
            {
                "name": "SW",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "System clock switch"
            }
        ]
    },
    "1073877004": {
        "name": "PLLCFGR",
        "address": 1073877004,
        "size": 32,
        "access": "read-write",
        "desc": "PLL configuration register",
        "fields": [
            {
                "name": "PLLSRC",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "PLL input clock source"
            },
            {
                "name": "PLLM",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Division factor M of the PLL input clock\n              divider"
            },
            {
                "name": "PLLN",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "PLL frequency multiplication factor\n              N"
            },
            {
                "name": "PLLPEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "PLLPCLK clock output\n              enable"
            },
            {
                "name": "PLLP",
                "bitOffset": 17,
                "bitWidth": 5,
                "desc": "PLL VCO division factor P for PLLPCLK\n              clock output"
            },
            {
                "name": "PLLQEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "PLLQCLK clock output\n              enable"
            },
            {
                "name": "PLLQ",
                "bitOffset": 25,
                "bitWidth": 3,
                "desc": "PLL VCO division factor Q for PLLQCLK\n              clock output"
            },
            {
                "name": "PLLREN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "PLLRCLK clock output\n              enable"
            },
            {
                "name": "PLLR",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "PLL VCO division factor R for PLLRCLK\n              clock output"
            }
        ]
    },
    "1073877012": {
        "name": "CRRCR",
        "address": 1073877012,
        "size": 32,
        "access": "read-only",
        "desc": "RCC clock recovery RC register",
        "fields": [
            {
                "name": "HSI48CAL",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "HSI48 clock calibration"
            }
        ]
    },
    "1073877016": {
        "name": "CIER",
        "address": 1073877016,
        "size": 32,
        "access": "read-write",
        "desc": "Clock interrupt enable\n          register",
        "fields": [
            {
                "name": "LSIRDYIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI ready interrupt enable"
            },
            {
                "name": "LSERDYIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt enable"
            },
            {
                "name": "HSIRDYIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI ready interrupt enable"
            },
            {
                "name": "HSERDYIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE ready interrupt enable"
            },
            {
                "name": "PLLSYSRDYIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "PLL ready interrupt enable"
            }
        ]
    },
    "1073877020": {
        "name": "CIFR",
        "address": 1073877020,
        "size": 32,
        "access": "read-only",
        "desc": "Clock interrupt flag register",
        "fields": [
            {
                "name": "LSIRDYF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI ready interrupt flag"
            },
            {
                "name": "LSERDYF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt flag"
            },
            {
                "name": "HSI48RDYF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "HSI48RDYF"
            },
            {
                "name": "HSIRDYF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI ready interrupt flag"
            },
            {
                "name": "HSERDYF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE ready interrupt flag"
            },
            {
                "name": "PLLSYSRDYF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "PLL ready interrupt flag"
            },
            {
                "name": "CSSF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Clock security system interrupt\n              flag"
            },
            {
                "name": "LSECSSF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "LSE Clock security system interrupt\n              flag"
            }
        ]
    },
    "1073877024": {
        "name": "CICR",
        "address": 1073877024,
        "size": 32,
        "access": "write-only",
        "desc": "Clock interrupt clear register",
        "fields": [
            {
                "name": "LSIRDYC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI ready interrupt clear"
            },
            {
                "name": "LSERDYC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE ready interrupt clear"
            },
            {
                "name": "HSI48RDYC",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "HSI48RDYC"
            },
            {
                "name": "HSIRDYC",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "HSI ready interrupt clear"
            },
            {
                "name": "HSERDYC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HSE ready interrupt clear"
            },
            {
                "name": "PLLSYSRDYC",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "PLL ready interrupt clear"
            },
            {
                "name": "CSSC",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Clock security system interrupt\n              clear"
            },
            {
                "name": "LSECSSC",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "LSE Clock security system interrupt\n              clear"
            }
        ]
    },
    "1073877028": {
        "name": "IOPRSTR",
        "address": 1073877028,
        "size": 32,
        "access": "read-write",
        "desc": "I/O port reset register",
        "fields": [
            {
                "name": "GPIOARST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "GPIOARST"
            },
            {
                "name": "GPIOBRST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "GPIOBRST"
            },
            {
                "name": "GPIOCRST",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "GPIOCRST"
            },
            {
                "name": "GPIODRST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "GPIODRST"
            },
            {
                "name": "GPIOERST",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "GPIOERST"
            },
            {
                "name": "GPIOFRST",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "GPIOFRST"
            }
        ]
    },
    "1073877032": {
        "name": "AHBRSTR",
        "address": 1073877032,
        "size": 32,
        "access": "read-write",
        "desc": "AHB peripheral reset register",
        "fields": [
            {
                "name": "DMA1RST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMA1 reset"
            },
            {
                "name": "DMA2RST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DMA1 reset"
            },
            {
                "name": "FLASHRST",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "FLITF reset"
            },
            {
                "name": "CRCRST",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC reset"
            },
            {
                "name": "AESRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "AES hardware accelerator\n              reset"
            },
            {
                "name": "RNGRST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Random number generator\n              reset"
            }
        ]
    },
    "1073877036": {
        "name": "APBRSTR1",
        "address": 1073877036,
        "size": 32,
        "access": "read-write",
        "desc": "APB peripheral reset register\n          1",
        "fields": [
            {
                "name": "TIM2RST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 timer reset"
            },
            {
                "name": "TIM3RST",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 timer reset"
            },
            {
                "name": "TIM4RST",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TIM4 timer reset"
            },
            {
                "name": "TIM6RST",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 timer reset"
            },
            {
                "name": "TIM7RST",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 timer reset"
            },
            {
                "name": "LPUART2RST",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPUART2RST"
            },
            {
                "name": "USART5RST",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "USART5RST"
            },
            {
                "name": "USART6RST",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "USART6RST"
            },
            {
                "name": "FDCANRST",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "FDCANRST"
            },
            {
                "name": "USBRST",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "USBRST"
            },
            {
                "name": "SPI2RST",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SPI2 reset"
            },
            {
                "name": "SPI3RST",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SPI3 reset"
            },
            {
                "name": "CRSRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CRSRST"
            },
            {
                "name": "USART2RST",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 reset"
            },
            {
                "name": "USART3RST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "USART3 reset"
            },
            {
                "name": "USART4RST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "USART4 reset"
            },
            {
                "name": "LPUART1RST",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "LPUART1 reset"
            },
            {
                "name": "I2C1RST",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 reset"
            },
            {
                "name": "I2C2RST",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C2 reset"
            },
            {
                "name": "I2C3RST",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "I2C3RST reset"
            },
            {
                "name": "CECRST",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "HDMI CEC reset"
            },
            {
                "name": "UCPD1RST",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "UCPD1 reset"
            },
            {
                "name": "UCPD2RST",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "UCPD2 reset"
            },
            {
                "name": "DBGRST",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Debug support reset"
            },
            {
                "name": "PWRRST",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Power interface reset"
            },
            {
                "name": "DAC1RST",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "DAC1 interface reset"
            },
            {
                "name": "LPTIM2RST",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Low Power Timer 2 reset"
            },
            {
                "name": "LPTIM1RST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Low Power Timer 1 reset"
            }
        ]
    },
    "1073877040": {
        "name": "APBRSTR2",
        "address": 1073877040,
        "size": 32,
        "access": "read-write",
        "desc": "APB peripheral reset register\n          2",
        "fields": [
            {
                "name": "SYSCFGRST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYSCFG, COMP and VREFBUF\n              reset"
            },
            {
                "name": "TIM1RST",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 timer reset"
            },
            {
                "name": "SPI1RST",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 reset"
            },
            {
                "name": "USART1RST",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 reset"
            },
            {
                "name": "TIM14RST",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "TIM14 timer reset"
            },
            {
                "name": "TIM15RST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "TIM15 timer reset"
            },
            {
                "name": "TIM16RST",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 timer reset"
            },
            {
                "name": "TIM17RST",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "TIM17 timer reset"
            },
            {
                "name": "ADCRST",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "ADC reset"
            }
        ]
    },
    "1073877044": {
        "name": "IOPENR",
        "address": 1073877044,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO clock enable register",
        "fields": [
            {
                "name": "GPIOAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I/O port A clock enable during Sleep\n              mode"
            },
            {
                "name": "GPIOBEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "I/O port B clock enable during Sleep\n              mode"
            },
            {
                "name": "GPIOCEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "I/O port C clock enable during Sleep\n              mode"
            },
            {
                "name": "GPIODEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "I/O port D clock enable during Sleep\n              mode"
            },
            {
                "name": "GPIOEEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "I/O port E clock enable during Sleep\n              mode"
            },
            {
                "name": "GPIOFEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "I/O port F clock enable during Sleep\n              mode"
            }
        ]
    },
    "1073877048": {
        "name": "AHBENR",
        "address": 1073877048,
        "size": 32,
        "access": "read-write",
        "desc": "AHB peripheral clock enable\n          register",
        "fields": [
            {
                "name": "DMA1EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMA1 clock enable"
            },
            {
                "name": "DMA2EN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DMA2 clock enable"
            },
            {
                "name": "FLASHEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Flash memory interface clock\n              enable"
            },
            {
                "name": "CRCEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC clock enable"
            },
            {
                "name": "AESEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "AES hardware accelerator"
            },
            {
                "name": "RNGEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Random number generator clock\n              enable"
            }
        ]
    },
    "1073877052": {
        "name": "APBENR1",
        "address": 1073877052,
        "size": 32,
        "access": "read-write",
        "desc": "APB peripheral clock enable register\n          1",
        "fields": [
            {
                "name": "TIM2EN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 timer clock enable"
            },
            {
                "name": "TIM3EN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 timer clock enable"
            },
            {
                "name": "TIM4EN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TIM4 timer clock enable"
            },
            {
                "name": "TIM6EN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 timer clock enable"
            },
            {
                "name": "TIM7EN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 timer clock enable"
            },
            {
                "name": "LPUART2EN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPUART2 clock enable"
            },
            {
                "name": "USART5EN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "USART5EN"
            },
            {
                "name": "USART6EN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "USART6EN"
            },
            {
                "name": "RTCAPBEN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "RTC APB clock enable"
            },
            {
                "name": "WWDGEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "WWDG clock enable"
            },
            {
                "name": "FDCANEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "USBEN"
            },
            {
                "name": "USBEN",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "USBEN"
            },
            {
                "name": "SPI2EN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SPI2 clock enable"
            },
            {
                "name": "SPI3EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SPI3 clock enable"
            },
            {
                "name": "CRSEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CRSEN"
            },
            {
                "name": "USART2EN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 clock enable"
            },
            {
                "name": "USART3EN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "USART3 clock enable"
            },
            {
                "name": "USART4EN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "USART4 clock enable"
            },
            {
                "name": "LPUART1EN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "LPUART1 clock enable"
            },
            {
                "name": "I2C1EN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 clock enable"
            },
            {
                "name": "I2C2EN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C2 clock enable"
            },
            {
                "name": "I2C3EN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "I2C3 clock enable"
            },
            {
                "name": "CECEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "HDMI CEC clock enable"
            },
            {
                "name": "UCPD1EN",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "UCPD1 clock enable"
            },
            {
                "name": "UCPD2EN",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "UCPD2 clock enable"
            },
            {
                "name": "DBGEN",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Debug support clock enable"
            },
            {
                "name": "PWREN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Power interface clock\n              enable"
            },
            {
                "name": "DAC1EN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "DAC1 interface clock\n              enable"
            },
            {
                "name": "LPTIM2EN",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "LPTIM2 clock enable"
            },
            {
                "name": "LPTIM1EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "LPTIM1 clock enable"
            }
        ]
    },
    "1073877056": {
        "name": "APBENR2",
        "address": 1073877056,
        "size": 32,
        "access": "read-write",
        "desc": "APB peripheral clock enable register\n          2",
        "fields": [
            {
                "name": "SYSCFGEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYSCFG, COMP and VREFBUF clock\n              enable"
            },
            {
                "name": "TIM1EN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 timer clock enable"
            },
            {
                "name": "SPI1EN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 clock enable"
            },
            {
                "name": "USART1EN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 clock enable"
            },
            {
                "name": "TIM14EN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "TIM14 timer clock enable"
            },
            {
                "name": "TIM15EN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "TIM15 timer clock enable"
            },
            {
                "name": "TIM16EN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 timer clock enable"
            },
            {
                "name": "TIM17EN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "TIM16 timer clock enable"
            },
            {
                "name": "ADCEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "ADC clock enable"
            }
        ]
    },
    "1073877060": {
        "name": "IOPSMENR",
        "address": 1073877060,
        "size": 32,
        "access": "read-write",
        "desc": "GPIO in Sleep mode clock enable\n          register",
        "fields": [
            {
                "name": "GPIOASMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I/O port A clock enable during Sleep\n              mode"
            },
            {
                "name": "GPIOBSMEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "I/O port B clock enable during Sleep\n              mode"
            },
            {
                "name": "GPIOCSMEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "I/O port C clock enable during Sleep\n              mode"
            },
            {
                "name": "GPIODSMEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "I/O port D clock enable during Sleep\n              mode"
            },
            {
                "name": "GPIOESMEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "I/O port E clock enable during Sleep\n              mode"
            },
            {
                "name": "GPIOFSMEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "I/O port F clock enable during Sleep\n              mode"
            }
        ]
    },
    "1073877064": {
        "name": "AHBSMENR",
        "address": 1073877064,
        "size": 32,
        "access": "read-write",
        "desc": "AHB peripheral clock enable in Sleep mode\n          register",
        "fields": [
            {
                "name": "DMA1SMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMA1 clock enable during Sleep\n              mode"
            },
            {
                "name": "DMA2SMEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DMA2 clock enable during Sleep\n              mode"
            },
            {
                "name": "FLASHSMEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Flash memory interface clock enable\n              during Sleep mode"
            },
            {
                "name": "SRAMSMEN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "SRAM clock enable during Sleep\n              mode"
            },
            {
                "name": "CRCSMEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "CRC clock enable during Sleep\n              mode"
            },
            {
                "name": "AESSMEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "AES hardware accelerator clock enable\n              during Sleep mode"
            },
            {
                "name": "RNGSMEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Random number generator clock enable\n              during Sleep mode"
            }
        ]
    },
    "1073877068": {
        "name": "APBSMENR1",
        "address": 1073877068,
        "size": 32,
        "access": "read-write",
        "desc": "APB peripheral clock enable in Sleep mode\n          register 1",
        "fields": [
            {
                "name": "TIM2SMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2 timer clock enable during Sleep\n              mode"
            },
            {
                "name": "TIM3SMEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM3 timer clock enable during Sleep\n              mode"
            },
            {
                "name": "TIM4SMEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TIM4 timer clock enable during Sleep\n              mode"
            },
            {
                "name": "TIM6SMEN",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "TIM6 timer clock enable during Sleep\n              mode"
            },
            {
                "name": "TIM7SMEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TIM7 timer clock enable during Sleep\n              mode"
            },
            {
                "name": "LPUART2SMEN",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPUART2 clock enable"
            },
            {
                "name": "USART5SMEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "USART5 clock enable"
            },
            {
                "name": "USART6SMEN",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "USART6 clock enable"
            },
            {
                "name": "RTCAPBSMEN",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "RTC APB clock enable during Sleep\n              mode"
            },
            {
                "name": "WWDGSMEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "WWDG clock enable during Sleep\n              mode"
            },
            {
                "name": "FDCANSMEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "FDCAN clock enable during Sleep\n              mode"
            },
            {
                "name": "USBSMEN",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "USB clock enable during Sleep\n              mode"
            },
            {
                "name": "SPI2SMEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SPI2 clock enable during Sleep\n              mode"
            },
            {
                "name": "SPI3SMEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "SPI3 clock enable during Sleep\n              mode"
            },
            {
                "name": "CRSSSMEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "CRSS clock enable during Sleep\n              mode"
            },
            {
                "name": "USART2SMEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "USART2 clock enable during Sleep\n              mode"
            },
            {
                "name": "USART3SMEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "USART3 clock enable during Sleep\n              mode"
            },
            {
                "name": "USART4SMEN",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "USART4 clock enable during Sleep\n              mode"
            },
            {
                "name": "LPUART1SMEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "LPUART1 clock enable during Sleep\n              mode"
            },
            {
                "name": "I2C1SMEN",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "I2C1 clock enable during Sleep\n              mode"
            },
            {
                "name": "I2C2SMEN",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "I2C2 clock enable during Sleep\n              mode"
            },
            {
                "name": "I2C3SMEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "I2C3 clock enable during Sleep\n              mode"
            },
            {
                "name": "CECSMEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "HDMI CEC clock enable during Sleep\n              mode"
            },
            {
                "name": "UCPD1SMEN",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "UCPD1 clock enable during Sleep\n              mode"
            },
            {
                "name": "UCPD2SMEN",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "UCPD2 clock enable during Sleep\n              mode"
            },
            {
                "name": "DBGSMEN",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Debug support clock enable during Sleep\n              mode"
            },
            {
                "name": "PWRSMEN",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Power interface clock enable during\n              Sleep mode"
            },
            {
                "name": "DAC1SMEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "DAC1 interface clock enable during Sleep\n              mode"
            },
            {
                "name": "LPTIM2SMEN",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Low Power Timer 2 clock enable during\n              Sleep mode"
            },
            {
                "name": "LPTIM1SMEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Low Power Timer 1 clock enable during\n              Sleep mode"
            }
        ]
    },
    "1073877072": {
        "name": "APBSMENR2",
        "address": 1073877072,
        "size": 32,
        "access": "read-write",
        "desc": "APB peripheral clock enable in Sleep mode\n          register 2",
        "fields": [
            {
                "name": "SYSCFGSMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SYSCFG, COMP and VREFBUF clock enable\n              during Sleep mode"
            },
            {
                "name": "TIM1SMEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "TIM1 timer clock enable during Sleep\n              mode"
            },
            {
                "name": "SPI1SMEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "SPI1 clock enable during Sleep\n              mode"
            },
            {
                "name": "USART1SMEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "USART1 clock enable during Sleep\n              mode"
            },
            {
                "name": "TIM14SMEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "TIM14 timer clock enable during Sleep\n              mode"
            },
            {
                "name": "TIM15SMEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "TIM15 timer clock enable during Sleep\n              mode"
            },
            {
                "name": "TIM16SMEN",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TIM16 timer clock enable during Sleep\n              mode"
            },
            {
                "name": "TIM17SMEN",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "TIM16 timer clock enable during Sleep\n              mode"
            },
            {
                "name": "ADCSMEN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "ADC clock enable during Sleep\n              mode"
            }
        ]
    },
    "1073877076": {
        "name": "CCIPR",
        "address": 1073877076,
        "size": 32,
        "access": "read-write",
        "desc": "Peripherals independent clock configuration\n          register",
        "fields": [
            {
                "name": "USART1SEL",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "USART1 clock source\n              selection"
            },
            {
                "name": "USART2SEL",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "USART2 clock source\n              selection"
            },
            {
                "name": "USART3SEL",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "USART3 clock source\n              selection"
            },
            {
                "name": "CECSEL",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "HDMI CEC clock source\n              selection"
            },
            {
                "name": "LPUART2SEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "LPUART2 clock source\n              selection"
            },
            {
                "name": "LPUART1SEL",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "LPUART1 clock source\n              selection"
            },
            {
                "name": "I2C1SEL",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "I2C1 clock source\n              selection"
            },
            {
                "name": "I2S2SEL",
                "bitOffset": 14,
                "bitWidth": 2,
                "desc": "I2S1 clock source\n              selection"
            },
            {
                "name": "LPTIM1SEL",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "LPTIM1 clock source\n              selection"
            },
            {
                "name": "LPTIM2SEL",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "LPTIM2 clock source\n              selection"
            },
            {
                "name": "TIM1SEL",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "TIM1 clock source\n              selection"
            },
            {
                "name": "TIM15SEL",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "TIM15 clock source\n              selection"
            },
            {
                "name": "RNGSEL",
                "bitOffset": 26,
                "bitWidth": 2,
                "desc": "RNG clock source selection"
            },
            {
                "name": "RNGDIV",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Division factor of RNG clock\n              divider"
            },
            {
                "name": "ADCSEL",
                "bitOffset": 30,
                "bitWidth": 2,
                "desc": "ADCs clock source\n              selection"
            }
        ]
    },
    "1073877080": {
        "name": "CCIPR2",
        "address": 1073877080,
        "size": 32,
        "access": "read-write",
        "desc": "Peripherals independent clock configuration register 2",
        "fields": [
            {
                "name": "I2S1SEL",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "2S1SEL"
            },
            {
                "name": "I2S2SEL",
                "bitOffset": 2,
                "bitWidth": 2,
                "desc": "I2S2SEL"
            },
            {
                "name": "FDCANSEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "FDCANSEL"
            },
            {
                "name": "USBSEL",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "USBSEL"
            }
        ]
    },
    "1073877084": {
        "name": "BDCR",
        "address": 1073877084,
        "size": 32,
        "access": "read-write",
        "desc": "RTC domain control register",
        "fields": [
            {
                "name": "LSEON",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSE oscillator enable"
            },
            {
                "name": "LSERDY",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSE oscillator ready"
            },
            {
                "name": "LSEBYP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "LSE oscillator bypass"
            },
            {
                "name": "LSEDRV",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "LSE oscillator drive\n              capability"
            },
            {
                "name": "LSECSSON",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "CSS on LSE enable"
            },
            {
                "name": "LSECSSD",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CSS on LSE failure\n              Detection"
            },
            {
                "name": "RTCSEL",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "RTC clock source selection"
            },
            {
                "name": "RTCEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "RTC clock enable"
            },
            {
                "name": "BDRST",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "RTC domain software reset"
            },
            {
                "name": "LSCOEN",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low-speed clock output (LSCO)\n              enable"
            },
            {
                "name": "LSCOSEL",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Low-speed clock output\n              selection"
            }
        ]
    },
    "1073877088": {
        "name": "CSR",
        "address": 1073877088,
        "size": 32,
        "access": "read-write",
        "desc": "Control/status register",
        "fields": [
            {
                "name": "LSION",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LSI oscillator enable"
            },
            {
                "name": "LSIRDY",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LSI oscillator ready"
            },
            {
                "name": "RMVF",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Remove reset flags"
            },
            {
                "name": "OBLRSTF",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Option byte loader reset\n              flag"
            },
            {
                "name": "PINRSTF",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Pin reset flag"
            },
            {
                "name": "PWRRSTF",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "BOR or POR/PDR flag"
            },
            {
                "name": "SFTRSTF",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Software reset flag"
            },
            {
                "name": "IWDGRSTF",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Independent window watchdog reset\n              flag"
            },
            {
                "name": "WWDGRSTF",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Window watchdog reset flag"
            },
            {
                "name": "LPWRRSTF",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Low-power reset flag"
            }
        ]
    },
    "1073893376": {
        "name": "RNG_CR",
        "address": 1073893376,
        "size": 32,
        "access": "read-write",
        "desc": "control register",
        "fields": [
            {
                "name": "RNGEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "True random number generator enable"
            },
            {
                "name": "IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Interrupt Enable"
            },
            {
                "name": "CED",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clock error detection\nThe clock error detection cannot be enabled nor disabled on-the-fly when the RNG is enabled, i.e. to enable or disable CED the RNG must be disabled."
            }
        ]
    },
    "1073893380": {
        "name": "RNG_SR",
        "address": 1073893380,
        "size": 32,
        "access": "",
        "desc": "status register",
        "fields": [
            {
                "name": "DRDY",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Data Ready\nOnce the output buffer becomes empty (after reading the RNG_DR register), this bit returns to 0 until a new random value is generated.\nNote: The DRDY bit can rise when the peripheral is disabled (RNGEN=0 in the RNG_CR register).\nIf IE=1 in the RNG_CR register, an interrupt is generated when DRDY=1."
            },
            {
                "name": "CECS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clock error current status\nNote: CECS bit is valid only if the CED bit in the RNG_CR register is set to 0."
            },
            {
                "name": "SECS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Seed error current status\nOne of the noise source has provided more than 64 consecutive bits at a constant value ('0' or '1'), or more than 32 consecutive occurrence of two bit patterns ('01' or '10')\nBoth noise sources have delivered more than 32 consecutive bits at a constant value ('0' or '1'), or more than 16 consecutive occurrence of two bit patterns ('01' or '10')"
            },
            {
                "name": "CEIS",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clock error interrupt status\nThis bit is set at the same time as CECS. It is cleared by writing 0. Writing 1 has no effect.\nAn interrupt is pending if IE = 1 in the RNG_CR register."
            },
            {
                "name": "SEIS",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Seed error interrupt status\nThis bit is set at the same time as SECS. It is cleared by writing 0. Writing 1 has no effect.\nAn interrupt is pending if IE = 1 in the RNG_CR register."
            }
        ]
    },
    "1073893384": {
        "name": "RNG_DR",
        "address": 1073893384,
        "size": 32,
        "access": "read-only",
        "desc": "data register",
        "fields": [
            {
                "name": "RNDATA",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "Random data"
            }
        ]
    },
    "1073752064": {
        "name": "RTC_TR",
        "address": 1073752064,
        "size": 32,
        "access": "",
        "desc": "RTC time register ",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format"
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            }
        ]
    },
    "1073752068": {
        "name": "RTC_DR",
        "address": 1073752068,
        "size": 32,
        "access": "",
        "desc": "RTC date register ",
        "fields": [
            {
                "name": "DU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Date units in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "MU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Month units in BCD format"
            },
            {
                "name": "MT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Month tens in BCD format"
            },
            {
                "name": "WDU",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Week day units\n..."
            },
            {
                "name": "YU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Year units in BCD format"
            },
            {
                "name": "YT",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Year tens in BCD format"
            }
        ]
    },
    "1073752072": {
        "name": "RTC_SSR",
        "address": 1073752072,
        "size": 32,
        "access": "",
        "desc": "RTC sub second register ",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Sub second value\nSS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below:\nSecond fraction = (PREDIV_S - SS) / (PREDIV_S + 1)\nNote: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR."
            }
        ]
    },
    "1073752076": {
        "name": "RTC_ICSR",
        "address": 1073752076,
        "size": 32,
        "access": "",
        "desc": "RTC initialization control and status register ",
        "fields": [
            {
                "name": "ALRAWF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A write flag\nThis bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode."
            },
            {
                "name": "ALRBWF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B write flag\nThis bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode."
            },
            {
                "name": "WUTWF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer write flag\nThis bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode."
            },
            {
                "name": "SHPF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Shift operation pending\nThis flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect."
            },
            {
                "name": "INITS",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Initialization status flag\nThis bit is set by hardware when the calendar year field is different from 0 (RTC domain reset state)."
            },
            {
                "name": "RSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Registers synchronization flag\nThis bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF = 1), or when in bypass shadow register mode (BYPSHAD = 1). This bit can also be cleared by software.\nIt is cleared either by software or by hardware in initialization mode."
            },
            {
                "name": "INITF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Initialization flag\nWhen this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated."
            },
            {
                "name": "INIT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Initialization mode"
            },
            {
                "name": "RECALPF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Recalibration pending Flag\nThe RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to ."
            }
        ]
    },
    "1073752080": {
        "name": "RTC_PRER",
        "address": 1073752080,
        "size": 32,
        "access": "",
        "desc": "RTC prescaler register ",
        "fields": [
            {
                "name": "PREDIV_S",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Synchronous prescaler factor\nThis is the synchronous division factor:\nck_spre frequency = ck_apre frequency/(PREDIV_S+1)"
            },
            {
                "name": "PREDIV_A",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Asynchronous prescaler factor\nThis is the asynchronous division factor:\nck_apre frequency = RTCCLK frequency/(PREDIV_A+1)"
            }
        ]
    },
    "1073752084": {
        "name": "RTC_WUTR",
        "address": 1073752084,
        "size": 32,
        "access": "",
        "desc": "RTC wakeup timer register ",
        "fields": [
            {
                "name": "WUT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Wakeup auto-reload value bits\nWhen the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]+1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register.\nWhen WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer.\nThe first assertion of WUTF occurs between WUT and (WUT + 1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] = 011 (RTCCLK/2) is forbidden."
            }
        ]
    },
    "1073752088": {
        "name": "RTC_CR",
        "address": 1073752088,
        "size": 32,
        "access": "",
        "desc": "RTC control register ",
        "fields": [
            {
                "name": "WUCKSEL",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "ck_wut wakeup clock selection\n10x: ck_spre (usually 1Hz) clock is selected\n11x: ck_spre (usually 1Hz) clock is selected and 216is added to the WUT counter value"
            },
            {
                "name": "TSEDGE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp event active edge\nTSE must be reset when TSEDGE is changed to avoid unwanted TSF setting."
            },
            {
                "name": "REFCKON",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "RTC_REFIN reference clock detection enable (50 or 60Hz)\nNote: PREDIV_S must be 0x00FF."
            },
            {
                "name": "BYPSHAD",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Bypass the shadow registers\nNote: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1."
            },
            {
                "name": "FMT",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Hour format"
            },
            {
                "name": "ALRAE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Alarm A enable"
            },
            {
                "name": "ALRBE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Alarm B enable"
            },
            {
                "name": "WUTE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Wakeup timer enable\nNote: When the wakeup timer is disabled, wait for WUTWF=1 before enabling it again."
            },
            {
                "name": "TSE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "timestamp enable"
            },
            {
                "name": "ALRAIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Alarm A interrupt enable"
            },
            {
                "name": "ALRBIE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Alarm B interrupt enable"
            },
            {
                "name": "WUTIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Wakeup timer interrupt enable"
            },
            {
                "name": "TSIE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Timestamp interrupt enable"
            },
            {
                "name": "ADD1H",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Add 1 hour (summer time change)\nWhen this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0."
            },
            {
                "name": "SUB1H",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Subtract 1 hour (winter time change)\nWhen this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0.\nSetting this bit has no effect when current hour is 0."
            },
            {
                "name": "BKP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Backup\nThis bit can be written by the user to memorize whether the daylight saving time change has been performed or not."
            },
            {
                "name": "COSEL",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Calibration output selection\nWhen COE = 1, this bit selects which signal is output on CALIB.\nThese frequencies are valid for RTCCLK at 32.768kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to ."
            },
            {
                "name": "POL",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Output polarity\nThis bit is used to configure the polarity of TAMPALRM output."
            },
            {
                "name": "OSEL",
                "bitOffset": 21,
                "bitWidth": 2,
                "desc": "Output selection\nThese bits are used to select the flag to be routed to TAMPALRM output."
            },
            {
                "name": "COE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Calibration output enable\nThis bit enables the CALIB output"
            },
            {
                "name": "ITSE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "timestamp on internal event enable"
            },
            {
                "name": "TAMPTS",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Activate timestamp on tamper detection event\nTAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set after the tamper flags, therefore if TAMPTS and TSIE are set, it is recommended to disable the tamper interrupts in order to avoid servicing 2 interrupts."
            },
            {
                "name": "TAMPOE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Tamper detection output enable on TAMPALRM"
            },
            {
                "name": "TAMPALRM_PU",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "TAMPALRM pull-up enable"
            },
            {
                "name": "TAMPALRM_TYPE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TAMPALRM output type"
            },
            {
                "name": "OUT2EN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RTC_OUT2 output enable\nSetting this bit allows to remap the RTC outputs on RTC_OUT2 as follows:\nOUT2EN = 0: RTC output 2 disable\nIf OSEL different 00 or TAMPOE = 1: TAMPALRM is output on RTC_OUT1\nIf OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT1\nOUT2EN = 1: RTC output 2 enable\nIf (OSEL different 00 or TAMPOE = 1) and COE = 0: TAMPALRM is output on RTC_OUT2\nIf OSEL = 00 and TAMPOE = 0 and COE = 1: CALIB is output on RTC_OUT2\nIf (OSEL different 00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1."
            }
        ]
    },
    "1073752100": {
        "name": "RTC_WPR",
        "address": 1073752100,
        "size": 32,
        "access": "",
        "desc": "RTC write protection register ",
        "fields": [
            {
                "name": "KEY",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Write protection key\nThis byte is written by software.\nReading this byte always returns 0x00.\nRefer to  for a description of how to unlock RTC register write protection."
            }
        ]
    },
    "1073752104": {
        "name": "RTC_CALR",
        "address": 1073752104,
        "size": 32,
        "access": "",
        "desc": "RTC calibration register ",
        "fields": [
            {
                "name": "CALM",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Calibration minus\nThe frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768Hz). This decreases the frequency of the calendar with a resolution of 0.9537ppm.\nTo increase the frequency of the calendar, this feature should be used in conjunction with CALP. See ."
            },
            {
                "name": "CALW16",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Use a 16-second calibration cycle period\nWhen CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1.\nNote: CALM[0] is stuck at 0 when CALW16 = 1. Refer to calibration."
            },
            {
                "name": "CALW8",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Use an 8-second calibration cycle period\nWhen CALW8 is set to 1, the 8-second calibration cycle period is selected.\nNote: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to digital calibration."
            },
            {
                "name": "CALP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Increase frequency of RTC by 488.5ppm\nThis feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM.\nRefer to ."
            }
        ]
    },
    "1073752108": {
        "name": "RTC_SHIFTR",
        "address": 1073752108,
        "size": 32,
        "access": "",
        "desc": "RTC shift control register ",
        "fields": [
            {
                "name": "SUBFS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Subtract a fraction of a second\nThese bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThe value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by:\nDelay (seconds) = SUBFS / (PREDIV_S + 1)\nA fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by:\nAdvance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))).\nNote: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time."
            },
            {
                "name": "ADD1S",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Add one second\nThis bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThis function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation."
            }
        ]
    },
    "1073752112": {
        "name": "RTC_TSTR",
        "address": 1073752112,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp time register ",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format."
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format."
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format."
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format."
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format."
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format."
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            }
        ]
    },
    "1073752116": {
        "name": "RTC_TSDR",
        "address": 1073752116,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp date register ",
        "fields": [
            {
                "name": "DU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Date units in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "MU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Month units in BCD format"
            },
            {
                "name": "MT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Month tens in BCD format"
            },
            {
                "name": "WDU",
                "bitOffset": 13,
                "bitWidth": 3,
                "desc": "Week day units"
            }
        ]
    },
    "1073752120": {
        "name": "RTC_TSSSR",
        "address": 1073752120,
        "size": 32,
        "access": "",
        "desc": "RTC timestamp sub second register ",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Sub second value\nSS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred."
            }
        ]
    },
    "1073752128": {
        "name": "RTC_ALRMAR",
        "address": 1073752128,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A register ",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format."
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format."
            },
            {
                "name": "MSK1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Alarm A seconds mask"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "MSK2",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Alarm A minutes mask"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            },
            {
                "name": "MSK3",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Alarm A hours mask"
            },
            {
                "name": "DU",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Date units or day in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "WDSEL",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Week day selection"
            },
            {
                "name": "MSK4",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Alarm A date mask"
            }
        ]
    },
    "1073752132": {
        "name": "RTC_ALRMASSR",
        "address": 1073752132,
        "size": 32,
        "access": "",
        "desc": "RTC alarm A sub second register ",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Sub seconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared."
            },
            {
                "name": "MASKSS",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Mask the most-significant bits starting at this bit\n2:\tSS[14:2] are don't care in alarm A comparison. Only SS[1:0] are compared.\n3:\tSS[14:3] are don't care in alarm A comparison. Only SS[2:0] are compared.\n...\n12:\tSS[14:12] are don't care in alarm A comparison. SS[11:0] are compared.\n13:\tSS[14:13] are don't care in alarm A comparison. SS[12:0] are compared.\n14:\tSS[14] is don't care in alarm A comparison. SS[13:0] are compared.\n15:\tAll 15 SS bits are compared and must match to activate alarm.\nThe overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.\nNote: The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation."
            }
        ]
    },
    "1073752136": {
        "name": "RTC_ALRMBR",
        "address": 1073752136,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B register ",
        "fields": [
            {
                "name": "SU",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Second units in BCD format"
            },
            {
                "name": "ST",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Second tens in BCD format"
            },
            {
                "name": "MSK1",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Alarm B seconds mask"
            },
            {
                "name": "MNU",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Minute units in BCD format"
            },
            {
                "name": "MNT",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Minute tens in BCD format"
            },
            {
                "name": "MSK2",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Alarm B minutes mask"
            },
            {
                "name": "HU",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Hour units in BCD format"
            },
            {
                "name": "HT",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Hour tens in BCD format"
            },
            {
                "name": "PM",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "AM/PM notation"
            },
            {
                "name": "MSK3",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Alarm B hours mask"
            },
            {
                "name": "DU",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Date units or day in BCD format"
            },
            {
                "name": "DT",
                "bitOffset": 28,
                "bitWidth": 2,
                "desc": "Date tens in BCD format"
            },
            {
                "name": "WDSEL",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Week day selection"
            },
            {
                "name": "MSK4",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Alarm B date mask"
            }
        ]
    },
    "1073752140": {
        "name": "RTC_ALRMBSSR",
        "address": 1073752140,
        "size": 32,
        "access": "",
        "desc": "RTC alarm B sub second register ",
        "fields": [
            {
                "name": "SS",
                "bitOffset": 0,
                "bitWidth": 15,
                "desc": "Sub seconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared."
            },
            {
                "name": "MASKSS",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "Mask the most-significant bits starting at this bit\n...\nThe overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation."
            }
        ]
    },
    "1073752144": {
        "name": "RTC_SR",
        "address": 1073752144,
        "size": 32,
        "access": "",
        "desc": "RTC status register ",
        "fields": [
            {
                "name": "ALRAF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR)."
            },
            {
                "name": "ALRBF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR)."
            },
            {
                "name": "WUTF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer flag\nThis flag is set by hardware when the wakeup auto-reload counter reaches 0.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
            },
            {
                "name": "TSF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp flag\nThis flag is set by hardware when a timestamp event occurs.\nIf ITSF flag is set, TSF must be cleared together with ITSF."
            },
            {
                "name": "TSOVF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Timestamp overflow flag\nThis flag is set by hardware when a timestamp event occurs while TSF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "ITSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Internal timestamp flag\nThis flag is set by hardware when a timestamp on the internal event occurs."
            }
        ]
    },
    "1073752148": {
        "name": "RTC_MISR",
        "address": 1073752148,
        "size": 32,
        "access": "",
        "desc": "RTC masked interrupt status register ",
        "fields": [
            {
                "name": "ALRAMF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Alarm A masked flag\nThis flag is set by hardware when the alarm A interrupt occurs."
            },
            {
                "name": "ALRBMF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Alarm B masked flag\nThis flag is set by hardware when the alarm B interrupt occurs."
            },
            {
                "name": "WUTMF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Wakeup timer masked flag\nThis flag is set by hardware when the wakeup timer interrupt occurs.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again."
            },
            {
                "name": "TSMF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Timestamp masked flag\nThis flag is set by hardware when a timestamp interrupt occurs.\nIf ITSF flag is set, TSF must be cleared together with ITSF."
            },
            {
                "name": "TSOVMF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Timestamp overflow masked flag\nThis flag is set by hardware when a timestamp interrupt occurs while TSMF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "ITSMF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Internal timestamp masked flag\nThis flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised."
            }
        ]
    },
    "1073752156": {
        "name": "RTC_SCR",
        "address": 1073752156,
        "size": 32,
        "access": "",
        "desc": "RTC status clear register ",
        "fields": [
            {
                "name": "CALRAF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear alarm A flag\nWriting 1 in this bit clears the ALRBF bit in the RTC_SR register."
            },
            {
                "name": "CALRBF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear alarm B flag\nWriting 1 in this bit clears the ALRBF bit in the RTC_SR register."
            },
            {
                "name": "CWUTF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Clear wakeup timer flag\nWriting 1 in this bit clears the WUTF bit in the RTC_SR register."
            },
            {
                "name": "CTSF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Clear timestamp flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIf ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF."
            },
            {
                "name": "CTSOVF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Clear timestamp overflow flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared."
            },
            {
                "name": "CITSF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Clear internal timestamp flag\nWriting 1 in this bit clears the ITSF bit in the RTC_SR register."
            }
        ]
    },
    "1073819648": {
        "name": "SPI_CR1",
        "address": 1073819648,
        "size": 22,
        "access": "",
        "desc": "SPI control register 1 ",
        "fields": [
            {
                "name": "CPHA",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clock phase\nNote: This bit should not be changed when communication is ongoing.\nThis bit is not used in I2S mode and SPI TI mode except the case when CRC is applied at TI mode."
            },
            {
                "name": "CPOL",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clock polarity\nNote: This bit should not be changed when communication is ongoing.\nThis bit is not used in I2S mode and SPI TI mode except the case when CRC is applied at TI mode."
            },
            {
                "name": "MSTR",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Master selection\nNote: This bit should not be changed when communication is ongoing.\nThis bit is not used in I2S mode."
            },
            {
                "name": "BR",
                "bitOffset": 3,
                "bitWidth": 3,
                "desc": "Baud rate control\nNote: These bits should not be changed when communication is ongoing.\nThese bits are not used in I2S mode."
            },
            {
                "name": "SPE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "SPI enable\nNote: When disabling the SPI, follow the procedure described in SPI on page1021.\nThis bit is not used in I2S mode."
            },
            {
                "name": "LSBFIRST",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Frame format\nNote: 1. This bit should not be changed when communication is ongoing.\n2. This bit is not used in I2S mode and SPI TI mode."
            },
            {
                "name": "SSI",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Internal slave select\nThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the NSS pin and the I/O value of the NSS pin is ignored.\nNote: This bit is not used in I2S mode and SPI TI mode."
            },
            {
                "name": "SSM",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Software slave management\nWhen the SSM bit is set, the NSS pin input is replaced with the value from the SSI bit.\nNote: This bit is not used in I2S mode and SPI TI mode."
            },
            {
                "name": "RXONLY",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Receive only mode enabled.\nThis bit enables simplex communication using a single unidirectional line to receive data exclusively. Keep BIDIMODE bit clear when receive only mode is active.This bit is also useful in a multislave system in which this particular slave is not accessed, the output from the accessed slave is not corrupted.\nNote: This bit is not used in I2S mode."
            },
            {
                "name": "CRCL",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "CRC length\nThis bit is set and cleared by software to select the CRC length.\nNote: This bit should be written only when SPI is disabled (SPE = '0') for correct operation.\nThis bit is not used in I2S mode."
            },
            {
                "name": "CRCNEXT",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Transmit CRC next\nNote: This bit has to be written as soon as the last data is written in the SPI_DR register.\nThis bit is not used in I2S mode."
            },
            {
                "name": "CRCEN",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Hardware CRC calculation enable\nNote: This bit should be written only when SPI is disabled (SPE = '0') for correct operation.\nThis bit is not used in I2S mode."
            },
            {
                "name": "BIDIOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Output enable in bidirectional mode\nThis bit combined with the BIDIMODE bit selects the direction of transfer in bidirectional mode.\nNote: In master mode, the MOSI pin is used and in slave mode, the MISO pin is used.\nThis bit is not used in I2S mode."
            },
            {
                "name": "BIDIMODE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Bidirectional data mode enable.\nThis bit enables half-duplex communication using common single bidirectional data line. Keep RXONLY bit clear when bidirectional mode is active.\nNote: This bit is not used in I2S mode."
            }
        ]
    },
    "1073819652": {
        "name": "SPI_CR2",
        "address": 1073819652,
        "size": 22,
        "access": "",
        "desc": "SPI control register 2 ",
        "fields": [
            {
                "name": "RXDMAEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Rx buffer DMA enable\nWhen this bit is set, a DMA request is generated whenever the RXNE flag is set."
            },
            {
                "name": "TXDMAEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tx buffer DMA enable\nWhen this bit is set, a DMA request is generated whenever the TXE flag is set."
            },
            {
                "name": "SSOE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "SS output enable\nNote: This bit is not used in I2S mode and SPI TI mode."
            },
            {
                "name": "NSSP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "NSS pulse management\nThis bit is used in master mode only. it allows the SPI to generate an NSS pulse between two consecutive data when doing continuous transfers. In the case of a single data transfer, it forces the NSS pin high level after the transfer.\nIt has no meaning if CPHA = '1', or FRF = '1'.\nNote: 1. This bit must be written only when the SPI is disabled (SPE=0).\n2. This bit is not used in I2S mode and SPI TI mode."
            },
            {
                "name": "FRF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Frame format\n1 SPI TI mode\nNote: This bit must be written only when the SPI is disabled (SPE=0).\nThis bit is not used in I2S mode."
            },
            {
                "name": "ERRIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Error interrupt enable\nThis bit controls the generation of an interrupt when an error condition occurs (CRCERR, OVR, MODF in SPI mode, FRE at TI mode and UDR, OVR, and FRE in I2S mode)."
            },
            {
                "name": "RXNEIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "RX buffer not empty interrupt enable"
            },
            {
                "name": "TXEIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Tx buffer empty interrupt enable"
            },
            {
                "name": "DS",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "Data size\nThese bits configure the data length for SPI transfers.\nIf software attempts to write one of the 'Not used' values, they are forced to the value '0111'\n(8-bit)\nNote: These bits are not used in I2S mode."
            },
            {
                "name": "FRXTH",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "FIFO reception threshold\nThis bit is used to set the threshold of the RXFIFO that triggers an RXNE event\nNote: This bit is not used in I2S mode."
            },
            {
                "name": "LDMA_RX",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Last DMA transfer for reception"
            },
            {
                "name": "LDMA_TX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Last DMA transfer for transmission"
            }
        ]
    },
    "1073819656": {
        "name": "SPI_SR",
        "address": 1073819656,
        "size": 22,
        "access": "",
        "desc": "SPI status register ",
        "fields": [
            {
                "name": "RXNE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Receive buffer not empty"
            },
            {
                "name": "TXE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Transmit buffer empty"
            },
            {
                "name": "CHSIDE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Channel side\nNote: This bit is not used in SPI mode. It has no significance in PCM mode."
            },
            {
                "name": "UDR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Underrun flag\nThis flag is set by hardware and reset by a software sequence. Refer to page1057 for the software sequence.\nNote: This bit is not used in SPI mode."
            },
            {
                "name": "CRCERR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "CRC error flag\nNote: This flag is set by hardware and cleared by software writing 0.\nThis bit is not used in I2S mode."
            },
            {
                "name": "MODF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Mode fault\nThis flag is set by hardware and reset by a software sequence. Refer to (MODF) on page1031 for the software sequence.\nNote: This bit is not used in I2S mode."
            },
            {
                "name": "OVR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Overrun flag\nThis flag is set by hardware and reset by a software sequence. Refer to page1057 for the software sequence."
            },
            {
                "name": "BSY",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Busy flag\nThis flag is set and cleared by hardware.\nNote: The BSY flag must be used with caution: refer to  and ."
            },
            {
                "name": "FRE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Frame format error\nThis flag is used for SPI in TI slave mode and I2S slave mode. Refer to error flags and .\nThis flag is set by hardware and reset when SPI_SR is read by software."
            },
            {
                "name": "FRLVL",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "FIFO reception level"
            },
            {
                "name": "FTLVL",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "FIFO transmission level\nThese bits are set and cleared by hardware.\nNote: This bit is not used in I2S mode."
            }
        ]
    },
    "1073819660": {
        "name": "SPI_DR",
        "address": 1073819660,
        "size": 22,
        "access": "",
        "desc": "SPI data register ",
        "fields": [
            {
                "name": "DR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Data register\nData received or to be transmitted\nThe data register serves as an interface between the Rx and Tx FIFOs. When the data register is read, RxFIFO is accessed while the write to data register accesses TxFIFO (See ).\nNote: Data is always right-aligned. Unused bits are ignored when writing to the register, and read as zero when the register is read. The Rx threshold setting must always correspond with the read access currently used."
            }
        ]
    },
    "1073819664": {
        "name": "SPI_CRCPR",
        "address": 1073819664,
        "size": 22,
        "access": "",
        "desc": "SPI CRC polynomial register ",
        "fields": [
            {
                "name": "CRCPOLY",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "CRC polynomial register\nThis register contains the polynomial for the CRC calculation.\nThe CRC polynomial (0x0007) is the reset value of this register. Another polynomial can be configured as required."
            }
        ]
    },
    "1073819668": {
        "name": "SPI_RXCRCR",
        "address": 1073819668,
        "size": 22,
        "access": "",
        "desc": "SPI Rx CRC register ",
        "fields": [
            {
                "name": "RXCRC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Rx CRC register\nWhen CRC calculation is enabled, the RXCRC[15:0] bits contain the computed CRC value of the subsequently received bytes. This register is reset when the CRCEN bit in SPI_CR1 register is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register.\nOnly the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard.\nThe entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard.\nNote: A read to this register when the BSY Flag is set could return an incorrect value.\nThese bits are not used in I2S mode."
            }
        ]
    },
    "1073819672": {
        "name": "SPI_TXCRCR",
        "address": 1073819672,
        "size": 22,
        "access": "",
        "desc": "SPI Tx CRC register ",
        "fields": [
            {
                "name": "TXCRC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Tx CRC register\nWhen CRC calculation is enabled, the TXCRC[7:0] bits contain the computed CRC value of the subsequently transmitted bytes. This register is reset when the CRCEN bit of SPI_CR1 is written to 1. The CRC is calculated serially using the polynomial programmed in the SPI_CRCPR register.\nOnly the 8 LSB bits are considered when the CRC frame format is set to be 8-bit length (CRCL bit in the SPI_CR1 is cleared). CRC calculation is done based on any CRC8 standard.\nThe entire 16-bits of this register are considered when a 16-bit CRC frame format is selected (CRCL bit in the SPI_CR1 register is set). CRC calculation is done based on any CRC16 standard.\nNote: A read to this register when the BSY flag is set could return an incorrect value.\nThese bits are not used in I2S mode."
            }
        ]
    },
    "1073819676": {
        "name": "SPI_I2SCFGR",
        "address": 1073819676,
        "size": 22,
        "access": "",
        "desc": "SPI_I2S configuration register ",
        "fields": [
            {
                "name": "CHLEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Channel length (number of bits per audio channel)\nThe bit write operation has a meaning only if DATLEN = 00 otherwise the channel length is fixed to 32-bit by hardware whatever the value filled in.\nNote: For correct operation, this bit should be configured when the I2S is disabled.\nIt is not used in SPI mode."
            },
            {
                "name": "DATLEN",
                "bitOffset": 1,
                "bitWidth": 2,
                "desc": "Data length to be transferred\nNote: For correct operation, these bits should be configured when the I2S is disabled.\nThey are not used in SPI mode."
            },
            {
                "name": "CKPOL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Inactive state clock polarity\nNote: For correct operation, this bit should be configured when the I2S is disabled.\nIt is not used in SPI mode.\nThe bit CKPOL does not affect the CK edge sensitivity used to receive or transmit the SD and WS signals."
            },
            {
                "name": "I2SSTD",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "I2S standard selection\nFor more details on I2S standards, refer to\nNote: For correct operation, these bits should be configured when the I2S is disabled.\nThey are not used in SPI mode."
            },
            {
                "name": "PCMSYNC",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "PCM frame synchronization\nNote: This bit has a meaning only if I2SSTD = 11 (PCM standard is used).\nIt is not used in SPI mode."
            },
            {
                "name": "I2SCFG",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "I2S configuration mode\nNote: These bits should be configured when the I2S is disabled.\nThey are not used in SPI mode."
            },
            {
                "name": "I2SE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "I2S enable\nNote: This bit is not used in SPI mode."
            },
            {
                "name": "I2SMOD",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "I2S mode selection\nNote: This bit should be configured when the SPI is disabled."
            },
            {
                "name": "ASTRTEN",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Asynchronous start enable.\nWhen the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and an appropriate transition is detected on the WS signal.\nWhen the I2S is enabled in slave mode, the hardware starts the transfer when the I2S clock is received and the appropriate level is detected on the WS signal.\nNote: The appropriate transition is a falling edge on WS signal when I2S Philips Standard is used, or a rising edge for other standards.\nThe appropriate level is a low level on WS signal when I2S Philips Standard is used, or a high level for other standards.\nPlease refer to  for additional information."
            }
        ]
    },
    "1073819680": {
        "name": "SPI_I2SPR",
        "address": 1073819680,
        "size": 22,
        "access": "",
        "desc": "SPI_I2S prescaler register ",
        "fields": [
            {
                "name": "I2SDIV",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "I2S linear prescaler\nI2SDIV [7:0] = 0 or I2SDIV [7:0] = 1 are forbidden values.\nRefer to .\nNote: These bits should be configured when the I2S is disabled. They are used only when the I2S is in master mode.\nThey are not used in SPI mode."
            },
            {
                "name": "ODD",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Odd factor for the prescaler\nRefer to .\nNote: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.\nIt is not used in SPI mode."
            },
            {
                "name": "MCKOE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Master clock output enable\nNote: This bit should be configured when the I2S is disabled. It is used only when the I2S is in master mode.\nIt is not used in SPI mode."
            }
        ]
    },
    "1073807360": {
        "name": "CFGR1",
        "address": 1073807360,
        "size": 32,
        "access": "read-write",
        "desc": "SYSCFG configuration register\n          1",
        "fields": [
            {
                "name": "I2C3_FMP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "I2C3_FMP"
            },
            {
                "name": "I2C_PA10_FMP",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Fast Mode Plus (FM+) driving capability\n              activation bits"
            },
            {
                "name": "I2C_PA9_FMP",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Fast Mode Plus (FM+) driving capability\n              activation bits"
            },
            {
                "name": "I2C2_FMP",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "FM+ driving capability activation for\n              I2C2"
            },
            {
                "name": "I2C1_FMP",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "FM+ driving capability activation for\n              I2C1"
            },
            {
                "name": "I2C_PB9_FMP",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "I2C_PB9_FMP"
            },
            {
                "name": "I2C_PB8_FMP",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "I2C_PB8_FMP"
            },
            {
                "name": "I2C_PB7_FMP",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "I2C_PB7_FMP"
            },
            {
                "name": "I2C_PBx_FMP",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Fast Mode Plus (FM+) driving capability\n              activation bits"
            },
            {
                "name": "UCPD2_STROBE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Strobe signal bit for\n              UCPD2"
            },
            {
                "name": "UCPD1_STROBE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Strobe signal bit for\n              UCPD1"
            },
            {
                "name": "BOOSTEN",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "I/O analog switch voltage booster\n              enable"
            },
            {
                "name": "IR_MOD",
                "bitOffset": 6,
                "bitWidth": 2,
                "desc": "IR Modulation Envelope signal\n              selection."
            },
            {
                "name": "IR_POL",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "IR output polarity\n              selection"
            },
            {
                "name": "PA12_RMP",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "PA11 and PA12 remapping\n              bit."
            },
            {
                "name": "PA11_RMP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "PA11_RMP"
            },
            {
                "name": "MEM_MODE",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Memory mapping selection\n              bits"
            }
        ]
    },
    "1073807384": {
        "name": "CFGR2",
        "address": 1073807384,
        "size": 32,
        "access": "read-write",
        "desc": "SYSCFG configuration register\n          1",
        "fields": [
            {
                "name": "LOCKUP_LOCK",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Cortex-M0+ LOCKUP bit enable\n              bit"
            },
            {
                "name": "SRAM_PARITY_LOCK",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "SRAM parity lock bit"
            },
            {
                "name": "ECC_LOCK",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "ECC error lock bit"
            },
            {
                "name": "SRAM_PEF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "SRAM parity error flag"
            }
        ]
    },
    "1073807488": {
        "name": "ITLINE0",
        "address": 1073807488,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 0 status\n          register",
        "fields": [
            {
                "name": "WWDG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Window watchdog interrupt pending\n              flag"
            }
        ]
    },
    "1073807496": {
        "name": "ITLINE2",
        "address": 1073807496,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 2 status\n          register",
        "fields": [
            {
                "name": "TAMP",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TAMP"
            },
            {
                "name": "RTC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "RTC"
            }
        ]
    },
    "1073807500": {
        "name": "ITLINE3",
        "address": 1073807500,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 3 status\n          register",
        "fields": [
            {
                "name": "FLASH_ITF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "FLASH_ITF"
            },
            {
                "name": "FLASH_ECC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "FLASH_ECC"
            }
        ]
    },
    "1073807504": {
        "name": "ITLINE4",
        "address": 1073807504,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 4 status\n          register",
        "fields": [
            {
                "name": "RCC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RCC"
            },
            {
                "name": "CRS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "CRS"
            }
        ]
    },
    "1073807508": {
        "name": "ITLINE5",
        "address": 1073807508,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 5 status\n          register",
        "fields": [
            {
                "name": "EXTI0",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "EXTI0"
            },
            {
                "name": "EXTI1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "EXTI1"
            }
        ]
    },
    "1073807512": {
        "name": "ITLINE6",
        "address": 1073807512,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 6 status\n          register",
        "fields": [
            {
                "name": "EXTI2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "EXTI2"
            },
            {
                "name": "EXTI3",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "EXTI3"
            }
        ]
    },
    "1073807516": {
        "name": "ITLINE7",
        "address": 1073807516,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 7 status\n          register",
        "fields": [
            {
                "name": "EXTI4",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "EXTI4"
            },
            {
                "name": "EXTI5",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "EXTI5"
            },
            {
                "name": "EXTI6",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "EXTI6"
            },
            {
                "name": "EXTI7",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "EXTI7"
            },
            {
                "name": "EXTI8",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "EXTI8"
            },
            {
                "name": "EXTI9",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "EXTI9"
            },
            {
                "name": "EXTI10",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "EXTI10"
            },
            {
                "name": "EXTI11",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "EXTI11"
            },
            {
                "name": "EXTI12",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "EXTI12"
            },
            {
                "name": "EXTI13",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "EXTI13"
            },
            {
                "name": "EXTI14",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "EXTI14"
            },
            {
                "name": "EXTI15",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "EXTI15"
            }
        ]
    },
    "1073807520": {
        "name": "ITLINE8",
        "address": 1073807520,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 8 status\n          register",
        "fields": [
            {
                "name": "UCPD1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "UCPD1"
            },
            {
                "name": "UCPD2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "UCPD2"
            },
            {
                "name": "USB",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "USB"
            }
        ]
    },
    "1073807524": {
        "name": "ITLINE9",
        "address": 1073807524,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 9 status\n          register",
        "fields": [
            {
                "name": "DMA1_CH1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMA1_CH1"
            }
        ]
    },
    "1073807528": {
        "name": "ITLINE10",
        "address": 1073807528,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 10 status\n          register",
        "fields": [
            {
                "name": "DMA1_CH2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMA1_CH1"
            },
            {
                "name": "DMA1_CH3",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DMA1_CH3"
            }
        ]
    },
    "1073807532": {
        "name": "ITLINE11",
        "address": 1073807532,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 11 status\n          register",
        "fields": [
            {
                "name": "DMAMUX",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "DMAMUX"
            },
            {
                "name": "DMA1_CH4",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DMA1_CH4"
            },
            {
                "name": "DMA1_CH5",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "DMA1_CH5"
            },
            {
                "name": "DMA1_CH6",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "DMA1_CH6"
            },
            {
                "name": "DMA1_CH7",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "DMA1_CH7"
            },
            {
                "name": "DMA2_CH1",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "DMA2_CH1"
            },
            {
                "name": "DMA2_CH2",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA2_CH2"
            },
            {
                "name": "DMA2_CH3",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA2_CH3"
            },
            {
                "name": "DMA2_CH4",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "DMA2_CH4"
            },
            {
                "name": "DMA2_CH5",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "DMA2_CH5"
            }
        ]
    },
    "1073807536": {
        "name": "ITLINE12",
        "address": 1073807536,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 12 status\n          register",
        "fields": [
            {
                "name": "ADC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "ADC"
            },
            {
                "name": "COMP1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "COMP1"
            },
            {
                "name": "COMP2",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "COMP2"
            },
            {
                "name": "COMP3",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "COMP3"
            }
        ]
    },
    "1073807540": {
        "name": "ITLINE13",
        "address": 1073807540,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 13 status\n          register",
        "fields": [
            {
                "name": "TIM1_CCU",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM1_CCU"
            },
            {
                "name": "TIM1_TRG",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM1_TRG"
            },
            {
                "name": "TIM1_UPD",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TIM1_UPD"
            },
            {
                "name": "TIM1_BRK",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "TIM1_BRK"
            }
        ]
    },
    "1073807544": {
        "name": "ITLINE14",
        "address": 1073807544,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 14 status\n          register",
        "fields": [
            {
                "name": "TIM1_CC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM1_CC"
            }
        ]
    },
    "1073807548": {
        "name": "ITLINE15",
        "address": 1073807548,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 15 status\n          register",
        "fields": [
            {
                "name": "TIM2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM2"
            }
        ]
    },
    "1073807552": {
        "name": "ITLINE16",
        "address": 1073807552,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 16 status\n          register",
        "fields": [
            {
                "name": "TIM3",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM3"
            },
            {
                "name": "TIM4",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TIM4"
            }
        ]
    },
    "1073807556": {
        "name": "ITLINE17",
        "address": 1073807556,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 17 status\n          register",
        "fields": [
            {
                "name": "TIM6",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM6"
            },
            {
                "name": "DAC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "DAC"
            },
            {
                "name": "LPTIM1",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "LPTIM1"
            }
        ]
    },
    "1073807560": {
        "name": "ITLINE18",
        "address": 1073807560,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 18 status\n          register",
        "fields": [
            {
                "name": "TIM7",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM7"
            },
            {
                "name": "LPTIM2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPTIM2"
            }
        ]
    },
    "1073807564": {
        "name": "ITLINE19",
        "address": 1073807564,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 19 status\n          register",
        "fields": [
            {
                "name": "TIM14",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM14"
            }
        ]
    },
    "1073807568": {
        "name": "ITLINE20",
        "address": 1073807568,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 20 status\n          register",
        "fields": [
            {
                "name": "TIM15",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM15"
            }
        ]
    },
    "1073807572": {
        "name": "ITLINE21",
        "address": 1073807572,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 21 status\n          register",
        "fields": [
            {
                "name": "TIM16",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM16"
            },
            {
                "name": "FDCAN1_IT0",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "FDCAN1_IT0"
            },
            {
                "name": "FDCAN2_IT0",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "FDCAN2_IT0"
            }
        ]
    },
    "1073807576": {
        "name": "ITLINE22",
        "address": 1073807576,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 22 status\n          register",
        "fields": [
            {
                "name": "TIM17",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TIM17"
            },
            {
                "name": "FDCAN1_IT1",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "FDCAN1_IT1"
            },
            {
                "name": "FDCAN2_IT1",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "FDCAN2_IT1"
            }
        ]
    },
    "1073807580": {
        "name": "ITLINE23",
        "address": 1073807580,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 23 status\n          register",
        "fields": [
            {
                "name": "I2C1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I2C1"
            }
        ]
    },
    "1073807584": {
        "name": "ITLINE24",
        "address": 1073807584,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 24 status\n          register",
        "fields": [
            {
                "name": "I2C2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "I2C2"
            },
            {
                "name": "I2C3",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "I2C3"
            }
        ]
    },
    "1073807588": {
        "name": "ITLINE25",
        "address": 1073807588,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 25 status\n          register",
        "fields": [
            {
                "name": "SPI1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SPI1"
            }
        ]
    },
    "1073807592": {
        "name": "ITLINE26",
        "address": 1073807592,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 26 status\n          register",
        "fields": [
            {
                "name": "SPI2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "SPI2"
            },
            {
                "name": "SPI3",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "SPI3"
            }
        ]
    },
    "1073807596": {
        "name": "ITLINE27",
        "address": 1073807596,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 27 status\n          register",
        "fields": [
            {
                "name": "USART1",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART1"
            }
        ]
    },
    "1073807600": {
        "name": "ITLINE28",
        "address": 1073807600,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 28 status\n          register",
        "fields": [
            {
                "name": "USART2",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART2"
            },
            {
                "name": "LPUART2",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPUART2"
            }
        ]
    },
    "1073807604": {
        "name": "ITLINE29",
        "address": 1073807604,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 29 status\n          register",
        "fields": [
            {
                "name": "USART3",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART3"
            },
            {
                "name": "USART4",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "USART4"
            },
            {
                "name": "LPUART1",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "LPUART1"
            },
            {
                "name": "USART5",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "USART5"
            },
            {
                "name": "USART6",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "USART6"
            }
        ]
    },
    "1073807608": {
        "name": "ITLINE30",
        "address": 1073807608,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 25 status\n          register",
        "fields": [
            {
                "name": "CEC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "CEC"
            }
        ]
    },
    "1073807612": {
        "name": "ITLINE31",
        "address": 1073807612,
        "size": 32,
        "access": "read-only",
        "desc": "interrupt line 25 status\n          register",
        "fields": [
            {
                "name": "RNG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "RNG"
            },
            {
                "name": "AES",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "AES"
            }
        ]
    },
    "1073786880": {
        "name": "TAMP_CR1",
        "address": 1073786880,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 1 ",
        "fields": [
            {
                "name": "TAMP1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN1 enable"
            },
            {
                "name": "TAMP2E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper detection on TAMP_IN2 enable"
            },
            {
                "name": "ITAMP3E",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 enable: LSE monitoring"
            },
            {
                "name": "ITAMP4E",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Internal tamper 4 enable: HSE monitoring"
            },
            {
                "name": "ITAMP5E",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 enable: RTC calendar overflow"
            },
            {
                "name": "ITAMP6E",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 enable: ST manufacturer readout"
            }
        ]
    },
    "1073786884": {
        "name": "TAMP_CR2",
        "address": 1073786884,
        "size": 32,
        "access": "",
        "desc": "TAMP control register 2 ",
        "fields": [
            {
                "name": "TAMP1NOER",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper 1 no erase"
            },
            {
                "name": "TAMP2NOER",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper 2 no erase"
            },
            {
                "name": "TAMP1MSK",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Tamper 1 mask\nThe tamper 1 interrupt must not be enabled when TAMP1MSK is set."
            },
            {
                "name": "TAMP2MSK",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Tamper 2 mask\nThe tamper 2 interrupt must not be enabled when TAMP2MSK is set."
            },
            {
                "name": "TAMP1TRG",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Active level for tamper 1 input (active mode disabled)\nIf TAMPFLT = 00 Tamper 1 input rising edge and high level triggers a tamper detection event.\nIf TAMPFLT = 00 Tamper 1 input falling edge and low level triggers a tamper detection event."
            },
            {
                "name": "TAMP2TRG",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Active level for tamper 2 input (active mode disabled)\nIf TAMPFLT = 00 Tamper 2 input rising edge and high level triggers a tamper detection event.\nIf TAMPFLT = 00 Tamper 2 input falling edge and low level triggers a tamper detection event."
            }
        ]
    },
    "1073786892": {
        "name": "TAMP_FLTCR",
        "address": 1073786892,
        "size": 32,
        "access": "",
        "desc": "TAMP filter control register ",
        "fields": [
            {
                "name": "TAMPFREQ",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Tamper sampling frequency\nDetermines the frequency at which each of the TAMP_INx inputs are sampled."
            },
            {
                "name": "TAMPFLT",
                "bitOffset": 3,
                "bitWidth": 2,
                "desc": "TAMP_INx filter count\nThese bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs."
            },
            {
                "name": "TAMPPRCH",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "TAMP_INx precharge duration\nThese bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs."
            },
            {
                "name": "TAMPPUDIS",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TAMP_INx pull-up disable\nThis bit determines if each of the TAMPx pins are precharged before each sample."
            }
        ]
    },
    "1073786924": {
        "name": "TAMP_IER",
        "address": 1073786924,
        "size": 32,
        "access": "",
        "desc": "TAMP interrupt enable register ",
        "fields": [
            {
                "name": "TAMP1IE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Tamper 1 interrupt enable"
            },
            {
                "name": "TAMP2IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tamper 2 interrupt enable"
            },
            {
                "name": "ITAMP3IE",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Internal tamper 3 interrupt enable: LSE monitoring"
            },
            {
                "name": "ITAMP4IE",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Internal tamper 4 interrupt enable: HSE monitoring"
            },
            {
                "name": "ITAMP5IE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Internal tamper 5 interrupt enable: RTC calendar overflow"
            },
            {
                "name": "ITAMP6IE",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Internal tamper 6 interrupt enable: ST manufacturer readout"
            }
        ]
    },
    "1073786928": {
        "name": "TAMP_SR",
        "address": 1073786928,
        "size": 32,
        "access": "",
        "desc": "TAMP status register ",
        "fields": [
            {
                "name": "TAMP1F",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TAMP1 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP1 input."
            },
            {
                "name": "TAMP2F",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TAMP2 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP2 input."
            },
            {
                "name": "ITAMP3F",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "LSE monitoring tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 3."
            },
            {
                "name": "ITAMP4F",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "HSE monitoring tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 4."
            },
            {
                "name": "ITAMP5F",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "RTC calendar overflow tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 5."
            },
            {
                "name": "ITAMP6F",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "ST manufacturer readout tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 6."
            }
        ]
    },
    "1073786932": {
        "name": "TAMP_MISR",
        "address": 1073786932,
        "size": 32,
        "access": "",
        "desc": "TAMP masked interrupt status register ",
        "fields": [
            {
                "name": "TAMP1MF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TAMP1 interrupt masked flag\nThis flag is set by hardware when the tamper 1 interrupt is raised."
            },
            {
                "name": "TAMP2MF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TAMP2 interrupt masked flag\nThis flag is set by hardware when the tamper 2 interrupt is raised."
            },
            {
                "name": "ITAMP3MF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "LSE monitoring tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 3 interrupt is raised."
            },
            {
                "name": "ITAMP4MF",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "HSE monitoring tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 4 interrupt is raised."
            },
            {
                "name": "ITAMP5MF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "RTC calendar overflow tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 5 interrupt is raised."
            },
            {
                "name": "ITAMP6MF",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "ST manufacturer readout tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 6 interrupt is raised."
            }
        ]
    },
    "1073786940": {
        "name": "TAMP_SCR",
        "address": 1073786940,
        "size": 32,
        "access": "",
        "desc": "TAMP status clear register ",
        "fields": [
            {
                "name": "CTAMP1F",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Clear TAMP1 detection flag\nWriting 1 in this bit clears the TAMP1F bit in the TAMP_SR register."
            },
            {
                "name": "CTAMP2F",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Clear TAMP2 detection flag\nWriting 1 in this bit clears the TAMP2F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP3F",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Clear ITAMP3 detection flag\nWriting 1 in this bit clears the ITAMP3F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP4F",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Clear ITAMP4 detection flag\nWriting 1 in this bit clears the ITAMP4F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP5F",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Clear ITAMP5 detection flag\nWriting 1 in this bit clears the ITAMP5F bit in the TAMP_SR register."
            },
            {
                "name": "CITAMP6F",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Clear ITAMP6 detection flag\nWriting 1 in this bit clears the ITAMP6F bit in the TAMP_SR register."
            }
        ]
    },
    "1073787136": {
        "name": "TAMP_BKP0R",
        "address": 1073787136,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 0 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787140": {
        "name": "TAMP_BKP1R",
        "address": 1073787140,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 1 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787144": {
        "name": "TAMP_BKP2R",
        "address": 1073787144,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 2 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787148": {
        "name": "TAMP_BKP3R",
        "address": 1073787148,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 3 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073787152": {
        "name": "TAMP_BKP4R",
        "address": 1073787152,
        "size": 32,
        "access": "",
        "desc": "TAMP backup 4 register",
        "fields": [
            {
                "name": "BKP",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the default configuration this register is reset on a tamper detection event. It is forced to reset value as long as there is at least one internal or external tamper flag being set. This register is also reset when the readout protection (RDP) is disabled."
            }
        ]
    },
    "1073818624": {
        "name": "TIM1_CR1",
        "address": 1073818624,
        "size": 32,
        "access": "read-write",
        "desc": "control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One pulse mode"
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction\nNote: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode."
            },
            {
                "name": "CMS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Center-aligned mode selection\nNote: Switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1) is not allowed"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (ETR, TIx):\nNote: tDTS = 1/fDTS, tCK_INT = 1/fCK_INT."
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073818628": {
        "name": "TIM1_CR2",
        "address": 1073818628,
        "size": 32,
        "access": "read-write",
        "desc": "control register 2",
        "fields": [
            {
                "name": "CCPC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare preloaded control\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCUS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare control update selection\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\nThese bits allow selected information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TI1 selection"
            },
            {
                "name": "OIS1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1 output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OIS1N",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1N output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OIS2",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output Idle state 2 (OC2 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS2N",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output Idle state 2 (OC2N output)\nRefer to OIS1N bit"
            },
            {
                "name": "OIS3",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Output Idle state 3 (OC3 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS3N",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Output Idle state 3 (OC3N output)\nRefer to OIS1N bit"
            },
            {
                "name": "OIS4",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Output Idle state 4 (OC4 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS5",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output Idle state 5 (OC5 output)\nRefer to OIS1 bit"
            },
            {
                "name": "OIS6",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Output Idle state 6 (OC6 output)\nRefer to OIS1 bit"
            },
            {
                "name": "MMS2",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Master mode selection 2\nThese bits allow the information to be sent to ADC for synchronization (TRGO2) to be selected. The combination is as follows:\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            }
        ]
    },
    "1073818632": {
        "name": "TIM1_SMCR",
        "address": 1073818632,
        "size": 32,
        "access": "read-write",
        "desc": "slave mode control register",
        "fields": [
            {
                "name": "SMS1",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nNote: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "OCCS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "OCREF clear selection\nThis bit is used to select the OCREF clear source."
            },
            {
                "name": "TS1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee  for more details on ITRx meaning for each Timer.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/slave mode"
            },
            {
                "name": "ETF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "External trigger filter\nThis bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "ETPS",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "External trigger prescaler\nExternal trigger signal ETRP frequency must be at most 1/4 of fCK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks."
            },
            {
                "name": "ECE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "External clock enable\nThis bit enables External clock mode 2.\nNote: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111).\nIt is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111).\nIf external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF."
            },
            {
                "name": "ETP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "External trigger polarity\nThis bit selects whether ETR or ETR is used for trigger operations"
            },
            {
                "name": "SMS2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nNote: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TS2",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee  for more details on ITRx meaning for each Timer.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            }
        ]
    },
    "1073818636": {
        "name": "TIM1_DIER",
        "address": 1073818636,
        "size": 32,
        "access": "read-write",
        "desc": "DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt enable"
            },
            {
                "name": "CC3IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt enable"
            },
            {
                "name": "CC4IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt enable"
            },
            {
                "name": "COMIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "BIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 DMA request enable"
            },
            {
                "name": "CC3DE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 DMA request enable"
            },
            {
                "name": "CC4DE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 DMA request enable"
            },
            {
                "name": "COMDE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "COM DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            }
        ]
    },
    "1073818640": {
        "name": "TIM1_SR",
        "address": 1073818640,
        "size": 32,
        "access": "read-write",
        "desc": "status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow or underflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by a trigger event (refer to control register (TIM1_SMCRTIMx_SMCR)N/A), if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when he content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC3IF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC4IF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "COMIF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt flag"
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\nThis flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software."
            },
            {
                "name": "BIF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt flag\nThis flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active."
            },
            {
                "name": "B2IF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Break 2 interrupt flag\nThis flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 overcapture flag\nRefer to CC1OF description"
            },
            {
                "name": "CC3OF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 overcapture flag\nRefer to CC1OF description"
            },
            {
                "name": "CC4OF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 overcapture flag\nRefer to CC1OF description"
            },
            {
                "name": "SBIF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "System Break interrupt flag\nThis flag is set by hardware as soon as the system break input goes active. It can be cleared by software if the system break input is not active.\nThis flag must be reset to re-start PWM operation."
            },
            {
                "name": "CC5IF",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Compare 5 interrupt flag\nRefer to CC1IF description (Note: Channel 5 can only be configured as output)"
            },
            {
                "name": "CC6IF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Compare 6 interrupt flag\nRefer to CC1IF description (Note: Channel 6 can only be configured as output)"
            }
        ]
    },
    "1073818644": {
        "name": "TIM1_EGR",
        "address": 1073818644,
        "size": 32,
        "access": "write-only",
        "desc": "event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 generation\nRefer to CC1G description"
            },
            {
                "name": "CC3G",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 generation\nRefer to CC1G description"
            },
            {
                "name": "CC4G",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 generation\nRefer to CC1G description"
            },
            {
                "name": "COMG",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare control update generation\nThis bit can be set by software, it is automatically cleared by hardware\nNote: This bit acts only on channels having a complementary output."
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            },
            {
                "name": "BG",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            },
            {
                "name": "B2G",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Break 2 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073818648": {
        "name": "CCMR1_Output",
        "address": 1073818648,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare mode register 1 (output\n          mode)",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = '0' in TIMx_CCER)."
            },
            {
                "name": "OC1FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output Compare 1 fast enable\nThis bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger."
            },
            {
                "name": "OC1PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output Compare 1 preload enable\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nThe PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed."
            },
            {
                "name": "OC1M1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Output Compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nNote: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.\nNote: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.\nNote: The OC1M[3] bit is not contiguous, located in bit 16."
            },
            {
                "name": "OC1CE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Output Compare 1 clear enable"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E = '0' in TIMx_CCER)."
            },
            {
                "name": "OC2FE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output Compare 2 fast enable\nRefer to OC1FE description."
            },
            {
                "name": "OC2PE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output Compare 2 preload enable\nRefer to OC1PE description."
            },
            {
                "name": "OC2M1",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Output Compare 2 mode\nRefer to OC1M[3:0] description."
            },
            {
                "name": "OC2CE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Output Compare 2 clear enable\nRefer to OC1CE description."
            },
            {
                "name": "OC1M2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output Compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nNote: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.\nNote: On channels having a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.\nNote: The OC1M[3] bit is not contiguous, located in bit 16."
            },
            {
                "name": "OC2M2",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Output Compare 2 mode\nRefer to OC1M[3:0] description."
            }
        ]
    },
    "1073818652": {
        "name": "CCMR2_Output",
        "address": 1073818652,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare mode register 2 (output\n          mode)",
        "fields": [
            {
                "name": "CC3S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 3 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC3S bits are writable only when the channel is OFF (CC3E = '0' in TIMx_CCER)."
            },
            {
                "name": "OC3FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output compare 3 fast enable\nRefer to OC1FE description."
            },
            {
                "name": "OC3PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output compare 3 preload enable\nRefer to OC1PE description."
            },
            {
                "name": "OC3M1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Output compare 3 mode\nRefer to OC1M[3:0] description."
            },
            {
                "name": "OC3CE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Output compare 3 clear enable\nRefer to OC1CE description."
            },
            {
                "name": "CC4S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 4 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC4S bits are writable only when the channel is OFF (CC4E = '0' in TIMx_CCER)."
            },
            {
                "name": "OC4FE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output compare 4 fast enable\nRefer to OC1FE description."
            },
            {
                "name": "OC4PE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output compare 4 preload enable\nRefer to OC1PE description."
            },
            {
                "name": "OC4M1",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Output compare 4 mode\nRefer to OC3M[3:0] description."
            },
            {
                "name": "OC4CE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Output compare 4 clear enable\nRefer to OC1CE description."
            },
            {
                "name": "OC3M2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output compare 3 mode\nRefer to OC1M[3:0] description."
            },
            {
                "name": "OC4M2",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Output compare 4 mode\nRefer to OC3M[3:0] description."
            }
        ]
    },
    "1073818656": {
        "name": "TIM1_CCER",
        "address": 1073818656,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare enable\n          register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable\nWhen CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to  for details.\nNote: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output polarity\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\nCC1NP=1, CC1P=1:\tnon-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\nCC1NP=1, CC1P=0:\tThe configuration is reserved, it must not be used.\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\nOn channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output enable\nOn channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output polarity\nCC1 channel configured as output:\nCC1 channel configured as input:\nThis bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer to CC1P description.\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (channel configured as output).\nOn channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC2NE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 complementary output enable\nRefer to CC1NE description"
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 complementary output polarity\nRefer to CC1NP description"
            },
            {
                "name": "CC3E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC3P",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC3NE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 complementary output enable\nRefer to CC1NE description"
            },
            {
                "name": "CC3NP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 complementary output polarity\nRefer to CC1NP description"
            },
            {
                "name": "CC4E",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC4NP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 complementary output polarity\nRefer to CC1NP description"
            },
            {
                "name": "CC5E",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Capture/Compare 5 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC5P",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Capture/Compare 5 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC6E",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Capture/Compare 6 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC6P",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Capture/Compare 6 output polarity\nRefer to CC1P description"
            }
        ]
    },
    "1073818660": {
        "name": "TIM1_CNT",
        "address": 1073818660,
        "size": 32,
        "access": "",
        "desc": "counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value"
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0."
            }
        ]
    },
    "1073818664": {
        "name": "TIM1_PSC",
        "address": 1073818664,
        "size": 32,
        "access": "read-write",
        "desc": "prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value\nThe counter clock frequency (CK_CNT) is equal to fCK_PSC / (PSC[15:0] + 1).\nPSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in 'reset mode')."
            }
        ]
    },
    "1073818668": {
        "name": "TIM1_ARR",
        "address": 1073818668,
        "size": 32,
        "access": "read-write",
        "desc": "auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the  for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null."
            }
        ]
    },
    "1073818672": {
        "name": "TIM1_RCR",
        "address": 1073818672,
        "size": 32,
        "access": "read-write",
        "desc": "repetition counter register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Repetition counter value"
            }
        ]
    },
    "1073818676": {
        "name": "TIM1_CCR1",
        "address": 1073818676,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 1 value"
            }
        ]
    },
    "1073818680": {
        "name": "TIM1_CCR2",
        "address": 1073818680,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 2 value"
            }
        ]
    },
    "1073818684": {
        "name": "TIM1_CCR3",
        "address": 1073818684,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare value"
            }
        ]
    },
    "1073818688": {
        "name": "TIM1_CCR4",
        "address": 1073818688,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare value"
            }
        ]
    },
    "1073818692": {
        "name": "TIM1_BDTR",
        "address": 1073818692,
        "size": 32,
        "access": "read-write",
        "desc": "break and dead-time register",
        "fields": [
            {
                "name": "DTG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time generator setup"
            },
            {
                "name": "LOCK",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Lock configuration\nThese bits offer a write protection against software errors.\nNote: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset."
            },
            {
                "name": "OSSI",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Off-state selection for Idle mode\nThis bit is used when MOE=0 due to a break event or by a software write, on channels configured as outputs.\nSee OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OSSR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Off-state selection for Run mode\nThis bit is used when MOE=1 on channels having a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.\nSee OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Break enable\nThis bit enables the complete break protection (including all sources connected to bk_acth and BKIN sources, as per ).\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Break polarity\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "AOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Automatic output enable\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "MOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Main output enable\nThis bit is cleared asynchronously by hardware as soon as one of the break inputs is active (BRK or BRK2). It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.\nIn response to a break event or if MOE is written to 0: OC and OCN outputs are disabled or forced to idle state depending on the OSSI bit.\nSee OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A)."
            },
            {
                "name": "BKF",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Break filter\nThis bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2F",
                "bitOffset": 20,
                "bitWidth": 4,
                "desc": "Break 2 filter\nThis bit-field defines the frequency used to sample BRK2 input and the length of the digital filter applied to BRK2. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2E",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Break 2 enable\nNote: The BRK2 must only be used with OSSR = OSSI = 1.\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2P",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Break 2 polarity\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKDSRM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Break Disarm\nThis bit is cleared by hardware when no break source is active.\nThe BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2DSRM",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "Break2 Disarm\nRefer to BKDSRM description"
            },
            {
                "name": "BKBID",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Break Bidirectional\nIn the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BK2BID",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Break2 bidirectional\nRefer to BKBID description"
            }
        ]
    },
    "1073818696": {
        "name": "TIM1_DCR",
        "address": 1073818696,
        "size": 32,
        "access": "read-write",
        "desc": "DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\nThis 5-bits vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n..."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\nThis 5-bit vector defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).\n...\nExample: Let us consider the following transfer: DBL = 7 bytes & DBA = TIMx_CR1.\nIf DBL = 7 bytes and DBA = TIMx_CR1 represents the address of the byte to be transferred, the address of the transfer should be given by the following equation:\n(TIMx_CR1 address) + DBA + (DMA index), where DMA index = DBL\nIn this example, 7 bytes are added to (TIMx_CR1 address) + DBA, which gives us the address from/to which the data is copied. In this case, the transfer is done to 7 registers starting from the following address: (TIMx_CR1 address) + DBA\nAccording to the configuration of the DMA Data Size, several cases may occur:\nIf the DMA Data Size is configured in half-words, 16-bit data is transferred to each of the 7 registers.\nIf the DMA Data Size is configured in bytes, the data is also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA."
            }
        ]
    },
    "1073818700": {
        "name": "TIM1_DMAR",
        "address": 1073818700,
        "size": 32,
        "access": "read-write",
        "desc": "DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "DMA register for burst accesses\n\tA read or write operation to the DMAR register accesses the register located at the address (TIMx_CR1 address) + (DBA + DMA index) x 4\n\twhere TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR)."
            }
        ]
    },
    "1073818704": {
        "name": "TIM1_OR1",
        "address": 1073818704,
        "size": 32,
        "access": "read-write",
        "desc": "option register 1",
        "fields": [
            {
                "name": "OCREF_CLR",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Ocref_clr source selection\nThis bit selects the ocref_clr input source."
            }
        ]
    },
    "1073818708": {
        "name": "CCMR3_Output",
        "address": 1073818708,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare mode register 2 (output\n          mode)",
        "fields": [
            {
                "name": "OC6M_bit3",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Output Compare 6 mode bit\n              3"
            },
            {
                "name": "OC5M_bit3",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output Compare 5 mode bit\n              3"
            },
            {
                "name": "OC6CE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Output compare 6 clear\n              enable"
            },
            {
                "name": "OC6M",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Output compare 6 mode"
            },
            {
                "name": "OC6PE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output compare 6 preload\n              enable"
            },
            {
                "name": "OC6FE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output compare 6 fast\n              enable"
            },
            {
                "name": "OC5CE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Output compare 5 clear\n              enable"
            },
            {
                "name": "OC5M",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Output compare 5 mode"
            },
            {
                "name": "OC5PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output compare 5 preload\n              enable"
            },
            {
                "name": "OC5FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output compare 5 fast\n              enable"
            }
        ]
    },
    "1073818712": {
        "name": "TIM1_CCR5",
        "address": 1073818712,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 4",
        "fields": [
            {
                "name": "CCR5",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 5 value\nCCR5 is the value to be loaded in the actual capture/compare 5 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR3 register (bit OC5PE). Else the preload value is copied in the active capture/compare 5 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC5 output."
            },
            {
                "name": "GC5C1",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Group Channel 5 and Channel 1\nDistortion on Channel 1 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).\nNote: it is also possible to apply this distortion on combined PWM signals."
            },
            {
                "name": "GC5C2",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Group Channel 5 and Channel 2\nDistortion on Channel 2 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR1).\nNote: it is also possible to apply this distortion on combined PWM signals."
            },
            {
                "name": "GC5C3",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "Group Channel 5 and Channel 3\nDistortion on Channel 3 output:\nThis bit can either have immediate effect or be preloaded and taken into account after an update event (if preload feature is selected in TIMxCCMR2).\nNote: it is also possible to apply this distortion on combined PWM signals."
            }
        ]
    },
    "1073818716": {
        "name": "TIM1_CCR6",
        "address": 1073818716,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 4",
        "fields": [
            {
                "name": "CCR6",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare value"
            }
        ]
    },
    "1073818720": {
        "name": "TIM1_AF1",
        "address": 1073818720,
        "size": 32,
        "access": "read-write",
        "desc": "DMA address for full transfer",
        "fields": [
            {
                "name": "BKINE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "BRK BKIN input enable\nThis bit enables the BKIN alternate function input for the timer's BRK input. BKIN input is 'ORed' with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "BRK COMP1 enable\nThis bit enables the COMP1 for the timer's BRK input. COMP1 output is 'ORed' with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "BRK COMP2 enable\nThis bit enables the COMP2 for the timer's BRK input. COMP2 output is 'ORed' with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKINP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "BRK BKIN input polarity\nThis bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "BRK COMP1 input polarity\nThis bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "BRK COMP2 input polarity\nThis bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "ETRSEL",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "ETR source selection\nThese bits select the ETR input source.\nOthers: Reserved\nNote: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073818724": {
        "name": "TIM1_AF2",
        "address": 1073818724,
        "size": 32,
        "access": "read-write",
        "desc": "DMA address for full transfer",
        "fields": [
            {
                "name": "BK2INE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "BRK2 BKIN input enable\nThis bit enables the BKIN2 alternate function input for the timer's BRK2 input. BKIN2 input is 'ORed' with the other BRK2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "BRK2 COMP1 enable\nThis bit enables the COMP1 for the timer's BRK2 input. COMP1 output is 'ORed' with the other BRK2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "BRK2 COMP2 enable\nThis bit enables the COMP2 for the timer's BRK2 input. COMP2 output is 'ORed' with the other BRK2 sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2INP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "BRK2 BKIN2 input polarity\nThis bit selects the BKIN2 alternate function input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "BRK2 COMP1 input polarity\nThis bit selects the COMP1 input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BK2CMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "BRK2 COMP2 input polarity\nThis bit selects the COMP2 input sensitivity. It must be programmed together with the BK2P polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073818728": {
        "name": "TIM1_TISEL",
        "address": 1073818728,
        "size": 32,
        "access": "read-write",
        "desc": "TIM1 timer input selection\n          register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "selects TI1[0] to TI1[15] input\nOthers: Reserved"
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "selects TI2[0] to TI2[15] input\nOthers: Reserved"
            },
            {
                "name": "TI3SEL",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "selects TI3[0] to TI3[15] input\nOthers: Reserved"
            },
            {
                "name": "TI4SEL",
                "bitOffset": 24,
                "bitWidth": 4,
                "desc": "selects TI4[0] to TI4[15] input\nOthers: Reserved"
            }
        ]
    },
    "1073741824": {
        "name": "CR1",
        "address": 1073741824,
        "size": 32,
        "access": "read-write",
        "desc": "control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nNote: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\nCEN is cleared automatically in one-pulse mode, when an update event occurs."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction\nNote: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode."
            },
            {
                "name": "CMS",
                "bitOffset": 5,
                "bitWidth": 2,
                "desc": "Center-aligned mode selection\nNote: It is not allowed to switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1)"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (ETR, TIx),"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073741828": {
        "name": "CR2",
        "address": 1073741828,
        "size": 32,
        "access": "read-write",
        "desc": "control register 2",
        "fields": [
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\nThese bits permit to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\nWhen the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in TIMx_SMCR register).\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TI1 selection"
            }
        ]
    },
    "1073741832": {
        "name": "SMCR",
        "address": 1073741832,
        "size": 32,
        "access": "read-write",
        "desc": "slave mode control register",
        "fields": [
            {
                "name": "SMS1",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nreinitializes the counter, generates an update of the registers and starts the counter.\nNote: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "OCCS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "OCREF clear selection\nThis bit is used to select the OCREF clear source"
            },
            {
                "name": "TS1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee  for more details on ITRx meaning for each Timer.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/Slave mode"
            },
            {
                "name": "ETF",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "External trigger filter\nThis bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:"
            },
            {
                "name": "ETPS",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "External trigger prescaler\nExternal trigger signal ETRP frequency must be at most 1/4 of CK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks."
            },
            {
                "name": "ECE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "External clock enable\nThis bit enables External clock mode 2.\nNote: Setting the ECE bit has the same effect as selecting external clock mode 1 with TRGI connected to ETRF (SMS=111 and TS=00111).\nIt is possible to simultaneously use external clock mode 2 with the following slave modes: reset mode, gated mode and trigger mode. Nevertheless, TRGI must not be connected to ETRF in this case (TS bits must not be 00111).\nIf external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF."
            },
            {
                "name": "ETP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "External trigger polarity\nThis bit selects whether ETR or ETR is used for trigger operations"
            },
            {
                "name": "SMS2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nreinitializes the counter, generates an update of the registers and starts the counter.\nNote: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS=00100). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TS2",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Trigger selection\nThis bit-field selects the trigger input to be used to synchronize the counter.\nOthers: Reserved\nSee  for more details on ITRx meaning for each Timer.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            }
        ]
    },
    "1073741836": {
        "name": "DIER",
        "address": 1073741836,
        "size": 32,
        "access": "read-write",
        "desc": "DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt enable"
            },
            {
                "name": "CC3IE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt enable"
            },
            {
                "name": "CC4IE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 DMA request enable"
            },
            {
                "name": "CC3DE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 DMA request enable"
            },
            {
                "name": "CC4DE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            }
        ]
    },
    "1073741840": {
        "name": "SR",
        "address": 1073741840,
        "size": 32,
        "access": "read-write",
        "desc": "status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow or underflow and if UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by a trigger event (refer to the synchro control register description), if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC3IF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "CC4IF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 interrupt flag\nRefer to CC1IF description"
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\nThis flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/compare 2 overcapture flag\nrefer to CC1OF description"
            },
            {
                "name": "CC3OF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 overcapture flag\nrefer to CC1OF description"
            },
            {
                "name": "CC4OF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 overcapture flag\nrefer to CC1OF description"
            }
        ]
    },
    "1073741844": {
        "name": "EGR",
        "address": 1073741844,
        "size": 32,
        "access": "write-only",
        "desc": "event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare 2 generation\nRefer to CC1G description"
            },
            {
                "name": "CC3G",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare 3 generation\nRefer to CC1G description"
            },
            {
                "name": "CC4G",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/compare 4 generation\nRefer to CC1G description"
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073741848": {
        "name": "CCMR1_Output",
        "address": 1073741848,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare mode register 1 (output\n          mode)",
        "fields": [
            {
                "name": "OC2M_3",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Output Compare 2 mode - bit\n              3"
            },
            {
                "name": "OC1M_3",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output Compare 1 mode - bit\n              3"
            },
            {
                "name": "OC2CE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Output compare 2 clear\n              enable"
            },
            {
                "name": "OC2M",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Output compare 2 mode"
            },
            {
                "name": "OC2PE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output compare 2 preload\n              enable"
            },
            {
                "name": "OC2FE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output compare 2 fast\n              enable"
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E = 0 in TIMx_CCER)."
            },
            {
                "name": "OC1CE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Output compare 1 clear enable"
            },
            {
                "name": "OC1M1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Output compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nNote: In PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.\nNote: The OC1M[3] bit is not contiguous, located in bit 16."
            },
            {
                "name": "OC1PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output compare 1 preload enable\nNote: The PWM mode can be used without validating the preload register only in one-pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed."
            },
            {
                "name": "OC1FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output compare 1 fast\n              enable"
            },
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER)."
            }
        ]
    },
    "1073741852": {
        "name": "CCMR2_Output",
        "address": 1073741852,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare mode register 2 (output\n          mode)",
        "fields": [
            {
                "name": "OC4M_3",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Output Compare 4 mode - bit\n              3"
            },
            {
                "name": "OC3M_3",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output Compare 3 mode - bit\n              3"
            },
            {
                "name": "OC4CE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Output compare 4 clear\n              enable"
            },
            {
                "name": "OC4M",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Output compare 4 mode"
            },
            {
                "name": "OC4PE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output compare 4 preload\n              enable"
            },
            {
                "name": "OC4FE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output compare 4 fast\n              enable"
            },
            {
                "name": "CC4S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 4\n              selection"
            },
            {
                "name": "OC3CE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Output compare 3 clear\n              enable"
            },
            {
                "name": "OC3M",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Output compare 3 mode"
            },
            {
                "name": "OC3PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output compare 3 preload\n              enable"
            },
            {
                "name": "OC3FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output compare 3 fast\n              enable"
            },
            {
                "name": "CC3S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 3\n              selection"
            }
        ]
    },
    "1073741856": {
        "name": "CCER",
        "address": 1073741856,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare enable\n          register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity.\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\nCC1NP=1, CC1P=1:\tnon-inverted/both edges. The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\nCC1NP=1, CC1P=0:\tThis configuration is reserved, it must not be used."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity.\nCC1 channel configured as output: CC1NP must be kept cleared in this case.\nCC1 channel configured as input: This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 polarity. refer to CC1P description."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output enable.\nRefer to CC1E description"
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity.\nrefer to CC1P description"
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output Polarity.\nRefer to CC1NP description"
            },
            {
                "name": "CC3E",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output enable.\nRefer to CC1E description"
            },
            {
                "name": "CC3P",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity.\nRefer to CC1P description"
            },
            {
                "name": "CC3NP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Capture/Compare 3 output Polarity.\nRefer to CC1NP description"
            },
            {
                "name": "CC4E",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output enable.\nrefer to CC1E description"
            },
            {
                "name": "CC4P",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity.\nRefer to CC1P description"
            },
            {
                "name": "CC4NP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Capture/Compare 4 output Polarity.\nRefer to CC1NP description"
            }
        ]
    },
    "1073741860": {
        "name": "CNT",
        "address": 1073741860,
        "size": 32,
        "access": "read-write",
        "desc": "counter",
        "fields": [
            {
                "name": "CNT_H",
                "bitOffset": 16,
                "bitWidth": 16,
                "desc": "High counter value (TIM2\n              only)"
            },
            {
                "name": "CNT_L",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Low counter value"
            }
        ]
    },
    "1073741864": {
        "name": "PSC",
        "address": 1073741864,
        "size": 32,
        "access": "read-write",
        "desc": "prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value"
            }
        ]
    },
    "1073741868": {
        "name": "ARR",
        "address": 1073741868,
        "size": 32,
        "access": "read-write",
        "desc": "auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "High auto-reload value (TIM2)\nnullLow Auto-reload value\nARR is the value to be loaded in the actual auto-reload register.\nRefer to the  for more details about ARR update and behavior.\nThe counter is blocked while the auto-reload value is null."
            }
        ]
    },
    "1073741876": {
        "name": "CCR1",
        "address": 1073741876,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "High Capture/Compare 1 value (TIM2)\nnullLow Capture/Compare 1 value\nIf channel CC1 is configured as output:\nCCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC1PE). Else the preload value is copied in the active capture/compare 1 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.\nIf channel CC1is configured as input:\nCCR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073741880": {
        "name": "CCR2",
        "address": 1073741880,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "High Capture/Compare 2 value (TIM2)\nnullLow Capture/Compare 2 value\nIf channel CC2 is configured as output:\nCCR2 is the value to be loaded in the actual capture/compare 2 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register (bit OC2PE). Else the preload value is copied in the active capture/compare 2 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC2 output.\nIf channel CC2 is configured as input:\nCCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073741884": {
        "name": "CCR3",
        "address": 1073741884,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 3",
        "fields": [
            {
                "name": "CCR3",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "High Capture/Compare 3 value (TIM2)\nnullLow Capture/Compare value\nIf channel CC3 is configured as output:\nCCR3 is the value to be loaded in the actual capture/compare 3 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC3PE). Else the preload value is copied in the active capture/compare 3 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC3 output.\nIf channel CC3is configured as input:\nCCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073741888": {
        "name": "CCR4",
        "address": 1073741888,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 4",
        "fields": [
            {
                "name": "CCR4",
                "bitOffset": 0,
                "bitWidth": 32,
                "desc": "High Capture/Compare 4 value (TIM2)\nnullLow Capture/Compare value\nif CC4 channel is configured as output (CC4S bits):\nCCR4 is the value to be loaded in the actual capture/compare 4 register (preload value).\nIt is loaded permanently if the preload feature is not selected in the TIMx_CCMR2 register (bit OC4PE). Else the preload value is copied in the active capture/compare 4 register when an update event occurs.\nThe active capture/compare register contains the value to be compared to the counter TIMx_CNT and signalled on OC4 output.\nif CC4 channel is configured as input (CC4S bits in TIMx_CCMR4 register):\nCCR4 is the counter value transferred by the last input capture 4 event (IC4). The TIMx_CCR4 register is read-only and cannot be programmed."
            }
        ]
    },
    "1073741896": {
        "name": "DCR",
        "address": 1073741896,
        "size": 32,
        "access": "read-write",
        "desc": "DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\nThis 5-bit vector defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n...\nExample: Let us consider the following transfer: DBL = 7 transfers & DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\nThis 5-bit vector defines the number of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).\n..."
            }
        ]
    },
    "1073741900": {
        "name": "DMAR",
        "address": 1073741900,
        "size": 32,
        "access": "read-write",
        "desc": "DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "DMA register for burst\n              accesses"
            }
        ]
    },
    "1073741904": {
        "name": "OR1",
        "address": 1073741904,
        "size": 32,
        "access": "read-write",
        "desc": "TIM option register",
        "fields": [
            {
                "name": "OCREF_CLR",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Ocref_clr source selection\nThis bit selects the ocref_clr input source."
            }
        ]
    },
    "1073741920": {
        "name": "AF1",
        "address": 1073741920,
        "size": 32,
        "access": "read-write",
        "desc": "TIM alternate function option register\n          1",
        "fields": [
            {
                "name": "ETRSEL",
                "bitOffset": 14,
                "bitWidth": 4,
                "desc": "ETR source selection\nThese bits select the ETR input source.\nOthers: Reserved"
            }
        ]
    },
    "1073741928": {
        "name": "TISEL",
        "address": 1073741928,
        "size": 32,
        "access": "read-write",
        "desc": "TIM alternate function option register\n          1",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "TI1[0] to TI1[15] input selection\nThese bits select the TI1[0] to TI1[15] input source.\nOthers: Reserved"
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "TI2[0] to TI2[15] input selection\nThese bits select the TI2[0] to TI2[15] input source.\nOthers: Reserved"
            }
        ]
    },
    "1073745920": {
        "name": "CR1",
        "address": 1073745920,
        "size": 32,
        "access": "read-write",
        "desc": "control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nNote: Gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.\nCEN is cleared automatically in one-pulse mode, when an update event occurs."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073745924": {
        "name": "CR2",
        "address": 1073745924,
        "size": 32,
        "access": "read-write",
        "desc": "control register 2",
        "fields": [
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\nThese bits are used to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:\nWhen the Counter Enable signal is controlled by the trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in the TIMx_SMCR register).\nNote: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer."
            }
        ]
    },
    "1073745932": {
        "name": "DIER",
        "address": 1073745932,
        "size": 32,
        "access": "read-write",
        "desc": "DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            }
        ]
    },
    "1073745936": {
        "name": "SR",
        "address": 1073745936,
        "size": 32,
        "access": "read-write",
        "desc": "status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow or underflow regarding the repetition counter value and if UDIS = 0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in the TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register."
            }
        ]
    },
    "1073745940": {
        "name": "EGR",
        "address": 1073745940,
        "size": 32,
        "access": "write-only",
        "desc": "event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            }
        ]
    },
    "1073745956": {
        "name": "CNT",
        "address": 1073745956,
        "size": 32,
        "access": "read-write",
        "desc": "counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Counter value"
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF Copy\nThis bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0."
            }
        ]
    },
    "1073745960": {
        "name": "PSC",
        "address": 1073745960,
        "size": 32,
        "access": "read-write",
        "desc": "prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value"
            }
        ]
    },
    "1073745964": {
        "name": "ARR",
        "address": 1073745964,
        "size": 32,
        "access": "read-write",
        "desc": "auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value"
            }
        ]
    },
    "1073750016": {
        "name": "CR1",
        "address": 1073750016,
        "size": 32,
        "access": "read-write",
        "desc": "control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nNote: External clock and gated mode can work only if the CEN bit has been previously set by\nsoftware. However trigger mode can set the CEN bit automatically by hardware."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable update interrupt (UEV) event generation.\nCounter overflow\nSetting the UG bit.\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the update interrupt (UEV) sources.\nCounter overflow\nSetting the UG bit"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (TIx),"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073750028": {
        "name": "DIER",
        "address": 1073750028,
        "size": 32,
        "access": "read-write",
        "desc": "DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            }
        ]
    },
    "1073750032": {
        "name": "SR",
        "address": 1073750032,
        "size": 32,
        "access": "read-write",
        "desc": "status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow and if UDIS='0' in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS='0' and UDIS='0' in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when he content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            }
        ]
    },
    "1073750036": {
        "name": "EGR",
        "address": 1073750036,
        "size": 32,
        "access": "write-only",
        "desc": "event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            }
        ]
    },
    "1073750040": {
        "name": "CCMR1_Output",
        "address": 1073750040,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare mode register 1 (output\n          mode)",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER)."
            },
            {
                "name": "OC1FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output compare 1 fast enable\nThis bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger."
            },
            {
                "name": "OC1PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output compare 1 preload enable\nNote: The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed."
            },
            {
                "name": "OC1M1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Output compare 1 mode (refer to bit 16 for OC1M[3])\nThese bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit.\nOthers: Reserved\nNote: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode.\nNote: The OC1M[3] bit is not contiguous, located in bit 16."
            },
            {
                "name": "OC1M2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output compare 1 mode (refer to bit 16 for OC1M[3])\nThese bits define the behavior of the output reference signal OC1REF from which OC1 is derived. OC1REF is active high whereas OC1 active level depends on CC1P bit.\nOthers: Reserved\nNote: In PWM mode 1 or 2, the OCREF level changes when the result of the comparison changes or when the output compare mode switches from frozen to PWM mode.\nNote: The OC1M[3] bit is not contiguous, located in bit 16."
            }
        ]
    },
    "1073750048": {
        "name": "CCER",
        "address": 1073750048,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare enable\n          register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output Polarity.\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\nCC1NP=1, CC1P=1:\tnon-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\nCC1NP=1, CC1P=0:\tThis configuration is reserved, it must not be used."
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output Polarity.\nCC1 channel configured as output: CC1NP must be kept cleared.\nCC1 channel configured as input: CC1NP bit is used in conjunction with CC1P to define TI1FP1 polarity (refer to CC1P description)."
            }
        ]
    },
    "1073750052": {
        "name": "CNT",
        "address": 1073750052,
        "size": 32,
        "access": "read-write",
        "desc": "counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "low counter value"
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF Copy"
            }
        ]
    },
    "1073750056": {
        "name": "PSC",
        "address": 1073750056,
        "size": 32,
        "access": "read-write",
        "desc": "prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value"
            }
        ]
    },
    "1073750060": {
        "name": "ARR",
        "address": 1073750060,
        "size": 32,
        "access": "read-write",
        "desc": "auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Low Auto-reload value"
            }
        ]
    },
    "1073750068": {
        "name": "CCR1",
        "address": 1073750068,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Low Capture/Compare 1\n              value"
            }
        ]
    },
    "1073750120": {
        "name": "TISEL",
        "address": 1073750120,
        "size": 32,
        "access": "read-write",
        "desc": "TIM timer input selection\n          register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "selects TI1[0] to TI1[15] input\nOthers: Reserved"
            }
        ]
    },
    "1073823744": {
        "name": "CR1",
        "address": 1073823744,
        "size": 32,
        "access": "read-write",
        "desc": "control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nNote: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One-pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\nThis bitfield indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS) used by the dead-time generators and the digital filters (TIx)"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073823748": {
        "name": "CR2",
        "address": 1073823748,
        "size": 32,
        "access": "read-write",
        "desc": "control register 2",
        "fields": [
            {
                "name": "CCPC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare preloaded control\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCUS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare control update selection\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "MMS",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Master mode selection\nThese bits allow to select the information to be sent in master mode to slave timers for synchronization (TRGO). The combination is as follows:"
            },
            {
                "name": "TI1S",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TI1 selection"
            },
            {
                "name": "OIS1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1 output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIM15_BDTR register)."
            },
            {
                "name": "OIS1N",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1N output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIM15_BDTR register)."
            },
            {
                "name": "OIS2",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output idle state 2 (OC2 output)\nNote: This bit cannot be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in the TIM15_BDTR register)."
            }
        ]
    },
    "1073823752": {
        "name": "SMCR",
        "address": 1073823752,
        "size": 32,
        "access": "read-write",
        "desc": "slave mode control register",
        "fields": [
            {
                "name": "SMS1",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nOther codes: reserved.\nNote: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS='00100'). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TS1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Trigger selection\nThis bit field selects the trigger input to be used to synchronize the counter.\nOther: Reserved\nSee  for more details on ITRx meaning for each Timer.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            },
            {
                "name": "MSM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Master/slave mode"
            },
            {
                "name": "SMS2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Slave mode selection\nWhen external signals are selected the active edge of the trigger signal (TRGI) is linked to the polarity selected on the external input (see Input Control register and Control Register description.\nOther codes: reserved.\nNote: The gated mode must not be used if TI1F_ED is selected as the trigger input (TS='00100'). Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the gated mode checks the level of the trigger signal.\nNote: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer."
            },
            {
                "name": "TS2",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Trigger selection\nThis bit field selects the trigger input to be used to synchronize the counter.\nOther: Reserved\nSee  for more details on ITRx meaning for each Timer.\nNote: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition."
            }
        ]
    },
    "1073823756": {
        "name": "DIER",
        "address": 1073823756,
        "size": 32,
        "access": "read-write",
        "desc": "DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "CC2IE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt enable"
            },
            {
                "name": "COMIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt enable"
            },
            {
                "name": "TIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt enable"
            },
            {
                "name": "BIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            },
            {
                "name": "CC2DE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 DMA request enable"
            },
            {
                "name": "COMDE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "COM DMA request enable"
            },
            {
                "name": "TDE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Trigger DMA request enable"
            }
        ]
    },
    "1073823760": {
        "name": "SR",
        "address": 1073823760,
        "size": 32,
        "access": "read-write",
        "desc": "status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by a trigger event (refer to control register (TIM15_SMCR)), if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "CC2IF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 interrupt flag\nrefer to CC1IF description"
            },
            {
                "name": "COMIF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt flag."
            },
            {
                "name": "TIF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger interrupt flag\nThis flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode, both edges in case gated mode is selected). It is set when the counter starts or stops when gated mode is selected. It is cleared by software."
            },
            {
                "name": "BIF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt flag\nThis flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            },
            {
                "name": "CC2OF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 overcapture flag\nRefer to CC1OF description"
            }
        ]
    },
    "1073823764": {
        "name": "EGR",
        "address": 1073823764,
        "size": 32,
        "access": "write-only",
        "desc": "event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "CC2G",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 generation\nRefer to CC1G description"
            },
            {
                "name": "COMG",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare control update generation\nThis bit can be set by software, it is automatically cleared by hardware.\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "TG",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Trigger generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            },
            {
                "name": "BG",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073823768": {
        "name": "CCMR1_Output",
        "address": 1073823768,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare mode register (output\n          mode)",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC1S bits are writable only when the channel is OFF (CC1E = '0' in TIMx_CCER)."
            },
            {
                "name": "OC1FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output Compare 1 fast enable\nThis bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger."
            },
            {
                "name": "OC1PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output Compare 1 preload enable\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nThe PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed."
            },
            {
                "name": "OC1M1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Output Compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nIn PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.\nOn channels that have a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.\nThe OC1M[3] bit is not contiguous, located in bit 16."
            },
            {
                "name": "CC2S",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Capture/Compare 2 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nNote: CC2S bits are writable only when the channel is OFF (CC2E = '0' in TIMx_CCER)."
            },
            {
                "name": "OC2FE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Output Compare 2 fast enable"
            },
            {
                "name": "OC2PE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Output Compare 2 preload enable"
            },
            {
                "name": "OC2M1",
                "bitOffset": 12,
                "bitWidth": 3,
                "desc": "Output Compare 2 mode"
            },
            {
                "name": "OC1M2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output Compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nIn PWM mode, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.\nOn channels that have a complementary output, this bit field is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the OC1M active bits take the new value from the preloaded bits only when a COM event is generated.\nThe OC1M[3] bit is not contiguous, located in bit 16."
            },
            {
                "name": "OC2M2",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Output Compare 2 mode"
            }
        ]
    },
    "1073823776": {
        "name": "CCER",
        "address": 1073823776,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare enable\n          register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable\nWhen CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to  for details."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output polarity\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\nCC1NP=1, CC1P=1:\tnon-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\nCC1NP=1, CC1P=0: this configuration is reserved, it must not be used.\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\nOn channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output enable"
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output polarity\nCC1 channel configured as output:\nCC1 channel configured as input:\nThis bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer\nto CC1P description.\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nOn channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC2E",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output enable\nRefer to CC1E description"
            },
            {
                "name": "CC2P",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 output polarity\nRefer to CC1P description"
            },
            {
                "name": "CC2NP",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Capture/Compare 2 complementary output polarity\nRefer to CC1NP description"
            }
        ]
    },
    "1073823780": {
        "name": "CNT",
        "address": 1073823780,
        "size": 32,
        "access": "",
        "desc": "counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "counter value"
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF Copy"
            }
        ]
    },
    "1073823784": {
        "name": "PSC",
        "address": 1073823784,
        "size": 32,
        "access": "read-write",
        "desc": "prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value"
            }
        ]
    },
    "1073823788": {
        "name": "ARR",
        "address": 1073823788,
        "size": 32,
        "access": "read-write",
        "desc": "auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto-reload value"
            }
        ]
    },
    "1073823792": {
        "name": "RCR",
        "address": 1073823792,
        "size": 32,
        "access": "read-write",
        "desc": "repetition counter register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Repetition counter value"
            }
        ]
    },
    "1073823796": {
        "name": "CCR1",
        "address": 1073823796,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 1 value"
            }
        ]
    },
    "1073823800": {
        "name": "CCR2",
        "address": 1073823800,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 2",
        "fields": [
            {
                "name": "CCR2",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 2 value"
            }
        ]
    },
    "1073823812": {
        "name": "BDTR",
        "address": 1073823812,
        "size": 32,
        "access": "read-write",
        "desc": "break and dead-time register",
        "fields": [
            {
                "name": "DTG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time generator setup"
            },
            {
                "name": "LOCK",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Lock configuration\nThese bits offer a write protection against software errors.\nNote: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset."
            },
            {
                "name": "OSSI",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Off-state selection for Idle mode\nThis bit is used when MOE=0 on channels configured as outputs.\nSee OC/OCN enable description for more details (enable register (TIM15_CCER) on page818).\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OSSR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Off-state selection for Run mode\nThis bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.\nSee OC/OCN enable description for more details (enable register (TIM15_CCER) on page818).\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Break enable\n1; Break inputs (BRK and CCS clock failure event) enabled\nThis bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Break polarity\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nAny write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "AOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Automatic output enable\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "MOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Main output enable\nThis bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.\nSee OC/OCN enable description for more details (enable register (TIM15_CCER) on page818)."
            },
            {
                "name": "BKF",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Break filter\nThis bit-field defines the frequency used to sample the BRK input signal and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output:\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKDSRM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Break Disarm\nThis bit is cleared by hardware when no break source is active.\nThe BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKBID",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Break Bidirectional\nIn the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            }
        ]
    },
    "1073823816": {
        "name": "DCR",
        "address": 1073823816,
        "size": 32,
        "access": "read-write",
        "desc": "DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\nThis 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n..."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\nThis 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address).\n..."
            }
        ]
    },
    "1073823820": {
        "name": "DMAR",
        "address": 1073823820,
        "size": 32,
        "access": "read-write",
        "desc": "DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "DMA register for burst\n              accesses"
            }
        ]
    },
    "1073823840": {
        "name": "AF1",
        "address": 1073823840,
        "size": 32,
        "access": "read-write",
        "desc": "TIM15 alternate register 1",
        "fields": [
            {
                "name": "BKINE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "BRK BKIN input enable\nThis bit enables the BKIN alternate function input for the timer's BRK input. BKIN input is 'ORed' with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "BRK COMP1 enable\nThis bit enables the COMP1 for the timer's BRK input. COMP1 output is 'ORed' with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "BRK COMP2 enable\nThis bit enables the COMP2 for the timer's BRK input. COMP2 output is 'ORed' with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP3E",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "BRK COMP3 enable\nThis bit enables the COMP3 for the timer's BRK input. COMP3 output is 'ORed' with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKINP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "BRK BKIN input polarity\nThis bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "BRK COMP1 input polarity\nThis bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "BRK COMP2 input polarity\nThis bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP3P",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "BRK COMP3 input polarity\nThis bit selects the COMP3 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073823848": {
        "name": "TISEL",
        "address": 1073823848,
        "size": 32,
        "access": "read-write",
        "desc": "input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "selects TI1[0] to TI1[15] input\nOthers: Reserved"
            },
            {
                "name": "TI2SEL",
                "bitOffset": 8,
                "bitWidth": 4,
                "desc": "selects TI2[0] to TI2[15] input\nOthers: Reserved"
            }
        ]
    },
    "1073824768": {
        "name": "CR1",
        "address": 1073824768,
        "size": 32,
        "access": "read-write",
        "desc": "control register 1",
        "fields": [
            {
                "name": "CEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Counter enable\nNote: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware."
            },
            {
                "name": "UDIS",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Update disable\nThis bit is set and cleared by software to enable/disable UEV event generation.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller\nBuffered registers are then loaded with their preload values."
            },
            {
                "name": "URS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Update request source\nThis bit is set and cleared by software to select the UEV event sources.\nCounter overflow/underflow\nSetting the UG bit\nUpdate generation through the slave mode controller"
            },
            {
                "name": "OPM",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "One pulse mode"
            },
            {
                "name": "ARPE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Auto-reload preload enable"
            },
            {
                "name": "CKD",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Clock division\nThis bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (TIx),"
            },
            {
                "name": "UIFREMAP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "UIF status bit remapping"
            }
        ]
    },
    "1073824772": {
        "name": "CR2",
        "address": 1073824772,
        "size": 32,
        "access": "read-write",
        "desc": "control register 2",
        "fields": [
            {
                "name": "CCPC",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/compare preloaded control\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCUS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/compare control update selection\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "CCDS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/compare DMA selection"
            },
            {
                "name": "OIS1",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1 output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OIS1N",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Output Idle state 1 (OC1N output)\nNote: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073824780": {
        "name": "DIER",
        "address": 1073824780,
        "size": 32,
        "access": "read-write",
        "desc": "DMA/Interrupt enable register",
        "fields": [
            {
                "name": "UIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt enable"
            },
            {
                "name": "CC1IE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt enable"
            },
            {
                "name": "COMIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt enable"
            },
            {
                "name": "BIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt enable"
            },
            {
                "name": "UDE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Update DMA request enable"
            },
            {
                "name": "CC1DE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 DMA request enable"
            }
        ]
    },
    "1073824784": {
        "name": "SR",
        "address": 1073824784,
        "size": 32,
        "access": "read-write",
        "desc": "status register",
        "fields": [
            {
                "name": "UIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update interrupt flag\nThis bit is set by hardware on an update event. It is cleared by software.\nAt overflow regarding the repetition counter value (update if repetition counter = 0) and if the UDIS=0 in the TIMx_CR1 register.\nWhen CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register."
            },
            {
                "name": "CC1IF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 interrupt flag\nThis flag is set by hardware. It is cleared by software (input capture or output compare mode) or by reading the TIMx_CCR1 register (input capture mode only).\nIf channel CC1 is configured as output: this flag is set when the content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. When the content of TIMx_CCR1 is greater than the content of TIMx_ARR, the CC1IF bit goes high on the counter overflow (in up-counting and up/down-counting modes) or underflow (in down-counting mode). There are 3 possible options for flag setting in center-aligned mode, refer to the CMS bits in the TIMx_CR1 register for the full description.\nIf channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER)."
            },
            {
                "name": "COMIF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "COM interrupt flag"
            },
            {
                "name": "BIF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break interrupt flag\nThis flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active."
            },
            {
                "name": "CC1OF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 overcapture flag\nThis flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to '0'."
            }
        ]
    },
    "1073824788": {
        "name": "EGR",
        "address": 1073824788,
        "size": 32,
        "access": "write-only",
        "desc": "event generation register",
        "fields": [
            {
                "name": "UG",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Update generation\nThis bit can be set by software, it is automatically cleared by hardware."
            },
            {
                "name": "CC1G",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware.\nIf channel CC1 is configured as output:\nCC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled.\nIf channel CC1 is configured as input:\nThe current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high."
            },
            {
                "name": "COMG",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Capture/Compare control update generation\nThis bit can be set by software, it is automatically cleared by hardware.\nNote: This bit acts only on channels that have a complementary output."
            },
            {
                "name": "BG",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Break generation\nThis bit is set by software in order to generate an event, it is automatically cleared by hardware."
            }
        ]
    },
    "1073824792": {
        "name": "CCMR1_Output",
        "address": 1073824792,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare mode register (output\n          mode)",
        "fields": [
            {
                "name": "CC1S",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Capture/Compare 1 selection\nThis bit-field defines the direction of the channel (input/output) as well as the used input.\nOthers: Reserved\nNote: CC1S bits are writable only when the channel is OFF (CC1E = '0' in TIMx_CCER)."
            },
            {
                "name": "OC1FE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Output Compare 1 fast enable\nThis bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger."
            },
            {
                "name": "OC1PE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Output Compare 1 preload enable\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nThe PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed."
            },
            {
                "name": "OC1M1",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "Output Compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nAll other values: Reserved\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nIn PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.\nThe OC1M[3] bit is not contiguous, located in bit 16."
            },
            {
                "name": "OC1M2",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Output Compare 1 mode\nThese bits define the behavior of the output reference signal OC1REF from which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and OC1N active level depends on CC1P and CC1NP bits.\nAll other values: Reserved\nNote: These bits can not be modified as long as LOCK level 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nIn PWM mode 1 or 2, the OCREF level changes only when the result of the comparison changes or when the output compare mode switches from 'frozen' mode to 'PWM' mode.\nThe OC1M[3] bit is not contiguous, located in bit 16."
            }
        ]
    },
    "1073824800": {
        "name": "CCER",
        "address": 1073824800,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare enable\n          register",
        "fields": [
            {
                "name": "CC1E",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output enable\nWhen CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to  for details."
            },
            {
                "name": "CC1P",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 output polarity\nWhen CC1 channel is configured as input, both CC1NP/CC1P bits select the active polarity of TI1FP1 and TI2FP1 for trigger or capture operations.\nCC1NP=0, CC1P=0:\tnon-inverted/rising edge. The circuit is sensitive to TIxFP1 rising edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is not inverted (trigger operation in gated mode or encoder mode).\nCC1NP=0, CC1P=1:\tinverted/falling edge. The circuit is sensitive to TIxFP1 falling edge (capture or trigger operations in reset, external clock or trigger mode), TIxFP1 is inverted (trigger operation in gated mode or encoder mode).\nCC1NP=1, CC1P=1:\tnon-inverted/both edges/ The circuit is sensitive to both TIxFP1 rising and falling edges (capture or trigger operations in reset, external clock or trigger mode), TIxFP1is not inverted (trigger operation in gated mode). This configuration must not be used in encoder mode.\nCC1NP=1, CC1P=0:\tthis configuration is reserved, it must not be used.\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).\nOn channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated."
            },
            {
                "name": "CC1NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output enable"
            },
            {
                "name": "CC1NP",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Capture/Compare 1 complementary output polarity\nCC1 channel configured as output:\nCC1 channel configured as input:\nThis bit is used in conjunction with CC1P to define the polarity of TI1FP1 and TI2FP1. Refer\nto the description of CC1P.\nNote: This bit is not writable as soon as LOCK level 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register) and CC1S='00' (the channel is configured in output).\nOn channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a commutation event is generated."
            }
        ]
    },
    "1073824804": {
        "name": "CNT",
        "address": 1073824804,
        "size": 32,
        "access": "",
        "desc": "counter",
        "fields": [
            {
                "name": "CNT",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "counter value"
            },
            {
                "name": "UIFCPY",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UIF Copy"
            }
        ]
    },
    "1073824808": {
        "name": "PSC",
        "address": 1073824808,
        "size": 32,
        "access": "read-write",
        "desc": "prescaler",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Prescaler value"
            }
        ]
    },
    "1073824812": {
        "name": "ARR",
        "address": 1073824812,
        "size": 32,
        "access": "read-write",
        "desc": "auto-reload register",
        "fields": [
            {
                "name": "ARR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Auto-reload value"
            }
        ]
    },
    "1073824816": {
        "name": "RCR",
        "address": 1073824816,
        "size": 32,
        "access": "read-write",
        "desc": "repetition counter register",
        "fields": [
            {
                "name": "REP",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Repetition counter value"
            }
        ]
    },
    "1073824820": {
        "name": "CCR1",
        "address": 1073824820,
        "size": 32,
        "access": "read-write",
        "desc": "capture/compare register 1",
        "fields": [
            {
                "name": "CCR1",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "Capture/Compare 1 value"
            }
        ]
    },
    "1073824836": {
        "name": "BDTR",
        "address": 1073824836,
        "size": 32,
        "access": "read-write",
        "desc": "break and dead-time register",
        "fields": [
            {
                "name": "DTG",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Dead-time generator setup"
            },
            {
                "name": "LOCK",
                "bitOffset": 8,
                "bitWidth": 2,
                "desc": "Lock configuration\nThese bits offer a write protection against software errors.\nNote: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset."
            },
            {
                "name": "OSSI",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Off-state selection for Idle mode\nThis bit is used when MOE=0 on channels configured as outputs.\nSee OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page846).\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "OSSR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Off-state selection for Run mode\nThis bit is used when MOE=1 on channels that have a complementary output which are configured as outputs. OSSR is not implemented if no complementary output is implemented in the timer.\nSee OC/OCN enable description for more details (enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page846).\nNote: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Break enable\n1; Break inputs (BRK and CCS clock failure event) enabled\nNote: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nAny write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKP",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Break polarity\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nAny write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "AOE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Automatic output enable\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "MOE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Main output enable\nThis bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.\nenable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page846)."
            },
            {
                "name": "BKF",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "Break filter\nThis bit-field defines the frequency used to sample BRK input and the length of the digital filter applied to BRK. The digital filter is made of an event counter in which N events are needed to validate a transition on the output:\nThis bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKDSRM",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Break Disarm\nThis bit is cleared by hardware when no break source is active.\nThe BKDSRM bit must be set by software to release the bidirectional output control (open-drain output in Hi-Z state) and then be polled it until it is reset by hardware, indicating that the fault condition has disappeared.\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            },
            {
                "name": "BKBID",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Break Bidirectional\nIn the bidirectional mode (BKBID bit set to 1), the break input is configured both in input mode and in open drain output mode. Any active break event asserts a low logic level on the Break input to indicate an internal break event to external devices.\nNote: This bit cannot be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).\nNote: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective."
            }
        ]
    },
    "1073824840": {
        "name": "DCR",
        "address": 1073824840,
        "size": 32,
        "access": "read-write",
        "desc": "DMA control register",
        "fields": [
            {
                "name": "DBA",
                "bitOffset": 0,
                "bitWidth": 5,
                "desc": "DMA base address\nThis 5-bit field defines the base-address for DMA transfers (when read/write access are done through the TIMx_DMAR address). DBA is defined as an offset starting from the address of the TIMx_CR1 register.\nExample:\n...\nExample: Let us consider the following transfer: DBL = 7 transfers and DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address."
            },
            {
                "name": "DBL",
                "bitOffset": 8,
                "bitWidth": 5,
                "desc": "DMA burst length\nThis 5-bit field defines the length of DMA transfers (the timer recognizes a burst transfer when a read or a write access is done to the TIMx_DMAR address), i.e. the number of transfers. Transfers can be in half-words or in bytes (see example below).\n..."
            }
        ]
    },
    "1073824844": {
        "name": "DMAR",
        "address": 1073824844,
        "size": 32,
        "access": "read-write",
        "desc": "DMA address for full transfer",
        "fields": [
            {
                "name": "DMAB",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "DMA register for burst\n              accesses"
            }
        ]
    },
    "1073824864": {
        "name": "AF1",
        "address": 1073824864,
        "size": 32,
        "access": "read-write",
        "desc": "TIM17 option register 1",
        "fields": [
            {
                "name": "BKINE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "BRK BKIN input enable\nThis bit enables the BKIN alternate function input for the timer's BRK input. BKIN input is 'ORed' with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1E",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "BRK COMP1 enable\nThis bit enables the COMP1 for the timer's BRK input. COMP1 output is 'ORed' with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2E",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "BRK COMP2 enable\nThis bit enables the COMP2 for the timer's BRK input. COMP2 output is 'ORed' with the other BRK sources.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKINP",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "BRK BKIN input polarity\nThis bit selects the BKIN alternate function input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP1P",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "BRK COMP1 input polarity\nThis bit selects the COMP1 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            },
            {
                "name": "BKCMP2P",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "BRK COMP2 input polarity\nThis bit selects the COMP2 input sensitivity. It must be programmed together with the BKP polarity bit.\nNote: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register)."
            }
        ]
    },
    "1073824872": {
        "name": "TISEL",
        "address": 1073824872,
        "size": 32,
        "access": "read-write",
        "desc": "input selection register",
        "fields": [
            {
                "name": "TI1SEL",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "selects TI1[0] to TI1[15] input\nOthers: Reserved"
            }
        ]
    },
    "1073782784": {
        "name": "UCPD_CFGR1",
        "address": 1073782784,
        "size": 32,
        "access": "",
        "desc": "UCPD configuration register 1 ",
        "fields": [
            {
                "name": "HBITCLKDIV",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "Division ratio for producing half-bit clock\nThe bitfield determines the division ratio (the bitfield value plus one) of a ucpd_clk divider producing half-bit clock (hbit_clk)."
            },
            {
                "name": "IFRGAP",
                "bitOffset": 6,
                "bitWidth": 5,
                "desc": "Division ratio for producing inter-frame gap timer clock\nThe bitfield determines the division ratio (the bitfield value minus one) of a ucpd_clk divider producing inter-frame gap timer clock (tInterFrameGap).\nThe division ratio 15 is to apply for Tx clock at the USB PD 2.0 specification nominal value. The division ratios below 15 are to apply for Tx clock below nominal, and the division ratios above 15 for Tx clock above nominal."
            },
            {
                "name": "TRANSWIN",
                "bitOffset": 11,
                "bitWidth": 5,
                "desc": "Transition window duration\nThe bitfield determines the division ratio (the bitfield value minus one) of a hbit_clk divider producing tTransitionWindow interval.\nSet a value that produces an interval of 12 to 20 us, taking into account the ucpd_clk frequency and the HBITCLKDIV[5:0] bitfield setting."
            },
            {
                "name": "PSC_USBPDCLK",
                "bitOffset": 17,
                "bitWidth": 3,
                "desc": "Pre-scaler division ratio for generating ucpd_clk\nThe bitfield determines the division ratio of a kernel clock pre-scaler producing UCPD peripheral clock (ucpd_clk).\nIt is recommended to use the pre-scaler so as to set the ucpd_clk frequency in the range from 6 to 9 MHz."
            },
            {
                "name": "RXORDSETEN",
                "bitOffset": 20,
                "bitWidth": 9,
                "desc": "Receiver ordered set enable\nThe bitfield determines the types of ordered sets that the receiver must detect. When set/cleared, each bit enables/disables a specific function:\n0bxxxxxxxx1: SOP detect enabled\n0bxxxxxxx1x: SOP' detect enabled\n0bxxxxxx1xx: SOP'' detect enabled\n0bxxxxx1xxx: Hard Reset detect enabled\n0bxxxx1xxxx: Cable Detect reset enabled\n0bxxx1xxxxx: SOP'_Debug enabled\n0bxx1xxxxxx: SOP''_Debug enabled\n0bx1xxxxxxx: SOP extension#1 enabled\n0b1xxxxxxxx: SOP extension#2 enabled"
            },
            {
                "name": "TXDMAEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Transmission DMA mode enable\nWhen set, the bit enables DMA mode for transmission."
            },
            {
                "name": "RXDMAEN",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Reception DMA mode enable\nWhen set, the bit enables DMA mode for reception."
            },
            {
                "name": "UCPDEN",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "UCPD peripheral enable\nGeneral enable of the UCPD peripheral.\nUpon disabling, the peripheral instantly quits any ongoing activity and all control bits and bitfields default to their reset values. They must be set to their desired values each time the peripheral transits from disabled to enabled state."
            }
        ]
    },
    "1073782788": {
        "name": "UCPD_CFGR2",
        "address": 1073782788,
        "size": 32,
        "access": "",
        "desc": "UCPD configuration register 2 ",
        "fields": [
            {
                "name": "RXFILTDIS",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "BMC decoder Rx pre-filter enable\nThe sampling clock is that of the receiver (that is, after pre-scaler)."
            },
            {
                "name": "RXFILT2N3",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "BMC decoder Rx pre-filter sampling method\nNumber of consistent consecutive samples before confirming a new value."
            },
            {
                "name": "FORCECLK",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Force ClkReq clock request"
            },
            {
                "name": "WUPEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Wakeup from Stop mode enable\nSetting the bit enables the UCPD_ASYNC_INT signal."
            }
        ]
    },
    "1073782792": {
        "name": "UCPD_CFGR3",
        "address": 1073782792,
        "size": 32,
        "access": "",
        "desc": "UCPD configuration register 3 ",
        "fields": [
            {
                "name": "TRIM1_NG_CCRPD",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "SW trim value for RPD resistors on the CC1 line"
            },
            {
                "name": "TRIM1_NG_CC1A5",
                "bitOffset": 4,
                "bitWidth": 5,
                "desc": "SW trim value for RP1A5 resistors on the CC1 line"
            },
            {
                "name": "TRIM1_NG_CC3A0",
                "bitOffset": 9,
                "bitWidth": 4,
                "desc": "SW trim value for RP3A0 resistors on the CC1 line"
            },
            {
                "name": "TRIM2_NG_CCRPD",
                "bitOffset": 16,
                "bitWidth": 4,
                "desc": "SW trim value for RPD resistors on the CC2 line"
            },
            {
                "name": "TRIM2_NG_CC1A5",
                "bitOffset": 20,
                "bitWidth": 5,
                "desc": "SW trim value for RP1A5 resistors on the CC2 line"
            },
            {
                "name": "TRIM2_NG_CC3A0",
                "bitOffset": 25,
                "bitWidth": 4,
                "desc": "SW trim value for RP3A0 resistors on the CC2 line"
            }
        ]
    },
    "1073782796": {
        "name": "UCPD_CR",
        "address": 1073782796,
        "size": 32,
        "access": "",
        "desc": "UCPD control register ",
        "fields": [
            {
                "name": "TXMODE",
                "bitOffset": 0,
                "bitWidth": 2,
                "desc": "Type of Tx packet"
            },
            {
                "name": "TXSEND",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Command to send a Tx packet\nThe bit is cleared by hardware as soon as the packet transmission begins or is discarded."
            },
            {
                "name": "TXHRST",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Command to send a Tx Hard Reset\nThe bit is cleared by hardware as soon as the message transmission begins or is discarded."
            },
            {
                "name": "RXMODE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Receiver mode\nDetermines the mode of the receiver.\nWhen the bit is set, RXORDSET behaves normally, RXDR no longer receives bytes yet the CRC checking still proceeds as for a normal message."
            },
            {
                "name": "PHYRXEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "USB Power Delivery receiver enable\nBoth CC1 and CC2 receivers are disabled when the bit is cleared. Only the CC receiver selected via the PHYCCSEL bit is enabled when the bit is set."
            },
            {
                "name": "PHYCCSEL",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "CC1/CC2 line selector for USB Power Delivery signaling\nThe selection depends on the cable orientation as discovered at attach."
            },
            {
                "name": "ANASUBMODE",
                "bitOffset": 7,
                "bitWidth": 2,
                "desc": "Analog PHY sub-mode\nRefer to TYPEC_VSTATE_CCx for the effect of this bitfield."
            },
            {
                "name": "ANAMODE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Analog PHY operating mode\nThe bit takes effect upon setting the UCPDx_STROBE bit of the SYS_CONFIG register.\nThe use of CC1 and CC2 depends on CCENABLE. Refer to ANAMODE, ANASUBMODE and link with TYPEC_VSTATE_CCx for the effect of this bitfield in conjunction with ANASUBMODE[1:0]."
            },
            {
                "name": "CCENABLE",
                "bitOffset": 10,
                "bitWidth": 2,
                "desc": "CC line enable\nThis bitfield enables CC1 and CC2 line analog PHYs (pull-ups and pull-downs) according to ANAMODE and ANASUBMODE[1:0] setting.\nA single line PHY can be enabled when, for example, the other line is driven by VCONN via an external VCONN switch. Enabling both PHYs is the normal usage for sink/source."
            },
            {
                "name": "CC1VCONNEN",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "VCONN switch enable for CC1"
            },
            {
                "name": "CC2VCONNEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "VCONN switch enable for CC2"
            },
            {
                "name": "DBATTEN",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Dead battery function enable\nThe bit takes effect upon setting the USBPDstrobe bit of the SYS_CONFIG register.\nDead battery function only operates if the external circuit is appropriately configured."
            },
            {
                "name": "FRSRXEN",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "FRS event detection enable\nSetting the bit enables FRS Rx event (FRSEVT) detection on the CC line selected through the PHYCCSEL bit. 0: Disable\nClear the bit when the device is attached to an FRS-incapable source/sink."
            },
            {
                "name": "FRSTX",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "FRS Tx signaling enable.\nSetting the bit enables FRS Tx signaling.\nThe bit is cleared by hardware after a delay respecting the USB Power Delivery specification Revision 3.0."
            },
            {
                "name": "RDCH",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Rdch condition drive"
            },
            {
                "name": "CC1TCDIS",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "CC1 Type-C detector disable\nThe bit disables the Type-C detector on the CC1 line.\nWhen enabled, the Type-C detector for CC1 is configured through ANAMODE and ANASUBMODE[1:0]."
            },
            {
                "name": "CC2TCDIS",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "CC2 Type-C detector disable\nThe bit disables the Type-C detector on the CC2 line.\nWhen enabled, the Type-C detector for CC2 is configured through ANAMODE and ANASUBMODE[1:0]."
            }
        ]
    },
    "1073782800": {
        "name": "UCPD_IMR",
        "address": 1073782800,
        "size": 32,
        "access": "",
        "desc": "UCPD interrupt mask register ",
        "fields": [
            {
                "name": "TXISIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "TXIS interrupt enable"
            },
            {
                "name": "TXMSGDISCIE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "TXMSGDISC interrupt enable"
            },
            {
                "name": "TXMSGSENTIE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "TXMSGSENT interrupt enable"
            },
            {
                "name": "TXMSGABTIE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "TXMSGABT interrupt enable"
            },
            {
                "name": "HRSTDISCIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "HRSTDISC interrupt enable"
            },
            {
                "name": "HRSTSENTIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "HRSTSENT interrupt enable"
            },
            {
                "name": "TXUNDIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "TXUND interrupt enable"
            },
            {
                "name": "RXNEIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "RXNE interrupt enable"
            },
            {
                "name": "RXORDDETIE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "RXORDDET interrupt enable"
            },
            {
                "name": "RXHRSTDETIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "RXHRSTDET interrupt enable"
            },
            {
                "name": "RXOVRIE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "RXOVR interrupt enable"
            },
            {
                "name": "RXMSGENDIE",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "RXMSGEND interrupt enable"
            },
            {
                "name": "TYPECEVT1IE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "TYPECEVT1 interrupt enable"
            },
            {
                "name": "TYPECEVT2IE",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "TYPECEVT2 interrupt enable"
            },
            {
                "name": "FRSEVTIE",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "FRSEVT interrupt enable"
            }
        ]
    },
    "1073782804": {
        "name": "UCPD_SR",
        "address": 1073782804,
        "size": 32,
        "access": "",
        "desc": "UCPD status register ",
        "fields": [
            {
                "name": "TXIS",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Transmit interrupt status\nThe flag indicates that the UCPD_TXDR register is empty and new data write is required (as the amount of data sent has not reached the payload size defined in the TXPAYSZ bitfield). The flag is cleared with the data write into the UCPD_TXDR register."
            },
            {
                "name": "TXMSGDISC",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Message transmission discarded\nThe flag indicates that a message transmission was dropped. The flag is cleared by setting the TXMSGDISCCF bit.\nTransmission of a message can be dropped if there is a concurrent receive in progress or at excessive noise on the line. After a Tx message is discarded, the flag is only raised when the CC line becomes idle."
            },
            {
                "name": "TXMSGSENT",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Message transmission completed\nThe flag indicates the completion of packet transmission. It is cleared by setting the TXMSGSENTCF bit.\nIn the event of a message transmission interrupted by a Hard Reset, the flag is not raised."
            },
            {
                "name": "TXMSGABT",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transmit message abort\nThe flag indicates that a Tx message is aborted due to a subsequent Hard Reset message send request taking priority during transmit. It is cleared by setting the TXMSGABTCF bit."
            },
            {
                "name": "HRSTDISC",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Hard Reset discarded\nThe flag indicates that the Hard Reset message is discarded. The flag is cleared by setting the HRSTDISCCF bit."
            },
            {
                "name": "HRSTSENT",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Hard Reset message sent\nThe flag indicates that the Hard Reset message is sent. The flag is cleared by setting the HRSTSENTCF bit."
            },
            {
                "name": "TXUND",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Tx data underrun detection\nThe flag indicates that the Tx data register (UCPD_TXDR) was not written in time for a transmit message to execute normally. It is cleared by setting the TXUNDCF bit."
            },
            {
                "name": "RXNE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Receive data register not empty detection\nThe flag indicates that the UCPD_RXDR register is not empty. It is automatically cleared upon reading UCPD_RXDR."
            },
            {
                "name": "RXORDDET",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Rx ordered set (4 K-codes) detection\nThe flag indicates the detection of an ordered set. The relevant information is stored in the RXORDSET[2:0] bitfield of the UCPD_RX_ORDSET register. It is cleared by setting the RXORDDETCF bit."
            },
            {
                "name": "RXHRSTDET",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Rx Hard Reset receipt detection\nThe flag indicates the receipt of valid Hard Reset message. It is cleared by setting the RXHRSTDETCF bit."
            },
            {
                "name": "RXOVR",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Rx data overflow detection\nThe flag indicates Rx data buffer overflow. It is cleared by setting the RXOVRCF bit.\nThe buffer overflow can occur if the received data are not read fast enough."
            },
            {
                "name": "RXMSGEND",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Rx message received\nThe flag indicates whether a message (except Hard Reset message) has been received, regardless the CRC value. The flag is cleared by setting the RXMSGENDCF bit.\nThe RXERR flag set when the RXMSGEND flag goes high indicates errors in the last-received message."
            },
            {
                "name": "RXERR",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Receive message error\nThe flag indicates errors of the last Rx message declared (via RXMSGEND), such as incorrect CRC or truncated message (a line becoming static before EOP is met). It is asserted whenever the RXMSGEND flag is set."
            },
            {
                "name": "TYPECEVT1",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Type-C voltage level event on CC1 line\nThe flag indicates a change of the TYPEC_VSTATE_CC1[1:0] bitfield value, which corresponds to a new Type-C event. It is cleared by setting the TYPECEVT2CF bit."
            },
            {
                "name": "TYPECEVT2",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Type-C voltage level event on CC2 line\nThe flag indicates a change of the TYPEC_VSTATE_CC2[1:0] bitfield value, which corresponds to a new Type-C event. It is cleared by setting the TYPECEVT2CF bit."
            },
            {
                "name": "TYPEC_VSTATE_CC1",
                "bitOffset": 16,
                "bitWidth": 2,
                "desc": "The status bitfield indicates the voltage level on the CC1 line in its steady state.\nThe voltage variation on the CC1 line during USB PD messages due to the BMC PHY modulation does not impact the bitfield value."
            },
            {
                "name": "TYPEC_VSTATE_CC2",
                "bitOffset": 18,
                "bitWidth": 2,
                "desc": "CC2 line voltage level\nThe status bitfield indicates the voltage level on the CC2 line in its steady state.\nThe voltage variation on the CC2 line during USB PD messages due to the BMC PHY modulation does not impact the bitfield value."
            },
            {
                "name": "FRSEVT",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "FRS detection event\nThe flag is cleared by setting the FRSEVTCF bit."
            }
        ]
    },
    "1073782808": {
        "name": "UCPD_ICR",
        "address": 1073782808,
        "size": 32,
        "access": "",
        "desc": "UCPD interrupt clear register ",
        "fields": [
            {
                "name": "TXMSGDISCCF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Tx message discard flag (TXMSGDISC) clear\nSetting the bit clears the TXMSGDISC flag in the UCPD_SR register."
            },
            {
                "name": "TXMSGSENTCF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Tx message send flag (TXMSGSENT) clear\nSetting the bit clears the TXMSGSENT flag in the UCPD_SR register."
            },
            {
                "name": "TXMSGABTCF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Tx message abort flag (TXMSGABT) clear\nSetting the bit clears the TXMSGABT flag in the UCPD_SR register."
            },
            {
                "name": "HRSTDISCCF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Hard reset discard flag (HRSTDISC) clear\nSetting the bit clears the HRSTDISC flag in the UCPD_SR register."
            },
            {
                "name": "HRSTSENTCF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Hard reset send flag (HRSTSENT) clear\nSetting the bit clears the HRSTSENT flag in the UCPD_SR register."
            },
            {
                "name": "TXUNDCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Tx underflow flag (TXUND) clear\nSetting the bit clears the TXUND flag in the UCPD_SR register."
            },
            {
                "name": "RXORDDETCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Rx ordered set detect flag (RXORDDET) clear\nSetting the bit clears the RXORDDET flag in the UCPD_SR register."
            },
            {
                "name": "RXHRSTDETCF",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Rx Hard Reset detect flag (RXHRSTDET) clear\nSetting the bit clears the RXHRSTDET flag in the UCPD_SR register."
            },
            {
                "name": "RXOVRCF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Rx overflow flag (RXOVR) clear\nSetting the bit clears the RXOVR flag in the UCPD_SR register."
            },
            {
                "name": "RXMSGENDCF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Rx message received flag (RXMSGEND) clear\nSetting the bit clears the RXMSGEND flag in the UCPD_SR register."
            },
            {
                "name": "TYPECEVT1CF",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Type-C CC1 event flag (TYPECEVT1) clear\nSetting the bit clears the TYPECEVT1 flag in the UCPD_SR register"
            },
            {
                "name": "TYPECEVT2CF",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Type-C CC2 line event flag (TYPECEVT2) clear\nSetting the bit clears the TYPECEVT2 flag in the UCPD_SR register"
            },
            {
                "name": "FRSEVTCF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "FRS event flag (FRSEVT) clear\nSetting the bit clears the FRSEVT flag in the UCPD_SR register."
            }
        ]
    },
    "1073782812": {
        "name": "UCPD_TX_ORDSETR",
        "address": 1073782812,
        "size": 32,
        "access": "",
        "desc": "UCPD Tx ordered set type register ",
        "fields": [
            {
                "name": "TXORDSET",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Ordered set to transmit\nThe bitfield determines a full 20-bit sequence to transmit, consisting of four K-codes, each of five bits, defining the packet to transmit. The bit 0 (bit 0 of K-code1) is the first, the bit 19 (bit 4 of code4) the last."
            }
        ]
    },
    "1073782816": {
        "name": "UCPD_TX_PAYSZR",
        "address": 1073782816,
        "size": 32,
        "access": "",
        "desc": "UCPD Tx payload size register ",
        "fields": [
            {
                "name": "TXPAYSZ",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Payload size yet to transmit\nThe bitfield is modified by software and by hardware. It contains the number of bytes of a payload (including header but excluding CRC) yet to transmit: each time a data byte is written into the UCPD_TXDR register, the bitfield value decrements and the TXIS bit is set, except when the bitfield value reaches zero. The enumerated values are standard payload sizes before the start of transmission."
            }
        ]
    },
    "1073782820": {
        "name": "UCPD_TXDR",
        "address": 1073782820,
        "size": 32,
        "access": "",
        "desc": "UCPD Tx data register ",
        "fields": [
            {
                "name": "TXDATA",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Data byte to transmit"
            }
        ]
    },
    "1073782824": {
        "name": "UCPD_RX_ORDSETR",
        "address": 1073782824,
        "size": 32,
        "access": "",
        "desc": "UCPD Rx ordered set register ",
        "fields": [
            {
                "name": "RXORDSET",
                "bitOffset": 0,
                "bitWidth": 3,
                "desc": "Rx ordered set code detected"
            },
            {
                "name": "RXSOP3OF4",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "The bit indicates the number of correct For debug purposes only."
            },
            {
                "name": "RXSOPKINVALID",
                "bitOffset": 4,
                "bitWidth": 3,
                "desc": "The bitfield is for debug purposes only.\nOthers: Invalid"
            }
        ]
    },
    "1073782828": {
        "name": "UCPD_RX_PAYSZR",
        "address": 1073782828,
        "size": 32,
        "access": "",
        "desc": "UCPD Rx payload size register ",
        "fields": [
            {
                "name": "RXPAYSZ",
                "bitOffset": 0,
                "bitWidth": 10,
                "desc": "Rx payload size received\nThis bitfield contains the number of bytes of a payload (including header but excluding CRC) received: each time a new data byte is received in the UCPD_RXDR register, the bitfield value increments and the RXMSGEND flag is set (and an interrupt generated if enabled).\nThe bitfield may return a spurious value when a byte reception is ongoing (the RXMSGEND flag is low)."
            }
        ]
    },
    "1073782832": {
        "name": "UCPD_RXDR",
        "address": 1073782832,
        "size": 32,
        "access": "",
        "desc": "UCPD receive data register ",
        "fields": [
            {
                "name": "RXDATA",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Data byte received"
            }
        ]
    },
    "1073782836": {
        "name": "UCPD_RX_ORDEXTR1",
        "address": 1073782836,
        "size": 32,
        "access": "",
        "desc": "UCPD Rx ordered set extension register 1 \t",
        "fields": [
            {
                "name": "RXSOPX1",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Ordered set 1 received."
            }
        ]
    },
    "1073782840": {
        "name": "UCPD_RX_ORDEXTR2",
        "address": 1073782840,
        "size": 32,
        "access": "",
        "desc": "UCPD Rx ordered set extension register 2 \t",
        "fields": [
            {
                "name": "RXSOPX2",
                "bitOffset": 0,
                "bitWidth": 20,
                "desc": "Ordered set 2 received"
            }
        ]
    },
    "1073821696": {
        "name": "CR1_FIFO_ENABLED",
        "address": 1073821696,
        "size": 32,
        "access": "read-write",
        "desc": "Control register 1",
        "fields": [
            {
                "name": "UE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all current operations are discarded. The USART configuration is kept, but all the USART_ISR status flags are reset. This bit is set and cleared by software.\nNote: To enter low-power mode without generating errors on the line, the TE bit must be previously reset and the software must wait for the TC bit in the USART_ISR to be set before resetting the UE bit.\nThe DMA requests are also reset when UE = 0 so the DMA channel must be disabled before resetting the UE bit.\nIn Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1, regardless of the UE bit value."
            },
            {
                "name": "UESM",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\nNote: It is recommended to set the UESM bit just before entering low-power mode and clear it when exit from low-power mode.\nIf the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "RE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software."
            },
            {
                "name": "TE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\nNote: During transmission, a low pulse on the TE bit ('0' followed by '1') sends a preamble (idle line) after the current word, except in Smartcard mode. In order to generate an idle character, the TE must not be immediately written to '1'. To ensure the required duration, the software can poll the TEACK bit in the USART_ISR register.\nIn Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts."
            },
            {
                "name": "IDLEIE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "IDLE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFNEIE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TCIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFNFIE",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PEIE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "PE interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "PS",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE bit set). It is set and cleared by software. The parity is selected after the current byte.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "PCE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity control is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit if M=0) and the parity is checked on the received data. This bit is set and cleared by software. Once it is set, PCE is active after the current byte (in reception and in transmission).\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "WAKE",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver wakeup method\nThis bit determines the USART wakeup method from Mute mode. It is set or cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "M0",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or cleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "MME",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Mute mode enable\nThis bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software."
            },
            {
                "name": "CMIE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Character match interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "OVER8",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Oversampling mode\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In LIN, IrDA and Smartcard modes, this bit must be kept cleared."
            },
            {
                "name": "DEDT",
                "bitOffset": 16,
                "bitWidth": 5,
                "desc": "Driver Enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted message, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nIf the USART_TDR register is written during the DEDT time, the new data is transmitted only when the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "DEAT",
                "bitOffset": 21,
                "bitWidth": 5,
                "desc": "Driver Enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and the beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time, depending on the oversampling rate).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "RTOIE",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receiver timeout interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. ."
            },
            {
                "name": "EOBIE",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "End of Block interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "M1",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or cleared by software.\nM[1:0] = '00': 1 start bit, 8 Data bits, n Stop bit\nM[1:0] = '01': 1 start bit, 9 Data bits, n Stop bit\nM[1:0] = '10': 1 start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported."
            },
            {
                "name": "FIFOEN",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "FIFO mode enable\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes."
            },
            {
                "name": "TXFEIE",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "TXFIFO empty interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "RXFFIE",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "RXFIFO Full interrupt enable\nThis bit is set and cleared by software."
            }
        ]
    },
    "1073821700": {
        "name": "CR2",
        "address": 1073821700,
        "size": 32,
        "access": "read-write",
        "desc": "Control register 2",
        "fields": [
            {
                "name": "SLVEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Synchronous Slave mode enable\nWhen the SLVEN bit is set, the synchronous slave mode is enabled.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "DIS_NSS",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "When the DIS_NSS bit is set, the NSS pin input is ignored.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "ADDM7",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "7-bit Address Detection/4-bit Address Detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\nThis bit can only be written when the USART is disabled (UE=0)\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively."
            },
            {
                "name": "LBDL",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "LIN break detection length\nThis bit is for selection between 11 bit or 10 bit break detection.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "LBDIE",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "LIN break detection interrupt enable\nBreak interrupt mask (break detection using break delimiter).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "LBCL",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Last bit clock pulse\nThis bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB) has to be output on the SCLK pin in synchronous mode.\nThe last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit format selected by the M bit in the USART_CR1 register.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CPHA",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Clock phase\nThis bit is used to select the phase of the clock output on the SCLK pin in synchronous mode. It works in conjunction with the CPOL bit to produce the desired clock/data relationship (see  and )\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CPOL",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "Clock polarity\nThis bit enables the user to select the polarity of the clock output on the SCLK pin in synchronous mode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CLKEN",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Clock enable\nThis bit enables the user to enable the SCLK pin.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If neither synchronous mode nor Smartcard mode is supported, this bit is reserved and must be kept at reset value. Refer to .\nIn Smartcard mode, in order to provide correctly the SCLK clock to the smartcard, the steps below must be respected:\nUE = 0\nSCEN = 1\nGTPR configuration\nCLKEN= 1\nUE = 1"
            },
            {
                "name": "STOP",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "stop bits\nThese bits are used for programming the stop bits.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "LINEN",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "LIN mode enable\nThis bit is set and cleared by software.\nThe LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the SBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "SWAP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Swap TX/RX pins\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "RXINV",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "RX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "TXINV",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "TX pin active level inversion\nThis bit is set and cleared by software.\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "DATAINV",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Binary data inversion\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "MSBFIRST",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Most significant bit first\nThis bit is set and cleared by software.\nThis bitfield can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "ABREN",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Auto baud rate enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "ABRMOD",
                "bitOffset": 21,
                "bitWidth": 2,
                "desc": "Auto baud rate mode\nThese bits are set and cleared by software.\nThis bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0).\nNote: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example 0xAA for MSBFIRST)\nIf the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "RTOEN",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Receiver timeout enable\nThis bit is set and cleared by software.\nWhen this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle (no reception) for the duration programmed in the RTOR (receiver timeout register).\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "ADD",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Address of the USART node\nADD[7:4]:\nThese bits give the address of the USART node or a character code to be recognized.\nThey are used to wake up the MCU with 7-bit address mark detection in multiprocessor communication during Mute mode or low-power mode. The MSB of the character sent by the transmitter should be equal to 1. They can also be used for character detection during normal reception, Mute mode inactive (for example, end of block detection in ModBus protocol). In this case, the whole received character (8-bit) is compared to the ADD[7:0] value and CMF flag is set on match.\nThese bits can only be written when reception is disabled (RE = 0) or the USART is disabled (UE=0).\nADD[3:0]:\nThese bits give the address of the USART node or a character code to be recognized.\nThey are used for wakeup with address mark detection, in multiprocessor communication during Mute mode or low-power mode.\nThese bits can only be written when reception is disabled (RE = 0) or the USART is disabled (UE=0)."
            }
        ]
    },
    "1073821704": {
        "name": "CR3",
        "address": 1073821704,
        "size": 32,
        "access": "read-write",
        "desc": "Control register 3",
        "fields": [
            {
                "name": "EIE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1 or UDR = 1 in the USART_ISR register)."
            },
            {
                "name": "IREN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "IrDA mode enable\nThis bit is set and cleared by software.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "IRLP",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "IrDA low-power\nThis bit is used for selecting between normal and low-power IrDA modes\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "HDSEL",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Half-duplex selection\nSelection of Single-wire Half-duplex mode\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "NACK",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Smartcard NACK enable\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "SCEN",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Smartcard mode enable\nThis bit is used for enabling Smartcard mode.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "DMAR",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "DMA enable receiver\nThis bit is set/reset by software"
            },
            {
                "name": "DMAT",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DMA enable transmitter\nThis bit is set/reset by software"
            },
            {
                "name": "RTSE",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "RTS enable\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CTSE",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS enable\nThis bit can only be written when the USART is disabled (UE=0)\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CTSIE",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS interrupt enable\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "ONEBIT",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "One sample bit method enable\nThis bit enables the user to select the sample method. When the one sample bit method is selected the noise detection flag (NE) is disabled.\nThis bit can only be written when the USART is disabled (UE=0)."
            },
            {
                "name": "OVRDIS",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Overrun Disable\nThis bit is used to disable the receive overrun detection.\nthe ORE flag is not set and the new received data overwrites the previous content of the USART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data is written directly in USART_RDR register. Even when FIFO management is enabled, the RXNE flag is to be used.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: This control bit enables checking the communication flow w/o reading the data"
            },
            {
                "name": "DDRE",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "DMA Disable on Reception Error\nThis bit can only be written when the USART is disabled (UE=0).\nNote: The reception errors are: parity error, framing error or noise error."
            },
            {
                "name": "DEM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. ."
            },
            {
                "name": "DEP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Driver enable polarity selection\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "SCARCNT",
                "bitOffset": 17,
                "bitWidth": 3,
                "desc": "Smartcard auto-retry count\nThis bitfield specifies the number of retries for transmission and reception in Smartcard mode.\nIn transmission mode, it specifies the number of automatic retransmission retries, before generating a transmission error (FE bit set).\nIn reception mode, it specifies the number or erroneous reception trials, before generating a reception error (RXNE/RXFNE and PE bits set).\nThis bitfield must be programmed only when the USART is disabled (UE=0).\nWhen the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to stop retransmission.\nNote: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "WUS",
                "bitOffset": 20,
                "bitWidth": 2,
                "desc": "Wakeup from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (Wakeup from low-power mode flag).\nThis bitfield can only be written when the USART is disabled (UE=0).\nIf the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page835."
            },
            {
                "name": "WUFIE",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode interrupt enable\nThis bit is set and cleared by software.\nNote: WUFIE must be set before entering in low-power mode.\nIf the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page835."
            },
            {
                "name": "TXFTIE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TCBGTIE",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Transmission Complete before guard time, interrupt enable\nThis bit is set and cleared by software.\nNote: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "RXFTCFG",
                "bitOffset": 25,
                "bitWidth": 3,
                "desc": "Receive FIFO threshold configuration\nRemaining combinations: Reserved"
            },
            {
                "name": "RXFTIE",
                "bitOffset": 28,
                "bitWidth": 1,
                "desc": "RXFIFO threshold interrupt enable\nThis bit is set and cleared by software."
            },
            {
                "name": "TXFTCFG",
                "bitOffset": 29,
                "bitWidth": 3,
                "desc": "TXFIFO threshold configuration\nRemaining combinations: Reserved"
            }
        ]
    },
    "1073821708": {
        "name": "BRR",
        "address": 1073821708,
        "size": 32,
        "access": "read-write",
        "desc": "Baud rate register",
        "fields": [
            {
                "name": "BRR",
                "bitOffset": 0,
                "bitWidth": 16,
                "desc": "USART baud rate"
            }
        ]
    },
    "1073821712": {
        "name": "GTPR",
        "address": 1073821712,
        "size": 32,
        "access": "read-write",
        "desc": "Guard time and prescaler\n          register",
        "fields": [
            {
                "name": "PSC",
                "bitOffset": 0,
                "bitWidth": 8,
                "desc": "Prescaler value\nIn IrDA low-power and normal IrDA mode:\nPSC[7:0] = IrDA Normal and Low-Power baud rate\nPSC[7:0] is used to program the prescaler for dividing the USART source clock to achieve the low-power frequency: the source clock is divided by the value given in the register (8 significant bits):\nIn Smartcard mode:\nPSC[4:0]=Prescaler value\nPSC[4:0] is used to program the prescaler for dividing the USART source clock to provide the Smartcard clock. The value given in the register (5 significant bits) is multiplied by 2 to give the division factor of the source clock frequency:\n...\n00100000: Divides the source clock by 32 (IrDA mode)\n...\n11111111: Divides the source clock by 255 (IrDA mode)\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: Bits [7:5] must be kept cleared if Smartcard mode is used.\nThis bitfield is reserved and forced by hardware to '0' when the Smartcard and IrDA modes are not supported. Refer to ."
            },
            {
                "name": "GT",
                "bitOffset": 8,
                "bitWidth": 8,
                "desc": "Guard time value\nThis bitfield is used to program the Guard time value in terms of number of baud clock periods.\nThis is used in Smartcard mode. The Transmission Complete flag is set after this guard time value.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            }
        ]
    },
    "1073821716": {
        "name": "RTOR",
        "address": 1073821716,
        "size": 32,
        "access": "read-write",
        "desc": "Receiver timeout register",
        "fields": [
            {
                "name": "RTO",
                "bitOffset": 0,
                "bitWidth": 24,
                "desc": "Receiver timeout value"
            },
            {
                "name": "BLEN",
                "bitOffset": 24,
                "bitWidth": 8,
                "desc": "Block Length"
            }
        ]
    },
    "1073821720": {
        "name": "RQR",
        "address": 1073821720,
        "size": 32,
        "access": "write-only",
        "desc": "Request register",
        "fields": [
            {
                "name": "ABRRQ",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Auto baud rate request\nWriting 1 to this bit resets the ABRF flag in the USART_ISR and requests an automatic baud rate measurement on the next received data frame.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "SBKRQ",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as the transmit machine is available.\nNote: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit."
            },
            {
                "name": "MMRQ",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Mute mode request\nWriting 1 to this bit puts the USART in Mute mode and resets the RWU flag."
            },
            {
                "name": "RXFRQ",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Receive data flush request\nWriting 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.\nThis enables to discard the received data without reading them, and avoid an overrun condition."
            },
            {
                "name": "TXFRQ",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Transmit data flush request\nWhen FIFO mode is disabled, writing '1' to this bit sets the TXE flag. This enables to discard the transmit data. This bit must be used only in Smartcard mode, when data have not been sent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value.\nWhen FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag (Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is supported in both UART and Smartcard modes.\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register."
            }
        ]
    },
    "1073821724": {
        "name": "ISR_FIFO_ENABLED",
        "address": 1073821724,
        "size": 32,
        "access": "read-only",
        "desc": "Interrupt & status\n          register",
        "fields": [
            {
                "name": "PE",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by software, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\nNote: This error is associated with the character in the USART_RDR."
            },
            {
                "name": "FE",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character is detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in Smartcard mode, this bit is set when the maximum number of transmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE=1 in the USART_CR1 register.\nNote: This error is associated with the character in the USART_RDR."
            },
            {
                "name": "NE",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by software, writing 1 to the NECF bit in the USART_ICR register.\nNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit which itself generates an interrupt. An interrupt is generated when the NE flag is set during multi buffer communication if the EIE bit is set.\nWhen the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page861).\nThis error is associated with the character in the USART_RDR."
            },
            {
                "name": "ORE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a software, writing 1 to the ORECF, in the USART_ICR register.\nAn interrupt is generated if RXFNEIE=1 or EIE = 1 in the USART_CR1 register.\nNote: When this bit is set, the USART_RDR register content is not lost but the shift register is overwritten. An interrupt is generated if the ORE flag is set during multi buffer communication if the EIE bit is set.\nThis bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register."
            },
            {
                "name": "IDLE",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if IDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in the USART_ICR register.\nNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line occurs).\nIf Mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0), whatever the Mute mode selected by the WAKE bit. If RWU=1, IDLE is not set."
            },
            {
                "name": "RXFNE",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "RXFIFO not empty\nRXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be read from the USART_RDR register. Every read operation from the USART_RDR frees a location in the RXFIFO.\nRXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR register.\nAn interrupt is generated if RXFNEIE=1 in the USART_CR1 register."
            },
            {
                "name": "TC",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of the shift register.\nIt is set by hardware when the transmission of a frame containing data is complete and when TXFE is set.\nAn interrupt is generated if TCIE=1 in the USART_CR1 register.\nTC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a write to the USART_TDR register.\nNote: If TE bit is reset and no transmission is on going, the TC bit is immediately set."
            },
            {
                "name": "TXFNF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "TXFIFO not full\nTXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the USART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO. This flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared indicating that data can not be written into the USART_TDR.\nAn interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register.\nNote: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending the flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to writing in TXFIFO (TXFNF and TXFE are set at the same time).\nThis bit is used during single buffer transmission."
            },
            {
                "name": "LBDF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by writing 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\nNote: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "CTSIF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS interrupt flag\nThis bit is set by hardware when the nCTS input toggles, if the CTSE bit is set. It is cleared by software, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE=1 in the USART_CR3 register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "CTS",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the nCTS input pin.\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value."
            },
            {
                "name": "RTOF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has lapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in the USART_ICR register.\nAn interrupt is generated if RTOIE=1 in the USART_CR2 register.\nIn Smartcard mode, the timeout corresponds to the CWT or BWT timings.\nNote: If a time equal to the value programmed in RTOR register separates 2 characters, RTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8, depending on the oversampling method), RTOF flag is set.\nThe counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has already elapsed when RE is set, then RTOF is set.\nIf the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "EOBF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "End of block flag\nThis bit is set by hardware when a complete block has been received (for example T=1 Smartcard mode). The detection is done when the number of received bytes (from the start of the block, including the prologue) is equal or greater than BLEN + 4.\nAn interrupt is generated if the EOBIE=1 in the USART_CR2 register.\nIt is cleared by software, writing 1 to the EOBCF in the USART_ICR register.\nNote: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "UDR",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SPI slave underrun error flag\nIn slave transmission mode, this flag is set when the first clock pulse for data transmission appears while the software has not yet loaded any value into USART_TDR. This flag is reset by setting UDRCF bit in the USART_ICR register.\nNote: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "ABRE",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or character comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_CR3 register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "ABRF",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXFNE is also set, generating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was completed without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case)\nIt is cleared by software, in order to request a new auto baud rate detection, by writing 1 to the ABRRQ in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value."
            },
            {
                "name": "BUSY",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not)."
            },
            {
                "name": "CMF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is cleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE=1in the USART_CR1 register."
            },
            {
                "name": "SBKF",
                "bitOffset": 18,
                "bitWidth": 1,
                "desc": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission."
            },
            {
                "name": "RWU",
                "bitOffset": 19,
                "bitWidth": 1,
                "desc": "Receiver wakeup from Mute mode\nThis bit indicates if the USART is in Mute mode. It is cleared/set by hardware when a wakeup/mute sequence is recognized. The Mute mode control sequence (address or IDLE) is selected by the WAKE bit in the USART_CR1 register.\nWhen wakeup on IDLE mode is selected, this bit can only be set by software, writing 1 to the MMRQ bit in the USART_RQR register.\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "WUF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode flag\nThis bit is set by hardware, when a wakeup event is detected. The event is defined by the WUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE=1 in the USART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nIf the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "TEACK",
                "bitOffset": 21,
                "bitWidth": 1,
                "desc": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by the USART.\nIt can be used when an idle frame request is generated by writing TE=0, followed by TE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period."
            },
            {
                "name": "REACK",
                "bitOffset": 22,
                "bitWidth": 1,
                "desc": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by the USART.\nIt can be used to verify that the USART is ready for reception before entering low-power mode.\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to ."
            },
            {
                "name": "TXFE",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "TXFIFO empty\nThis bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one data, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4) in the USART_RQR register.\nAn interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register."
            },
            {
                "name": "RXFF",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "RXFIFO full\nThis bit is set by hardware when the number of received data corresponds to RXFIFOsize+1 (RXFIFO full + 1 data in the USART_RDR register.\nAn interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register."
            },
            {
                "name": "TCBGT",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmission complete before guard time flag\nThis bit is set when the last data written in the USART_TDR has been transmitted correctly out of the shift register.\nIt is set by hardware in Smartcard mode, if the transmission of a frame containing data is complete and if the smartcard did not send back any NACK. An interrupt is generated if TCBGTIE=1 in the USART_CR3 register.\nThis bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or by a write to the USART_TDR register.\nNote: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is '1'. Refer to on page835."
            },
            {
                "name": "RXFT",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "RXFIFO threshold flag\nThis bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3 register is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and one data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit 27) in the USART_CR3 register.\nNote: When the RXFTCFG threshold is configured to '101', RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data."
            },
            {
                "name": "TXFT",
                "bitOffset": 27,
                "bitWidth": 1,
                "desc": "TXFIFO threshold flag\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register."
            }
        ]
    },
    "1073821728": {
        "name": "ICR",
        "address": 1073821728,
        "size": 32,
        "access": "write-only",
        "desc": "Interrupt flag clear register",
        "fields": [
            {
                "name": "PECF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Parity error clear flag\nWriting 1 to this bit clears the PE flag in the USART_ISR register."
            },
            {
                "name": "FECF",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Framing error clear flag\nWriting 1 to this bit clears the FE flag in the USART_ISR register."
            },
            {
                "name": "NECF",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the USART_ISR register."
            },
            {
                "name": "ORECF",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the USART_ISR register."
            },
            {
                "name": "IDLECF",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the USART_ISR register."
            },
            {
                "name": "TXFECF",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "TXFIFO empty clear flag\nWriting 1 to this bit clears the TXFE flag in the USART_ISR register."
            },
            {
                "name": "TCCF",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the USART_ISR register."
            },
            {
                "name": "TCBGTCF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Transmission complete before Guard time clear flag\nWriting 1 to this bit clears the TCBGT flag in the USART_ISR register."
            },
            {
                "name": "LBDCF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "LIN break detection clear flag\nWriting 1 to this bit clears the LBDF flag in the USART_ISR register.\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "CTSCF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the USART_ISR register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "RTOCF",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Receiver timeout clear flag\nWriting 1 to this bit clears the RTOF flag in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to page835."
            },
            {
                "name": "EOBCF",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "End of block clear flag\nWriting 1 to this bit clears the EOBF flag in the USART_ISR register.\nNote: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to ."
            },
            {
                "name": "UDRCF",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "SPI slave underrun clear flag\nWriting 1 to this bit clears the UDRF flag in the USART_ISR register.\nNote: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to"
            },
            {
                "name": "CMCF",
                "bitOffset": 17,
                "bitWidth": 1,
                "desc": "Character match clear flag\nWriting 1 to this bit clears the CMF flag in the USART_ISR register."
            },
            {
                "name": "WUCF",
                "bitOffset": 20,
                "bitWidth": 1,
                "desc": "Wakeup from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the USART_ISR register.\nNote: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page835."
            }
        ]
    },
    "1073821732": {
        "name": "RDR",
        "address": 1073821732,
        "size": 32,
        "access": "read-only",
        "desc": "Receive data register",
        "fields": [
            {
                "name": "RDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Receive data value"
            }
        ]
    },
    "1073821736": {
        "name": "TDR",
        "address": 1073821736,
        "size": 32,
        "access": "read-write",
        "desc": "Transmit data register",
        "fields": [
            {
                "name": "TDR",
                "bitOffset": 0,
                "bitWidth": 9,
                "desc": "Transmit data value"
            }
        ]
    },
    "1073821740": {
        "name": "PRESC",
        "address": 1073821740,
        "size": 32,
        "access": "read-write",
        "desc": "Prescaler register",
        "fields": [
            {
                "name": "PRESCALER",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Clock prescaler\nThe USART input clock can be divided by a prescaler factor:\nRemaining combinations: Reserved\nNote: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256."
            }
        ]
    },
    "1073765376": {
        "name": "USB_CHEP0R",
        "address": 1073765376,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 0 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STTX bits to NAK, when a correct transfer has occurred (VTTX=1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STTX bits to 'STALL' or 'NAK' for an Isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nSame as STRX behaviour but for IN transactions (TBC)"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data Toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to )\nIf the endpoint/channel is Isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (Refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for Isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGTX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written.\nHost mode\nSame of VTRX behaviour but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the EP_TYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in endpoint/channel type encoding on page2001. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of Isochronous channels/endpoints is explained in transfers"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page2000.These bits can be toggled by software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STRX bits to NAK when a correct transfer has occurred (VTRX=1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledge a new transaction\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STRX bits to 'STALL' or 'NAK' for an Isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the Host execution list. If the aborted transaction was already under execution it will be regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nAn Host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the Host Frame Schedure to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel will be re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to ).\nIf the endpoint/channel is Isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGRX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the VTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STRX field of this register. One naked transaction keeps pending and is automatically retried by the Host at the next frame, or the Host can immediately retry by resetting STRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\nThis bit is read/write but only '0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can be use this bit to monitoring the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmit error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receive error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is  always activated."
            }
        ]
    },
    "1073765380": {
        "name": "USB_CHEP1R",
        "address": 1073765380,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 1 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STTX bits to NAK, when a correct transfer has occurred (VTTX=1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STTX bits to 'STALL' or 'NAK' for an Isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nSame as STRX behaviour but for IN transactions (TBC)"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data Toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to )\nIf the endpoint/channel is Isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (Refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for Isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGTX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written.\nHost mode\nSame of VTRX behaviour but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the EP_TYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in endpoint/channel type encoding on page2001. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of Isochronous channels/endpoints is explained in transfers"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page2000.These bits can be toggled by software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STRX bits to NAK when a correct transfer has occurred (VTRX=1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledge a new transaction\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STRX bits to 'STALL' or 'NAK' for an Isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the Host execution list. If the aborted transaction was already under execution it will be regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nAn Host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the Host Frame Schedure to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel will be re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to ).\nIf the endpoint/channel is Isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGRX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the VTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STRX field of this register. One naked transaction keeps pending and is automatically retried by the Host at the next frame, or the Host can immediately retry by resetting STRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\nThis bit is read/write but only '0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can be use this bit to monitoring the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmit error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receive error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is  always activated."
            }
        ]
    },
    "1073765384": {
        "name": "USB_CHEP2R",
        "address": 1073765384,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 2 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STTX bits to NAK, when a correct transfer has occurred (VTTX=1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STTX bits to 'STALL' or 'NAK' for an Isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nSame as STRX behaviour but for IN transactions (TBC)"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data Toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to )\nIf the endpoint/channel is Isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (Refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for Isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGTX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written.\nHost mode\nSame of VTRX behaviour but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the EP_TYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in endpoint/channel type encoding on page2001. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of Isochronous channels/endpoints is explained in transfers"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page2000.These bits can be toggled by software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STRX bits to NAK when a correct transfer has occurred (VTRX=1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledge a new transaction\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STRX bits to 'STALL' or 'NAK' for an Isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the Host execution list. If the aborted transaction was already under execution it will be regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nAn Host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the Host Frame Schedure to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel will be re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to ).\nIf the endpoint/channel is Isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGRX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the VTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STRX field of this register. One naked transaction keeps pending and is automatically retried by the Host at the next frame, or the Host can immediately retry by resetting STRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\nThis bit is read/write but only '0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can be use this bit to monitoring the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmit error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receive error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is  always activated."
            }
        ]
    },
    "1073765388": {
        "name": "USB_CHEP3R",
        "address": 1073765388,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 3 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STTX bits to NAK, when a correct transfer has occurred (VTTX=1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STTX bits to 'STALL' or 'NAK' for an Isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nSame as STRX behaviour but for IN transactions (TBC)"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data Toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to )\nIf the endpoint/channel is Isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (Refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for Isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGTX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written.\nHost mode\nSame of VTRX behaviour but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the EP_TYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in endpoint/channel type encoding on page2001. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of Isochronous channels/endpoints is explained in transfers"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page2000.These bits can be toggled by software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STRX bits to NAK when a correct transfer has occurred (VTRX=1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledge a new transaction\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STRX bits to 'STALL' or 'NAK' for an Isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the Host execution list. If the aborted transaction was already under execution it will be regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nAn Host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the Host Frame Schedure to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel will be re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to ).\nIf the endpoint/channel is Isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGRX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the VTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STRX field of this register. One naked transaction keeps pending and is automatically retried by the Host at the next frame, or the Host can immediately retry by resetting STRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\nThis bit is read/write but only '0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can be use this bit to monitoring the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmit error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receive error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is  always activated."
            }
        ]
    },
    "1073765392": {
        "name": "USB_CHEP4R",
        "address": 1073765392,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 4 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STTX bits to NAK, when a correct transfer has occurred (VTTX=1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STTX bits to 'STALL' or 'NAK' for an Isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nSame as STRX behaviour but for IN transactions (TBC)"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data Toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to )\nIf the endpoint/channel is Isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (Refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for Isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGTX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written.\nHost mode\nSame of VTRX behaviour but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the EP_TYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in endpoint/channel type encoding on page2001. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of Isochronous channels/endpoints is explained in transfers"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page2000.These bits can be toggled by software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STRX bits to NAK when a correct transfer has occurred (VTRX=1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledge a new transaction\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STRX bits to 'STALL' or 'NAK' for an Isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the Host execution list. If the aborted transaction was already under execution it will be regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nAn Host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the Host Frame Schedure to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel will be re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to ).\nIf the endpoint/channel is Isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGRX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the VTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STRX field of this register. One naked transaction keeps pending and is automatically retried by the Host at the next frame, or the Host can immediately retry by resetting STRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\nThis bit is read/write but only '0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can be use this bit to monitoring the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmit error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receive error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is  always activated."
            }
        ]
    },
    "1073765396": {
        "name": "USB_CHEP5R",
        "address": 1073765396,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 5 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STTX bits to NAK, when a correct transfer has occurred (VTTX=1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STTX bits to 'STALL' or 'NAK' for an Isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nSame as STRX behaviour but for IN transactions (TBC)"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data Toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to )\nIf the endpoint/channel is Isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (Refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for Isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGTX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written.\nHost mode\nSame of VTRX behaviour but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the EP_TYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in endpoint/channel type encoding on page2001. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of Isochronous channels/endpoints is explained in transfers"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page2000.These bits can be toggled by software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STRX bits to NAK when a correct transfer has occurred (VTRX=1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledge a new transaction\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STRX bits to 'STALL' or 'NAK' for an Isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the Host execution list. If the aborted transaction was already under execution it will be regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nAn Host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the Host Frame Schedure to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel will be re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to ).\nIf the endpoint/channel is Isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGRX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the VTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STRX field of this register. One naked transaction keeps pending and is automatically retried by the Host at the next frame, or the Host can immediately retry by resetting STRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\nThis bit is read/write but only '0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can be use this bit to monitoring the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmit error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receive error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is  always activated."
            }
        ]
    },
    "1073765400": {
        "name": "USB_CHEP6R",
        "address": 1073765400,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 6 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STTX bits to NAK, when a correct transfer has occurred (VTTX=1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STTX bits to 'STALL' or 'NAK' for an Isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nSame as STRX behaviour but for IN transactions (TBC)"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data Toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to )\nIf the endpoint/channel is Isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (Refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for Isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGTX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written.\nHost mode\nSame of VTRX behaviour but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the EP_TYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in endpoint/channel type encoding on page2001. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of Isochronous channels/endpoints is explained in transfers"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page2000.These bits can be toggled by software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STRX bits to NAK when a correct transfer has occurred (VTRX=1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledge a new transaction\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STRX bits to 'STALL' or 'NAK' for an Isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the Host execution list. If the aborted transaction was already under execution it will be regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nAn Host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the Host Frame Schedure to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel will be re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to ).\nIf the endpoint/channel is Isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGRX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the VTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STRX field of this register. One naked transaction keeps pending and is automatically retried by the Host at the next frame, or the Host can immediately retry by resetting STRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\nThis bit is read/write but only '0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can be use this bit to monitoring the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmit error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receive error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is  always activated."
            }
        ]
    },
    "1073765404": {
        "name": "USB_CHEP7R",
        "address": 1073765404,
        "size": 32,
        "access": "",
        "desc": "USB endpoint/channel 7 register",
        "fields": [
            {
                "name": "EA",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "endpoint/channel address\nDevice mode\nSoftware must write in this field the 4-bit address used to identify the transactions directed to this endpoint. A value must be written before enabling the corresponding endpoint.\nHost mode\nSoftware must write in this field the 4-bit address used to identify the channel addressed by the host transaction."
            },
            {
                "name": "STATTX",
                "bitOffset": 4,
                "bitWidth": 2,
                "desc": "Status bits, for transmission transfers\nDevice mode\nThese bits contain the information about the endpoint status, listed in . These bits can be toggled by the software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STTX bits to NAK, when a correct transfer has occurred (VTTX=1) corresponding to a IN or SETUP (control only) transaction addressed to this channel/endpoint. It then waits for the software to prepare the next set of data to be transmitted.\nDouble-buffered bulk endpoints implement a special transaction flow control, which controls the status based on buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can only be 'VALID' or 'DISABLED'. Therefore, the hardware cannot change the status of the channel/endpoint/channel after a successful transaction. If the software sets the STTX bits to 'STALL' or 'NAK' for an Isochronous channel/endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nSame as STRX behaviour but for IN transactions (TBC)"
            },
            {
                "name": "DTOGTX",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Data Toggle, for transmission transfers\nIf the endpoint/channel is non-isochronous, this bit contains the required value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be transmitted. Hardware toggles this bit when the ACK handshake is received from the USB host, following a data packet transmission. If the endpoint/channel is defined as a control one, hardware sets this bit to 1 at the reception of a SETUP PID addressed to this endpoint.\nIf the endpoint/channel is using the double buffer feature, this bit is used to support packet buffer swapping too (Refer to )\nIf the endpoint/channel is Isochronous, this bit is used to support packet buffer swapping since no data toggling is used for this sort of endpoints and only DATA0 packet are transmitted (Refer to ). Hardware toggles this bit just after the end of data packet transmission, since no handshake is used for Isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint/channel is not a control one) or to force a specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGTX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can only be toggled by writing 1."
            },
            {
                "name": "VTTX",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Valid USB transaction transmitted\nDevice mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in the USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written.\nHost mode\nSame of VTRX behaviour but for USB OUT and SETUP transactions."
            },
            {
                "name": "EPKIND",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "endpoint/channel kind\nThe meaning of this bit depends on the endpoint/channel type configured by the EP_TYPE bits.  summarizes the different meanings.\nDBL_BUF: This bit is set by the software to enable the double-buffering feature for this bulk endpoint. The usage of double-buffered bulk endpoints is explained in Double-buffered endpoints.\nSTATUS_OUT: This bit is set by the software to indicate that a status out transaction is expected: in this case all OUT transactions containing more than zero data bytes are answered 'STALL' instead of 'ACK'. This bit may be used to improve the robustness of the application to protocol errors during control transfers and its usage is intended for control endpoints only. When STATUS_OUT is reset, OUT transactions can have any number of bytes, as required."
            },
            {
                "name": "UTYPE",
                "bitOffset": 9,
                "bitWidth": 2,
                "desc": "USB type of transaction\nThese bits configure the behavior of this endpoint/channel as described in endpoint/channel type encoding on page2001. Channel0/Endpoint0 must always be a control endpoint/channel and each USB function must have at least one control endpoint/channel which has address 0, but there may be other control channels/endpoints if required. Only control channels/endpoints handle SETUP transactions, which are ignored by endpoints of other kinds. SETUP transactions cannot be answered with NAK or STALL. If a control endpoint/channel is defined as NAK, the USB peripheral will not answer, simulating a receive error, in the receive direction when a SETUP transaction is received. If the control endpoint/channel is defined as STALL in the receive direction, then the SETUP packet will be accepted anyway, transferring data and issuing the CTR interrupt. The reception of OUT transactions is handled in the normal way, even if the endpoint/channel is a control one.\nBulk and interrupt endpoints have very similar behavior and they differ only in the special feature available using the EPKIND configuration bit.\nThe usage of Isochronous channels/endpoints is explained in transfers"
            },
            {
                "name": "SETUP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Setup transaction completed\nDevice mode\nThis bit is read-only and it is set by the hardware when the last completed transaction is a SETUP. This bit changes its value only for control endpoints. It must be examined, in the case of a successful receive transaction (VTRX event), to determine the type of transaction occurred. To protect the interrupt service routine from the changes in SETUP bits due to next incoming tokens, this bit is kept frozen while VTRX bit is at 1; its state changes when VTRX is at 0. This bit is read-only.\nHost mode\nThis bit is set by the software to send a SETUP transaction on a control endpoint. This bit changes its value only for control endpoints. It is cleared by hardware when the SETUP transaction is acknowledged and VTTX interrupt generated."
            },
            {
                "name": "STATRX",
                "bitOffset": 12,
                "bitWidth": 2,
                "desc": "Status bits, for reception transfers\nDevice mode\nThese bits contain information about the endpoint status, which are listed in Reception status encoding on page2000.These bits can be toggled by software to initialize their value. When the application software writes '0, the value remains unchanged, while writing '1 makes the bit value toggle. Hardware sets the STRX bits to NAK when a correct transfer has occurred (VTRX=1) corresponding to a OUT or SETUP (control only) transaction addressed to this endpoint, so the software has the time to elaborate the received data before it acknowledge a new transaction\nDouble-buffered bulk endpoints implement a special transaction flow control, which control the status based upon buffer availability condition (Refer to endpoints).\nIf the endpoint is defined as Isochronous, its status can be only 'VALID' or 'DISABLED', so that the hardware cannot change the status of the endpoint after a successful transaction. If the software sets the STRX bits to 'STALL' or 'NAK' for an Isochronous endpoint, the USB peripheral behavior is not defined. These bits are read/write but they can be only toggled by writing '1.\nHost mode\nThese bits are the host application controls to start, retry, or abort host transactions driven by the channel.\nThese bits also contain information about the device answer to the last IN channel transaction and report the current status of the channel according to the following STRX table of states:\n-\tDISABLE\nDISABLE value is reported in case of ACK acknowledge is received on a single-buffer channel. When in DISABLE state the channel is unused or not active waiting for application to restart it by writing VALID. Application can reset a VALID channel to DISABLE to abort a transaction. In this case the transaction is immediately removed from the Host execution list. If the aborted transaction was already under execution it will be regularly terminated on the USB but the relative VTRX interrupt is not generated.\n-\tVALID\nAn Host channel is actively trying to submit USB transaction to device only when in VALID state.VALID state can be set by software or automatically by hardware on a NAKED channel at the start of a new frame. When set to VALID, an host channel enters the host execution queue and waits permission from the Host Frame Schedure to submit its configured transaction.\nVALID value is also reported in case of ACK acknowledge is received on a double-buffered channel. In this case the channel remains active on the alternate buffer while application needs to read the current buffer and toggle DTOGTX. In case software is late in reading and the alternate buffer is not ready, the host channel is automatically suspended transparently to the application. The suspended double buffered channel will be re-activated as soon as delay is recovered and DTOGTX is toggled.\n- NAK\nNAK value is reported in case of NAK acknowledge received. When in NAK state the channel is suspended and does not try to transmit. NAK state is moved to VALID by hardware at the start of the next frame, or software can change it to immediately retry transmission by writing it to VALID, or can disable it and abort the transaction by writing DISABLE\n- STALL\nSTALL value is reported in case of STALL acknowledge received. When in STALL state the channel behaves as disabled. Application should not retry transmission but reset the USB and re-enumerate."
            },
            {
                "name": "DTOGRX",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Data Toggle, for reception transfers\nIf the endpoint/channel is not Isochronous, this bit contains the expected value of the data toggle bit (0=DATA0, 1=DATA1) for the next data packet to be received. Hardware toggles this bit, when the ACK handshake is sent following a data packet reception having a matching data PID value; if the endpoint is defined as a control one, hardware clears this bit at the reception of a SETUP PID received from host (in device) or acknowledged by device (in host).\nIf the endpoint/channel is using the double-buffering feature this bit is used to support packet buffer swapping too (Refer to ).\nIf the endpoint/channel is Isochronous, this bit is used only to support packet buffer swapping for data transmission since no data toggling is used for this kind of channels/endpoints and only DATA0 packet are transmitted (Refer to Isochronous transfers). Hardware toggles this bit just after the end of data packet reception, since no handshake is used for isochronous transfers.\nThis bit can also be toggled by the software to initialize its value (mandatory when the endpoint is not a control one) or to force specific data toggle/packet buffer usage. When the application software writes '0, the value of DTOGRX remains unchanged, while writing '1 makes the bit value toggle. This bit is read/write but it can be only toggled by writing 1."
            },
            {
                "name": "VTRX",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "USB valid transaction received\nDevice mode\nThis bit is set by the hardware when an OUT/SETUP transaction is successfully completed on this endpoint; the software can only clear this bit. If the CTRM bit in USB_CNTR register is set accordingly, a generic interrupt condition is generated together with the endpoint related interrupt condition, which is always activated. The type of occurred transaction, OUT or SETUP, can be determined from the SETUP bit described below.\nA transaction ended with a NAK or STALL handshake does not set this bit, since no data is actually transferred, as in the case of protocol errors or data toggle mismatches.\nThis bit is read/write but only '0 can be written, writing 1 has no effect.\nHost mode\nThis bit is set by the hardware when an IN transaction is successfully completed on this channel. The software can only clear this bit. If the VTRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated.\n- A transaction ended with a NAK sets this bit and NAK answer is reported to application reading the NAK state from the STRX field of this register. One naked transaction keeps pending and is automatically retried by the Host at the next frame, or the Host can immediately retry by resetting STRX state to VALID.\n- A transaction ended by STALL handshake sets this bit and the STALL answer is reported to application reading the STALL state from the STRX field of this register. Host application should consequently disable the channel and re-enumerate.\n- A transaction ended with ACK handshake sets this bit\nIf double buffering is disabled, ACK answer is reported by application reading the DISABLE state from the STRX field of this register. Host application should read received data from USBRAM and re-arm the channel by writing VALID to the STRX field of this register.\nIf double buffering is enabled, ACK answer is reported by application reading VALID state from the STRX field of this register. Host application should read received data from USBRAM and toggle the DTOGTX bit of this register.\nThis bit is read/write but only '0 can be written, writing 1 has no effect."
            },
            {
                "name": "DEVADDR",
                "bitOffset": 16,
                "bitWidth": 7,
                "desc": "Host mode\nDevice address assigned to the endpoint during the enumeration process."
            },
            {
                "name": "NAK",
                "bitOffset": 23,
                "bitWidth": 1,
                "desc": "Host mode\nThis bit is set by the hardware when a device responds with a NAK. Software can be use this bit to monitoring the number of NAKs received from a device."
            },
            {
                "name": "LS_EP",
                "bitOffset": 24,
                "bitWidth": 1,
                "desc": "Low speed endpoint"
            },
            {
                "name": "ERR_TX",
                "bitOffset": 25,
                "bitWidth": 1,
                "desc": "Transmit error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an OUT or SETUP transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is always activated."
            },
            {
                "name": "ERR_RX",
                "bitOffset": 26,
                "bitWidth": 1,
                "desc": "Receive error\nHost mode\nThis bit is set by the hardware when an error (e.g. no answer by the device, CRC error, bit stuffing error, framing format violation, etc.) has occurred during an IN transaction on this channel. The software can only clear this bit. If the ERRM bit in USB_CNTR register is set a generic interrupt condition is generated together with the channel related flag, which is  always activated."
            }
        ]
    },
    "1073765440": {
        "name": "USB_CNTR",
        "address": 1073765440,
        "size": 32,
        "access": "",
        "desc": "USB control register ",
        "fields": [
            {
                "name": "USBRST",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "USB Reset\nDevice mode\nSoftware can set this bit to reset the USB core, exactly as it happens when receiving a RESET signaling on the USB.The USB peripheral, in response to a RESET, resets its internal protocol state machine. Reception and transmission are disabled until the RESET bit is cleared. All configuration registers do not reset: the microcontroller must explicitly clear these registers (this is to ensure that the RESET interrupt can be safely delivered, and any transaction immediately followed by a RESET can be completed). The function address and endpoint registers are reset by an USB reset event.\nHost mode\nSoftware sets this bit to drive USB reset state on the bus and initialize the device. USB reset terminates as soon as this bit is cleared by software."
            },
            {
                "name": "PDWN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Power down\nThis bit is used to completely switch off all USB-related analog parts if it is required to completely disable the USB peripheral for any reason. When this bit is set, the USB peripheral is disconnected from the transceivers and it cannot be used."
            },
            {
                "name": "SUSPRDY",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Suspend state effective\nThis bit is set by hardware as soon as the suspend state entered through the SUSPEN control gets internally effective. In this state USB activity is suspended, USB clock is gated, transceiver is set in low power mode by disabling the differential receiver. Only asynchronous wakeup logic and single ended receiver is kept alive to detect remote wakeup or resume events.\nSoftware must poll this bit to confirm it to be set before any STOP mode entry.\nThis bit is cleared by hardware simultaneously to the WAKEUP flag being set."
            },
            {
                "name": "SUSPEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Suspend state enable\nDevice mode\nSoftware can set this bit when the SUSP interrupt is received, which is issued when no traffic is received by the USB peripheral for 3ms. Software can also set this bit when the L1REQ interrupt is received with positive acknowledge sent.\nAs soon as the suspend state is propagated internally all device activity is stopped, USB clock is gated, USB transceiver is set into low power mode and the SUSPRDY bit is set by hardware. In the case that device application wants to purse more aggressive power saving by stopping the USB clock source and by moving the microcontroller to stop mode, as in the case of bus powered device application, it must first wait few cycles to see the SUSPRDY=1 acknowledge the suspend request.\nThis bit is cleared by hardware simultaneous with the WAKEUP flag set.\nHost mode\nSoftware can set this bit when Host application has nothing scheduled for the next frames and wants to enter long term power saving. When set, it stops immediately SOF generation and any other host activity, gates the USB clock and sets the transceiver in low power mode. If any USB transaction is on-going at the time SUSPEN is set, suspend is entered at the end of the current transaction.\nAs soon as suspend state is propagated internally and gets effective the SUSPRDY bit is set. In the case that host application wants to purse more aggressive power saving by stopping the USB clock source and by moving the micro-controller to STOP mode, it must first wait few cycles to see SUSPRDY=1 acknowledge to the suspend request.\nThis bit is cleared by hardware simultaneous with the WAKEUP flag set."
            },
            {
                "name": "L2RESUME",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "L2 Remote Wakeup / Resume driver\nDevice mode\nThe microcontroller can set this bit to send remote wake-up signaling to the Host. It must be activated, according to USB specifications, for no less than 1ms and no more than 15ms after which the Host PC is ready to drive the resume sequence up to its end.\nHost mode\nSoftware sets this bit to send resume signaling to the device.\nSoftware clears this bit to send end of resume to device and restart SOF generation.\nIn the context of remote wake up, this bit is to be set following the WAKEUP interrupt."
            },
            {
                "name": "L1RESUME",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "L1 Remote Wakeup / Resume driver\nDevice mode\nSoftware sets this bit to send a LPM L1 50us remote wakeup signaling to the host. After the signaling ends, this bit is cleared by hardware.\nHost mode\nSoftware sets this bit to send L1 resume signaling to device. Resume duration and next SOF generation is automatically driven to set the restart of USB activity timely aligned with the programmed BESL value.\nIn the context of remote wake up, this bit is to be set following the WAKEUP interrupt.\nThis bit is cleared by hardware at the end of resume."
            },
            {
                "name": "L1REQM",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPM L1 state request interrupt mask"
            },
            {
                "name": "ESOFM",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Expected start of frame interrupt mask"
            },
            {
                "name": "SOFM",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Start of frame interrupt mask"
            },
            {
                "name": "RESETM",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "USB reset interrupt mask"
            },
            {
                "name": "SUSPM",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Suspend mode interrupt mask"
            },
            {
                "name": "WKUPM",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Wakeup interrupt mask"
            },
            {
                "name": "ERRM",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Error interrupt mask"
            },
            {
                "name": "PMAOVRM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Packet memory area over / underrun interrupt mask"
            },
            {
                "name": "CTRM",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Correct transfer interrupt mask"
            },
            {
                "name": "THR512M",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "512 byte threshold interrupt mask"
            },
            {
                "name": "HOST",
                "bitOffset": 31,
                "bitWidth": 1,
                "desc": "HOST mode\nHOST bit selects betweens Host or Device USB mode of operation. It must be set before enabling the USB peripheral by the function enable bit."
            }
        ]
    },
    "1073765444": {
        "name": "USB_ISTR",
        "address": 1073765444,
        "size": 32,
        "access": "",
        "desc": "USB interrupt status register ",
        "fields": [
            {
                "name": "IDN",
                "bitOffset": 0,
                "bitWidth": 4,
                "desc": "Device Endpoint / Host channel identification number\nThese bits are written by the hardware according to the host channel or device endpoint number, which generated the interrupt request. If several endpoint/channel transactions are pending, the hardware writes the identification number related to the endpoint/channel having the highest priority defined in the following way: Two levels are defined, in order of priority: Isochronous and double-buffered bulk channels/endpoints are considered first and then the others are examined. If more than one endpoint/channel from the same set is requesting an interrupt, the IDN bits in USB_ISTR register are assigned according to the lowest requesting register, CHEP0R having the highest priority followed by CHEP1R and so on. The application software can assign a register to each endpoint/channel according to this priority scheme, so as to order the concurring endpoint/channel requests in a suitable way. These bits are read only."
            },
            {
                "name": "DIR",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Direction of transaction\nThis bit is written by the hardware according to the direction of the successful transaction, which generated the interrupt request.\nIf DIR bit=0, VTTX bit is set in the USB_EPnR register related to the interrupting endpoint. The interrupting transaction is of IN type (data transmitted by the USB peripheral to the host PC).\nIf DIR bit=1, VTRX bit or both VTTX/VTRX are set in the USB_EPnR register related to the interrupting endpoint. The interrupting transaction is of OUT type (data received by the USB peripheral from the host PC) or two pending transactions are waiting to be processed.\nThis information can be used by the application software to access the USB_EPnR bits related to the triggering transaction since it represents the direction having the interrupt pending. This bit is read-only."
            },
            {
                "name": "L1REQ",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "LPM L1 state request\nThis bit is set by the hardware when LPM command to enter the L1 state is successfully received and acknowledged. This bit is read/write but only '0 can be written and writing '1 has no effect."
            },
            {
                "name": "ESOF",
                "bitOffset": 8,
                "bitWidth": 1,
                "desc": "Expected start of frame\nThis bit is set by the hardware when an SOF packet is expected but not received. The host sends an SOF packet each 1ms, but if the device does not receive it properly, the Suspend Timer issues this interrupt. If three consecutive ESOF interrupts are generated (i.e. three SOF packets are lost) without any traffic occurring in between, a SUSP interrupt is generated. This bit is set even when the missing SOF packets occur while the Suspend Timer is not yet locked. This bit is read/write but only '0 can be written and writing '1 has no effect."
            },
            {
                "name": "SOF",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Start of frame\nThis bit signals the beginning of a new USB frame and it is set when a SOF packet arrives through the USB bus. The interrupt service routine may monitor the SOF events to have a 1ms synchronization event to the USB host and to safely read the USB_FNR register which is updated at the SOF packet reception (this could be useful for isochronous applications). This bit is read/write but only '0 can be written and writing '1 has no effect."
            },
            {
                "name": "RST_DCON",
                "bitOffset": 10,
                "bitWidth": 1,
                "desc": "USB reset request\nDevice mode\nThis bit is set by hardware when an USB reset is released by the host and the bus returns to idle. USB reset state is internally detected after the sampling of 60 consecutive SE0 cycles.\nHost mode\nThis bit is set by hardware when device connection or device disconnection is detected. Device connection is signaled after J state is sampled for 22cycles consecutively from unconnected state. Device disconnection is signaled after SE0 state is sampled for 22cycles consecutively from connected state."
            },
            {
                "name": "SUSP",
                "bitOffset": 11,
                "bitWidth": 1,
                "desc": "Suspend mode request\nThis bit is set by the hardware when no traffic has been received for 3ms, indicating a suspend mode request from the USB bus. The suspend condition check is enabled immediately after any USB reset and it is disabled by the hardware when the suspend mode is active (SUSPEN=1) until the end of resume sequence. This bit is read/write but only '0 can be written and writing '1 has no effect."
            },
            {
                "name": "WKUP",
                "bitOffset": 12,
                "bitWidth": 1,
                "desc": "Wakeup\nThis bit is set to 1 by the hardware when, during suspend mode, activity is detected that wakes up the USB peripheral. This event asynchronously clears the LP_MODE bit in the CTLR register and activates the USB_WAKEUP line, which can be used to notify the rest of the device (e.g. wakeup unit) about the start of the resume process. This bit is read/write but only '0 can be written and writing '1 has no effect."
            },
            {
                "name": "ERR",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Error\nThis flag is set whenever one of the errors listed below has occurred:\nNANS:\tNo ANSwer. The timeout for a host response has expired.\nCRC:\tCyclic Redundancy Check error. One of the received CRCs, either in the token or in the data, was wrong.\nBST:\tBit Stuffing error. A bit stuffing error was detected anywhere in the PID, data, and/or CRC.\nFVIO:\tFraming format Violation. A non-standard frame was received (EOP not in the right place, wrong token sequence, etc.).\nThe USB software can usually ignore errors, since the USB peripheral and the PC host manage retransmission in case of errors in a fully transparent way. This interrupt can be useful during the software development phase, or to monitor the quality of transmission over the USB bus, to flag possible problems to the user (e.g. loose connector, too noisy environment, broken conductor in the USB cable and so on). This bit is read/write but only '0 can be written and writing '1 has no effect."
            },
            {
                "name": "PMAOVR",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Packet memory area over / underrun\nThis bit is set if the microcontroller has not been able to respond in time to an USB memory request. The USB peripheral handles this event in the following way: During reception an ACK handshake packet is not sent, during transmission a bit-stuff error is forced on the transmitted stream; in both cases the host will retry the transaction. The PMAOVR interrupt should never occur during normal operations. Since the failed transaction is retried by the host, the application software has the chance to speed-up device operations during this interrupt handling, to be ready for the next transaction retry; however this does not happen during Isochronous transfers (no isochronous transaction is anyway retried) leading to a loss of data in this case. This bit is read/write but only '0 can be written and writing '1 has no effect."
            },
            {
                "name": "CTR",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Correct transfer\nThis bit is set by the hardware to indicate that an endpoint/channel has successfully completed a transaction; using DIR and EP_ID bits software can determine which endpoint/channel requested the interrupt. This bit is read-only."
            },
            {
                "name": "THR512",
                "bitOffset": 16,
                "bitWidth": 1,
                "desc": "512 byte threshold interrupt\nThis bit is set to 1 by the hardware when 512 bytes have been transmitted or received during isochronous transfers. This bit is read/write but only 0 can be written and writing 1 has no effect. Note that no information is available to indicate the associated channel/endpoint, however in practice only one ISO endpoint/channel with such large packets can be supported, so that channel."
            },
            {
                "name": "DCON_STAT",
                "bitOffset": 29,
                "bitWidth": 1,
                "desc": "Device connection status\nHost mode:\nThis bit contains information about device connection status. It is set by hardware when a LS/FS device is attached to the host while it is reset when the device is disconnected."
            },
            {
                "name": "LS_DCON",
                "bitOffset": 30,
                "bitWidth": 1,
                "desc": "Low Speed device connected\nHost mode:\nThis bit is set by hardware when an LS device connection is detected. Device connection is signaled after LS J-state is sampled for 22 consecutive cycles of the USB clock (48 MHz) from the unconnected state."
            }
        ]
    },
    "1073765448": {
        "name": "USB_FNR",
        "address": 1073765448,
        "size": 32,
        "access": "",
        "desc": "USB frame number register ",
        "fields": [
            {
                "name": "FN",
                "bitOffset": 0,
                "bitWidth": 11,
                "desc": "Frame number\nThis bit field contains the 11-bits frame number contained in the last received SOF packet. The frame number is incremented for every frame sent by the host and it is useful for Isochronous transfers. This bit field is updated on the generation of an SOF interrupt."
            },
            {
                "name": "LSOF",
                "bitOffset": 11,
                "bitWidth": 2,
                "desc": "Lost SOF\nDevice mode\nThese bits are written by the hardware when an ESOF interrupt is generated, counting the number of consecutive SOF packets lost. At the reception of an SOF packet, these bits are cleared."
            },
            {
                "name": "LCK",
                "bitOffset": 13,
                "bitWidth": 1,
                "desc": "Locked\nDevice mode\nThis bit is set by the hardware when at least two consecutive SOF packets have been received after the end of an USB reset condition or after the end of an USB resume sequence. Once locked, the frame timer remains in this state until an USB reset or USB suspend event occurs."
            },
            {
                "name": "RXDM",
                "bitOffset": 14,
                "bitWidth": 1,
                "desc": "Receive data - line status\nThis bit can be used to observe the status of received data minus upstream port data line. It can be used during end-of-suspend routines to help determining the wakeup event."
            },
            {
                "name": "RXDP",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "Receive data + line status\nThis bit can be used to observe the status of received data plus upstream port data line. It can be used during end-of-suspend routines to help determining the wakeup event."
            }
        ]
    },
    "1073765452": {
        "name": "USB_DADDR",
        "address": 1073765452,
        "size": 32,
        "access": "",
        "desc": "USB device address ",
        "fields": [
            {
                "name": "ADD",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "Device address\nDevice mode\nThese bits contain the USB function address assigned by the host PC during the enumeration process. Both this field and the endpoint/channel Address (EA) field in the associated USB_EPnR register must match with the information contained in a USB token in order to handle a transaction to the required endpoint.\nHost mode\nThese bits contain the address transmitted with the LPM transaction"
            },
            {
                "name": "EF",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Enable function\nThis bit is set by the software to enable the USB device. The address of this device is contained in the following ADD[6:0] bits. If this bit is at '0 no transactions are handled, irrespective of the settings of USB_EPnR registers."
            }
        ]
    },
    "1073765460": {
        "name": "USB_LPMCSR",
        "address": 1073765460,
        "size": 32,
        "access": "",
        "desc": "LPM control and status register ",
        "fields": [
            {
                "name": "LPMEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "LPM support enable\nDevice mode\nThis bit is set by the software to enable the LPM support within the USB device. If this bit is at '0 no LPM transactions are handled.\nHost mode\nSoftware sets this bit to transmit an LPM transaction to device. This bit is cleared by hardware, simultaneous with L1REQ flag set, when device answer is received"
            },
            {
                "name": "LPMACK",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "LPM Token acknowledge enable\nThe NYET/ACK will be returned only on a successful LPM transaction:\nNo errors in both the EXT token and the LPM token (else ERROR)\nA valid bLinkState = 0001B (L1) is received (else STALL)\nThis bit contains the device answer to the LPM transaction. It mast be evaluated following the L1REQ interrupt."
            },
            {
                "name": "REMWAKE",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "bRemoteWake value\nDevice mode\nThis bit contains the bRemoteWake value received with last ACKed LPM Token\nHost mode\nThis bit contains the bRemoteWake value transmitted with the LPM transaction"
            },
            {
                "name": "BESL",
                "bitOffset": 4,
                "bitWidth": 4,
                "desc": "BESL value\nDevice mode\nThese bits contain the BESL value received with last ACKed LPM Token\nHost mode\nThese bits contain the BESL value transmitted with the LPM transaction"
            }
        ]
    },
    "1073765464": {
        "name": "USB_BCDR",
        "address": 1073765464,
        "size": 32,
        "access": "",
        "desc": "Battery charging detector ",
        "fields": [
            {
                "name": "BCDEN",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Battery charging detector (BCD) enable\nDevice mode\nThis bit is set by the software to enable the BCD support within the USB device. When enabled, the USB PHY is fully controlled by BCD and cannot be used for normal communication. Once the BCD discovery is finished, the BCD should be placed in OFF mode by clearing this bit to '0 in order to allow the normal USB operation."
            },
            {
                "name": "DCDEN",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "Data contact detection (DCD) mode enable\nDevice mode\nThis bit is set by the software to put the BCD into DCD mode. Only one detection mode (DCD, PD, SD or OFF) should be selected to work correctly."
            },
            {
                "name": "PDEN",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Primary detection (PD) mode enable\nDevice mode\nThis bit is set by the software to put the BCD into PD mode. Only one detection mode (DCD, PD, SD or OFF) should be selected to work correctly."
            },
            {
                "name": "SDEN",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Secondary detection (SD) mode enable\nDevice mode\nThis bit is set by the software to put the BCD into SD mode. Only one detection mode (DCD, PD, SD or OFF) should be selected to work correctly."
            },
            {
                "name": "DCDET",
                "bitOffset": 4,
                "bitWidth": 1,
                "desc": "Data contact detection (DCD) status\nDevice mode\nThis bit gives the result of DCD."
            },
            {
                "name": "PDET",
                "bitOffset": 5,
                "bitWidth": 1,
                "desc": "Primary detection (PD) status\nDevice mode\nThis bit gives the result of PD."
            },
            {
                "name": "SDET",
                "bitOffset": 6,
                "bitWidth": 1,
                "desc": "Secondary detection (SD) status\nDevice mode\nThis bit gives the result of SD."
            },
            {
                "name": "PS2DET",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "DM pull-up detection status\nDevice mode\nThis bit is active only during PD and gives the result of comparison between DM voltage level and VLGC threshold. In normal situation, the DM level should be below this threshold. If it is above, it means that the DM is externally pulled high. This can be caused by connection to a PS2 port (which pulls-up both DP and DM lines) or to some proprietary charger not following the BCD specification."
            },
            {
                "name": "DPPU_DPD",
                "bitOffset": 15,
                "bitWidth": 1,
                "desc": "DP pull-up / DPDM pull-down\nDevice mode\nThis bit is set by software to enable the embedded pull-up on DP line. Clearing it to '0 can be used to signal disconnect to the host when needed by the user software.\nHost mode\nThis bit is set by software to enable the embedded pull-down on DP and DM lines."
            }
        ]
    },
    "1073807408": {
        "name": "VREFBUF_CSR",
        "address": 1073807408,
        "size": 32,
        "access": "",
        "desc": "VREFBUF control and status\n          register",
        "fields": [
            {
                "name": "ENVR",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Voltage reference buffer mode enable\nThis bit is used to enable the voltage reference buffer mode."
            },
            {
                "name": "HIZ",
                "bitOffset": 1,
                "bitWidth": 1,
                "desc": "High impedance mode\nThis bit controls the analog switch to connect or not the VREF+ pin.\nRefer to  for the mode descriptions depending on ENVR bit configuration."
            },
            {
                "name": "VRS",
                "bitOffset": 2,
                "bitWidth": 1,
                "desc": "Voltage reference scale\nThis bit selects the value generated by the voltage reference buffer."
            },
            {
                "name": "VRR",
                "bitOffset": 3,
                "bitWidth": 1,
                "desc": "Voltage reference buffer ready"
            }
        ]
    },
    "1073807412": {
        "name": "VREFBUF_CCR",
        "address": 1073807412,
        "size": 32,
        "access": "read-write",
        "desc": "VREFBUF calibration control\n          register",
        "fields": [
            {
                "name": "TRIM",
                "bitOffset": 0,
                "bitWidth": 6,
                "desc": "Trimming code\nThese bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows the tuning of the internal reference buffer voltage."
            }
        ]
    },
    "1073753088": {
        "name": "WWDG_CR",
        "address": 1073753088,
        "size": 32,
        "access": "read-write",
        "desc": "Control register",
        "fields": [
            {
                "name": "T",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "7-bit counter (MSB to LSB)\nThese bits contain the value of the watchdog counter, decremented every\n(4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared)."
            },
            {
                "name": "WDGA",
                "bitOffset": 7,
                "bitWidth": 1,
                "desc": "Activation bit\nThis bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset."
            }
        ]
    },
    "1073753092": {
        "name": "WWDG_CFR",
        "address": 1073753092,
        "size": 32,
        "access": "read-write",
        "desc": "Configuration register",
        "fields": [
            {
                "name": "W",
                "bitOffset": 0,
                "bitWidth": 7,
                "desc": "7-bit window value\nThese bits contain the window value to be compared with the down-counter."
            },
            {
                "name": "EWI",
                "bitOffset": 9,
                "bitWidth": 1,
                "desc": "Early wakeup interrupt\nWhen set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset."
            },
            {
                "name": "WDGTB",
                "bitOffset": 11,
                "bitWidth": 3,
                "desc": "Timer base\nThe timebase of the prescaler can be modified as follows:"
            }
        ]
    },
    "1073753096": {
        "name": "WWDG_SR",
        "address": 1073753096,
        "size": 32,
        "access": "read-write",
        "desc": "Status register",
        "fields": [
            {
                "name": "EWIF",
                "bitOffset": 0,
                "bitWidth": 1,
                "desc": "Early wakeup interrupt\n              flag"
            }
        ]
    }
}